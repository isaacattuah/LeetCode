{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"LeetCode Solutions Getting Started In this repository, I'll work on solutions to all LeetCode problems by C++, Java, and Python. Coding Style I believe messy code is costing you. C++ code is formatted by clang-format following the Google C++ Style Guide . You can see the configuration here . Java code is formatted by Language Support for Java(TM) by Red Hat Python code is formatted by PEP 8 -- Style Guide for Python Code . More Information The repository is still under construction, and the goal is to keep up with the growth of LeetCode problems by Aug 2020! For more information, please visit my GitHub . By Jay Chen on Feb 23, 2019. Revised on Dec 25, 2019.","title":"Preface"},{"location":"#leetcode-solutions","text":"","title":"LeetCode Solutions"},{"location":"#getting-started","text":"In this repository, I'll work on solutions to all LeetCode problems by C++, Java, and Python.","title":"Getting Started"},{"location":"#coding-style","text":"I believe messy code is costing you. C++ code is formatted by clang-format following the Google C++ Style Guide . You can see the configuration here . Java code is formatted by Language Support for Java(TM) by Red Hat Python code is formatted by PEP 8 -- Style Guide for Python Code .","title":"Coding Style"},{"location":"#more-information","text":"The repository is still under construction, and the goal is to keep up with the growth of LeetCode problems by Aug 2020! For more information, please visit my GitHub . By Jay Chen on Feb 23, 2019. Revised on Dec 25, 2019.","title":"More Information"},{"location":"cpp/","text":"LeetCode in C++","title":"Preface"},{"location":"cpp/#leetcode-in-c","text":"","title":"LeetCode in C++"},{"location":"cpp/0001-0100/0001-0010/","text":"1. Two Sum $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector < int > twoSum ( vector < int >& nums , int target ) { unordered_map < int , int > map ; for ( int i = 0 ; i < nums . size (); i ++ ) { if ( map . count ( nums [ i ])) return { map [ nums [ i ]], i }; map [ target - nums [ i ]] = i ; } throw ; } }; 2. Add Two Numbers $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { ListNode dummy ( 0 ); ListNode * curr = & dummy ; int carry = 0 ; while ( carry || l1 || l2 ) { carry += ( l1 ? l1 -> val : 0 ) + ( l2 ? l2 -> val : 0 ); curr -> next = new ListNode ( carry % 10 ); curr = curr -> next ; carry /= 10 ; if ( l1 ) l1 = l1 -> next ; if ( l2 ) l2 = l2 -> next ; } return dummy . next ; } }; 3. Longest Substring Without Repeating Characters $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int lengthOfLongestSubstring ( string s ) { int ans = 0 ; unordered_map < char , int > map ; int j = 0 ; for ( int i = 0 ; i < s . size (); i ++ ) { char c = s [ i ]; if ( map . count ( c )) j = max ( j , map [ c ]); ans = max ( ans , i - j + 1 ); map [ c ] = i + 1 ; } return ans ; } }; 4. Median of Two Sorted Arrays $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : double findMedianSortedArrays ( vector < int >& nums1 , vector < int >& nums2 ) { const int n1 = nums1 . size (); const int n2 = nums2 . size (); if ( n1 > n2 ) return findMedianSortedArrays ( nums2 , nums1 ); int l = 0 ; int r = n1 ; while ( l <= r ) { int partition1 = l + ( r - l ) / 2 ; int partition2 = ( n1 + n2 + 1 ) / 2 - partition1 ; int maxLeft1 = partition1 == 0 ? INT_MIN : nums1 [ partition1 - 1 ]; int maxLeft2 = partition2 == 0 ? INT_MIN : nums2 [ partition2 - 1 ]; int minRight1 = partition1 == n1 ? INT_MAX : nums1 [ partition1 ]; int minRight2 = partition2 == n2 ? INT_MAX : nums2 [ partition2 ]; if ( maxLeft1 <= minRight2 && maxLeft2 <= minRight1 ) return ( n1 + n2 ) % 2 == 0 ? ( max ( maxLeft1 , maxLeft2 ) + min ( minRight1 , minRight2 )) * 0.5 : max ( maxLeft1 , maxLeft2 ); else if ( maxLeft1 > minRight2 ) r = partition1 - 1 ; else l = partition1 + 1 ; } throw ; } }; 5. Longest Palindromic Substring $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public : string longestPalindrome ( string s ) { const int length = s . length () * 2 + 3 ; // Manacher's Algorithm string T ( length , '#' ); T [ 0 ] = '$' ; T [ length - 1 ] = '@' ; for ( int i = 2 ; i < length - 2 ; i += 2 ) T [ i ] = s [ i / 2 - 1 ]; int center = 1 ; int right = 1 ; vector < int > P ( length , 0 ); for ( int i = 1 ; i < length - 1 ; i ++ ) { int mirr = 2 * center - i ; if ( i < right ) P [ i ] = min ( P [ mirr ], right - i ); while ( T [ i + P [ i ] + 1 ] == T [ i - P [ i ] - 1 ]) P [ i ] ++ ; if ( i + P [ i ] > right ) { center = i ; right = i + P [ i ]; } } // find max and the center; int max = 0 ; int c = 0 ; for ( int i = 0 ; i < length ; i ++ ) if ( P [ i ] > max ) { max = P [ i ]; c = i ; } // omit '#' and get the string desired string ans ( max , '#' ); int i = 0 ; for ( int j = c - max + 1 ; j < c + max ; j += 2 ) { ans [ i ] = T [ j ]; i ++ ; } return ans ; } }; 6. ZigZag Conversion $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : string convert ( string s , int numRows ) { string ans ( s ); vector < vector < char >> rows ( numRows ); int k = 0 ; int direction = ( numRows == 1 ) - 1 ; for ( char c : s ) { rows [ k ]. push_back ( c ); if ( k == 0 || k == numRows - 1 ) direction *= - 1 ; k += direction ; } k = 0 ; for ( int i = 0 ; i < numRows ; i ++ ) for ( int j = 0 ; j < rows [ i ]. size (); j ++ ) ans [ k ++ ] = rows [ i ][ j ]; return ans ; } }; 7. Reverse Integer $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int reverse ( int x ) { long ans = 0 ; while ( x ) { ans = ans * 10 + x % 10 ; x /= 10 ; } if ( ans < INT_MIN || ans > INT_MAX ) return 0 ; return ans ; } }; 8. String to Integer (atoi) $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int myAtoi ( string str ) { long long ans = 0 ; bool isNegative = false ; int j = 0 ; while ( j < str . size () && str [ j ] == ' ' ) j ++ ; if ( j == str . size ()) return 0 ; if ( str [ j ] == '-' ) { isNegative = true ; j ++ ; } else if ( str [ j ] == '+' ) { j ++ ; } for ( int i = j ; i < str . size (); i ++ ) { if ( str [ i ] < '0' || str [ i ] > '9' ) break ; else { ans = ans * 10 + ( str [ i ] - '0' ); if ( isNegative && - ans <= INT_MIN ) return INT_MIN ; if ( ! isNegative && ans >= INT_MAX ) return INT_MAX ; } } return isNegative ? - ans : ans ; } }; 9. Palindrome Number $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool isPalindrome ( int x ) { if ( x < 0 ) return false ; long ans = 0 ; int y = x ; while ( y ) { ans = ans * 10 + y % 10 ; y /= 10 ; } return ans == x ; } }; 10. Regular Expression Matching $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool isMatch ( string s , string p ) { if ( p . empty ()) return s . empty (); bool isFirstMatch = ( ! s . empty () && ( p [ 0 ] == s [ 0 ] || p [ 0 ] == '.' )); if ( p . length () >= 2 && p [ 1 ] == '*' ) return ( isMatch ( s , p . substr ( 2 )) || ( isFirstMatch && isMatch ( s . substr ( 1 ), p ))); return isFirstMatch && isMatch ( s . substr ( 1 ), p . substr ( 1 )); } };","title":"0001-0010"},{"location":"cpp/0001-0100/0001-0010/#1-two-sum-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector < int > twoSum ( vector < int >& nums , int target ) { unordered_map < int , int > map ; for ( int i = 0 ; i < nums . size (); i ++ ) { if ( map . count ( nums [ i ])) return { map [ nums [ i ]], i }; map [ target - nums [ i ]] = i ; } throw ; } };","title":"1. Two Sum $\\star$"},{"location":"cpp/0001-0100/0001-0010/#2-add-two-numbers-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { ListNode dummy ( 0 ); ListNode * curr = & dummy ; int carry = 0 ; while ( carry || l1 || l2 ) { carry += ( l1 ? l1 -> val : 0 ) + ( l2 ? l2 -> val : 0 ); curr -> next = new ListNode ( carry % 10 ); curr = curr -> next ; carry /= 10 ; if ( l1 ) l1 = l1 -> next ; if ( l2 ) l2 = l2 -> next ; } return dummy . next ; } };","title":"2. Add Two Numbers $\\star\\star$"},{"location":"cpp/0001-0100/0001-0010/#3-longest-substring-without-repeating-characters-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int lengthOfLongestSubstring ( string s ) { int ans = 0 ; unordered_map < char , int > map ; int j = 0 ; for ( int i = 0 ; i < s . size (); i ++ ) { char c = s [ i ]; if ( map . count ( c )) j = max ( j , map [ c ]); ans = max ( ans , i - j + 1 ); map [ c ] = i + 1 ; } return ans ; } };","title":"3. Longest Substring Without Repeating Characters $\\star\\star$"},{"location":"cpp/0001-0100/0001-0010/#4-median-of-two-sorted-arrays-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : double findMedianSortedArrays ( vector < int >& nums1 , vector < int >& nums2 ) { const int n1 = nums1 . size (); const int n2 = nums2 . size (); if ( n1 > n2 ) return findMedianSortedArrays ( nums2 , nums1 ); int l = 0 ; int r = n1 ; while ( l <= r ) { int partition1 = l + ( r - l ) / 2 ; int partition2 = ( n1 + n2 + 1 ) / 2 - partition1 ; int maxLeft1 = partition1 == 0 ? INT_MIN : nums1 [ partition1 - 1 ]; int maxLeft2 = partition2 == 0 ? INT_MIN : nums2 [ partition2 - 1 ]; int minRight1 = partition1 == n1 ? INT_MAX : nums1 [ partition1 ]; int minRight2 = partition2 == n2 ? INT_MAX : nums2 [ partition2 ]; if ( maxLeft1 <= minRight2 && maxLeft2 <= minRight1 ) return ( n1 + n2 ) % 2 == 0 ? ( max ( maxLeft1 , maxLeft2 ) + min ( minRight1 , minRight2 )) * 0.5 : max ( maxLeft1 , maxLeft2 ); else if ( maxLeft1 > minRight2 ) r = partition1 - 1 ; else l = partition1 + 1 ; } throw ; } };","title":"4. Median of Two Sorted Arrays $\\star\\star\\star$"},{"location":"cpp/0001-0100/0001-0010/#5-longest-palindromic-substring-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public : string longestPalindrome ( string s ) { const int length = s . length () * 2 + 3 ; // Manacher's Algorithm string T ( length , '#' ); T [ 0 ] = '$' ; T [ length - 1 ] = '@' ; for ( int i = 2 ; i < length - 2 ; i += 2 ) T [ i ] = s [ i / 2 - 1 ]; int center = 1 ; int right = 1 ; vector < int > P ( length , 0 ); for ( int i = 1 ; i < length - 1 ; i ++ ) { int mirr = 2 * center - i ; if ( i < right ) P [ i ] = min ( P [ mirr ], right - i ); while ( T [ i + P [ i ] + 1 ] == T [ i - P [ i ] - 1 ]) P [ i ] ++ ; if ( i + P [ i ] > right ) { center = i ; right = i + P [ i ]; } } // find max and the center; int max = 0 ; int c = 0 ; for ( int i = 0 ; i < length ; i ++ ) if ( P [ i ] > max ) { max = P [ i ]; c = i ; } // omit '#' and get the string desired string ans ( max , '#' ); int i = 0 ; for ( int j = c - max + 1 ; j < c + max ; j += 2 ) { ans [ i ] = T [ j ]; i ++ ; } return ans ; } };","title":"5. Longest Palindromic Substring $\\star\\star$"},{"location":"cpp/0001-0100/0001-0010/#6-zigzag-conversion-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : string convert ( string s , int numRows ) { string ans ( s ); vector < vector < char >> rows ( numRows ); int k = 0 ; int direction = ( numRows == 1 ) - 1 ; for ( char c : s ) { rows [ k ]. push_back ( c ); if ( k == 0 || k == numRows - 1 ) direction *= - 1 ; k += direction ; } k = 0 ; for ( int i = 0 ; i < numRows ; i ++ ) for ( int j = 0 ; j < rows [ i ]. size (); j ++ ) ans [ k ++ ] = rows [ i ][ j ]; return ans ; } };","title":"6. ZigZag Conversion $\\star\\star$"},{"location":"cpp/0001-0100/0001-0010/#7-reverse-integer-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int reverse ( int x ) { long ans = 0 ; while ( x ) { ans = ans * 10 + x % 10 ; x /= 10 ; } if ( ans < INT_MIN || ans > INT_MAX ) return 0 ; return ans ; } };","title":"7. Reverse Integer $\\star$"},{"location":"cpp/0001-0100/0001-0010/#8-string-to-integer-atoi-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : int myAtoi ( string str ) { long long ans = 0 ; bool isNegative = false ; int j = 0 ; while ( j < str . size () && str [ j ] == ' ' ) j ++ ; if ( j == str . size ()) return 0 ; if ( str [ j ] == '-' ) { isNegative = true ; j ++ ; } else if ( str [ j ] == '+' ) { j ++ ; } for ( int i = j ; i < str . size (); i ++ ) { if ( str [ i ] < '0' || str [ i ] > '9' ) break ; else { ans = ans * 10 + ( str [ i ] - '0' ); if ( isNegative && - ans <= INT_MIN ) return INT_MIN ; if ( ! isNegative && ans >= INT_MAX ) return INT_MAX ; } } return isNegative ? - ans : ans ; } };","title":"8. String to Integer (atoi) $\\star\\star$"},{"location":"cpp/0001-0100/0001-0010/#9-palindrome-number-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool isPalindrome ( int x ) { if ( x < 0 ) return false ; long ans = 0 ; int y = x ; while ( y ) { ans = ans * 10 + y % 10 ; y /= 10 ; } return ans == x ; } };","title":"9. Palindrome Number $\\star$"},{"location":"cpp/0001-0100/0001-0010/#10-regular-expression-matching-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool isMatch ( string s , string p ) { if ( p . empty ()) return s . empty (); bool isFirstMatch = ( ! s . empty () && ( p [ 0 ] == s [ 0 ] || p [ 0 ] == '.' )); if ( p . length () >= 2 && p [ 1 ] == '*' ) return ( isMatch ( s , p . substr ( 2 )) || ( isFirstMatch && isMatch ( s . substr ( 1 ), p ))); return isFirstMatch && isMatch ( s . substr ( 1 ), p . substr ( 1 )); } };","title":"10. Regular Expression Matching $\\star\\star\\star$"},{"location":"cpp/0001-0100/0011-0020/","text":"11. Container With Most Water $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxArea ( vector < int >& height ) { int ans = 0 ; int l = 0 ; int r = height . size () - 1 ; while ( l < r ) { int h = min ( height [ l ], height [ r ]); ans = max ( ans , ( r - l ) * h ); while ( height [ l ] <= h && l < r ) l ++ ; while ( height [ r ] <= h && l < r ) r -- ; } return ans ; } }; 12. Integer to Roman $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : string intToRoman ( int num ) { string M [ 4 ] = { \"\" , \"M\" , \"MM\" , \"MMM\" }; string C [ 10 ] = { \"\" , \"C\" , \"CC\" , \"CCC\" , \"CD\" , \"D\" , \"DC\" , \"DCC\" , \"DCCC\" , \"CM\" }; string X [ 10 ] = { \"\" , \"X\" , \"XX\" , \"XXX\" , \"XL\" , \"L\" , \"LX\" , \"LXX\" , \"LXXX\" , \"XC\" }; string I [ 10 ] = { \"\" , \"I\" , \"II\" , \"III\" , \"IV\" , \"V\" , \"VI\" , \"VII\" , \"VIII\" , \"IX\" }; return M [ num / 1000 ] + C [ num % 1000 / 100 ] + X [ num % 100 / 10 ] + I [ num % 10 ]; } }; 13. Roman to Integer $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int romanToInt ( string s ) { int ans = 0 ; unordered_map < char , int > map = {{ 'I' , 1 }, { 'V' , 5 }, { 'X' , 10 }, { 'L' , 50 }, { 'C' , 100 }, { 'D' , 500 }, { 'M' , 1000 }}; for ( int i = 0 ; i < s . size (); i ++ ) { if ( map [ s [ i ]] < map [ s [ i + 1 ]]) ans -= map [ s [ i ]]; else ans += map [ s [ i ]]; } return ans ; } }; 14. Longest Common Prefix $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : string longestCommonPrefix ( vector < string >& strs ) { if ( strs . size () == 0 ) return \"\" ; if ( strs . size () == 1 ) return strs [ 0 ]; string ans ; int min = strs [ 0 ]. length (); bool isMatch = true ; for ( int i = 1 ; i < strs . size (); i ++ ) min = std :: min ( min , ( int ) strs [ i ]. length ()); for ( int i = 0 ; i < min ; i ++ ) { char c = strs [ 0 ][ i ]; for ( int j = 1 ; j < strs . size (); j ++ ) if ( c != strs [ j ][ i ]) { isMatch = false ; break ; } if ( ! isMatch ) break ; ans += c ; } return ans ; } }; 15. 3Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : vector < vector < int >> threeSum ( vector < int >& nums ) { vector < vector < int >> ans ; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i + 2 < nums . size (); i ++ ) { if ( i > 0 && nums [ i ] == nums [ i - 1 ]) continue ; int l = i + 1 ; int r = nums . size () - 1 ; while ( l < r ) { int sum = nums [ i ] + nums [ l ] + nums [ r ]; if ( sum == 0 ) { ans . push_back ({ nums [ i ], nums [ l ], nums [ r ]}); l ++ ; r -- ; while ( nums [ l ] == nums [ l - 1 ] && l < r ) l ++ ; while ( nums [ r ] == nums [ r + 1 ] && l < r ) r -- ; } else if ( sum < 0 ) { l ++ ; } else { r -- ; } } } return ans ; } }; 16. 3Sum Closest $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int threeSumClosest ( vector < int >& nums , int target ) { int ans = nums [ 0 ] + nums [ 1 ] + nums [ 2 ]; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i + 2 < nums . size (); i ++ ) { int l = i + 1 ; int r = nums . size () - 1 ; while ( l < r ) { int sum = nums [ i ] + nums [ l ] + nums [ r ]; if ( sum == target ) return sum ; if ( abs ( sum - target ) < abs ( ans - target )) ans = sum ; if ( sum < target ) l ++ ; else r -- ; } } return ans ; } }; 17. Letter Combinations of a Phone Number $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < string > letterCombinations ( string digits ) { if ( digits . empty ()) return {}; vector < string > ans = { \"\" }; unordered_map < char , string > map = { { '2' , \"abc\" }, { '3' , \"def\" }, { '4' , \"ghi\" }, { '5' , \"jkl\" }, { '6' , \"mno\" }, { '7' , \"pqrs\" }, { '8' , \"tuv\" }, { '9' , \"wxyz\" }}; for ( char i : digits ) { vector < string > tmp ; for ( string & j : ans ) for ( char k : map [ i ]) tmp . push_back ( j + k ); ans = tmp ; } return ans ; } }; 18. 4Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { public : vector < vector < int >> fourSum ( vector < int >& nums , int target ) { vector < vector < int >> ans ; vector < int > path ; sort ( nums . begin (), nums . end ()); nSum ( nums , target , 0 , nums . size () - 1 , 4 , path , ans ); return ans ; } private : void nSum ( vector < int >& nums , int target , int l , int r , int n , vector < int >& path , vector < vector < int >>& ans ) { if ( r - l + 1 < n || n < 2 || target < nums [ l ] * n || target > nums [ r ] * n ) return ; if ( n == 2 ) { while ( l < r ) { int sum = nums [ l ] + nums [ r ]; if ( sum == target ) { path . push_back ( nums [ l ]); path . push_back ( nums [ r ]); ans . push_back ( path ); path . pop_back (); path . pop_back (); l ++ ; while ( nums [ l ] == nums [ l - 1 ] && l < r ) l ++ ; } else if ( sum < target ) { l ++ ; } else { r -- ; } } return ; } for ( int i = l ; i <= r ; i ++ ) { if ( i > l && nums [ i ] == nums [ i - 1 ]) continue ; path . push_back ( nums [ i ]); nSum ( nums , target - nums [ i ], i + 1 , r , n - 1 , path , ans ); path . pop_back (); } } }; 19. Remove Nth Node From End of List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : ListNode * removeNthFromEnd ( ListNode * head , int n ) { auto slow = head ; auto fast = head ; while ( n -- ) fast = fast -> next ; if ( ! fast ) return head -> next ; while ( fast -> next ) { slow = slow -> next ; fast = fast -> next ; } slow -> next = slow -> next -> next ; return head ; } }; 20. Valid Parentheses $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool isValid ( string s ) { stack < char > stack ; for ( char c : s ) { if ( c == '(' || c == '{' || c == '[' ) { stack . push ( c ); } else { if ( stack . empty () || ( c == ')' && stack . top () != '(' ) || ( c == '}' && stack . top () != '{' ) || ( c == ']' && stack . top () != '[' )) return false ; stack . pop (); } } return stack . empty (); } };","title":"0011-0020"},{"location":"cpp/0001-0100/0011-0020/#11-container-with-most-water-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxArea ( vector < int >& height ) { int ans = 0 ; int l = 0 ; int r = height . size () - 1 ; while ( l < r ) { int h = min ( height [ l ], height [ r ]); ans = max ( ans , ( r - l ) * h ); while ( height [ l ] <= h && l < r ) l ++ ; while ( height [ r ] <= h && l < r ) r -- ; } return ans ; } };","title":"11. Container With Most Water $\\star\\star$"},{"location":"cpp/0001-0100/0011-0020/#12-integer-to-roman-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : string intToRoman ( int num ) { string M [ 4 ] = { \"\" , \"M\" , \"MM\" , \"MMM\" }; string C [ 10 ] = { \"\" , \"C\" , \"CC\" , \"CCC\" , \"CD\" , \"D\" , \"DC\" , \"DCC\" , \"DCCC\" , \"CM\" }; string X [ 10 ] = { \"\" , \"X\" , \"XX\" , \"XXX\" , \"XL\" , \"L\" , \"LX\" , \"LXX\" , \"LXXX\" , \"XC\" }; string I [ 10 ] = { \"\" , \"I\" , \"II\" , \"III\" , \"IV\" , \"V\" , \"VI\" , \"VII\" , \"VIII\" , \"IX\" }; return M [ num / 1000 ] + C [ num % 1000 / 100 ] + X [ num % 100 / 10 ] + I [ num % 10 ]; } };","title":"12. Integer to Roman $\\star\\star$"},{"location":"cpp/0001-0100/0011-0020/#13-roman-to-integer-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int romanToInt ( string s ) { int ans = 0 ; unordered_map < char , int > map = {{ 'I' , 1 }, { 'V' , 5 }, { 'X' , 10 }, { 'L' , 50 }, { 'C' , 100 }, { 'D' , 500 }, { 'M' , 1000 }}; for ( int i = 0 ; i < s . size (); i ++ ) { if ( map [ s [ i ]] < map [ s [ i + 1 ]]) ans -= map [ s [ i ]]; else ans += map [ s [ i ]]; } return ans ; } };","title":"13. Roman to Integer $\\star$"},{"location":"cpp/0001-0100/0011-0020/#14-longest-common-prefix-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : string longestCommonPrefix ( vector < string >& strs ) { if ( strs . size () == 0 ) return \"\" ; if ( strs . size () == 1 ) return strs [ 0 ]; string ans ; int min = strs [ 0 ]. length (); bool isMatch = true ; for ( int i = 1 ; i < strs . size (); i ++ ) min = std :: min ( min , ( int ) strs [ i ]. length ()); for ( int i = 0 ; i < min ; i ++ ) { char c = strs [ 0 ][ i ]; for ( int j = 1 ; j < strs . size (); j ++ ) if ( c != strs [ j ][ i ]) { isMatch = false ; break ; } if ( ! isMatch ) break ; ans += c ; } return ans ; } };","title":"14. Longest Common Prefix $\\star$"},{"location":"cpp/0001-0100/0011-0020/#15-3sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : vector < vector < int >> threeSum ( vector < int >& nums ) { vector < vector < int >> ans ; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i + 2 < nums . size (); i ++ ) { if ( i > 0 && nums [ i ] == nums [ i - 1 ]) continue ; int l = i + 1 ; int r = nums . size () - 1 ; while ( l < r ) { int sum = nums [ i ] + nums [ l ] + nums [ r ]; if ( sum == 0 ) { ans . push_back ({ nums [ i ], nums [ l ], nums [ r ]}); l ++ ; r -- ; while ( nums [ l ] == nums [ l - 1 ] && l < r ) l ++ ; while ( nums [ r ] == nums [ r + 1 ] && l < r ) r -- ; } else if ( sum < 0 ) { l ++ ; } else { r -- ; } } } return ans ; } };","title":"15. 3Sum $\\star\\star$"},{"location":"cpp/0001-0100/0011-0020/#16-3sum-closest-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int threeSumClosest ( vector < int >& nums , int target ) { int ans = nums [ 0 ] + nums [ 1 ] + nums [ 2 ]; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i + 2 < nums . size (); i ++ ) { int l = i + 1 ; int r = nums . size () - 1 ; while ( l < r ) { int sum = nums [ i ] + nums [ l ] + nums [ r ]; if ( sum == target ) return sum ; if ( abs ( sum - target ) < abs ( ans - target )) ans = sum ; if ( sum < target ) l ++ ; else r -- ; } } return ans ; } };","title":"16. 3Sum Closest $\\star\\star$"},{"location":"cpp/0001-0100/0011-0020/#17-letter-combinations-of-a-phone-number-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < string > letterCombinations ( string digits ) { if ( digits . empty ()) return {}; vector < string > ans = { \"\" }; unordered_map < char , string > map = { { '2' , \"abc\" }, { '3' , \"def\" }, { '4' , \"ghi\" }, { '5' , \"jkl\" }, { '6' , \"mno\" }, { '7' , \"pqrs\" }, { '8' , \"tuv\" }, { '9' , \"wxyz\" }}; for ( char i : digits ) { vector < string > tmp ; for ( string & j : ans ) for ( char k : map [ i ]) tmp . push_back ( j + k ); ans = tmp ; } return ans ; } };","title":"17. Letter Combinations of a Phone Number $\\star\\star$"},{"location":"cpp/0001-0100/0011-0020/#18-4sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { public : vector < vector < int >> fourSum ( vector < int >& nums , int target ) { vector < vector < int >> ans ; vector < int > path ; sort ( nums . begin (), nums . end ()); nSum ( nums , target , 0 , nums . size () - 1 , 4 , path , ans ); return ans ; } private : void nSum ( vector < int >& nums , int target , int l , int r , int n , vector < int >& path , vector < vector < int >>& ans ) { if ( r - l + 1 < n || n < 2 || target < nums [ l ] * n || target > nums [ r ] * n ) return ; if ( n == 2 ) { while ( l < r ) { int sum = nums [ l ] + nums [ r ]; if ( sum == target ) { path . push_back ( nums [ l ]); path . push_back ( nums [ r ]); ans . push_back ( path ); path . pop_back (); path . pop_back (); l ++ ; while ( nums [ l ] == nums [ l - 1 ] && l < r ) l ++ ; } else if ( sum < target ) { l ++ ; } else { r -- ; } } return ; } for ( int i = l ; i <= r ; i ++ ) { if ( i > l && nums [ i ] == nums [ i - 1 ]) continue ; path . push_back ( nums [ i ]); nSum ( nums , target - nums [ i ], i + 1 , r , n - 1 , path , ans ); path . pop_back (); } } };","title":"18. 4Sum $\\star\\star$"},{"location":"cpp/0001-0100/0011-0020/#19-remove-nth-node-from-end-of-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : ListNode * removeNthFromEnd ( ListNode * head , int n ) { auto slow = head ; auto fast = head ; while ( n -- ) fast = fast -> next ; if ( ! fast ) return head -> next ; while ( fast -> next ) { slow = slow -> next ; fast = fast -> next ; } slow -> next = slow -> next -> next ; return head ; } };","title":"19. Remove Nth Node From End of List $\\star\\star$"},{"location":"cpp/0001-0100/0011-0020/#20-valid-parentheses-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool isValid ( string s ) { stack < char > stack ; for ( char c : s ) { if ( c == '(' || c == '{' || c == '[' ) { stack . push ( c ); } else { if ( stack . empty () || ( c == ')' && stack . top () != '(' ) || ( c == '}' && stack . top () != '{' ) || ( c == ']' && stack . top () != '[' )) return false ; stack . pop (); } } return stack . empty (); } };","title":"20. Valid Parentheses $\\star$"},{"location":"cpp/0001-0100/0021-0030/","text":"21. Merge Two Sorted Lists $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : ListNode * mergeTwoLists ( ListNode * l1 , ListNode * l2 ) { if ( ! l1 || ! l2 ) return l1 ? l1 : l2 ; if ( l1 -> val > l2 -> val ) swap ( l1 , l2 ); l1 -> next = mergeTwoLists ( l1 -> next , l2 ); return l1 ; } }; 22. Generate Parentheses $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < string > generateParenthesis ( int n ) { vector < string > ans ; helper ( \"\" , n , n , ans ); return ans ; } private : void helper ( string str , int l , int r , vector < string >& ans ) { if ( l == 0 && r == 0 ) ans . push_back ( str ); if ( l > 0 ) helper ( str + '(' , l - 1 , r , ans ); if ( l < r ) helper ( str + ')' , l , r - 1 , ans ); } }; 23. Merge k Sorted Lists $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : ListNode * mergeKLists ( vector < ListNode *>& lists ) { ListNode dummy ( 0 ); ListNode * curr = & dummy ; priority_queue < ListNode * , vector < ListNode *> , compareListNode > pq ; for ( auto list : lists ) if ( list ) pq . push ( list ); while ( ! pq . empty ()) { curr -> next = pq . top (); pq . pop (); curr = curr -> next ; if ( curr -> next ) pq . push ( curr -> next ); } return dummy . next ; } private : struct compareListNode { bool operator ()( const ListNode * l1 , const ListNode * l2 ) { return l1 -> val > l2 -> val ; } }; }; 24. Swap Nodes in Pairs $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : ListNode * swapPairs ( ListNode * head ) { if ( ! head || ! head -> next ) return head ; ListNode dummy ( 0 ); dummy . next = head ; int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) length ++ ; auto prev = & dummy ; auto curr = head ; for ( int i = 0 ; i < length / 2 ; i ++ ) { auto next = curr -> next ; curr -> next = next -> next ; next -> next = prev -> next ; prev -> next = next ; prev = curr ; curr = curr -> next ; } return dummy . next ; } }; 25. Reverse Nodes in k-Group $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : ListNode * reverseKGroup ( ListNode * head , int k ) { if ( ! head || k == 1 ) return head ; ListNode dummy ( 0 ); dummy . next = head ; int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) length ++ ; auto prev = & dummy ; auto curr = head ; for ( int i = 0 ; i < length / k ; i ++ ) { for ( int j = 0 ; j < k - 1 ; j ++ ) { auto next = curr -> next ; curr -> next = next -> next ; next -> next = prev -> next ; prev -> next = next ; } prev = curr ; curr = curr -> next ; } return dummy . next ; } }; 26. Remove Duplicates from Sorted Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int removeDuplicates ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; int j = 0 ; for ( int i = 1 ; i < nums . size (); i ++ ) if ( nums [ i ] != nums [ j ]) nums [ ++ j ] = nums [ i ]; return j + 1 ; } }; 27. Remove Element $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int removeElement ( vector < int >& nums , int val ) { int i = 0 ; for ( int num : nums ) if ( num != val ) nums [ i ++ ] = num ; return i ; } }; 28. Implement strStr() $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int strStr ( string haystack , string needle ) { const int m = haystack . length (); const int n = needle . length (); for ( int i = 0 ; i < m - n + 1 ; i ++ ) if ( haystack . substr ( i , n ) == needle ) return i ; return - 1 ; } }; 29. Divide Two Integers $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int divide ( int dividend , int divisor ) { if ( dividend == INT_MIN && divisor == - 1 ) return INT_MAX ; long ans = 0 ; long dvd = labs ( dividend ); long dvs = labs ( divisor ); int sign = dividend > 0 ^ divisor > 0 ? - 1 : 1 ; while ( dvd >= dvs ) { long m = 1 ; long temp = dvs ; while ( temp << 1 <= dvd ) { m <<= 1 ; temp <<= 1 ; } dvd -= temp ; ans += m ; } return sign * ans ; } }; 30. Substring with Concatenation of All Words $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Solution { public : vector < int > findSubstring ( string s , vector < string >& words ) { if ( s . empty () || words . empty ()) return {}; const int m = s . length (); const int n = words [ 0 ]. length (); vector < int > ans ; unordered_map < string , int > map ; for ( string & word : words ) map [ word ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { int index = i ; int count = 0 ; unordered_map < string , int > tempMap ; for ( int j = i ; j <= m - n ; j += n ) { string str = s . substr ( j , n ); if ( map . count ( str )) { tempMap [ str ] ++ ; count ++ ; while ( tempMap [ str ] > map [ str ]) { tempMap [ s . substr ( index , n )] -- ; count -- ; index += n ; } if ( count == words . size ()) { ans . push_back ( index ); tempMap [ s . substr ( index , n )] -- ; count -- ; index += n ; } } else { tempMap . clear (); count = 0 ; index = j + n ; } } } return ans ; } };","title":"0021-0030"},{"location":"cpp/0001-0100/0021-0030/#21-merge-two-sorted-lists-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : ListNode * mergeTwoLists ( ListNode * l1 , ListNode * l2 ) { if ( ! l1 || ! l2 ) return l1 ? l1 : l2 ; if ( l1 -> val > l2 -> val ) swap ( l1 , l2 ); l1 -> next = mergeTwoLists ( l1 -> next , l2 ); return l1 ; } };","title":"21. Merge Two Sorted Lists $\\star$"},{"location":"cpp/0001-0100/0021-0030/#22-generate-parentheses-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < string > generateParenthesis ( int n ) { vector < string > ans ; helper ( \"\" , n , n , ans ); return ans ; } private : void helper ( string str , int l , int r , vector < string >& ans ) { if ( l == 0 && r == 0 ) ans . push_back ( str ); if ( l > 0 ) helper ( str + '(' , l - 1 , r , ans ); if ( l < r ) helper ( str + ')' , l , r - 1 , ans ); } };","title":"22. Generate Parentheses $\\star\\star$"},{"location":"cpp/0001-0100/0021-0030/#23-merge-k-sorted-lists-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : ListNode * mergeKLists ( vector < ListNode *>& lists ) { ListNode dummy ( 0 ); ListNode * curr = & dummy ; priority_queue < ListNode * , vector < ListNode *> , compareListNode > pq ; for ( auto list : lists ) if ( list ) pq . push ( list ); while ( ! pq . empty ()) { curr -> next = pq . top (); pq . pop (); curr = curr -> next ; if ( curr -> next ) pq . push ( curr -> next ); } return dummy . next ; } private : struct compareListNode { bool operator ()( const ListNode * l1 , const ListNode * l2 ) { return l1 -> val > l2 -> val ; } }; };","title":"23. Merge k Sorted Lists $\\star\\star\\star$"},{"location":"cpp/0001-0100/0021-0030/#24-swap-nodes-in-pairs-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : ListNode * swapPairs ( ListNode * head ) { if ( ! head || ! head -> next ) return head ; ListNode dummy ( 0 ); dummy . next = head ; int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) length ++ ; auto prev = & dummy ; auto curr = head ; for ( int i = 0 ; i < length / 2 ; i ++ ) { auto next = curr -> next ; curr -> next = next -> next ; next -> next = prev -> next ; prev -> next = next ; prev = curr ; curr = curr -> next ; } return dummy . next ; } };","title":"24. Swap Nodes in Pairs $\\star\\star$"},{"location":"cpp/0001-0100/0021-0030/#25-reverse-nodes-in-k-group-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : ListNode * reverseKGroup ( ListNode * head , int k ) { if ( ! head || k == 1 ) return head ; ListNode dummy ( 0 ); dummy . next = head ; int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) length ++ ; auto prev = & dummy ; auto curr = head ; for ( int i = 0 ; i < length / k ; i ++ ) { for ( int j = 0 ; j < k - 1 ; j ++ ) { auto next = curr -> next ; curr -> next = next -> next ; next -> next = prev -> next ; prev -> next = next ; } prev = curr ; curr = curr -> next ; } return dummy . next ; } };","title":"25. Reverse Nodes in k-Group $\\star\\star\\star$"},{"location":"cpp/0001-0100/0021-0030/#26-remove-duplicates-from-sorted-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int removeDuplicates ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; int j = 0 ; for ( int i = 1 ; i < nums . size (); i ++ ) if ( nums [ i ] != nums [ j ]) nums [ ++ j ] = nums [ i ]; return j + 1 ; } };","title":"26. Remove Duplicates from Sorted Array $\\star$"},{"location":"cpp/0001-0100/0021-0030/#27-remove-element-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int removeElement ( vector < int >& nums , int val ) { int i = 0 ; for ( int num : nums ) if ( num != val ) nums [ i ++ ] = num ; return i ; } };","title":"27. Remove Element $\\star$"},{"location":"cpp/0001-0100/0021-0030/#28-implement-strstr-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int strStr ( string haystack , string needle ) { const int m = haystack . length (); const int n = needle . length (); for ( int i = 0 ; i < m - n + 1 ; i ++ ) if ( haystack . substr ( i , n ) == needle ) return i ; return - 1 ; } };","title":"28. Implement strStr() $\\star$"},{"location":"cpp/0001-0100/0021-0030/#29-divide-two-integers-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int divide ( int dividend , int divisor ) { if ( dividend == INT_MIN && divisor == - 1 ) return INT_MAX ; long ans = 0 ; long dvd = labs ( dividend ); long dvs = labs ( divisor ); int sign = dividend > 0 ^ divisor > 0 ? - 1 : 1 ; while ( dvd >= dvs ) { long m = 1 ; long temp = dvs ; while ( temp << 1 <= dvd ) { m <<= 1 ; temp <<= 1 ; } dvd -= temp ; ans += m ; } return sign * ans ; } };","title":"29. Divide Two Integers $\\star\\star$"},{"location":"cpp/0001-0100/0021-0030/#30-substring-with-concatenation-of-all-words-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class Solution { public : vector < int > findSubstring ( string s , vector < string >& words ) { if ( s . empty () || words . empty ()) return {}; const int m = s . length (); const int n = words [ 0 ]. length (); vector < int > ans ; unordered_map < string , int > map ; for ( string & word : words ) map [ word ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { int index = i ; int count = 0 ; unordered_map < string , int > tempMap ; for ( int j = i ; j <= m - n ; j += n ) { string str = s . substr ( j , n ); if ( map . count ( str )) { tempMap [ str ] ++ ; count ++ ; while ( tempMap [ str ] > map [ str ]) { tempMap [ s . substr ( index , n )] -- ; count -- ; index += n ; } if ( count == words . size ()) { ans . push_back ( index ); tempMap [ s . substr ( index , n )] -- ; count -- ; index += n ; } } else { tempMap . clear (); count = 0 ; index = j + n ; } } } return ans ; } };","title":"30. Substring with Concatenation of All Words $\\star\\star\\star$"},{"location":"cpp/0001-0100/0031-0040/","text":"31. Next Permutation $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : void nextPermutation ( vector < int >& nums ) { int i ; for ( i = nums . size () - 2 ; i >= 0 ; i -- ) if ( nums [ i ] < nums [ i + 1 ]) break ; if ( i >= 0 ) { int j ; for ( j = nums . size () - 1 ; j >= 0 ; j -- ) if ( nums [ j ] > nums [ i ]) break ; swap ( nums [ i ], nums [ j ]); } reverse ( nums , i + 1 , nums . size () - 1 ); } private : void reverse ( vector < int >& nums , int l , int r ) { while ( l < r ) { swap ( nums [ l ], nums [ r ]); l ++ ; r -- ; } } }; 32. Longest Valid Parentheses $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public : int longestValidParentheses ( string s ) { int ans = 0 ; int l = 0 ; int r = 0 ; for ( int i = 0 ; i < s . length (); i ++ ) { if ( s [ i ] == '(' ) l ++ ; else r ++ ; if ( l == r ) ans = max ( ans , 2 * r ); else if ( r > l ) { l = 0 ; r = 0 ; } } l = 0 ; r = 0 ; for ( int i = s . length () - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '(' ) l ++ ; else r ++ ; if ( l == r ) ans = max ( ans , 2 * l ); else if ( l > r ) { l = 0 ; r = 0 ; } } return ans ; } }; 33. Search in Rotated Sorted Array $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int search ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size () - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ l ] <= nums [ m ]) { if ( nums [ l ] <= target && target < nums [ m ]) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ]) l = m + 1 ; else r = m - 1 ; } } return - 1 ; } }; 34. Find First and Last Position of Element in Sorted Array $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < int > searchRange ( vector < int >& nums , int target ) { int leftIndex = find ( nums , target , true ); if ( leftIndex == nums . size () || nums [ leftIndex ] != target ) return { - 1 , - 1 }; return { leftIndex , find ( nums , target , false ) - 1 }; } private : int find ( vector < int >& nums , int target , bool isLeft ) { int l = 0 ; int r = nums . size (); while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] > target || ( isLeft && nums [ m ] == target )) r = m ; else l = m + 1 ; } return l ; } }; 35. Search Insert Position $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int searchInsert ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size (); while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ m ] < target ) l = m + 1 ; else r = m ; } return l ; } }; 36. Valid Sudoku $\\star\\star$ 37. Sudoku Solver $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : void solveSudoku ( vector < vector < char >>& board ) { dfs ( 0 , board ); } private : bool dfs ( int s , vector < vector < char >>& board ) { if ( s == 81 ) return true ; int i = s / 9 ; int j = s % 9 ; if ( board [ i ][ j ] != '.' ) return dfs ( s + 1 , board ); for ( char c = '1' ; c <= '9' ; c ++ ) if ( isValid ( i , j , c , board )) { board [ i ][ j ] = c ; if ( dfs ( s + 1 , board )) return true ; board [ i ][ j ] = '.' ; } return false ; } bool isValid ( int row , int col , char c , vector < vector < char >>& board ) { for ( int i = 0 ; i < 9 ; i ++ ) { if ( board [ i ][ col ] != '.' && board [ i ][ col ] == c ) return false ; if ( board [ row ][ i ] != '.' && board [ row ][ i ] == c ) return false ; if ( board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] != '.' && board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] == c ) return false ; } return true ; } }; 38. Count and Say $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : string countAndSay ( int n ) { unordered_map < int , string > map = { { 1 , \"1\" }, { 2 , \"11\" }, { 3 , \"21\" }, { 4 , \"1211\" }, { 5 , \"111221\" }}; if ( n <= 5 ) return map [ n ]; for ( int i = 6 ; i < n + 1 ; i ++ ) { string s ; int j = 0 ; while ( j <= map [ i - 1 ]. size () - 2 ) { int count = 1 ; while ( j <= map [ i - 1 ]. size () - 2 && map [ i - 1 ][ j ] == map [ i - 1 ][ j + 1 ]) { count ++ ; j ++ ; } s += to_string ( count ) + map [ i - 1 ][ j ]; j ++ ; } if ( j == map [ i - 1 ]. size () - 1 ) s += to_string ( 1 ) + map [ i - 1 ][ j ]; map [ i ] = s ; } return map [ n ]; } }; 39. Combination Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < vector < int >> combinationSum ( vector < int >& candidates , int target ) { vector < vector < int >> ans ; vector < int > path ; sort ( candidates . begin (), candidates . end ()); dfs ( candidates , target , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& candidates , int target , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i < candidates . size (); i ++ ) { path . push_back ( candidates [ i ]); dfs ( candidates , target - candidates [ i ], i , path , ans ); path . pop_back (); } } }; 40. Combination Sum II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : vector < vector < int >> combinationSum2 ( vector < int >& candidates , int target ) { vector < vector < int >> ans ; vector < int > path ; sort ( candidates . begin (), candidates . end ()); dfs ( candidates , target , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& candidates , int target , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i < candidates . size (); i ++ ) { if ( i > s && candidates [ i ] == candidates [ i - 1 ]) continue ; path . push_back ( candidates [ i ]); dfs ( candidates , target - candidates [ i ], i + 1 , path , ans ); path . pop_back (); } } };","title":"0031-0040"},{"location":"cpp/0001-0100/0031-0040/#31-next-permutation-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : void nextPermutation ( vector < int >& nums ) { int i ; for ( i = nums . size () - 2 ; i >= 0 ; i -- ) if ( nums [ i ] < nums [ i + 1 ]) break ; if ( i >= 0 ) { int j ; for ( j = nums . size () - 1 ; j >= 0 ; j -- ) if ( nums [ j ] > nums [ i ]) break ; swap ( nums [ i ], nums [ j ]); } reverse ( nums , i + 1 , nums . size () - 1 ); } private : void reverse ( vector < int >& nums , int l , int r ) { while ( l < r ) { swap ( nums [ l ], nums [ r ]); l ++ ; r -- ; } } };","title":"31. Next Permutation $\\star\\star$"},{"location":"cpp/0001-0100/0031-0040/#32-longest-valid-parentheses-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public : int longestValidParentheses ( string s ) { int ans = 0 ; int l = 0 ; int r = 0 ; for ( int i = 0 ; i < s . length (); i ++ ) { if ( s [ i ] == '(' ) l ++ ; else r ++ ; if ( l == r ) ans = max ( ans , 2 * r ); else if ( r > l ) { l = 0 ; r = 0 ; } } l = 0 ; r = 0 ; for ( int i = s . length () - 1 ; i >= 0 ; i -- ) { if ( s [ i ] == '(' ) l ++ ; else r ++ ; if ( l == r ) ans = max ( ans , 2 * l ); else if ( l > r ) { l = 0 ; r = 0 ; } } return ans ; } };","title":"32. Longest Valid Parentheses $\\star\\star\\star$"},{"location":"cpp/0001-0100/0031-0040/#33-search-in-rotated-sorted-array-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int search ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size () - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ l ] <= nums [ m ]) { if ( nums [ l ] <= target && target < nums [ m ]) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ]) l = m + 1 ; else r = m - 1 ; } } return - 1 ; } };","title":"33. Search in Rotated Sorted Array $\\star\\star$"},{"location":"cpp/0001-0100/0031-0040/#34-find-first-and-last-position-of-element-in-sorted-array-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < int > searchRange ( vector < int >& nums , int target ) { int leftIndex = find ( nums , target , true ); if ( leftIndex == nums . size () || nums [ leftIndex ] != target ) return { - 1 , - 1 }; return { leftIndex , find ( nums , target , false ) - 1 }; } private : int find ( vector < int >& nums , int target , bool isLeft ) { int l = 0 ; int r = nums . size (); while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] > target || ( isLeft && nums [ m ] == target )) r = m ; else l = m + 1 ; } return l ; } };","title":"34. Find First and Last Position of Element in Sorted Array $\\star\\star$"},{"location":"cpp/0001-0100/0031-0040/#35-search-insert-position-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int searchInsert ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size (); while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ m ] < target ) l = m + 1 ; else r = m ; } return l ; } };","title":"35. Search Insert Position $\\star$"},{"location":"cpp/0001-0100/0031-0040/#36-valid-sudoku-starstar","text":"","title":"36. Valid Sudoku $\\star\\star$"},{"location":"cpp/0001-0100/0031-0040/#37-sudoku-solver-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : void solveSudoku ( vector < vector < char >>& board ) { dfs ( 0 , board ); } private : bool dfs ( int s , vector < vector < char >>& board ) { if ( s == 81 ) return true ; int i = s / 9 ; int j = s % 9 ; if ( board [ i ][ j ] != '.' ) return dfs ( s + 1 , board ); for ( char c = '1' ; c <= '9' ; c ++ ) if ( isValid ( i , j , c , board )) { board [ i ][ j ] = c ; if ( dfs ( s + 1 , board )) return true ; board [ i ][ j ] = '.' ; } return false ; } bool isValid ( int row , int col , char c , vector < vector < char >>& board ) { for ( int i = 0 ; i < 9 ; i ++ ) { if ( board [ i ][ col ] != '.' && board [ i ][ col ] == c ) return false ; if ( board [ row ][ i ] != '.' && board [ row ][ i ] == c ) return false ; if ( board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] != '.' && board [ 3 * ( row / 3 ) + i / 3 ][ 3 * ( col / 3 ) + i % 3 ] == c ) return false ; } return true ; } };","title":"37. Sudoku Solver $\\star\\star\\star$"},{"location":"cpp/0001-0100/0031-0040/#38-count-and-say-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : string countAndSay ( int n ) { unordered_map < int , string > map = { { 1 , \"1\" }, { 2 , \"11\" }, { 3 , \"21\" }, { 4 , \"1211\" }, { 5 , \"111221\" }}; if ( n <= 5 ) return map [ n ]; for ( int i = 6 ; i < n + 1 ; i ++ ) { string s ; int j = 0 ; while ( j <= map [ i - 1 ]. size () - 2 ) { int count = 1 ; while ( j <= map [ i - 1 ]. size () - 2 && map [ i - 1 ][ j ] == map [ i - 1 ][ j + 1 ]) { count ++ ; j ++ ; } s += to_string ( count ) + map [ i - 1 ][ j ]; j ++ ; } if ( j == map [ i - 1 ]. size () - 1 ) s += to_string ( 1 ) + map [ i - 1 ][ j ]; map [ i ] = s ; } return map [ n ]; } };","title":"38. Count and Say $\\star$"},{"location":"cpp/0001-0100/0031-0040/#39-combination-sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < vector < int >> combinationSum ( vector < int >& candidates , int target ) { vector < vector < int >> ans ; vector < int > path ; sort ( candidates . begin (), candidates . end ()); dfs ( candidates , target , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& candidates , int target , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i < candidates . size (); i ++ ) { path . push_back ( candidates [ i ]); dfs ( candidates , target - candidates [ i ], i , path , ans ); path . pop_back (); } } };","title":"39. Combination Sum $\\star\\star$"},{"location":"cpp/0001-0100/0031-0040/#40-combination-sum-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : vector < vector < int >> combinationSum2 ( vector < int >& candidates , int target ) { vector < vector < int >> ans ; vector < int > path ; sort ( candidates . begin (), candidates . end ()); dfs ( candidates , target , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& candidates , int target , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i < candidates . size (); i ++ ) { if ( i > s && candidates [ i ] == candidates [ i - 1 ]) continue ; path . push_back ( candidates [ i ]); dfs ( candidates , target - candidates [ i ], i + 1 , path , ans ); path . pop_back (); } } };","title":"40. Combination Sum II $\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/","text":"41. First Missing Positive $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int firstMissingPositive ( vector < int >& nums ) { if ( nums . empty ()) return 1 ; const int n = nums . size (); for ( int i = 0 ; i < nums . size (); i ++ ) while ( nums [ i ] > 0 && nums [ i ] <= n && nums [ i ] != nums [ nums [ i ] - 1 ]) swap ( nums [ i ], nums [ nums [ i ] - 1 ]); for ( int i = 0 ; i < n ; i ++ ) if ( nums [ i ] != i + 1 ) return i + 1 ; return n + 1 ; } }; 42. Trapping Rain Water $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int trap ( vector < int >& height ) { int ans = 0 ; int l = 0 ; int r = height . size () - 1 ; int maxLeft = 0 ; int maxRight = 0 ; while ( l < r ) { if ( height [ l ] < height [ r ]) { maxLeft = max ( maxLeft , height [ l ]); ans += maxLeft - height [ l ]; l ++ ; } else { maxRight = max ( maxRight , height [ r ]); ans += maxRight - height [ r ]; r -- ; } } return ans ; } }; 43. Multiply Strings $\\star\\star$ 44. Wildcard Matching $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : bool isMatch ( string s , string p ) { const int m = s . length (); const int n = p . length (); vector < vector < bool >> dp ( m + 1 , vector < bool > ( n + 1 )); for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 && j == 0 ) dp [ i ][ j ] = true ; else if ( i == 0 ) dp [ i ][ j ] = dp [ i ][ j - 1 ] && p [ j - 1 ] == '*' ; else if ( j == 0 ) dp [ i ][ j ] = dp [ i - 1 ][ j ] && s [ i - 1 ] == '*' ; else dp [ i ][ j ] = ( dp [ i - 1 ][ j ] || dp [ i ][ j - 1 ] || dp [ i - 1 ][ j - 1 ]) && ( s [ i - 1 ] == '*' || p [ j - 1 ] == '*' ) || ( dp [ i - 1 ][ j - 1 ]) && ( s [ i - 1 ] == '?' || p [ j - 1 ] == '?' || s [ i - 1 ] == p [ j - 1 ]); } return dp [ m ][ n ]; } }; 45. Jump Game II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int jump ( vector < int >& nums ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i + 1 < nums . size (); i ++ ) { farthest = max ( farthest , i + nums [ i ]); if ( i == end ) { ans ++ ; end = farthest ; } } return ans ; } }; 46. Permutations $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < vector < int >> permute ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size (), false ); dfs ( nums , nums . size (), used , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int target , vector < bool >& used , vector < int >& path , vector < vector < int >>& ans ) { if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); i ++ ) { if ( used [ i ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs ( nums , target - 1 , used , path , ans ); path . pop_back (); used [ i ] = false ; } } }; 47. Permutations II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : vector < vector < int >> permuteUnique ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size (), false ); sort ( nums . begin (), nums . end ()); dfs ( nums , nums . size (), used , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int target , vector < bool >& used , vector < int >& path , vector < vector < int >>& ans ) { if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); i ++ ) { if ( used [ i ] || i > 0 && used [ i - 1 ] && nums [ i ] == nums [ i - 1 ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs ( nums , target - 1 , used , path , ans ); path . pop_back (); used [ i ] = false ; } } }; 48. Rotate Image $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : void rotate ( vector < vector < int >>& matrix ) { for ( int min = 0 ; min < matrix . size () / 2 ; min ++ ) { int max = matrix . size () - min - 1 ; for ( int i = min ; i < max ; i ++ ) { int offset = i - min ; int top = matrix [ min ][ i ]; matrix [ min ][ i ] = matrix [ max - offset ][ min ]; matrix [ max - offset ][ min ] = matrix [ max ][ max - offset ]; matrix [ max ][ max - offset ] = matrix [ i ][ max ]; matrix [ i ][ max ] = top ; } } } }; 49. Group Anagrams $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < vector < string >> groupAnagrams ( vector < string >& strs ) { vector < vector < string >> ans ; unordered_map < string , vector < string >> map ; for ( string & str : strs ) { string s = str ; sort ( s . begin (), s . end ()); map [ s ]. push_back ( str ); } for ( auto & [ key , value ] : map ) { vector < string > s = value ; sort ( s . begin (), s . end ()); ans . push_back ( s ); } return ans ; } }; 50. Pow(x, n) $\\star\\star$ 1 2 3 4 5 6 7 8 9 class Solution { public : double myPow ( double x , long n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 1 / myPow ( x , - n ); if ( n % 2 ) return x * myPow ( x , n - 1 ); return myPow ( x * x , n / 2 ); } };","title":"0041-0050"},{"location":"cpp/0001-0100/0041-0050/#41-first-missing-positive-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int firstMissingPositive ( vector < int >& nums ) { if ( nums . empty ()) return 1 ; const int n = nums . size (); for ( int i = 0 ; i < nums . size (); i ++ ) while ( nums [ i ] > 0 && nums [ i ] <= n && nums [ i ] != nums [ nums [ i ] - 1 ]) swap ( nums [ i ], nums [ nums [ i ] - 1 ]); for ( int i = 0 ; i < n ; i ++ ) if ( nums [ i ] != i + 1 ) return i + 1 ; return n + 1 ; } };","title":"41. First Missing Positive $\\star\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#42-trapping-rain-water-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int trap ( vector < int >& height ) { int ans = 0 ; int l = 0 ; int r = height . size () - 1 ; int maxLeft = 0 ; int maxRight = 0 ; while ( l < r ) { if ( height [ l ] < height [ r ]) { maxLeft = max ( maxLeft , height [ l ]); ans += maxLeft - height [ l ]; l ++ ; } else { maxRight = max ( maxRight , height [ r ]); ans += maxRight - height [ r ]; r -- ; } } return ans ; } };","title":"42. Trapping Rain Water $\\star\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#43-multiply-strings-starstar","text":"","title":"43. Multiply Strings $\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#44-wildcard-matching-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : bool isMatch ( string s , string p ) { const int m = s . length (); const int n = p . length (); vector < vector < bool >> dp ( m + 1 , vector < bool > ( n + 1 )); for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 && j == 0 ) dp [ i ][ j ] = true ; else if ( i == 0 ) dp [ i ][ j ] = dp [ i ][ j - 1 ] && p [ j - 1 ] == '*' ; else if ( j == 0 ) dp [ i ][ j ] = dp [ i - 1 ][ j ] && s [ i - 1 ] == '*' ; else dp [ i ][ j ] = ( dp [ i - 1 ][ j ] || dp [ i ][ j - 1 ] || dp [ i - 1 ][ j - 1 ]) && ( s [ i - 1 ] == '*' || p [ j - 1 ] == '*' ) || ( dp [ i - 1 ][ j - 1 ]) && ( s [ i - 1 ] == '?' || p [ j - 1 ] == '?' || s [ i - 1 ] == p [ j - 1 ]); } return dp [ m ][ n ]; } };","title":"44. Wildcard Matching $\\star\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#45-jump-game-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int jump ( vector < int >& nums ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i + 1 < nums . size (); i ++ ) { farthest = max ( farthest , i + nums [ i ]); if ( i == end ) { ans ++ ; end = farthest ; } } return ans ; } };","title":"45. Jump Game II $\\star\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#46-permutations-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < vector < int >> permute ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size (), false ); dfs ( nums , nums . size (), used , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int target , vector < bool >& used , vector < int >& path , vector < vector < int >>& ans ) { if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); i ++ ) { if ( used [ i ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs ( nums , target - 1 , used , path , ans ); path . pop_back (); used [ i ] = false ; } } };","title":"46. Permutations $\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#47-permutations-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : vector < vector < int >> permuteUnique ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; vector < bool > used ( nums . size (), false ); sort ( nums . begin (), nums . end ()); dfs ( nums , nums . size (), used , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int target , vector < bool >& used , vector < int >& path , vector < vector < int >>& ans ) { if ( target == 0 ) { ans . push_back ( path ); return ; } for ( int i = 0 ; i < nums . size (); i ++ ) { if ( used [ i ] || i > 0 && used [ i - 1 ] && nums [ i ] == nums [ i - 1 ]) continue ; used [ i ] = true ; path . push_back ( nums [ i ]); dfs ( nums , target - 1 , used , path , ans ); path . pop_back (); used [ i ] = false ; } } };","title":"47. Permutations II $\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#48-rotate-image-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : void rotate ( vector < vector < int >>& matrix ) { for ( int min = 0 ; min < matrix . size () / 2 ; min ++ ) { int max = matrix . size () - min - 1 ; for ( int i = min ; i < max ; i ++ ) { int offset = i - min ; int top = matrix [ min ][ i ]; matrix [ min ][ i ] = matrix [ max - offset ][ min ]; matrix [ max - offset ][ min ] = matrix [ max ][ max - offset ]; matrix [ max ][ max - offset ] = matrix [ i ][ max ]; matrix [ i ][ max ] = top ; } } } };","title":"48. Rotate Image $\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#49-group-anagrams-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < vector < string >> groupAnagrams ( vector < string >& strs ) { vector < vector < string >> ans ; unordered_map < string , vector < string >> map ; for ( string & str : strs ) { string s = str ; sort ( s . begin (), s . end ()); map [ s ]. push_back ( str ); } for ( auto & [ key , value ] : map ) { vector < string > s = value ; sort ( s . begin (), s . end ()); ans . push_back ( s ); } return ans ; } };","title":"49. Group Anagrams $\\star\\star$"},{"location":"cpp/0001-0100/0041-0050/#50-powx-n-starstar","text":"1 2 3 4 5 6 7 8 9 class Solution { public : double myPow ( double x , long n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 1 / myPow ( x , - n ); if ( n % 2 ) return x * myPow ( x , n - 1 ); return myPow ( x * x , n / 2 ); } };","title":"50. Pow(x, n) $\\star\\star$"},{"location":"cpp/0001-0100/0051-0060/","text":"51. N-Queens $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < vector < string >> solveNQueens ( int n ) { vector < vector < string >> ans ; vector < string > board ( n , string ( n , '.' )); vector < bool > cols ( n , false ); vector < bool > diag1 ( 2 * n - 1 , false ); vector < bool > diag2 ( 2 * n - 1 , false ); dfs ( 0 , cols , diag1 , diag2 , board , ans ); return ans ; } private : void dfs ( int y , vector < bool >& cols , vector < bool >& diag1 , vector < bool >& diag2 , vector < string >& board , vector < vector < string >>& ans ) { if ( y == cols . size ()) { ans . push_back ( board ); return ; } for ( int x = 0 ; x < cols . size (); x ++ ) { if ( ! cols [ x ] && ! diag1 [ x + y ] && ! diag2 [ x - y + cols . size () - 1 ]) { board [ y ][ x ] = 'Q' ; cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + cols . size () - 1 ] = true ; dfs ( y + 1 , cols , diag1 , diag2 , board , ans ); cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + cols . size () - 1 ] = false ; board [ y ][ x ] = '.' ; } } } }; 52. N-Queens II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int totalNQueens ( int n ) { int ans = 0 ; vector < bool > cols ( n , false ); vector < bool > diag1 ( 2 * n - 1 , false ); vector < bool > diag2 ( 2 * n - 1 , false ); dfs ( 0 , cols , diag1 , diag2 , ans ); return ans ; } private : void dfs ( int y , vector < bool >& cols , vector < bool >& diag1 , vector < bool >& diag2 , int & ans ) { if ( y == cols . size ()) { ans ++ ; return ; } for ( int x = 0 ; x < cols . size (); x ++ ) { if ( ! cols [ x ] && ! diag1 [ x + y ] && ! diag2 [ x - y + cols . size () - 1 ]) { cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + cols . size () - 1 ] = true ; dfs ( y + 1 , cols , diag1 , diag2 , ans ); cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + cols . size () - 1 ] = false ; } } } }; 53. Maximum Subarray $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int maxSubArray ( vector < int >& nums ) { int ans = INT_MIN ; int sum = 0 ; for ( int num : nums ) { sum += num ; ans = max ( ans , sum ); sum = max ( sum , 0 ); } return ans ; } }; 54. Spiral Matrix $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < int > spiralOrder ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return {}; vector < int > ans ; int r1 = 0 ; int c1 = 0 ; int r2 = matrix . size () - 1 ; int c2 = matrix [ 0 ]. size () - 1 ; while ( r1 <= r2 && c1 <= c2 ) { for ( int c = c1 ; c <= c2 ; c ++ ) ans . push_back ( matrix [ r1 ][ c ]); for ( int r = r1 + 1 ; r <= r2 ; r ++ ) ans . push_back ( matrix [ r ][ c2 ]); if ( r1 < r2 && c1 < c2 ) { for ( int c = c2 - 1 ; c > c1 ; c -- ) ans . push_back ( matrix [ r2 ][ c ]); for ( int r = r2 ; r > r1 ; r -- ) ans . push_back ( matrix [ r ][ c1 ]); } r1 ++ ; c1 ++ ; r2 -- ; c2 -- ; } return ans ; } }; 55. Jump Game $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : bool canJump ( vector < int >& nums ) { int goal = nums . size () - 1 ; for ( int i = goal ; i >= 0 ; i -- ) if ( i + nums [ i ] >= goal ) goal = i ; return goal == 0 ; } }; 56. Merge Intervals $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < vector < int >> merge ( vector < vector < int >>& intervals ) { vector < vector < int >> ans ; sort ( intervals . begin (), intervals . end (), compare ); for ( vector < int >& interval : intervals ) { if ( ans . empty () || ans . back ()[ 1 ] < interval [ 0 ]) ans . push_back ( interval ); else ans . back ()[ 1 ] = max ( ans . back ()[ 1 ], interval [ 1 ]); } return ans ; } private : bool static compare ( const vector < int >& a , const vector < int >& b ) { return a [ 0 ] < b [ 0 ]; } }; 57. Insert Interval $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < vector < int >> insert ( vector < vector < int >>& intervals , vector < int >& newInterval ) { vector < vector < int >> ans ; auto it = intervals . begin (); for (; it != intervals . end (); it ++ ) if (( * it )[ 0 ] >= newInterval [ 0 ]) break ; intervals . insert ( it , newInterval ); for ( vector < int >& interval : intervals ) { if ( ans . empty () || interval [ 0 ] > ans . back ()[ 1 ]) ans . push_back ( interval ); else ans . back ()[ 1 ] = max ( ans . back ()[ 1 ], interval [ 1 ]); } return ans ; } }; 58. Length of Last Word $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int lengthOfLastWord ( string s ) { int ans = 0 ; int i = s . size () - 1 ; while ( i >= 0 && s [ i ] == ' ' ) i -- ; while ( i >= 0 && s [ i ] != ' ' ) { i -- ; ans ++ ; } return ans ; } }; 59. Spiral Matrix II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < vector < int >> generateMatrix ( int n ) { vector < vector < int >> ans ( n , vector < int > ( n )); int count = 1 ; for ( int min = 0 , max = n - min - 1 ; min < n / 2 ; min ++ , max -- ) { for ( int i = min ; i < max ; i ++ ) ans [ min ][ i ] = count ++ ; for ( int i = min ; i < max ; i ++ ) ans [ i ][ max ] = count ++ ; for ( int i = max ; i > min ; i -- ) ans [ max ][ i ] = count ++ ; for ( int i = max ; i > min ; i -- ) ans [ i ][ min ] = count ++ ; } if ( n & 1 ) ans [ n / 2 ][ n / 2 ] = count ; return ans ; } }; 60. Permutation Sequence $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : string getPermutation ( int n , int k ) { string ans ; vector < int > nums ( n ); vector < int > fact ( n , 1 ); for ( int i = 0 ; i < n ; i ++ ) nums [ i ] = i + 1 ; for ( int i = 1 ; i < n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; k -- ; for ( int i = n ; i >= 1 ; i -- ) { int j = k / fact [ i - 1 ]; k %= fact [ i - 1 ]; ans . append ( to_string ( nums [ j ])); nums . erase ( nums . begin () + j ); } return ans ; } };","title":"0051-0060"},{"location":"cpp/0001-0100/0051-0060/#51-n-queens-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < vector < string >> solveNQueens ( int n ) { vector < vector < string >> ans ; vector < string > board ( n , string ( n , '.' )); vector < bool > cols ( n , false ); vector < bool > diag1 ( 2 * n - 1 , false ); vector < bool > diag2 ( 2 * n - 1 , false ); dfs ( 0 , cols , diag1 , diag2 , board , ans ); return ans ; } private : void dfs ( int y , vector < bool >& cols , vector < bool >& diag1 , vector < bool >& diag2 , vector < string >& board , vector < vector < string >>& ans ) { if ( y == cols . size ()) { ans . push_back ( board ); return ; } for ( int x = 0 ; x < cols . size (); x ++ ) { if ( ! cols [ x ] && ! diag1 [ x + y ] && ! diag2 [ x - y + cols . size () - 1 ]) { board [ y ][ x ] = 'Q' ; cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + cols . size () - 1 ] = true ; dfs ( y + 1 , cols , diag1 , diag2 , board , ans ); cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + cols . size () - 1 ] = false ; board [ y ][ x ] = '.' ; } } } };","title":"51. N-Queens $\\star\\star\\star$"},{"location":"cpp/0001-0100/0051-0060/#52-n-queens-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int totalNQueens ( int n ) { int ans = 0 ; vector < bool > cols ( n , false ); vector < bool > diag1 ( 2 * n - 1 , false ); vector < bool > diag2 ( 2 * n - 1 , false ); dfs ( 0 , cols , diag1 , diag2 , ans ); return ans ; } private : void dfs ( int y , vector < bool >& cols , vector < bool >& diag1 , vector < bool >& diag2 , int & ans ) { if ( y == cols . size ()) { ans ++ ; return ; } for ( int x = 0 ; x < cols . size (); x ++ ) { if ( ! cols [ x ] && ! diag1 [ x + y ] && ! diag2 [ x - y + cols . size () - 1 ]) { cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + cols . size () - 1 ] = true ; dfs ( y + 1 , cols , diag1 , diag2 , ans ); cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + cols . size () - 1 ] = false ; } } } };","title":"52. N-Queens II $\\star\\star\\star$"},{"location":"cpp/0001-0100/0051-0060/#53-maximum-subarray-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int maxSubArray ( vector < int >& nums ) { int ans = INT_MIN ; int sum = 0 ; for ( int num : nums ) { sum += num ; ans = max ( ans , sum ); sum = max ( sum , 0 ); } return ans ; } };","title":"53. Maximum Subarray $\\star$"},{"location":"cpp/0001-0100/0051-0060/#54-spiral-matrix-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : vector < int > spiralOrder ( vector < vector < int >>& matrix ) { if ( matrix . empty ()) return {}; vector < int > ans ; int r1 = 0 ; int c1 = 0 ; int r2 = matrix . size () - 1 ; int c2 = matrix [ 0 ]. size () - 1 ; while ( r1 <= r2 && c1 <= c2 ) { for ( int c = c1 ; c <= c2 ; c ++ ) ans . push_back ( matrix [ r1 ][ c ]); for ( int r = r1 + 1 ; r <= r2 ; r ++ ) ans . push_back ( matrix [ r ][ c2 ]); if ( r1 < r2 && c1 < c2 ) { for ( int c = c2 - 1 ; c > c1 ; c -- ) ans . push_back ( matrix [ r2 ][ c ]); for ( int r = r2 ; r > r1 ; r -- ) ans . push_back ( matrix [ r ][ c1 ]); } r1 ++ ; c1 ++ ; r2 -- ; c2 -- ; } return ans ; } };","title":"54. Spiral Matrix $\\star\\star$"},{"location":"cpp/0001-0100/0051-0060/#55-jump-game-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : bool canJump ( vector < int >& nums ) { int goal = nums . size () - 1 ; for ( int i = goal ; i >= 0 ; i -- ) if ( i + nums [ i ] >= goal ) goal = i ; return goal == 0 ; } };","title":"55. Jump Game $\\star\\star$"},{"location":"cpp/0001-0100/0051-0060/#56-merge-intervals-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < vector < int >> merge ( vector < vector < int >>& intervals ) { vector < vector < int >> ans ; sort ( intervals . begin (), intervals . end (), compare ); for ( vector < int >& interval : intervals ) { if ( ans . empty () || ans . back ()[ 1 ] < interval [ 0 ]) ans . push_back ( interval ); else ans . back ()[ 1 ] = max ( ans . back ()[ 1 ], interval [ 1 ]); } return ans ; } private : bool static compare ( const vector < int >& a , const vector < int >& b ) { return a [ 0 ] < b [ 0 ]; } };","title":"56. Merge Intervals $\\star\\star$"},{"location":"cpp/0001-0100/0051-0060/#57-insert-interval-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < vector < int >> insert ( vector < vector < int >>& intervals , vector < int >& newInterval ) { vector < vector < int >> ans ; auto it = intervals . begin (); for (; it != intervals . end (); it ++ ) if (( * it )[ 0 ] >= newInterval [ 0 ]) break ; intervals . insert ( it , newInterval ); for ( vector < int >& interval : intervals ) { if ( ans . empty () || interval [ 0 ] > ans . back ()[ 1 ]) ans . push_back ( interval ); else ans . back ()[ 1 ] = max ( ans . back ()[ 1 ], interval [ 1 ]); } return ans ; } };","title":"57. Insert Interval $\\star\\star\\star$"},{"location":"cpp/0001-0100/0051-0060/#58-length-of-last-word-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int lengthOfLastWord ( string s ) { int ans = 0 ; int i = s . size () - 1 ; while ( i >= 0 && s [ i ] == ' ' ) i -- ; while ( i >= 0 && s [ i ] != ' ' ) { i -- ; ans ++ ; } return ans ; } };","title":"58. Length of Last Word $\\star$"},{"location":"cpp/0001-0100/0051-0060/#59-spiral-matrix-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < vector < int >> generateMatrix ( int n ) { vector < vector < int >> ans ( n , vector < int > ( n )); int count = 1 ; for ( int min = 0 , max = n - min - 1 ; min < n / 2 ; min ++ , max -- ) { for ( int i = min ; i < max ; i ++ ) ans [ min ][ i ] = count ++ ; for ( int i = min ; i < max ; i ++ ) ans [ i ][ max ] = count ++ ; for ( int i = max ; i > min ; i -- ) ans [ max ][ i ] = count ++ ; for ( int i = max ; i > min ; i -- ) ans [ i ][ min ] = count ++ ; } if ( n & 1 ) ans [ n / 2 ][ n / 2 ] = count ; return ans ; } };","title":"59. Spiral Matrix II $\\star\\star$"},{"location":"cpp/0001-0100/0051-0060/#60-permutation-sequence-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : string getPermutation ( int n , int k ) { string ans ; vector < int > nums ( n ); vector < int > fact ( n , 1 ); for ( int i = 0 ; i < n ; i ++ ) nums [ i ] = i + 1 ; for ( int i = 1 ; i < n ; i ++ ) fact [ i ] = fact [ i - 1 ] * i ; k -- ; for ( int i = n ; i >= 1 ; i -- ) { int j = k / fact [ i - 1 ]; k %= fact [ i - 1 ]; ans . append ( to_string ( nums [ j ])); nums . erase ( nums . begin () + j ); } return ans ; } };","title":"60. Permutation Sequence $\\star\\star$"},{"location":"cpp/0001-0100/0061-0070/","text":"61. Rotate List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : ListNode * rotateRight ( ListNode * head , int k ) { if ( ! head || ! head -> next || k == 0 ) return head ; int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) length ++ ; k %= length ; if ( k == 0 ) return head ; auto slow = head ; auto fast = head ; while ( k -- ) fast = fast -> next ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next ; } auto ans = slow -> next ; slow -> next = NULL ; fast -> next = head ; return ans ; } }; 62. Unique Paths $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int uniquePaths ( int m , int n ) { vector < int > dp ( n , 1 ); for ( int i = 1 ; i < m ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) dp [ j ] += dp [ j - 1 ]; return dp [ n - 1 ]; } }; 63. Unique Paths II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int uniquePathsWithObstacles ( vector < vector < int >>& obstacleGrid ) { const int m = obstacleGrid . size (); const int n = obstacleGrid [ 0 ]. size (); vector < long > dp ( n , 0 ); dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { if ( obstacleGrid [ i ][ j ]) dp [ j ] = 0 ; else if ( j > 0 ) dp [ j ] += dp [ j - 1 ]; } return dp [ n - 1 ]; } }; 64. Minimum Path Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int minPathSum ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); for ( int i = 1 ; i < m ; i ++ ) grid [ i ][ 0 ] += grid [ i - 1 ][ 0 ]; for ( int j = 1 ; j < n ; j ++ ) grid [ 0 ][ j ] += grid [ 0 ][ j - 1 ]; for ( int i = 1 ; i < m ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) grid [ i ][ j ] += min ( grid [ i - 1 ][ j ], grid [ i ][ j - 1 ]); return grid [ m - 1 ][ n - 1 ]; } }; 65. Valid Number $\\star\\star\\star$ 66. Plus One $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < int > plusOne ( vector < int >& digits ) { const int n = digits . size (); for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( digits [ i ] < 9 ) { digits [ i ] ++ ; return digits ; } digits [ i ] = 0 ; } vector < int > ans ( n + 1 ); ans [ 0 ] = 1 ; return ans ; } }; 67. Add Binary $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : string addBinary ( string a , string b ) { string ans ; int carry = 0 ; int i = a . length () - 1 ; int j = b . length () - 1 ; while ( i >= 0 || j >= 0 || carry == 1 ) { if ( i >= 0 ) carry += a [ i -- ] - '0' ; if ( j >= 0 ) carry += b [ j -- ] - '0' ; ans = char ( carry % 2 + '0' ) + ans ; carry >>= 1 ; } return ans ; } }; 68. Text Justification $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : vector < string > fullJustify ( vector < string >& words , int maxWidth ) { vector < string > ans ; vector < string > curr ; int numOfLetters = 0 ; for ( string & word : words ) { if ( numOfLetters + ( int ) curr . size () + ( int ) word . length () > maxWidth ) { for ( int i = 0 ; i < maxWidth - numOfLetters ; i ++ ) { curr . size () - 1 == 0 ? curr [ 0 ]. append ( \" \" ) : curr [ i % ( curr . size () - 1 )]. append ( \" \" ); } ans . push_back ( join ( curr , \"\" )); curr . clear (); numOfLetters = 0 ; } curr . push_back ( word ); numOfLetters += word . length (); } ans . push_back ( ljust ( join ( curr , \" \" ), maxWidth )); return ans ; } private : string join ( vector < string >& v , string c ) { string s ; for ( auto p = v . begin (); p != v . end (); p ++ ) { s += * p ; if ( p != v . end () - 1 ) s += c ; } return s ; } string ljust ( string s , int width ) { for ( int i = 0 ; i < s . length () - width ; i ++ ) s += \" \" ; return s ; } }; 69. Sqrt(x) $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int mySqrt ( int x ) { unsigned l = 1 ; unsigned r = x + 1u ; while ( l < r ) { unsigned m = ( l + r ) >> 1 ; if ( m > x / m ) r = m ; else l = m + 1 ; } return l - 1 ; } }; 70. Climbing Stairs $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int climbStairs ( int n ) { if ( n == 1 ) return 1 ; vector < int > dp ( n + 1 ); dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]; return dp [ n ]; } };","title":"0061-0070"},{"location":"cpp/0001-0100/0061-0070/#61-rotate-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : ListNode * rotateRight ( ListNode * head , int k ) { if ( ! head || ! head -> next || k == 0 ) return head ; int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) length ++ ; k %= length ; if ( k == 0 ) return head ; auto slow = head ; auto fast = head ; while ( k -- ) fast = fast -> next ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next ; } auto ans = slow -> next ; slow -> next = NULL ; fast -> next = head ; return ans ; } };","title":"61. Rotate List $\\star\\star$"},{"location":"cpp/0001-0100/0061-0070/#62-unique-paths-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int uniquePaths ( int m , int n ) { vector < int > dp ( n , 1 ); for ( int i = 1 ; i < m ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) dp [ j ] += dp [ j - 1 ]; return dp [ n - 1 ]; } };","title":"62. Unique Paths $\\star\\star$"},{"location":"cpp/0001-0100/0061-0070/#63-unique-paths-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int uniquePathsWithObstacles ( vector < vector < int >>& obstacleGrid ) { const int m = obstacleGrid . size (); const int n = obstacleGrid [ 0 ]. size (); vector < long > dp ( n , 0 ); dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { if ( obstacleGrid [ i ][ j ]) dp [ j ] = 0 ; else if ( j > 0 ) dp [ j ] += dp [ j - 1 ]; } return dp [ n - 1 ]; } };","title":"63. Unique Paths II $\\star\\star$"},{"location":"cpp/0001-0100/0061-0070/#64-minimum-path-sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int minPathSum ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); for ( int i = 1 ; i < m ; i ++ ) grid [ i ][ 0 ] += grid [ i - 1 ][ 0 ]; for ( int j = 1 ; j < n ; j ++ ) grid [ 0 ][ j ] += grid [ 0 ][ j - 1 ]; for ( int i = 1 ; i < m ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) grid [ i ][ j ] += min ( grid [ i - 1 ][ j ], grid [ i ][ j - 1 ]); return grid [ m - 1 ][ n - 1 ]; } };","title":"64. Minimum Path Sum $\\star\\star$"},{"location":"cpp/0001-0100/0061-0070/#65-valid-number-starstarstar","text":"","title":"65. Valid Number $\\star\\star\\star$"},{"location":"cpp/0001-0100/0061-0070/#66-plus-one-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < int > plusOne ( vector < int >& digits ) { const int n = digits . size (); for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( digits [ i ] < 9 ) { digits [ i ] ++ ; return digits ; } digits [ i ] = 0 ; } vector < int > ans ( n + 1 ); ans [ 0 ] = 1 ; return ans ; } };","title":"66. Plus One $\\star$"},{"location":"cpp/0001-0100/0061-0070/#67-add-binary-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : string addBinary ( string a , string b ) { string ans ; int carry = 0 ; int i = a . length () - 1 ; int j = b . length () - 1 ; while ( i >= 0 || j >= 0 || carry == 1 ) { if ( i >= 0 ) carry += a [ i -- ] - '0' ; if ( j >= 0 ) carry += b [ j -- ] - '0' ; ans = char ( carry % 2 + '0' ) + ans ; carry >>= 1 ; } return ans ; } };","title":"67. Add Binary $\\star$"},{"location":"cpp/0001-0100/0061-0070/#68-text-justification-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : vector < string > fullJustify ( vector < string >& words , int maxWidth ) { vector < string > ans ; vector < string > curr ; int numOfLetters = 0 ; for ( string & word : words ) { if ( numOfLetters + ( int ) curr . size () + ( int ) word . length () > maxWidth ) { for ( int i = 0 ; i < maxWidth - numOfLetters ; i ++ ) { curr . size () - 1 == 0 ? curr [ 0 ]. append ( \" \" ) : curr [ i % ( curr . size () - 1 )]. append ( \" \" ); } ans . push_back ( join ( curr , \"\" )); curr . clear (); numOfLetters = 0 ; } curr . push_back ( word ); numOfLetters += word . length (); } ans . push_back ( ljust ( join ( curr , \" \" ), maxWidth )); return ans ; } private : string join ( vector < string >& v , string c ) { string s ; for ( auto p = v . begin (); p != v . end (); p ++ ) { s += * p ; if ( p != v . end () - 1 ) s += c ; } return s ; } string ljust ( string s , int width ) { for ( int i = 0 ; i < s . length () - width ; i ++ ) s += \" \" ; return s ; } };","title":"68. Text Justification $\\star\\star\\star$"},{"location":"cpp/0001-0100/0061-0070/#69-sqrtx-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int mySqrt ( int x ) { unsigned l = 1 ; unsigned r = x + 1u ; while ( l < r ) { unsigned m = ( l + r ) >> 1 ; if ( m > x / m ) r = m ; else l = m + 1 ; } return l - 1 ; } };","title":"69. Sqrt(x) $\\star$"},{"location":"cpp/0001-0100/0061-0070/#70-climbing-stairs-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int climbStairs ( int n ) { if ( n == 1 ) return 1 ; vector < int > dp ( n + 1 ); dp [ 1 ] = 1 ; dp [ 2 ] = 2 ; for ( int i = 3 ; i <= n ; i ++ ) dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ]; return dp [ n ]; } };","title":"70. Climbing Stairs $\\star$"},{"location":"cpp/0001-0100/0071-0080/","text":"71. Simplify Path $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : string simplifyPath ( string path ) { string ans ; string temp ; stringstream ss ( path ); vector < string > stack ; while ( getline ( ss , temp , '/' )) { if ( temp == \"\" || temp == \".\" ) continue ; if ( temp == \"..\" ) { if ( ! stack . empty ()) stack . pop_back (); } else { stack . push_back ( temp ); } } for ( auto str : stack ) ans += \"/\" + str ; return ans . empty () ? \"/\" : ans ; } }; 72. Edit Distance $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int minDistance ( string word1 , string word2 ) { const int m = word1 . length (); const int n = word2 . length (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ][ j ] = j ; else if ( j == 0 ) dp [ i ][ j ] = i ; else dp [ i ][ j ] = min ( dp [ i - 1 ][ j - 1 ] + ( word1 [ i - 1 ] == word2 [ j - 1 ] ? 0 : 1 ), min ( dp [ i - 1 ][ j ] + 1 , dp [ i ][ j - 1 ] + 1 )); } return dp [ m ][ n ]; } }; 73. Set Matrix Zeroes $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : void setZeroes ( vector < vector < int >>& matrix ) { const int m = matrix . size (); const int n = matrix [ 0 ]. size (); bool isFirstRow = false ; bool isFirstCol = false ; for ( int j = 0 ; j < n ; j ++ ) if ( matrix [ 0 ][ j ] == 0 ) isFirstRow = true ; for ( int i = 0 ; i < m ; i ++ ) if ( matrix [ i ][ 0 ] == 0 ) isFirstCol = true ; for ( int i = 1 ; i < m ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) if ( matrix [ i ][ j ] == 0 ) { matrix [ i ][ 0 ] = 0 ; matrix [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i < m ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) if ( matrix [ i ][ 0 ] == 0 || matrix [ 0 ][ j ] == 0 ) matrix [ i ][ j ] = 0 ; if ( isFirstRow ) for ( int j = 0 ; j < n ; j ++ ) matrix [ 0 ][ j ] = 0 ; if ( isFirstCol ) for ( int i = 0 ; i < m ; i ++ ) matrix [ i ][ 0 ] = 0 ; } }; 74. Search a 2D Matrix $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { if ( matrix . empty ()) return false ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); int l = 0 ; int r = m * n ; while ( l < r ) { int mid = l + ( r - l ) / 2 ; int i = mid / n ; int j = mid % n ; if ( matrix [ i ][ j ] == target ) return true ; if ( matrix [ i ][ j ] < target ) l = mid + 1 ; else r = mid ; } return false ; } }; 75. Sort Colors $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : void sortColors ( vector < int >& nums ) { int zero = - 1 ; int one = - 1 ; int two = - 1 ; for ( int num : nums ) { if ( num == 0 ) { nums [ ++ two ] = 2 ; nums [ ++ one ] = 1 ; nums [ ++ zero ] = 0 ; } else if ( num == 1 ) { nums [ ++ two ] = 2 ; nums [ ++ one ] = 1 ; } else { nums [ ++ two ] = 2 ; } } } }; 76. Minimum Window Substring $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : string minWindow ( string s , string t ) { if ( s . empty () || t . empty ()) return \"\" ; unordered_map < char , int > map ; for ( char c : t ) map [ c ] ++ ; int l = 0 ; int r = 0 ; int bestLeft = 0 ; int bestRight = 0 ; int required = map . size (); int windowLength = s . length () + 1 ; for ( int r = 0 ; r < s . length (); r ++ ) { if ( map . count ( s [ r ])) if ( -- map [ s [ r ]] == 0 ) required -- ; while ( required == 0 && l <= r ) { if ( r - l + 1 < windowLength ) { windowLength = r - l + 1 ; bestLeft = l ; bestRight = r ; } if ( map . count ( s [ l ])) if ( ++ map [ s [ l ]] > 0 ) required ++ ; l ++ ; } } return windowLength == s . length () + 1 ? \"\" : s . substr ( bestLeft , windowLength ); } }; 77. Combinations $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < vector < int >> combine ( int n , int k ) { vector < vector < int >> ans ; vector < int > path ; dfs ( n , k , 1 , path , ans ); return ans ; } private : void dfs ( int n , int k , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( k == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i <= n ; i ++ ) { path . push_back ( i ); dfs ( n , k - 1 , i + 1 , path , ans ); path . pop_back (); } } }; 78. Subsets $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < vector < int >> subsets ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; dfs ( nums , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int s , vector < int >& path , vector < vector < int >>& ans ) { ans . push_back ( path ); if ( s == nums . size ()) return ; for ( int i = s ; i < nums . size (); i ++ ) { path . push_back ( nums [ i ]); dfs ( nums , i + 1 , path , ans ); path . pop_back (); } } }; 79. Word Search $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : bool exist ( vector < vector < char >>& board , string word ) { if ( board . empty ()) return false ; for ( int i = 0 ; i < board . size (); i ++ ) for ( int j = 0 ; j < board [ 0 ]. size (); j ++ ) if ( dfs ( board , word , i , j , 0 )) return true ; return false ; } private : bool dfs ( vector < vector < char >>& board , string & word , int i , int j , int pos ) { if ( i < 0 || i >= board . size () || j < 0 || j >= board [ 0 ]. size () || board [ i ][ j ] != word [ pos ] || board [ i ][ j ] == '*' ) return false ; if ( pos == word . length () - 1 ) return true ; char c = board [ i ][ j ]; board [ i ][ j ] = '*' ; bool flag = dfs ( board , word , i + 1 , j , pos + 1 ) || dfs ( board , word , i - 1 , j , pos + 1 ) || dfs ( board , word , i , j + 1 , pos + 1 ) || dfs ( board , word , i , j - 1 , pos + 1 ); board [ i ][ j ] = c ; return flag ; } }; 80. Remove Duplicates from Sorted Array II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int removeDuplicates ( vector < int >& nums ) { int i = 0 ; for ( int num : nums ) if ( i < 2 || num != nums [ i - 2 ]) nums [ i ++ ] = num ; return i ; } };","title":"0071-0080"},{"location":"cpp/0001-0100/0071-0080/#71-simplify-path-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : string simplifyPath ( string path ) { string ans ; string temp ; stringstream ss ( path ); vector < string > stack ; while ( getline ( ss , temp , '/' )) { if ( temp == \"\" || temp == \".\" ) continue ; if ( temp == \"..\" ) { if ( ! stack . empty ()) stack . pop_back (); } else { stack . push_back ( temp ); } } for ( auto str : stack ) ans += \"/\" + str ; return ans . empty () ? \"/\" : ans ; } };","title":"71. Simplify Path $\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#72-edit-distance-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int minDistance ( string word1 , string word2 ) { const int m = word1 . length (); const int n = word2 . length (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 )); for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 ) dp [ i ][ j ] = j ; else if ( j == 0 ) dp [ i ][ j ] = i ; else dp [ i ][ j ] = min ( dp [ i - 1 ][ j - 1 ] + ( word1 [ i - 1 ] == word2 [ j - 1 ] ? 0 : 1 ), min ( dp [ i - 1 ][ j ] + 1 , dp [ i ][ j - 1 ] + 1 )); } return dp [ m ][ n ]; } };","title":"72. Edit Distance $\\star\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#73-set-matrix-zeroes-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : void setZeroes ( vector < vector < int >>& matrix ) { const int m = matrix . size (); const int n = matrix [ 0 ]. size (); bool isFirstRow = false ; bool isFirstCol = false ; for ( int j = 0 ; j < n ; j ++ ) if ( matrix [ 0 ][ j ] == 0 ) isFirstRow = true ; for ( int i = 0 ; i < m ; i ++ ) if ( matrix [ i ][ 0 ] == 0 ) isFirstCol = true ; for ( int i = 1 ; i < m ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) if ( matrix [ i ][ j ] == 0 ) { matrix [ i ][ 0 ] = 0 ; matrix [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i < m ; i ++ ) for ( int j = 1 ; j < n ; j ++ ) if ( matrix [ i ][ 0 ] == 0 || matrix [ 0 ][ j ] == 0 ) matrix [ i ][ j ] = 0 ; if ( isFirstRow ) for ( int j = 0 ; j < n ; j ++ ) matrix [ 0 ][ j ] = 0 ; if ( isFirstCol ) for ( int i = 0 ; i < m ; i ++ ) matrix [ i ][ 0 ] = 0 ; } };","title":"73. Set Matrix Zeroes $\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#74-search-a-2d-matrix-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { if ( matrix . empty ()) return false ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); int l = 0 ; int r = m * n ; while ( l < r ) { int mid = l + ( r - l ) / 2 ; int i = mid / n ; int j = mid % n ; if ( matrix [ i ][ j ] == target ) return true ; if ( matrix [ i ][ j ] < target ) l = mid + 1 ; else r = mid ; } return false ; } };","title":"74. Search a 2D Matrix $\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#75-sort-colors-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : void sortColors ( vector < int >& nums ) { int zero = - 1 ; int one = - 1 ; int two = - 1 ; for ( int num : nums ) { if ( num == 0 ) { nums [ ++ two ] = 2 ; nums [ ++ one ] = 1 ; nums [ ++ zero ] = 0 ; } else if ( num == 1 ) { nums [ ++ two ] = 2 ; nums [ ++ one ] = 1 ; } else { nums [ ++ two ] = 2 ; } } } };","title":"75. Sort Colors $\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#76-minimum-window-substring-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : string minWindow ( string s , string t ) { if ( s . empty () || t . empty ()) return \"\" ; unordered_map < char , int > map ; for ( char c : t ) map [ c ] ++ ; int l = 0 ; int r = 0 ; int bestLeft = 0 ; int bestRight = 0 ; int required = map . size (); int windowLength = s . length () + 1 ; for ( int r = 0 ; r < s . length (); r ++ ) { if ( map . count ( s [ r ])) if ( -- map [ s [ r ]] == 0 ) required -- ; while ( required == 0 && l <= r ) { if ( r - l + 1 < windowLength ) { windowLength = r - l + 1 ; bestLeft = l ; bestRight = r ; } if ( map . count ( s [ l ])) if ( ++ map [ s [ l ]] > 0 ) required ++ ; l ++ ; } } return windowLength == s . length () + 1 ? \"\" : s . substr ( bestLeft , windowLength ); } };","title":"76. Minimum Window Substring $\\star\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#77-combinations-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < vector < int >> combine ( int n , int k ) { vector < vector < int >> ans ; vector < int > path ; dfs ( n , k , 1 , path , ans ); return ans ; } private : void dfs ( int n , int k , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( k == 0 ) { ans . push_back ( path ); return ; } for ( int i = s ; i <= n ; i ++ ) { path . push_back ( i ); dfs ( n , k - 1 , i + 1 , path , ans ); path . pop_back (); } } };","title":"77. Combinations $\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#78-subsets-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < vector < int >> subsets ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; dfs ( nums , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int s , vector < int >& path , vector < vector < int >>& ans ) { ans . push_back ( path ); if ( s == nums . size ()) return ; for ( int i = s ; i < nums . size (); i ++ ) { path . push_back ( nums [ i ]); dfs ( nums , i + 1 , path , ans ); path . pop_back (); } } };","title":"78. Subsets $\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#79-word-search-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : bool exist ( vector < vector < char >>& board , string word ) { if ( board . empty ()) return false ; for ( int i = 0 ; i < board . size (); i ++ ) for ( int j = 0 ; j < board [ 0 ]. size (); j ++ ) if ( dfs ( board , word , i , j , 0 )) return true ; return false ; } private : bool dfs ( vector < vector < char >>& board , string & word , int i , int j , int pos ) { if ( i < 0 || i >= board . size () || j < 0 || j >= board [ 0 ]. size () || board [ i ][ j ] != word [ pos ] || board [ i ][ j ] == '*' ) return false ; if ( pos == word . length () - 1 ) return true ; char c = board [ i ][ j ]; board [ i ][ j ] = '*' ; bool flag = dfs ( board , word , i + 1 , j , pos + 1 ) || dfs ( board , word , i - 1 , j , pos + 1 ) || dfs ( board , word , i , j + 1 , pos + 1 ) || dfs ( board , word , i , j - 1 , pos + 1 ); board [ i ][ j ] = c ; return flag ; } };","title":"79. Word Search $\\star\\star$"},{"location":"cpp/0001-0100/0071-0080/#80-remove-duplicates-from-sorted-array-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int removeDuplicates ( vector < int >& nums ) { int i = 0 ; for ( int num : nums ) if ( i < 2 || num != nums [ i - 2 ]) nums [ i ++ ] = num ; return i ; } };","title":"80. Remove Duplicates from Sorted Array II $\\star\\star$"},{"location":"cpp/0001-0100/0081-0090/","text":"81. Search in Rotated Sorted Array II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : bool search ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size () - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return true ; if ( nums [ l ] == nums [ m ] && nums [ m ] == nums [ r ]) { l ++ ; r -- ; } else if ( nums [ l ] <= nums [ m ]) { if ( nums [ l ] <= target && target < nums [ m ]) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ]) l = m + 1 ; else r = m - 1 ; } } return false ; } }; 82. Remove Duplicates from Sorted List II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { ListNode dummy ( 0 ); dummy . next = head ; ListNode * prev = & dummy ; while ( head ) { while ( head -> next && head -> val == head -> next -> val ) head = head -> next ; if ( prev -> next == head ) prev = prev -> next ; else prev -> next = head -> next ; head = head -> next ; } return dummy . next ; } }; 83. Remove Duplicates from Sorted List $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { ListNode * curr = head ; while ( curr ) { while ( curr -> next && curr -> val == curr -> next -> val ) curr -> next = curr -> next -> next ; curr = curr -> next ; } return head ; } }; 84. Largest Rectangle in Histogram $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int largestRectangleArea ( vector < int >& heights ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i <= heights . size (); i ++ ) { while ( ! stack . empty () && ( i == heights . size () || heights [ i ] < heights [ stack . top ()])) { int h = heights [ stack . top ()]; stack . pop (); int w = stack . empty () ? i : i - stack . top () - 1 ; ans = max ( ans , h * w ); } stack . push ( i ); } return ans ; } }; 85. Maximal Rectangle $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : int maximalRectangle ( vector < vector < char >>& matrix ) { if ( matrix . empty ()) return 0 ; int ans = 0 ; vector < int > temp ( matrix [ 0 ]. size ()); for ( int i = 0 ; i < matrix . size (); i ++ ) { for ( int j = 0 ; j < matrix [ 0 ]. size (); j ++ ) temp [ j ] = matrix [ i ][ j ] == '0' ? 0 : temp [ j ] + 1 ; ans = max ( ans , largestRectangleArea ( temp )); } return ans ; } private : int largestRectangleArea ( vector < int >& heights ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i <= heights . size (); i ++ ) { while ( ! stack . empty () && ( i == heights . size () || heights [ i ] < heights [ stack . top ()])) { int h = heights [ stack . top ()]; stack . pop (); int w = stack . empty () ? i : i - stack . top () - 1 ; ans = max ( ans , h * w ); } stack . push ( i ); } return ans ; } }; 86. Partition List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : ListNode * partition ( ListNode * head , int x ) { ListNode beforeHead ( 0 ); ListNode afterHead ( 0 ); ListNode * before = & beforeHead ; ListNode * after = & afterHead ; while ( head ) { if ( head -> val < x ) { before -> next = head ; before = before -> next ; } else { after -> next = head ; after = after -> next ; } head = head -> next ; } after -> next = NULL ; before -> next = afterHead . next ; return beforeHead . next ; }; }; 87. Scramble String $\\star\\star\\star$ 88. Merge Sorted Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : void merge ( vector < int >& nums1 , int m , vector < int >& nums2 , int n ) { int k = m + n ; while ( n > 0 ) { if ( m > 0 && nums1 [ m - 1 ] > nums2 [ n - 1 ]) nums1 [ -- k ] = nums1 [ -- m ]; else nums1 [ -- k ] = nums2 [ -- n ]; } } }; 89. Gray Code $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < int > grayCode ( int n ) { vector < int > ans = { 0 }; for ( int i = 0 ; i < n ; i ++ ) for ( int j = ans . size () - 1 ; j >= 0 ; j -- ) ans . push_back ( ans [ j ] | 1 << i ); return ans ; } }; 90. Subsets II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < vector < int >> subsetsWithDup ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; sort ( nums . begin (), nums . end ()); dfs ( nums , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int s , vector < int >& path , vector < vector < int >>& ans ) { ans . push_back ( path ); if ( s == nums . size ()) return ; for ( int i = s ; i < nums . size (); i ++ ) { if ( i > s && nums [ i ] == nums [ i - 1 ]) continue ; path . push_back ( nums [ i ]); dfs ( nums , i + 1 , path , ans ); path . pop_back (); } } };","title":"0081-0090"},{"location":"cpp/0001-0100/0081-0090/#81-search-in-rotated-sorted-array-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : bool search ( vector < int >& nums , int target ) { int l = 0 ; int r = nums . size () - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return true ; if ( nums [ l ] == nums [ m ] && nums [ m ] == nums [ r ]) { l ++ ; r -- ; } else if ( nums [ l ] <= nums [ m ]) { if ( nums [ l ] <= target && target < nums [ m ]) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ]) l = m + 1 ; else r = m - 1 ; } } return false ; } };","title":"81. Search in Rotated Sorted Array II $\\star\\star$"},{"location":"cpp/0001-0100/0081-0090/#82-remove-duplicates-from-sorted-list-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { ListNode dummy ( 0 ); dummy . next = head ; ListNode * prev = & dummy ; while ( head ) { while ( head -> next && head -> val == head -> next -> val ) head = head -> next ; if ( prev -> next == head ) prev = prev -> next ; else prev -> next = head -> next ; head = head -> next ; } return dummy . next ; } };","title":"82. Remove Duplicates from Sorted List II $\\star\\star$"},{"location":"cpp/0001-0100/0081-0090/#83-remove-duplicates-from-sorted-list-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : ListNode * deleteDuplicates ( ListNode * head ) { ListNode * curr = head ; while ( curr ) { while ( curr -> next && curr -> val == curr -> next -> val ) curr -> next = curr -> next -> next ; curr = curr -> next ; } return head ; } };","title":"83. Remove Duplicates from Sorted List $\\star$"},{"location":"cpp/0001-0100/0081-0090/#84-largest-rectangle-in-histogram-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int largestRectangleArea ( vector < int >& heights ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i <= heights . size (); i ++ ) { while ( ! stack . empty () && ( i == heights . size () || heights [ i ] < heights [ stack . top ()])) { int h = heights [ stack . top ()]; stack . pop (); int w = stack . empty () ? i : i - stack . top () - 1 ; ans = max ( ans , h * w ); } stack . push ( i ); } return ans ; } };","title":"84. Largest Rectangle in Histogram $\\star\\star\\star$"},{"location":"cpp/0001-0100/0081-0090/#85-maximal-rectangle-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : int maximalRectangle ( vector < vector < char >>& matrix ) { if ( matrix . empty ()) return 0 ; int ans = 0 ; vector < int > temp ( matrix [ 0 ]. size ()); for ( int i = 0 ; i < matrix . size (); i ++ ) { for ( int j = 0 ; j < matrix [ 0 ]. size (); j ++ ) temp [ j ] = matrix [ i ][ j ] == '0' ? 0 : temp [ j ] + 1 ; ans = max ( ans , largestRectangleArea ( temp )); } return ans ; } private : int largestRectangleArea ( vector < int >& heights ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i <= heights . size (); i ++ ) { while ( ! stack . empty () && ( i == heights . size () || heights [ i ] < heights [ stack . top ()])) { int h = heights [ stack . top ()]; stack . pop (); int w = stack . empty () ? i : i - stack . top () - 1 ; ans = max ( ans , h * w ); } stack . push ( i ); } return ans ; } };","title":"85. Maximal Rectangle $\\star\\star\\star$"},{"location":"cpp/0001-0100/0081-0090/#86-partition-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : ListNode * partition ( ListNode * head , int x ) { ListNode beforeHead ( 0 ); ListNode afterHead ( 0 ); ListNode * before = & beforeHead ; ListNode * after = & afterHead ; while ( head ) { if ( head -> val < x ) { before -> next = head ; before = before -> next ; } else { after -> next = head ; after = after -> next ; } head = head -> next ; } after -> next = NULL ; before -> next = afterHead . next ; return beforeHead . next ; }; };","title":"86. Partition List $\\star\\star$"},{"location":"cpp/0001-0100/0081-0090/#87-scramble-string-starstarstar","text":"","title":"87. Scramble String $\\star\\star\\star$"},{"location":"cpp/0001-0100/0081-0090/#88-merge-sorted-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : void merge ( vector < int >& nums1 , int m , vector < int >& nums2 , int n ) { int k = m + n ; while ( n > 0 ) { if ( m > 0 && nums1 [ m - 1 ] > nums2 [ n - 1 ]) nums1 [ -- k ] = nums1 [ -- m ]; else nums1 [ -- k ] = nums2 [ -- n ]; } } };","title":"88. Merge Sorted Array $\\star$"},{"location":"cpp/0001-0100/0081-0090/#89-gray-code-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < int > grayCode ( int n ) { vector < int > ans = { 0 }; for ( int i = 0 ; i < n ; i ++ ) for ( int j = ans . size () - 1 ; j >= 0 ; j -- ) ans . push_back ( ans [ j ] | 1 << i ); return ans ; } };","title":"89. Gray Code $\\star\\star$"},{"location":"cpp/0001-0100/0081-0090/#90-subsets-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < vector < int >> subsetsWithDup ( vector < int >& nums ) { vector < vector < int >> ans ; vector < int > path ; sort ( nums . begin (), nums . end ()); dfs ( nums , 0 , path , ans ); return ans ; } private : void dfs ( vector < int >& nums , int s , vector < int >& path , vector < vector < int >>& ans ) { ans . push_back ( path ); if ( s == nums . size ()) return ; for ( int i = s ; i < nums . size (); i ++ ) { if ( i > s && nums [ i ] == nums [ i - 1 ]) continue ; path . push_back ( nums [ i ]); dfs ( nums , i + 1 , path , ans ); path . pop_back (); } } };","title":"90. Subsets II $\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/","text":"91. Decode Ways $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int numDecodings ( string s ) { if ( s . empty () || s [ 0 ] == '0' ) return 0 ; if ( s . length () == 1 ) return 1 ; int dp1 = 1 ; int dp2 = 1 ; for ( int i = 1 ; i < s . length (); i ++ ) { int dp = 0 ; if ( ! isValid ( s [ i ]) && ! isValid ( s [ i - 1 ], s [ i ])) return 0 ; if ( isValid ( s [ i ])) dp += dp1 ; if ( isValid ( s [ i - 1 ], s [ i ])) dp += dp2 ; dp2 = dp1 ; dp1 = dp ; } return dp1 ; } private : bool isValid ( char c ) { return c != '0' ; } bool isValid ( char c1 , char c2 ) { return c1 == '1' || ( c1 == '2' && c2 <= '6' ); } }; 92. Reverse Linked List II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : ListNode * reverseBetween ( ListNode * head , int m , int n ) { if ( ! head ) return NULL ; ListNode * prev = NULL ; ListNode * curr = head ; for ( int i = 0 ; i < m - 1 ; i ++ ) { prev = curr ; curr = curr -> next ; } ListNode * conn = prev ; ListNode * tail = curr ; for ( int i = 0 ; i < n - m + 1 ; i ++ ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } if ( conn ) conn -> next = prev ; else head = prev ; tail -> next = curr ; return head ; } }; 93. Restore IP Addresses $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < string > restoreIpAddresses ( string s ) { vector < string > ans ; vector < string > path ( 4 ); dfs ( s , 0 , 0 , path , ans ); return ans ; } void dfs ( string s , int depth , int index , vector < string >& path , vector < string >& ans ) { if ( depth == 4 && index == s . length ()) { ans . push_back ( path [ 0 ] + \".\" + path [ 1 ] + \".\" + path [ 2 ] + \".\" + path [ 3 ]); return ; } if ( depth == 4 || index == s . length ()) return ; for ( int i = 1 ; i <= 3 ; ++ i ) { if ( index + i > s . length ()) return ; if ( i > 1 && s [ index ] == '0' ) return ; string temp = s . substr ( index , i ); if ( stoi ( temp ) > 255 ) return ; path [ depth ] = temp ; dfs ( s , depth + 1 , index + i , path , ans ); path [ depth ] = \"\" ; } } }; 94. Binary Tree Inorder Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < int > inorderTraversal ( TreeNode * root ) { vector < int > ans ; stack < TreeNode *> stack ; TreeNode * curr = root ; while ( curr || ! stack . empty ()) { while ( curr ) { stack . push ( curr ); curr = curr -> left ; } curr = stack . top (); stack . pop (); ans . push_back ( curr -> val ); curr = curr -> right ; } return ans ; } }; 95. Unique Binary Search Trees II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : vector < TreeNode *> generateTrees ( int n ) { if ( n == 0 ) return {}; return helper ( 1 , n ); } private : vector < TreeNode *> helper ( int min , int max ) { vector < TreeNode *> ans ; if ( min > max ) { ans . push_back ( NULL ); return ans ; } for ( int i = min ; i <= max ; i ++ ) { vector < TreeNode *> leftTree = helper ( min , i - 1 ); vector < TreeNode *> rightTree = helper ( i + 1 , max ); for ( TreeNode * left : leftTree ) for ( TreeNode * right : rightTree ) { TreeNode * root = new TreeNode ( i ); root -> left = left ; root -> right = right ; ans . push_back ( root ); } } return ans ; } }; 96. Unique Binary Search Trees $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int numTrees ( int n ) { vector < int > G ( n + 1 ); G [ 0 ] = 1 ; G [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) G [ i ] += G [ j ] * G [ i - j - 1 ]; return G [ n ]; } }; 97. Interleaving String $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : bool isInterleave ( string s1 , string s2 , string s3 ) { if ( s1 . length () + s2 . length () != s3 . length ()) return false ; vector < bool > dp ( s2 . length () + 1 ); for ( int i = 0 ; i <= s1 . length (); i ++ ) for ( int j = 0 ; j <= s2 . length (); j ++ ) { if ( i == 0 && j == 0 ) dp [ j ] = true ; else if ( i == 0 ) dp [ j ] = dp [ j - 1 ] && s2 [ j - 1 ] == s3 [ i + j - 1 ]; else if ( j == 0 ) dp [ j ] = dp [ j ] && s1 [ i - 1 ] == s3 [ i + j - 1 ]; else dp [ j ] = ( dp [ j ] && s1 [ i - 1 ] == s3 [ i + j - 1 ]) || ( dp [ j - 1 ] && s2 [ j - 1 ] == s3 [ i + j - 1 ]); } return dp [ s2 . length ()]; } }; 98. Validate Binary Search Tree $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool isValidBST ( TreeNode * root ) { return helper ( root , NULL , NULL ); } private : bool helper ( TreeNode * root , TreeNode * minNode , TreeNode * maxNode ) { if ( ! root ) return true ; if ( minNode && root -> val <= minNode -> val || maxNode && root -> val >= maxNode -> val ) return false ; return helper ( root -> left , minNode , root ) && helper ( root -> right , root , maxNode ); } }; 99. Recover Binary Search Tree $\\star\\star\\star$ 100. Same Tree $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : bool isSameTree ( TreeNode * p , TreeNode * q ) { if ( ! p || ! q ) return p == q ; return p -> val == q -> val && isSameTree ( p -> left , q -> left ) && isSameTree ( p -> right , q -> right ); } };","title":"0091-0100"},{"location":"cpp/0001-0100/0091-0100/#91-decode-ways-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int numDecodings ( string s ) { if ( s . empty () || s [ 0 ] == '0' ) return 0 ; if ( s . length () == 1 ) return 1 ; int dp1 = 1 ; int dp2 = 1 ; for ( int i = 1 ; i < s . length (); i ++ ) { int dp = 0 ; if ( ! isValid ( s [ i ]) && ! isValid ( s [ i - 1 ], s [ i ])) return 0 ; if ( isValid ( s [ i ])) dp += dp1 ; if ( isValid ( s [ i - 1 ], s [ i ])) dp += dp2 ; dp2 = dp1 ; dp1 = dp ; } return dp1 ; } private : bool isValid ( char c ) { return c != '0' ; } bool isValid ( char c1 , char c2 ) { return c1 == '1' || ( c1 == '2' && c2 <= '6' ); } };","title":"91. Decode Ways $\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#92-reverse-linked-list-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : ListNode * reverseBetween ( ListNode * head , int m , int n ) { if ( ! head ) return NULL ; ListNode * prev = NULL ; ListNode * curr = head ; for ( int i = 0 ; i < m - 1 ; i ++ ) { prev = curr ; curr = curr -> next ; } ListNode * conn = prev ; ListNode * tail = curr ; for ( int i = 0 ; i < n - m + 1 ; i ++ ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } if ( conn ) conn -> next = prev ; else head = prev ; tail -> next = curr ; return head ; } };","title":"92. Reverse Linked List II $\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#93-restore-ip-addresses-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : vector < string > restoreIpAddresses ( string s ) { vector < string > ans ; vector < string > path ( 4 ); dfs ( s , 0 , 0 , path , ans ); return ans ; } void dfs ( string s , int depth , int index , vector < string >& path , vector < string >& ans ) { if ( depth == 4 && index == s . length ()) { ans . push_back ( path [ 0 ] + \".\" + path [ 1 ] + \".\" + path [ 2 ] + \".\" + path [ 3 ]); return ; } if ( depth == 4 || index == s . length ()) return ; for ( int i = 1 ; i <= 3 ; ++ i ) { if ( index + i > s . length ()) return ; if ( i > 1 && s [ index ] == '0' ) return ; string temp = s . substr ( index , i ); if ( stoi ( temp ) > 255 ) return ; path [ depth ] = temp ; dfs ( s , depth + 1 , index + i , path , ans ); path [ depth ] = \"\" ; } } };","title":"93. Restore IP Addresses $\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#94-binary-tree-inorder-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < int > inorderTraversal ( TreeNode * root ) { vector < int > ans ; stack < TreeNode *> stack ; TreeNode * curr = root ; while ( curr || ! stack . empty ()) { while ( curr ) { stack . push ( curr ); curr = curr -> left ; } curr = stack . top (); stack . pop (); ans . push_back ( curr -> val ); curr = curr -> right ; } return ans ; } };","title":"94. Binary Tree Inorder Traversal $\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#95-unique-binary-search-trees-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : vector < TreeNode *> generateTrees ( int n ) { if ( n == 0 ) return {}; return helper ( 1 , n ); } private : vector < TreeNode *> helper ( int min , int max ) { vector < TreeNode *> ans ; if ( min > max ) { ans . push_back ( NULL ); return ans ; } for ( int i = min ; i <= max ; i ++ ) { vector < TreeNode *> leftTree = helper ( min , i - 1 ); vector < TreeNode *> rightTree = helper ( i + 1 , max ); for ( TreeNode * left : leftTree ) for ( TreeNode * right : rightTree ) { TreeNode * root = new TreeNode ( i ); root -> left = left ; root -> right = right ; ans . push_back ( root ); } } return ans ; } };","title":"95. Unique Binary Search Trees II $\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#96-unique-binary-search-trees-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int numTrees ( int n ) { vector < int > G ( n + 1 ); G [ 0 ] = 1 ; G [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) for ( int j = 0 ; j < i ; j ++ ) G [ i ] += G [ j ] * G [ i - j - 1 ]; return G [ n ]; } };","title":"96. Unique Binary Search Trees $\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#97-interleaving-string-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : bool isInterleave ( string s1 , string s2 , string s3 ) { if ( s1 . length () + s2 . length () != s3 . length ()) return false ; vector < bool > dp ( s2 . length () + 1 ); for ( int i = 0 ; i <= s1 . length (); i ++ ) for ( int j = 0 ; j <= s2 . length (); j ++ ) { if ( i == 0 && j == 0 ) dp [ j ] = true ; else if ( i == 0 ) dp [ j ] = dp [ j - 1 ] && s2 [ j - 1 ] == s3 [ i + j - 1 ]; else if ( j == 0 ) dp [ j ] = dp [ j ] && s1 [ i - 1 ] == s3 [ i + j - 1 ]; else dp [ j ] = ( dp [ j ] && s1 [ i - 1 ] == s3 [ i + j - 1 ]) || ( dp [ j - 1 ] && s2 [ j - 1 ] == s3 [ i + j - 1 ]); } return dp [ s2 . length ()]; } };","title":"97. Interleaving String $\\star\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#98-validate-binary-search-tree-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool isValidBST ( TreeNode * root ) { return helper ( root , NULL , NULL ); } private : bool helper ( TreeNode * root , TreeNode * minNode , TreeNode * maxNode ) { if ( ! root ) return true ; if ( minNode && root -> val <= minNode -> val || maxNode && root -> val >= maxNode -> val ) return false ; return helper ( root -> left , minNode , root ) && helper ( root -> right , root , maxNode ); } };","title":"98. Validate Binary Search Tree $\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#99-recover-binary-search-tree-starstarstar","text":"","title":"99. Recover Binary Search Tree $\\star\\star\\star$"},{"location":"cpp/0001-0100/0091-0100/#100-same-tree-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : bool isSameTree ( TreeNode * p , TreeNode * q ) { if ( ! p || ! q ) return p == q ; return p -> val == q -> val && isSameTree ( p -> left , q -> left ) && isSameTree ( p -> right , q -> right ); } };","title":"100. Same Tree $\\star$"},{"location":"cpp/0101-0200/0101-0110/","text":"101. Symmetric Tree $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool isSymmetric ( TreeNode * root ) { return helper ( root , root ); } private : bool helper ( TreeNode * p , TreeNode * q ) { if ( ! p || ! q ) return p == q ; return p -> val == q -> val && helper ( p -> left , q -> right ) && helper ( p -> right , q -> left ); } }; 102. Binary Tree Level Order Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < vector < int >> levelOrder ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { vector < int > currLevel ; for ( int i = queue . size (); i > 0 ; i -- ) { TreeNode * node = queue . front (); queue . pop (); currLevel . push_back ( node -> val ); if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } ans . push_back ( currLevel ); } return ans ; } }; 103. Binary Tree Zigzag Level Order Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < vector < int >> zigzagLevelOrder ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; deque < TreeNode *> deque ; deque . push_back ( root ); bool isLeftToRight = true ; while ( ! deque . empty ()) { vector < int > currLevel ; for ( int i = deque . size (); i > 0 ; i -- ) { if ( isLeftToRight ) { TreeNode * node = deque . front (); deque . pop_front (); currLevel . push_back ( node -> val ); if ( node -> left ) deque . push_back ( node -> left ); if ( node -> right ) deque . push_back ( node -> right ); } else { TreeNode * node = deque . back (); deque . pop_back (); currLevel . push_back ( node -> val ); if ( node -> right ) deque . push_front ( node -> right ); if ( node -> left ) deque . push_front ( node -> left ); } } ans . push_back ( currLevel ); isLeftToRight = ! isLeftToRight ; } return ans ; } }; 104. Maximum Depth of Binary Tree $\\star$ 1 2 3 4 5 6 7 8 class Solution { public : int maxDepth ( TreeNode * root ) { if ( ! root ) return 0 ; return 1 + max ( maxDepth ( root -> left ), maxDepth ( root -> right )); } }; 105. Construct Binary Tree from Preorder and Inorder Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : TreeNode * buildTree ( vector < int >& preorder , vector < int >& inorder ) { unordered_map < int , int > map ; for ( int i = 0 ; i < inorder . size (); i ++ ) map [ inorder [ i ]] = i ; return helper ( preorder , 0 , preorder . size () - 1 , inorder , 0 , inorder . size () - 1 , map ); } TreeNode * helper ( vector < int >& preorder , int pLeft , int pRight , vector < int >& inorder , int iLeft , int iRight , unordered_map < int , int >& map ) { if ( pLeft > pRight || iLeft > iRight ) return nullptr ; int i = map [ preorder [ pLeft ]]; TreeNode * curr = new TreeNode ( preorder [ pLeft ]); curr -> left = helper ( preorder , pLeft + 1 , pLeft + i - iLeft , inorder , iLeft , i - 1 , map ); curr -> right = helper ( preorder , pLeft + i - iLeft + 1 , pRight , inorder , i + 1 , iRight , map ); return curr ; } }; 106. Construct Binary Tree from Inorder and Postorder Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : TreeNode * buildTree ( vector < int >& inorder , vector < int >& postorder ) { unordered_map < int , int > map ; for ( int i = 0 ; i < inorder . size (); i ++ ) map [ inorder [ i ]] = i ; return helper ( inorder , 0 , inorder . size () - 1 , postorder , 0 , postorder . size () - 1 , map ); } TreeNode * helper ( vector < int >& inorder , int iLeft , int iRight , vector < int >& postorder , int pLeft , int pRight , unordered_map < int , int >& map ) { if ( iLeft > iRight || pLeft > pRight ) return nullptr ; int i = map [ postorder [ pRight ]]; TreeNode * curr = new TreeNode ( postorder [ pRight ]); curr -> left = helper ( inorder , iLeft , i - 1 , postorder , pLeft , pLeft + i - iLeft - 1 , map ); curr -> right = helper ( inorder , i + 1 , iRight , postorder , pLeft + i - iLeft , pRight - 1 , map ); return curr ; } }; 107. Binary Tree Level Order Traversal II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < vector < int >> levelOrderBottom ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { vector < int > currLevel ; for ( int i = queue . size (); i > 0 ; i -- ) { TreeNode * node = queue . front (); queue . pop (); currLevel . push_back ( node -> val ); if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } ans . insert ( ans . begin (), currLevel ); } return ans ; } }; 108. Convert Sorted Array to Binary Search Tree $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : TreeNode * sortedArrayToBST ( vector < int >& nums ) { return helper ( nums , 0 , nums . size () - 1 ); } private : TreeNode * helper ( vector < int >& nums , int l , int r ) { if ( l > r ) return NULL ; int mid = ( l + r ) >> 1 ; TreeNode * root = new TreeNode ( nums [ mid ]); root -> left = helper ( nums , l , mid - 1 ); root -> right = helper ( nums , mid + 1 , r ); return root ; } }; 109. Convert Sorted List to Binary Search Tree $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : TreeNode * sortedListToBST ( ListNode * head ) { int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) length ++ ; this -> head = head ; return helper ( 0 , length - 1 ); } private : ListNode * head ; TreeNode * helper ( int l , int r ) { if ( l > r ) return NULL ; int mid = ( l + r ) >> 1 ; TreeNode * left = helper ( l , mid - 1 ); TreeNode * node = new TreeNode ( head -> val ); head = head -> next ; node -> left = left ; node -> right = helper ( mid + 1 , r ); return node ; } }; 110. Balanced Binary Tree $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool isBalanced ( TreeNode * root ) { if ( ! root ) return true ; return abs ( maxDepth ( root -> left ) - maxDepth ( root -> right )) <= 1 && isBalanced ( root -> left ) && isBalanced ( root -> right ); } private : int maxDepth ( TreeNode * root ) { if ( ! root ) return 0 ; return 1 + max ( maxDepth ( root -> left ), maxDepth ( root -> right )); } };","title":"0101-0110"},{"location":"cpp/0101-0200/0101-0110/#101-symmetric-tree-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool isSymmetric ( TreeNode * root ) { return helper ( root , root ); } private : bool helper ( TreeNode * p , TreeNode * q ) { if ( ! p || ! q ) return p == q ; return p -> val == q -> val && helper ( p -> left , q -> right ) && helper ( p -> right , q -> left ); } };","title":"101. Symmetric Tree $\\star$"},{"location":"cpp/0101-0200/0101-0110/#102-binary-tree-level-order-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < vector < int >> levelOrder ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { vector < int > currLevel ; for ( int i = queue . size (); i > 0 ; i -- ) { TreeNode * node = queue . front (); queue . pop (); currLevel . push_back ( node -> val ); if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } ans . push_back ( currLevel ); } return ans ; } };","title":"102. Binary Tree Level Order Traversal $\\star\\star$"},{"location":"cpp/0101-0200/0101-0110/#103-binary-tree-zigzag-level-order-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < vector < int >> zigzagLevelOrder ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; deque < TreeNode *> deque ; deque . push_back ( root ); bool isLeftToRight = true ; while ( ! deque . empty ()) { vector < int > currLevel ; for ( int i = deque . size (); i > 0 ; i -- ) { if ( isLeftToRight ) { TreeNode * node = deque . front (); deque . pop_front (); currLevel . push_back ( node -> val ); if ( node -> left ) deque . push_back ( node -> left ); if ( node -> right ) deque . push_back ( node -> right ); } else { TreeNode * node = deque . back (); deque . pop_back (); currLevel . push_back ( node -> val ); if ( node -> right ) deque . push_front ( node -> right ); if ( node -> left ) deque . push_front ( node -> left ); } } ans . push_back ( currLevel ); isLeftToRight = ! isLeftToRight ; } return ans ; } };","title":"103. Binary Tree Zigzag Level Order Traversal $\\star\\star$"},{"location":"cpp/0101-0200/0101-0110/#104-maximum-depth-of-binary-tree-star","text":"1 2 3 4 5 6 7 8 class Solution { public : int maxDepth ( TreeNode * root ) { if ( ! root ) return 0 ; return 1 + max ( maxDepth ( root -> left ), maxDepth ( root -> right )); } };","title":"104. Maximum Depth of Binary Tree $\\star$"},{"location":"cpp/0101-0200/0101-0110/#105-construct-binary-tree-from-preorder-and-inorder-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : TreeNode * buildTree ( vector < int >& preorder , vector < int >& inorder ) { unordered_map < int , int > map ; for ( int i = 0 ; i < inorder . size (); i ++ ) map [ inorder [ i ]] = i ; return helper ( preorder , 0 , preorder . size () - 1 , inorder , 0 , inorder . size () - 1 , map ); } TreeNode * helper ( vector < int >& preorder , int pLeft , int pRight , vector < int >& inorder , int iLeft , int iRight , unordered_map < int , int >& map ) { if ( pLeft > pRight || iLeft > iRight ) return nullptr ; int i = map [ preorder [ pLeft ]]; TreeNode * curr = new TreeNode ( preorder [ pLeft ]); curr -> left = helper ( preorder , pLeft + 1 , pLeft + i - iLeft , inorder , iLeft , i - 1 , map ); curr -> right = helper ( preorder , pLeft + i - iLeft + 1 , pRight , inorder , i + 1 , iRight , map ); return curr ; } };","title":"105. Construct Binary Tree from Preorder and Inorder Traversal $\\star\\star$"},{"location":"cpp/0101-0200/0101-0110/#106-construct-binary-tree-from-inorder-and-postorder-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : TreeNode * buildTree ( vector < int >& inorder , vector < int >& postorder ) { unordered_map < int , int > map ; for ( int i = 0 ; i < inorder . size (); i ++ ) map [ inorder [ i ]] = i ; return helper ( inorder , 0 , inorder . size () - 1 , postorder , 0 , postorder . size () - 1 , map ); } TreeNode * helper ( vector < int >& inorder , int iLeft , int iRight , vector < int >& postorder , int pLeft , int pRight , unordered_map < int , int >& map ) { if ( iLeft > iRight || pLeft > pRight ) return nullptr ; int i = map [ postorder [ pRight ]]; TreeNode * curr = new TreeNode ( postorder [ pRight ]); curr -> left = helper ( inorder , iLeft , i - 1 , postorder , pLeft , pLeft + i - iLeft - 1 , map ); curr -> right = helper ( inorder , i + 1 , iRight , postorder , pLeft + i - iLeft , pRight - 1 , map ); return curr ; } };","title":"106. Construct Binary Tree from Inorder and Postorder Traversal $\\star\\star$"},{"location":"cpp/0101-0200/0101-0110/#107-binary-tree-level-order-traversal-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : vector < vector < int >> levelOrderBottom ( TreeNode * root ) { if ( ! root ) return {}; vector < vector < int >> ans ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { vector < int > currLevel ; for ( int i = queue . size (); i > 0 ; i -- ) { TreeNode * node = queue . front (); queue . pop (); currLevel . push_back ( node -> val ); if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } ans . insert ( ans . begin (), currLevel ); } return ans ; } };","title":"107. Binary Tree Level Order Traversal II $\\star$"},{"location":"cpp/0101-0200/0101-0110/#108-convert-sorted-array-to-binary-search-tree-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : TreeNode * sortedArrayToBST ( vector < int >& nums ) { return helper ( nums , 0 , nums . size () - 1 ); } private : TreeNode * helper ( vector < int >& nums , int l , int r ) { if ( l > r ) return NULL ; int mid = ( l + r ) >> 1 ; TreeNode * root = new TreeNode ( nums [ mid ]); root -> left = helper ( nums , l , mid - 1 ); root -> right = helper ( nums , mid + 1 , r ); return root ; } };","title":"108. Convert Sorted Array to Binary Search Tree $\\star$"},{"location":"cpp/0101-0200/0101-0110/#109-convert-sorted-list-to-binary-search-tree-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : TreeNode * sortedListToBST ( ListNode * head ) { int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) length ++ ; this -> head = head ; return helper ( 0 , length - 1 ); } private : ListNode * head ; TreeNode * helper ( int l , int r ) { if ( l > r ) return NULL ; int mid = ( l + r ) >> 1 ; TreeNode * left = helper ( l , mid - 1 ); TreeNode * node = new TreeNode ( head -> val ); head = head -> next ; node -> left = left ; node -> right = helper ( mid + 1 , r ); return node ; } };","title":"109. Convert Sorted List to Binary Search Tree $\\star\\star$"},{"location":"cpp/0101-0200/0101-0110/#110-balanced-binary-tree-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool isBalanced ( TreeNode * root ) { if ( ! root ) return true ; return abs ( maxDepth ( root -> left ) - maxDepth ( root -> right )) <= 1 && isBalanced ( root -> left ) && isBalanced ( root -> right ); } private : int maxDepth ( TreeNode * root ) { if ( ! root ) return 0 ; return 1 + max ( maxDepth ( root -> left ), maxDepth ( root -> right )); } };","title":"110. Balanced Binary Tree $\\star$"},{"location":"cpp/0101-0200/0111-0120/","text":"111. Minimum Depth of Binary Tree $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int minDepth ( TreeNode * root ) { if ( ! root ) return 0 ; int ans = 0 ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { ans ++ ; for ( int i = queue . size (); i > 0 ; i -- ) { TreeNode * node = queue . front (); queue . pop (); if ( ! node -> left && ! node -> right ) return ans ; if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } } return - 1 ; } }; 112. Path Sum $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : bool hasPathSum ( TreeNode * root , int sum ) { if ( ! root ) return false ; if ( root -> val == sum && ! root -> left && ! root -> right ) return true ; return hasPathSum ( root -> left , sum - root -> val ) || hasPathSum ( root -> right , sum - root -> val ); } }; 113. Path Sum II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < vector < int >> pathSum ( TreeNode * root , int sum ) { vector < vector < int >> ans ; vector < int > path ; dfs ( root , sum , path , ans ); return ans ; } private : void dfs ( TreeNode * root , int sum , vector < int >& path , vector < vector < int >>& ans ) { if ( ! root ) return ; if ( sum == root -> val && ! root -> left && ! root -> right ) { path . push_back ( root -> val ); ans . push_back ( path ); path . pop_back (); return ; } path . push_back ( root -> val ); dfs ( root -> left , sum - root -> val , path , ans ); dfs ( root -> right , sum - root -> val , path , ans ); path . pop_back (); } }; 114. Flatten Binary Tree to Linked List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : void flatten ( TreeNode * root ) { if ( ! root ) return ; flatten ( root -> right ); flatten ( root -> left ); root -> right = next ; root -> left = NULL ; next = root ; } private : TreeNode * next = NULL ; }; 115. Distinct Subsequences $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int numDistinct ( string s , string t ) { const int m = s . length (); const int n = t . length (); vector < vector < long >> dp ( m + 1 , vector < long > ( n + 1 )); for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) { if ( j == 0 ) dp [ i ][ j ] = 1 ; else if ( i == 0 ) dp [ i ][ j ] = 0 ; else dp [ i ][ j ] = dp [ i - 1 ][ j ] + ( s [ i - 1 ] == t [ j - 1 ] ? dp [ i - 1 ][ j - 1 ] : 0 ); } return dp [ m ][ n ]; } }; 116. Populating Next Right Pointers in Each Node $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Node * connect ( Node * root ) { Node * node = root ; while ( node && node -> left ) { Node * next = node -> left ; while ( node ) { node -> left -> next = node -> right ; node -> right -> next = node -> next ? node -> next -> left : NULL ; node = node -> next ; } node = next ; } return root ; } }; 117. Populating Next Right Pointers in Each Node II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : Node * connect ( Node * root ) { Node * node = root ; Node * curr = new Node ( NULL ); Node * prev = curr ; while ( node ) { while ( node ) { curr -> next = node -> left ; if ( curr -> next ) curr = curr -> next ; curr -> next = node -> right ; if ( curr -> next ) curr = curr -> next ; node = node -> next ; } node = prev -> next ; curr = prev ; } return root ; } }; 118. Pascal's Triangle $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < vector < int >> generate ( int numRows ) { vector < vector < int >> ans ; for ( int i = 0 ; i < numRows ; i ++ ) ans . push_back ( vector < int > ( i + 1 , 1 )); for ( int i = 2 ; i < numRows ; i ++ ) for ( int j = 1 ; j < ans [ i ]. size () - 1 ; j ++ ) ans [ i ][ j ] = ans [ i - 1 ][ j - 1 ] + ans [ i - 1 ][ j ]; return ans ; } }; 119. Pascal's Triangle II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < int > getRow ( int rowIndex ) { vector < int > ans ( rowIndex + 1 , 1 ); for ( int i = 2 ; i < rowIndex + 1 ; i ++ ) for ( int j = 1 ; j < i ; j ++ ) ans [ i - j ] += ans [ i - j - 1 ]; return ans ; } }; 120. Triangle $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int minimumTotal ( vector < vector < int >>& triangle ) { for ( int i = triangle . size () - 2 ; i >= 0 ; i -- ) for ( int j = 0 ; j <= i ; j ++ ) triangle [ i ][ j ] += min ( triangle [ i + 1 ][ j ], triangle [ i + 1 ][ j + 1 ]); return triangle [ 0 ][ 0 ]; } };","title":"0111-0120"},{"location":"cpp/0101-0200/0111-0120/#111-minimum-depth-of-binary-tree-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int minDepth ( TreeNode * root ) { if ( ! root ) return 0 ; int ans = 0 ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { ans ++ ; for ( int i = queue . size (); i > 0 ; i -- ) { TreeNode * node = queue . front (); queue . pop (); if ( ! node -> left && ! node -> right ) return ans ; if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } } return - 1 ; } };","title":"111. Minimum Depth of Binary Tree $\\star$"},{"location":"cpp/0101-0200/0111-0120/#112-path-sum-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : bool hasPathSum ( TreeNode * root , int sum ) { if ( ! root ) return false ; if ( root -> val == sum && ! root -> left && ! root -> right ) return true ; return hasPathSum ( root -> left , sum - root -> val ) || hasPathSum ( root -> right , sum - root -> val ); } };","title":"112. Path Sum $\\star$"},{"location":"cpp/0101-0200/0111-0120/#113-path-sum-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : vector < vector < int >> pathSum ( TreeNode * root , int sum ) { vector < vector < int >> ans ; vector < int > path ; dfs ( root , sum , path , ans ); return ans ; } private : void dfs ( TreeNode * root , int sum , vector < int >& path , vector < vector < int >>& ans ) { if ( ! root ) return ; if ( sum == root -> val && ! root -> left && ! root -> right ) { path . push_back ( root -> val ); ans . push_back ( path ); path . pop_back (); return ; } path . push_back ( root -> val ); dfs ( root -> left , sum - root -> val , path , ans ); dfs ( root -> right , sum - root -> val , path , ans ); path . pop_back (); } };","title":"113. Path Sum II $\\star\\star$"},{"location":"cpp/0101-0200/0111-0120/#114-flatten-binary-tree-to-linked-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : void flatten ( TreeNode * root ) { if ( ! root ) return ; flatten ( root -> right ); flatten ( root -> left ); root -> right = next ; root -> left = NULL ; next = root ; } private : TreeNode * next = NULL ; };","title":"114. Flatten Binary Tree to Linked List $\\star\\star$"},{"location":"cpp/0101-0200/0111-0120/#115-distinct-subsequences-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int numDistinct ( string s , string t ) { const int m = s . length (); const int n = t . length (); vector < vector < long >> dp ( m + 1 , vector < long > ( n + 1 )); for ( int i = 0 ; i <= m ; i ++ ) for ( int j = 0 ; j <= n ; j ++ ) { if ( j == 0 ) dp [ i ][ j ] = 1 ; else if ( i == 0 ) dp [ i ][ j ] = 0 ; else dp [ i ][ j ] = dp [ i - 1 ][ j ] + ( s [ i - 1 ] == t [ j - 1 ] ? dp [ i - 1 ][ j - 1 ] : 0 ); } return dp [ m ][ n ]; } };","title":"115. Distinct Subsequences $\\star\\star\\star$"},{"location":"cpp/0101-0200/0111-0120/#116-populating-next-right-pointers-in-each-node-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Node * connect ( Node * root ) { Node * node = root ; while ( node && node -> left ) { Node * next = node -> left ; while ( node ) { node -> left -> next = node -> right ; node -> right -> next = node -> next ? node -> next -> left : NULL ; node = node -> next ; } node = next ; } return root ; } };","title":"116. Populating Next Right Pointers in Each Node $\\star\\star$"},{"location":"cpp/0101-0200/0111-0120/#117-populating-next-right-pointers-in-each-node-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : Node * connect ( Node * root ) { Node * node = root ; Node * curr = new Node ( NULL ); Node * prev = curr ; while ( node ) { while ( node ) { curr -> next = node -> left ; if ( curr -> next ) curr = curr -> next ; curr -> next = node -> right ; if ( curr -> next ) curr = curr -> next ; node = node -> next ; } node = prev -> next ; curr = prev ; } return root ; } };","title":"117. Populating Next Right Pointers in Each Node II $\\star\\star$"},{"location":"cpp/0101-0200/0111-0120/#118-pascals-triangle-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < vector < int >> generate ( int numRows ) { vector < vector < int >> ans ; for ( int i = 0 ; i < numRows ; i ++ ) ans . push_back ( vector < int > ( i + 1 , 1 )); for ( int i = 2 ; i < numRows ; i ++ ) for ( int j = 1 ; j < ans [ i ]. size () - 1 ; j ++ ) ans [ i ][ j ] = ans [ i - 1 ][ j - 1 ] + ans [ i - 1 ][ j ]; return ans ; } };","title":"118. Pascal's Triangle $\\star$"},{"location":"cpp/0101-0200/0111-0120/#119-pascals-triangle-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < int > getRow ( int rowIndex ) { vector < int > ans ( rowIndex + 1 , 1 ); for ( int i = 2 ; i < rowIndex + 1 ; i ++ ) for ( int j = 1 ; j < i ; j ++ ) ans [ i - j ] += ans [ i - j - 1 ]; return ans ; } };","title":"119. Pascal's Triangle II $\\star$"},{"location":"cpp/0101-0200/0111-0120/#120-triangle-starstar","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int minimumTotal ( vector < vector < int >>& triangle ) { for ( int i = triangle . size () - 2 ; i >= 0 ; i -- ) for ( int j = 0 ; j <= i ; j ++ ) triangle [ i ][ j ] += min ( triangle [ i + 1 ][ j ], triangle [ i + 1 ][ j + 1 ]); return triangle [ 0 ][ 0 ]; } };","title":"120. Triangle $\\star\\star$"},{"location":"cpp/0101-0200/0121-0130/","text":"121. Best Time to Buy and Sell Stock $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxProfit ( vector < int >& prices ) { int sellOne = 0 ; int holdOne = INT_MIN ; for ( int price : prices ) { sellOne = max ( sellOne , holdOne + price ); holdOne = max ( holdOne , - price ); } return sellOne ; } }; 122. Best Time to Buy and Sell Stock II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxProfit ( vector < int >& prices ) { int sell = 0 ; int hold = INT_MIN ; for ( int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price ); } return sell ; } }; 123. Best Time to Buy and Sell Stock III $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int maxProfit ( vector < int >& prices ) { int sellTwo = 0 ; int holdTwo = INT_MIN ; int sellOne = 0 ; int holdOne = INT_MIN ; for ( int price : prices ) { sellTwo = max ( sellTwo , holdTwo + price ); holdTwo = max ( holdTwo , sellOne - price ); sellOne = max ( sellOne , holdOne + price ); holdOne = max ( holdOne , - price ); } return sellTwo ; } }; 124. Binary Tree Maximum Path Sum $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int maxPathSum ( TreeNode * root ) { helper ( root ); return ans ; } private : int ans = INT_MIN ; int helper ( TreeNode * root ) { if ( ! root ) return 0 ; int left = max ( helper ( root -> left ), 0 ); int right = max ( helper ( root -> right ), 0 ); ans = max ( ans , root -> val + left + right ); return root -> val + max ( left , right ); } }; 125. Valid Palindrome $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool isPalindrome ( string s ) { int l = 0 ; int r = s . length () - 1 ; while ( l < r ) { while ( l < r && ! isalnum ( s [ l ])) l ++ ; while ( l < r && ! isalnum ( s [ r ])) r -- ; if ( tolower ( s [ l ]) != tolower ( s [ r ])) return false ; l ++ ; r -- ; } return true ; } }; 126. Word Ladder II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class Solution { public : vector < vector < string >> findLadders ( string beginWord , string endWord , vector < string >& wordList ) { vector < vector < string >> ans ; unordered_set < string > set ( wordList . begin (), wordList . end ()); if ( ! set . count ( endWord )) return ans ; unordered_set < string > set1 = { beginWord }; unordered_map < string , vector < string >> map ; bool isFound = false ; while ( ! set1 . empty () && ! isFound ) { for ( const string & word : set1 ) set . erase ( word ); unordered_set < string > tempSet ; for ( const string & parent : set1 ) { string word = parent ; for ( int i = 0 ; i < word . length (); i ++ ) { char c = word [ i ]; for ( char j = 'a' ; j <= 'z' ; j ++ ) { word [ i ] = j ; if ( word == endWord ) { map [ parent ]. push_back ( word ); isFound = true ; } else if ( set . count ( word ) && ! isFound ) { tempSet . insert ( word ); map [ parent ]. push_back ( word ); } } word [ i ] = c ; } } swap ( set1 , tempSet ); } if ( isFound ) { vector < string > path = { beginWord }; dfs ( map , beginWord , endWord , path , ans ); } return ans ; } private : void dfs ( const unordered_map < string , vector < string >>& map , const string & word , const string & endWord , vector < string >& path , vector < vector < string >>& ans ) { if ( word == endWord ) { ans . push_back ( path ); return ; } if ( map . find ( word ) == map . cend ()) return ; for ( const string & child : map . at ( word )) { path . push_back ( child ); dfs ( map , child , endWord , path , ans ); path . pop_back (); } } }; 127. Word Ladder $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : int ladderLength ( string beginWord , string endWord , vector < string >& wordList ) { unordered_set < string > set ( wordList . begin (), wordList . end ()); if ( ! set . count ( endWord )) return 0 ; int ans = 0 ; unordered_set < string > set1 = { beginWord }; unordered_set < string > set2 = { endWord }; while ( ! set1 . empty () && ! set2 . empty ()) { ans ++ ; if ( set1 . size () > set2 . size ()) swap ( set1 , set2 ); unordered_set < string > tempSet ; for ( string word : set1 ) for ( int i = 0 ; i < word . length (); i ++ ) { char c = word [ i ]; for ( char j = 'a' ; j <= 'z' ; j ++ ) { word [ i ] = j ; if ( set2 . count ( word )) return ans + 1 ; if ( ! set . count ( word )) continue ; set . erase ( word ); tempSet . insert ( word ); } word [ i ] = c ; } swap ( set1 , tempSet ); } return 0 ; } }; 128. Longest Consecutive Sequence $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int longestConsecutive ( vector < int >& nums ) { int ans = 0 ; unordered_set < int > set ( nums . begin (), nums . end ()); for ( long num : nums ) if ( ! set . count ( num - 1 )) { int length = 0 ; while ( set . count ( num ++ )) length ++ ; ans = max ( ans , length ); } return ans ; } }; 129. Sum Root to Leaf Numbers $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int sumNumbers ( TreeNode * root ) { int ans = 0 ; int path = 0 ; dfs ( root , path , ans ); return ans ; } private : void dfs ( TreeNode * root , int & path , int & ans ) { if ( ! root ) return ; if ( ! root -> left && ! root -> right ) { path = path * 10 + root -> val ; ans += path ; path = ( path - root -> val ) / 10 ; return ; } path = path * 10 + root -> val ; dfs ( root -> left , path , ans ); dfs ( root -> right , path , ans ); path = ( path - root -> val ) / 10 ; } }; 130. Surrounded Regions $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : void solve ( vector < vector < char >>& board ) { if ( board . empty ()) return ; const int m = board . size (); const int n = board [ 0 ]. size (); for ( int i = 0 ; i < m ; i ++ ) { dfs ( board , i , 0 ); dfs ( board , i , n - 1 ); } for ( int j = 1 ; j < n - 1 ; j ++ ) { dfs ( board , 0 , j ); dfs ( board , m - 1 , j ); } for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) board [ i ][ j ] = board [ i ][ j ] == '.' ? 'O' : 'X' ; } private : void dfs ( vector < vector < char >>& board , int i , int j ) { if ( i < 0 || j < 0 || i >= board . size () || j >= board [ 0 ]. size () || board [ i ][ j ] != 'O' ) return ; board [ i ][ j ] = '.' ; dfs ( board , i , j + 1 ); dfs ( board , i , j - 1 ); dfs ( board , i + 1 , j ); dfs ( board , i - 1 , j ); } };","title":"0121-0130"},{"location":"cpp/0101-0200/0121-0130/#121-best-time-to-buy-and-sell-stock-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxProfit ( vector < int >& prices ) { int sellOne = 0 ; int holdOne = INT_MIN ; for ( int price : prices ) { sellOne = max ( sellOne , holdOne + price ); holdOne = max ( holdOne , - price ); } return sellOne ; } };","title":"121. Best Time to Buy and Sell Stock $\\star$"},{"location":"cpp/0101-0200/0121-0130/#122-best-time-to-buy-and-sell-stock-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxProfit ( vector < int >& prices ) { int sell = 0 ; int hold = INT_MIN ; for ( int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price ); } return sell ; } };","title":"122. Best Time to Buy and Sell Stock II $\\star$"},{"location":"cpp/0101-0200/0121-0130/#123-best-time-to-buy-and-sell-stock-iii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int maxProfit ( vector < int >& prices ) { int sellTwo = 0 ; int holdTwo = INT_MIN ; int sellOne = 0 ; int holdOne = INT_MIN ; for ( int price : prices ) { sellTwo = max ( sellTwo , holdTwo + price ); holdTwo = max ( holdTwo , sellOne - price ); sellOne = max ( sellOne , holdOne + price ); holdOne = max ( holdOne , - price ); } return sellTwo ; } };","title":"123. Best Time to Buy and Sell Stock III $\\star\\star\\star$"},{"location":"cpp/0101-0200/0121-0130/#124-binary-tree-maximum-path-sum-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int maxPathSum ( TreeNode * root ) { helper ( root ); return ans ; } private : int ans = INT_MIN ; int helper ( TreeNode * root ) { if ( ! root ) return 0 ; int left = max ( helper ( root -> left ), 0 ); int right = max ( helper ( root -> right ), 0 ); ans = max ( ans , root -> val + left + right ); return root -> val + max ( left , right ); } };","title":"124. Binary Tree Maximum Path Sum $\\star\\star\\star$"},{"location":"cpp/0101-0200/0121-0130/#125-valid-palindrome-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : bool isPalindrome ( string s ) { int l = 0 ; int r = s . length () - 1 ; while ( l < r ) { while ( l < r && ! isalnum ( s [ l ])) l ++ ; while ( l < r && ! isalnum ( s [ r ])) r -- ; if ( tolower ( s [ l ]) != tolower ( s [ r ])) return false ; l ++ ; r -- ; } return true ; } };","title":"125. Valid Palindrome $\\star$"},{"location":"cpp/0101-0200/0121-0130/#126-word-ladder-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 class Solution { public : vector < vector < string >> findLadders ( string beginWord , string endWord , vector < string >& wordList ) { vector < vector < string >> ans ; unordered_set < string > set ( wordList . begin (), wordList . end ()); if ( ! set . count ( endWord )) return ans ; unordered_set < string > set1 = { beginWord }; unordered_map < string , vector < string >> map ; bool isFound = false ; while ( ! set1 . empty () && ! isFound ) { for ( const string & word : set1 ) set . erase ( word ); unordered_set < string > tempSet ; for ( const string & parent : set1 ) { string word = parent ; for ( int i = 0 ; i < word . length (); i ++ ) { char c = word [ i ]; for ( char j = 'a' ; j <= 'z' ; j ++ ) { word [ i ] = j ; if ( word == endWord ) { map [ parent ]. push_back ( word ); isFound = true ; } else if ( set . count ( word ) && ! isFound ) { tempSet . insert ( word ); map [ parent ]. push_back ( word ); } } word [ i ] = c ; } } swap ( set1 , tempSet ); } if ( isFound ) { vector < string > path = { beginWord }; dfs ( map , beginWord , endWord , path , ans ); } return ans ; } private : void dfs ( const unordered_map < string , vector < string >>& map , const string & word , const string & endWord , vector < string >& path , vector < vector < string >>& ans ) { if ( word == endWord ) { ans . push_back ( path ); return ; } if ( map . find ( word ) == map . cend ()) return ; for ( const string & child : map . at ( word )) { path . push_back ( child ); dfs ( map , child , endWord , path , ans ); path . pop_back (); } } };","title":"126. Word Ladder II $\\star\\star\\star$"},{"location":"cpp/0101-0200/0121-0130/#127-word-ladder-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : int ladderLength ( string beginWord , string endWord , vector < string >& wordList ) { unordered_set < string > set ( wordList . begin (), wordList . end ()); if ( ! set . count ( endWord )) return 0 ; int ans = 0 ; unordered_set < string > set1 = { beginWord }; unordered_set < string > set2 = { endWord }; while ( ! set1 . empty () && ! set2 . empty ()) { ans ++ ; if ( set1 . size () > set2 . size ()) swap ( set1 , set2 ); unordered_set < string > tempSet ; for ( string word : set1 ) for ( int i = 0 ; i < word . length (); i ++ ) { char c = word [ i ]; for ( char j = 'a' ; j <= 'z' ; j ++ ) { word [ i ] = j ; if ( set2 . count ( word )) return ans + 1 ; if ( ! set . count ( word )) continue ; set . erase ( word ); tempSet . insert ( word ); } word [ i ] = c ; } swap ( set1 , tempSet ); } return 0 ; } };","title":"127. Word Ladder $\\star\\star$"},{"location":"cpp/0101-0200/0121-0130/#128-longest-consecutive-sequence-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int longestConsecutive ( vector < int >& nums ) { int ans = 0 ; unordered_set < int > set ( nums . begin (), nums . end ()); for ( long num : nums ) if ( ! set . count ( num - 1 )) { int length = 0 ; while ( set . count ( num ++ )) length ++ ; ans = max ( ans , length ); } return ans ; } };","title":"128. Longest Consecutive Sequence $\\star\\star\\star$"},{"location":"cpp/0101-0200/0121-0130/#129-sum-root-to-leaf-numbers-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int sumNumbers ( TreeNode * root ) { int ans = 0 ; int path = 0 ; dfs ( root , path , ans ); return ans ; } private : void dfs ( TreeNode * root , int & path , int & ans ) { if ( ! root ) return ; if ( ! root -> left && ! root -> right ) { path = path * 10 + root -> val ; ans += path ; path = ( path - root -> val ) / 10 ; return ; } path = path * 10 + root -> val ; dfs ( root -> left , path , ans ); dfs ( root -> right , path , ans ); path = ( path - root -> val ) / 10 ; } };","title":"129. Sum Root to Leaf Numbers $\\star\\star$"},{"location":"cpp/0101-0200/0121-0130/#130-surrounded-regions-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : void solve ( vector < vector < char >>& board ) { if ( board . empty ()) return ; const int m = board . size (); const int n = board [ 0 ]. size (); for ( int i = 0 ; i < m ; i ++ ) { dfs ( board , i , 0 ); dfs ( board , i , n - 1 ); } for ( int j = 1 ; j < n - 1 ; j ++ ) { dfs ( board , 0 , j ); dfs ( board , m - 1 , j ); } for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) board [ i ][ j ] = board [ i ][ j ] == '.' ? 'O' : 'X' ; } private : void dfs ( vector < vector < char >>& board , int i , int j ) { if ( i < 0 || j < 0 || i >= board . size () || j >= board [ 0 ]. size () || board [ i ][ j ] != 'O' ) return ; board [ i ][ j ] = '.' ; dfs ( board , i , j + 1 ); dfs ( board , i , j - 1 ); dfs ( board , i + 1 , j ); dfs ( board , i - 1 , j ); } };","title":"130. Surrounded Regions $\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/","text":"131. Palindrome Partitioning $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < vector < string >> partition ( string s ) { vector < vector < string >> ans ; vector < string > path ; dfs ( s , 0 , path , ans ); return ans ; } private : void dfs ( string & s , int j , vector < string >& path , vector < vector < string >>& ans ) { if ( j == s . length ()) { ans . push_back ( path ); return ; } for ( int i = j ; i < s . length (); i ++ ) if ( isPalindrome ( s , j , i )) { path . push_back ( s . substr ( j , i - j + 1 )); dfs ( s , i + 1 , path , ans ); path . pop_back (); } } bool isPalindrome ( string & s , int l , int r ) { while ( l < r ) if ( s [ l ++ ] != s [ r -- ]) return false ; return true ; } }; 132. Palindrome Partitioning II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int minCut ( string s ) { const int n = s . length (); vector < int > cut ( n ); vector < vector < bool >> dp ( n , vector < bool > ( n )); for ( int i = 0 ; i < n ; i ++ ) { int min = i ; for ( int j = 0 ; j <= i ; j ++ ) if ( s [ j ] == s [ i ] && ( j + 1 > i - 1 || dp [ j + 1 ][ i - 1 ])) { dp [ j ][ i ] = true ; min = j == 0 ? 0 : std :: min ( min , cut [ j - 1 ] + 1 ); } cut [ i ] = min ; } return cut [ n - 1 ]; } }; 133. Clone Graph $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : Node * cloneGraph ( Node * node ) { if ( ! node ) return NULL ; if ( map . count ( node )) return map [ node ]; map [ node ] = new Node ( node -> val , {}); for ( Node * neighbor : node -> neighbors ) map [ node ] -> neighbors . push_back ( cloneGraph ( neighbor )); return map [ node ]; } private : unordered_map < Node * , Node *> map ; }; 134. Gas Station $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int canCompleteCircuit ( vector < int >& gas , vector < int >& cost ) { int ans = 0 ; int net = 0 ; int sum = 0 ; for ( int i = 0 ; i < gas . size (); i ++ ) { net += gas [ i ] - cost [ i ]; sum += gas [ i ] - cost [ i ]; if ( sum < 0 ) { sum = 0 ; ans = i + 1 ; } } return net < 0 ? - 1 : ans ; } }; 135. Candy $\\star\\star\\star$ 136. Single Number $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int singleNumber ( vector < int >& nums ) { int ans = 0 ; for ( int num : nums ) ans ^= num ; return ans ; } }; 137. Single Number II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int singleNumber ( vector < int >& nums ) { int ones = 0 ; int twos = 0 ; for ( int num : nums ) { ones ^= ( num & ~ twos ); twos ^= ( num & ~ ones ); } return ones ; } }; 138. Copy List with Random Pointer $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : Node * copyRandomList ( Node * head ) { if ( ! head ) return NULL ; if ( map . count ( head )) return map [ head ]; map [ head ] = new Node ( head -> val , NULL , NULL ); map [ head ] -> next = copyRandomList ( head -> next ); map [ head ] -> random = copyRandomList ( head -> random ); return map [ head ]; } private : unordered_map < Node * , Node *> map ; }; 139. Word Break $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : bool wordBreak ( string s , vector < string >& wordDict ) { unordered_set < string > set ( wordDict . begin (), wordDict . end ()); return wordBreak ( s , set ); } private : unordered_map < string , bool > map ; bool wordBreak ( string & s , unordered_set < string >& set ) { if ( map . count ( s )) return map [ s ]; if ( set . count ( s )) return map [ s ] = true ; for ( int i = 1 ; i < s . length (); i ++ ) { string left = s . substr ( 0 , i ); string right = s . substr ( i ); if ( wordBreak ( left , set ) && set . count ( right )) return map [ s ] = true ; } return map [ s ] = false ; } }; 140. Word Break II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < string > wordBreak ( string s , vector < string >& wordDict ) { unordered_set < string > set ( wordDict . begin (), wordDict . end ()); return wordBreak ( s , set ); } private : unordered_map < string , vector < string >> map ; vector < string >& wordBreak ( string & s , unordered_set < string >& set ) { if ( map . count ( s )) return map [ s ]; vector < string > ans ; if ( set . count ( s )) ans . push_back ( s ); for ( int i = 1 ; i < s . length (); i ++ ) { string right = s . substr ( i ); if ( set . count ( right )) { string left = s . substr ( 0 , i ); vector < string > leftAns = append ( wordBreak ( left , set ), right ); ans . insert ( ans . end (), leftAns . begin (), leftAns . end ()); } } return map [ s ] = ans ; } vector < string > append ( vector < string > prefixes , string & word ) { for ( string & prefix : prefixes ) prefix += \" \" + word ; return prefixes ; } };","title":"0131-0140"},{"location":"cpp/0101-0200/0131-0140/#131-palindrome-partitioning-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < vector < string >> partition ( string s ) { vector < vector < string >> ans ; vector < string > path ; dfs ( s , 0 , path , ans ); return ans ; } private : void dfs ( string & s , int j , vector < string >& path , vector < vector < string >>& ans ) { if ( j == s . length ()) { ans . push_back ( path ); return ; } for ( int i = j ; i < s . length (); i ++ ) if ( isPalindrome ( s , j , i )) { path . push_back ( s . substr ( j , i - j + 1 )); dfs ( s , i + 1 , path , ans ); path . pop_back (); } } bool isPalindrome ( string & s , int l , int r ) { while ( l < r ) if ( s [ l ++ ] != s [ r -- ]) return false ; return true ; } };","title":"131. Palindrome Partitioning $\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/#132-palindrome-partitioning-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int minCut ( string s ) { const int n = s . length (); vector < int > cut ( n ); vector < vector < bool >> dp ( n , vector < bool > ( n )); for ( int i = 0 ; i < n ; i ++ ) { int min = i ; for ( int j = 0 ; j <= i ; j ++ ) if ( s [ j ] == s [ i ] && ( j + 1 > i - 1 || dp [ j + 1 ][ i - 1 ])) { dp [ j ][ i ] = true ; min = j == 0 ? 0 : std :: min ( min , cut [ j - 1 ] + 1 ); } cut [ i ] = min ; } return cut [ n - 1 ]; } };","title":"132. Palindrome Partitioning II $\\star\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/#133-clone-graph-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : Node * cloneGraph ( Node * node ) { if ( ! node ) return NULL ; if ( map . count ( node )) return map [ node ]; map [ node ] = new Node ( node -> val , {}); for ( Node * neighbor : node -> neighbors ) map [ node ] -> neighbors . push_back ( cloneGraph ( neighbor )); return map [ node ]; } private : unordered_map < Node * , Node *> map ; };","title":"133. Clone Graph $\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/#134-gas-station-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int canCompleteCircuit ( vector < int >& gas , vector < int >& cost ) { int ans = 0 ; int net = 0 ; int sum = 0 ; for ( int i = 0 ; i < gas . size (); i ++ ) { net += gas [ i ] - cost [ i ]; sum += gas [ i ] - cost [ i ]; if ( sum < 0 ) { sum = 0 ; ans = i + 1 ; } } return net < 0 ? - 1 : ans ; } };","title":"134. Gas Station $\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/#135-candy-starstarstar","text":"","title":"135. Candy $\\star\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/#136-single-number-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int singleNumber ( vector < int >& nums ) { int ans = 0 ; for ( int num : nums ) ans ^= num ; return ans ; } };","title":"136. Single Number $\\star$"},{"location":"cpp/0101-0200/0131-0140/#137-single-number-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int singleNumber ( vector < int >& nums ) { int ones = 0 ; int twos = 0 ; for ( int num : nums ) { ones ^= ( num & ~ twos ); twos ^= ( num & ~ ones ); } return ones ; } };","title":"137. Single Number II $\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/#138-copy-list-with-random-pointer-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : Node * copyRandomList ( Node * head ) { if ( ! head ) return NULL ; if ( map . count ( head )) return map [ head ]; map [ head ] = new Node ( head -> val , NULL , NULL ); map [ head ] -> next = copyRandomList ( head -> next ); map [ head ] -> random = copyRandomList ( head -> random ); return map [ head ]; } private : unordered_map < Node * , Node *> map ; };","title":"138. Copy List with Random Pointer $\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/#139-word-break-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : bool wordBreak ( string s , vector < string >& wordDict ) { unordered_set < string > set ( wordDict . begin (), wordDict . end ()); return wordBreak ( s , set ); } private : unordered_map < string , bool > map ; bool wordBreak ( string & s , unordered_set < string >& set ) { if ( map . count ( s )) return map [ s ]; if ( set . count ( s )) return map [ s ] = true ; for ( int i = 1 ; i < s . length (); i ++ ) { string left = s . substr ( 0 , i ); string right = s . substr ( i ); if ( wordBreak ( left , set ) && set . count ( right )) return map [ s ] = true ; } return map [ s ] = false ; } };","title":"139. Word Break $\\star\\star$"},{"location":"cpp/0101-0200/0131-0140/#140-word-break-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < string > wordBreak ( string s , vector < string >& wordDict ) { unordered_set < string > set ( wordDict . begin (), wordDict . end ()); return wordBreak ( s , set ); } private : unordered_map < string , vector < string >> map ; vector < string >& wordBreak ( string & s , unordered_set < string >& set ) { if ( map . count ( s )) return map [ s ]; vector < string > ans ; if ( set . count ( s )) ans . push_back ( s ); for ( int i = 1 ; i < s . length (); i ++ ) { string right = s . substr ( i ); if ( set . count ( right )) { string left = s . substr ( 0 , i ); vector < string > leftAns = append ( wordBreak ( left , set ), right ); ans . insert ( ans . end (), leftAns . begin (), leftAns . end ()); } } return map [ s ] = ans ; } vector < string > append ( vector < string > prefixes , string & word ) { for ( string & prefix : prefixes ) prefix += \" \" + word ; return prefixes ; } };","title":"140. Word Break II $\\star\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/","text":"141. Linked List Cycle $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool hasCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) return true ; } return false ; } }; 142. Linked List Cycle II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : ListNode * detectCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow -> next ; fast = fast -> next ; } return slow ; } } return nullptr ; } }; 143. Reorder List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public : void reorderList ( ListNode * head ) { if ( ! head || ! head -> next ) return ; ListNode * prev = NULL ; ListNode * slow = head ; ListNode * fast = head ; ListNode * l1 = head ; while ( fast && fast -> next ) { prev = slow ; slow = slow -> next ; fast = fast -> next -> next ; } prev -> next = NULL ; ListNode * l2 = reverse ( slow ); merge ( l1 , l2 ); } private : ListNode * reverse ( ListNode * head ) { ListNode * prev = NULL ; ListNode * curr = head ; while ( curr ) { auto next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } void merge ( ListNode * l1 , ListNode * l2 ) { while ( l2 ) { auto next = l1 -> next ; l1 -> next = l2 ; l1 = l2 ; l2 = next ; } } }; 144. Binary Tree Preorder Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; stack < TreeNode *> stack ; stack . push ( root ); while ( ! stack . empty ()) { TreeNode * node = stack . top (); ans . push_back ( node -> val ); stack . pop (); if ( node -> right ) stack . push ( node -> right ); if ( node -> left ) stack . push ( node -> left ); } return ans ; } }; 145. Binary Tree Postorder Traversal $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < int > postorderTraversal ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; stack < TreeNode *> stack ; stack . push ( root ); while ( ! stack . empty ()) { TreeNode * node = stack . top (); ans . push_back ( node -> val ); stack . pop (); if ( node -> left ) stack . push ( node -> left ); if ( node -> right ) stack . push ( node -> right ); } reverse ( ans . begin (), ans . end ()); return ans ; } }; 146. LRU Cache $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class LRUCache { public : LRUCache ( int capacity ) : capacity ( capacity ) {} int get ( int key ) { if ( ! map . count ( key )) return - 1 ; cache . splice ( cache . begin (), cache , map [ key ]); return map [ key ] -> second ; } void put ( int key , int value ) { if ( map . count ( key )) { map [ key ] -> second = value ; cache . splice ( cache . begin (), cache , map [ key ]); return ; } if ( cache . size () == capacity ) { pair < int , int >& node = cache . back (); map . erase ( node . first ); cache . pop_back (); } cache . emplace_front ( key , value ); map [ key ] = cache . begin (); } private : int capacity ; list < pair < int , int >> cache ; unordered_map < int , list < pair < int , int >>:: iterator > map ; }; 147. Insertion Sort List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : ListNode * insertionSortList ( ListNode * head ) { ListNode dummy ( 0 ); ListNode * curr = head ; while ( curr ) { auto prev = & dummy ; while ( prev -> next && prev -> next -> val < curr -> val ) prev = prev -> next ; auto next = curr -> next ; curr -> next = prev -> next ; prev -> next = curr ; curr = next ; } return dummy . next ; } }; 148. Sort List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public : ListNode * sortList ( ListNode * head ) { int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) length ++ ; ListNode dummy ( 0 ); dummy . next = head ; for ( int k = 1 ; k < length ; k <<= 1 ) { ListNode * curr = dummy . next ; ListNode * tail = & dummy ; while ( curr ) { ListNode * l = curr ; ListNode * r = split ( l , k ); curr = split ( r , k ); vector < ListNode *> merged = merge ( l , r ); tail -> next = merged [ 0 ]; tail = merged [ 1 ]; } } return dummy . next ; } private : ListNode * split ( ListNode * head , int k ) { while ( -- k && head ) head = head -> next ; ListNode * rest = head ? head -> next : NULL ; if ( head ) head -> next = NULL ; return rest ; } vector < ListNode *> merge ( ListNode * l1 , ListNode * l2 ) { ListNode dummy ( 0 ); ListNode * tail = & dummy ; while ( l1 && l2 ) { if ( l1 -> val > l2 -> val ) swap ( l1 , l2 ); tail -> next = l1 ; l1 = l1 -> next ; tail = tail -> next ; } tail -> next = l1 ? l1 : l2 ; while ( tail -> next ) tail = tail -> next ; return { dummy . next , tail }; } }; 149. Max Points on a Line $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : int maxPoints ( vector < vector < int >>& points ) { int ans = 0 ; for ( int i = 0 ; i < points . size (); i ++ ) { map < pair < int , int > , int > map ; vector < int > p1 = points [ i ]; int samePoints = 1 ; int maxPoints = 0 ; for ( int j = i + 1 ; j < points . size (); j ++ ) { vector < int > p2 = points [ j ]; if ( p1 [ 0 ] == p2 [ 0 ] && p1 [ 1 ] == p2 [ 1 ]) samePoints ++ ; else maxPoints = max ( maxPoints , ++ map [ getSlope ( p1 , p2 )]); } ans = max ( ans , samePoints + maxPoints ); } return ans ; } private : pair < int , int > getSlope ( vector < int >& p1 , vector < int >& p2 ) { int dx = p2 [ 0 ] - p1 [ 0 ]; int dy = p2 [ 1 ] - p1 [ 1 ]; if ( dy == 0 ) return { p1 [ 1 ], 0 }; if ( dx == 0 ) return { 0 , p1 [ 0 ]}; int d = gcd ( dx , dy ); return { dy / d , dx / d }; } int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ); } }; 150. Evaluate Reverse Polish Notation $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : int evalRPN ( vector < string >& tokens ) { stack < int > stack ; int a ; int b ; for ( string & token : tokens ) { if ( token == \"+\" ) { helper ( stack , a , b ); stack . push ( a + b ); } else if ( token == \"-\" ) { helper ( stack , a , b ); stack . push ( a - b ); } else if ( token == \"*\" ) { helper ( stack , a , b ); stack . push ( a * b ); } else if ( token == \"/\" ) { helper ( stack , a , b ); stack . push ( a / b ); } else { stack . push ( stoi ( token )); } } return stack . top (); } private : void helper ( stack < int >& stack , int & a , int & b ) { b = stack . top (); stack . pop (); a = stack . top (); stack . pop (); } };","title":"0141-0150"},{"location":"cpp/0101-0200/0141-0150/#141-linked-list-cycle-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool hasCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) return true ; } return false ; } };","title":"141. Linked List Cycle $\\star$"},{"location":"cpp/0101-0200/0141-0150/#142-linked-list-cycle-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : ListNode * detectCycle ( ListNode * head ) { ListNode * slow = head ; ListNode * fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow -> next ; fast = fast -> next ; } return slow ; } } return nullptr ; } };","title":"142. Linked List Cycle II $\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/#143-reorder-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public : void reorderList ( ListNode * head ) { if ( ! head || ! head -> next ) return ; ListNode * prev = NULL ; ListNode * slow = head ; ListNode * fast = head ; ListNode * l1 = head ; while ( fast && fast -> next ) { prev = slow ; slow = slow -> next ; fast = fast -> next -> next ; } prev -> next = NULL ; ListNode * l2 = reverse ( slow ); merge ( l1 , l2 ); } private : ListNode * reverse ( ListNode * head ) { ListNode * prev = NULL ; ListNode * curr = head ; while ( curr ) { auto next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } void merge ( ListNode * l1 , ListNode * l2 ) { while ( l2 ) { auto next = l1 -> next ; l1 -> next = l2 ; l1 = l2 ; l2 = next ; } } };","title":"143. Reorder List $\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/#144-binary-tree-preorder-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : vector < int > preorderTraversal ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; stack < TreeNode *> stack ; stack . push ( root ); while ( ! stack . empty ()) { TreeNode * node = stack . top (); ans . push_back ( node -> val ); stack . pop (); if ( node -> right ) stack . push ( node -> right ); if ( node -> left ) stack . push ( node -> left ); } return ans ; } };","title":"144. Binary Tree Preorder Traversal $\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/#145-binary-tree-postorder-traversal-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < int > postorderTraversal ( TreeNode * root ) { if ( ! root ) return {}; vector < int > ans ; stack < TreeNode *> stack ; stack . push ( root ); while ( ! stack . empty ()) { TreeNode * node = stack . top (); ans . push_back ( node -> val ); stack . pop (); if ( node -> left ) stack . push ( node -> left ); if ( node -> right ) stack . push ( node -> right ); } reverse ( ans . begin (), ans . end ()); return ans ; } };","title":"145. Binary Tree Postorder Traversal $\\star\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/#146-lru-cache-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class LRUCache { public : LRUCache ( int capacity ) : capacity ( capacity ) {} int get ( int key ) { if ( ! map . count ( key )) return - 1 ; cache . splice ( cache . begin (), cache , map [ key ]); return map [ key ] -> second ; } void put ( int key , int value ) { if ( map . count ( key )) { map [ key ] -> second = value ; cache . splice ( cache . begin (), cache , map [ key ]); return ; } if ( cache . size () == capacity ) { pair < int , int >& node = cache . back (); map . erase ( node . first ); cache . pop_back (); } cache . emplace_front ( key , value ); map [ key ] = cache . begin (); } private : int capacity ; list < pair < int , int >> cache ; unordered_map < int , list < pair < int , int >>:: iterator > map ; };","title":"146. LRU Cache $\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/#147-insertion-sort-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : ListNode * insertionSortList ( ListNode * head ) { ListNode dummy ( 0 ); ListNode * curr = head ; while ( curr ) { auto prev = & dummy ; while ( prev -> next && prev -> next -> val < curr -> val ) prev = prev -> next ; auto next = curr -> next ; curr -> next = prev -> next ; prev -> next = curr ; curr = next ; } return dummy . next ; } };","title":"147. Insertion Sort List $\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/#148-sort-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class Solution { public : ListNode * sortList ( ListNode * head ) { int length = 0 ; for ( auto curr = head ; curr ; curr = curr -> next ) length ++ ; ListNode dummy ( 0 ); dummy . next = head ; for ( int k = 1 ; k < length ; k <<= 1 ) { ListNode * curr = dummy . next ; ListNode * tail = & dummy ; while ( curr ) { ListNode * l = curr ; ListNode * r = split ( l , k ); curr = split ( r , k ); vector < ListNode *> merged = merge ( l , r ); tail -> next = merged [ 0 ]; tail = merged [ 1 ]; } } return dummy . next ; } private : ListNode * split ( ListNode * head , int k ) { while ( -- k && head ) head = head -> next ; ListNode * rest = head ? head -> next : NULL ; if ( head ) head -> next = NULL ; return rest ; } vector < ListNode *> merge ( ListNode * l1 , ListNode * l2 ) { ListNode dummy ( 0 ); ListNode * tail = & dummy ; while ( l1 && l2 ) { if ( l1 -> val > l2 -> val ) swap ( l1 , l2 ); tail -> next = l1 ; l1 = l1 -> next ; tail = tail -> next ; } tail -> next = l1 ? l1 : l2 ; while ( tail -> next ) tail = tail -> next ; return { dummy . next , tail }; } };","title":"148. Sort List $\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/#149-max-points-on-a-line-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : int maxPoints ( vector < vector < int >>& points ) { int ans = 0 ; for ( int i = 0 ; i < points . size (); i ++ ) { map < pair < int , int > , int > map ; vector < int > p1 = points [ i ]; int samePoints = 1 ; int maxPoints = 0 ; for ( int j = i + 1 ; j < points . size (); j ++ ) { vector < int > p2 = points [ j ]; if ( p1 [ 0 ] == p2 [ 0 ] && p1 [ 1 ] == p2 [ 1 ]) samePoints ++ ; else maxPoints = max ( maxPoints , ++ map [ getSlope ( p1 , p2 )]); } ans = max ( ans , samePoints + maxPoints ); } return ans ; } private : pair < int , int > getSlope ( vector < int >& p1 , vector < int >& p2 ) { int dx = p2 [ 0 ] - p1 [ 0 ]; int dy = p2 [ 1 ] - p1 [ 1 ]; if ( dy == 0 ) return { p1 [ 1 ], 0 }; if ( dx == 0 ) return { 0 , p1 [ 0 ]}; int d = gcd ( dx , dy ); return { dy / d , dx / d }; } int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ); } };","title":"149. Max Points on a Line $\\star\\star\\star$"},{"location":"cpp/0101-0200/0141-0150/#150-evaluate-reverse-polish-notation-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : int evalRPN ( vector < string >& tokens ) { stack < int > stack ; int a ; int b ; for ( string & token : tokens ) { if ( token == \"+\" ) { helper ( stack , a , b ); stack . push ( a + b ); } else if ( token == \"-\" ) { helper ( stack , a , b ); stack . push ( a - b ); } else if ( token == \"*\" ) { helper ( stack , a , b ); stack . push ( a * b ); } else if ( token == \"/\" ) { helper ( stack , a , b ); stack . push ( a / b ); } else { stack . push ( stoi ( token )); } } return stack . top (); } private : void helper ( stack < int >& stack , int & a , int & b ) { b = stack . top (); stack . pop (); a = stack . top (); stack . pop (); } };","title":"150. Evaluate Reverse Polish Notation $\\star\\star$"},{"location":"cpp/0101-0200/0151-0160/","text":"151. Reverse Words in a String $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : string reverseWords ( string s ) { reverse ( s . begin (), s . end ()); reverseWords ( s , 0 , 0 ); return cleanSpaces ( s , 0 , 0 ); } private : void reverseWords ( string & s , int i , int j ) { while ( i < s . length ()) { while ( i < j || i < s . length () && s [ i ] == ' ' ) i ++ ; while ( j < i || j < s . length () && s [ j ] != ' ' ) j ++ ; reverse ( s . begin () + i , s . begin () + j ); } } string cleanSpaces ( string & s , int i , int j ) { while ( j < s . length ()) { while ( j < s . length () && s [ j ] == ' ' ) j ++ ; while ( j < s . length () && s [ j ] != ' ' ) s [ i ++ ] = s [ j ++ ]; while ( j < s . length () && s [ j ] == ' ' ) j ++ ; if ( j < s . length ()) s [ i ++ ] = ' ' ; } return s . substr ( 0 , i ); } }; 152. Maximum Product Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int maxProduct ( vector < int >& nums ) { int ans = nums [ 0 ]; int prevMin = nums [ 0 ]; int prevMax = nums [ 0 ]; for ( int i = 1 ; i < nums . size (); i ++ ) { int min = prevMin * nums [ i ]; int max = prevMax * nums [ i ]; prevMin = std :: min ( nums [ i ], std :: min ( min , max )); prevMax = std :: max ( nums [ i ], std :: max ( min , max )); ans = std :: max ( ans , prevMax ); } return ans ; } }; 153. Find Minimum in Rotated Sorted Array $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int findMin ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] < nums [ r ]) r = m ; else l = m + 1 ; } return nums [ l ]; } }; 154. Find Minimum in Rotated Sorted Array II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int findMin ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == nums [ r ]) r -- ; else if ( nums [ m ] < nums [ r ]) r = m ; else l = m + 1 ; } return nums [ l ]; } }; 155. Min Stack $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MinStack { public : void push ( int x ) { int min = stack . empty () ? x : std :: min ( stack . top (). second , x ); stack . push ({ x , min }); } void pop () { stack . pop (); } int top () { return stack . top (). first ; } int getMin () { return stack . top (). second ; } private : std :: stack < pair < int , int >> stack ; }; 156. Binary Tree Upside Down $\\star\\star$ 157. Read N Characters Given Read4 $\\star$ 158. Read N Characters Given Read4 II - Call multiple times $\\star\\star\\star$ 159. Longest Substring with At Most Two Distinct Characters $\\star\\star$ 160. Intersection of Two Linked Lists $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { if ( ! headA || ! headB ) return NULL ; ListNode * a = headA ; ListNode * b = headB ; while ( a != b ) { a = a == NULL ? headB : a -> next ; b = b == NULL ? headA : b -> next ; } return a ; } };","title":"0151-0160"},{"location":"cpp/0101-0200/0151-0160/#151-reverse-words-in-a-string-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public : string reverseWords ( string s ) { reverse ( s . begin (), s . end ()); reverseWords ( s , 0 , 0 ); return cleanSpaces ( s , 0 , 0 ); } private : void reverseWords ( string & s , int i , int j ) { while ( i < s . length ()) { while ( i < j || i < s . length () && s [ i ] == ' ' ) i ++ ; while ( j < i || j < s . length () && s [ j ] != ' ' ) j ++ ; reverse ( s . begin () + i , s . begin () + j ); } } string cleanSpaces ( string & s , int i , int j ) { while ( j < s . length ()) { while ( j < s . length () && s [ j ] == ' ' ) j ++ ; while ( j < s . length () && s [ j ] != ' ' ) s [ i ++ ] = s [ j ++ ]; while ( j < s . length () && s [ j ] == ' ' ) j ++ ; if ( j < s . length ()) s [ i ++ ] = ' ' ; } return s . substr ( 0 , i ); } };","title":"151. Reverse Words in a String $\\star\\star$"},{"location":"cpp/0101-0200/0151-0160/#152-maximum-product-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int maxProduct ( vector < int >& nums ) { int ans = nums [ 0 ]; int prevMin = nums [ 0 ]; int prevMax = nums [ 0 ]; for ( int i = 1 ; i < nums . size (); i ++ ) { int min = prevMin * nums [ i ]; int max = prevMax * nums [ i ]; prevMin = std :: min ( nums [ i ], std :: min ( min , max )); prevMax = std :: max ( nums [ i ], std :: max ( min , max )); ans = std :: max ( ans , prevMax ); } return ans ; } };","title":"152. Maximum Product Subarray $\\star\\star$"},{"location":"cpp/0101-0200/0151-0160/#153-find-minimum-in-rotated-sorted-array-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int findMin ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] < nums [ r ]) r = m ; else l = m + 1 ; } return nums [ l ]; } };","title":"153. Find Minimum in Rotated Sorted Array $\\star\\star$"},{"location":"cpp/0101-0200/0151-0160/#154-find-minimum-in-rotated-sorted-array-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int findMin ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == nums [ r ]) r -- ; else if ( nums [ m ] < nums [ r ]) r = m ; else l = m + 1 ; } return nums [ l ]; } };","title":"154. Find Minimum in Rotated Sorted Array II $\\star\\star\\star$"},{"location":"cpp/0101-0200/0151-0160/#155-min-stack-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class MinStack { public : void push ( int x ) { int min = stack . empty () ? x : std :: min ( stack . top (). second , x ); stack . push ({ x , min }); } void pop () { stack . pop (); } int top () { return stack . top (). first ; } int getMin () { return stack . top (). second ; } private : std :: stack < pair < int , int >> stack ; };","title":"155. Min Stack $\\star$"},{"location":"cpp/0101-0200/0151-0160/#156-binary-tree-upside-down-starstar","text":"","title":"156. Binary Tree Upside Down $\\star\\star$"},{"location":"cpp/0101-0200/0151-0160/#157-read-n-characters-given-read4-star","text":"","title":"157. Read N Characters Given Read4 $\\star$"},{"location":"cpp/0101-0200/0151-0160/#158-read-n-characters-given-read4-ii-call-multiple-times-starstarstar","text":"","title":"158. Read N Characters Given Read4 II - Call multiple times $\\star\\star\\star$"},{"location":"cpp/0101-0200/0151-0160/#159-longest-substring-with-at-most-two-distinct-characters-starstar","text":"","title":"159. Longest Substring with At Most Two Distinct Characters $\\star\\star$"},{"location":"cpp/0101-0200/0151-0160/#160-intersection-of-two-linked-lists-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : ListNode * getIntersectionNode ( ListNode * headA , ListNode * headB ) { if ( ! headA || ! headB ) return NULL ; ListNode * a = headA ; ListNode * b = headB ; while ( a != b ) { a = a == NULL ? headB : a -> next ; b = b == NULL ? headA : b -> next ; } return a ; } };","title":"160. Intersection of Two Linked Lists $\\star$"},{"location":"cpp/0101-0200/0161-0170/","text":"161. One Edit Distance $\\star\\star$ 162. Find Peak Element $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int findPeakElement ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] > nums [ m + 1 ]) r = m ; else l = m + 1 ; } return l ; } }; 163. Missing Ranges $\\star\\star$ 164. Maximum Gap $\\star\\star\\star$ 165. Compare Version Numbers $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int compareVersion ( string version1 , string version2 ) { istringstream iss1 ( version1 ); istringstream iss2 ( version2 ); int num1 ; int num2 ; char c ; while ( bool ( iss1 >> num1 ) + bool ( iss2 >> num2 )) { if ( num1 < num2 ) return - 1 ; if ( num1 > num2 ) return 1 ; iss1 >> c ; iss2 >> c ; num1 = 0 ; num2 = 0 ; } if ( num1 == num2 ) return 0 ; return 0 ; }; }; 166. Fraction to Recurring Decimal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : string fractionToDecimal ( int numerator , int denominator ) { if ( numerator == 0 ) return \"0\" ; string ans ; if ( numerator < 0 ^ denominator < 0 ) ans += \"-\" ; long n = abs (( long ) numerator ); long d = abs (( long ) denominator ); ans += to_string ( n / d ); if ( n % d == 0 ) return ans ; ans += '.' ; unordered_map < int , int > map ; for ( long r = n % d ; r ; r %= d ) { if ( map . count ( r ) > 0 ) { ans . insert ( map [ r ], 1 , '(' ); ans += ')' ; break ; } map [ r ] = ans . size (); r *= 10 ; ans += to_string ( r / d ); } return ans ; } }; 167. Two Sum II - Input array is sorted $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > twoSum ( vector < int >& numbers , int target ) { int l = 0 ; int r = numbers . size () - 1 ; while ( l < r ) { int sum = numbers [ l ] + numbers [ r ]; if ( sum == target ) return { l + 1 , r + 1 }; if ( sum < target ) l ++ ; else r -- ; } throw ; } }; 168. Excel Sheet Column Title $\\star$ 1 2 3 4 5 6 7 class Solution { public : string convertToTitle ( int n ) { return n == 0 ? \"\" : convertToTitle (( n - 1 ) / 26 ) + ( char )( 'A' + (( n - 1 ) % 26 )); } }; 169. Majority Element $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int majorityElement ( vector < int >& nums ) { int ans ; int count = 0 ; for ( int num : nums ) { if ( count == 0 ) ans = num ; count += num == ans ? 1 : - 1 ; } return ans ; } }; 170. Two Sum III - Data structure design $\\star$","title":"0161-0170"},{"location":"cpp/0101-0200/0161-0170/#161-one-edit-distance-starstar","text":"","title":"161. One Edit Distance $\\star\\star$"},{"location":"cpp/0101-0200/0161-0170/#162-find-peak-element-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int findPeakElement ( vector < int >& nums ) { int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] > nums [ m + 1 ]) r = m ; else l = m + 1 ; } return l ; } };","title":"162. Find Peak Element $\\star\\star$"},{"location":"cpp/0101-0200/0161-0170/#163-missing-ranges-starstar","text":"","title":"163. Missing Ranges $\\star\\star$"},{"location":"cpp/0101-0200/0161-0170/#164-maximum-gap-starstarstar","text":"","title":"164. Maximum Gap $\\star\\star\\star$"},{"location":"cpp/0101-0200/0161-0170/#165-compare-version-numbers-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int compareVersion ( string version1 , string version2 ) { istringstream iss1 ( version1 ); istringstream iss2 ( version2 ); int num1 ; int num2 ; char c ; while ( bool ( iss1 >> num1 ) + bool ( iss2 >> num2 )) { if ( num1 < num2 ) return - 1 ; if ( num1 > num2 ) return 1 ; iss1 >> c ; iss2 >> c ; num1 = 0 ; num2 = 0 ; } if ( num1 == num2 ) return 0 ; return 0 ; }; };","title":"165. Compare Version Numbers $\\star\\star$"},{"location":"cpp/0101-0200/0161-0170/#166-fraction-to-recurring-decimal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : string fractionToDecimal ( int numerator , int denominator ) { if ( numerator == 0 ) return \"0\" ; string ans ; if ( numerator < 0 ^ denominator < 0 ) ans += \"-\" ; long n = abs (( long ) numerator ); long d = abs (( long ) denominator ); ans += to_string ( n / d ); if ( n % d == 0 ) return ans ; ans += '.' ; unordered_map < int , int > map ; for ( long r = n % d ; r ; r %= d ) { if ( map . count ( r ) > 0 ) { ans . insert ( map [ r ], 1 , '(' ); ans += ')' ; break ; } map [ r ] = ans . size (); r *= 10 ; ans += to_string ( r / d ); } return ans ; } };","title":"166. Fraction to Recurring Decimal $\\star\\star$"},{"location":"cpp/0101-0200/0161-0170/#167-two-sum-ii-input-array-is-sorted-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > twoSum ( vector < int >& numbers , int target ) { int l = 0 ; int r = numbers . size () - 1 ; while ( l < r ) { int sum = numbers [ l ] + numbers [ r ]; if ( sum == target ) return { l + 1 , r + 1 }; if ( sum < target ) l ++ ; else r -- ; } throw ; } };","title":"167. Two Sum II - Input array is sorted $\\star$"},{"location":"cpp/0101-0200/0161-0170/#168-excel-sheet-column-title-star","text":"1 2 3 4 5 6 7 class Solution { public : string convertToTitle ( int n ) { return n == 0 ? \"\" : convertToTitle (( n - 1 ) / 26 ) + ( char )( 'A' + (( n - 1 ) % 26 )); } };","title":"168. Excel Sheet Column Title $\\star$"},{"location":"cpp/0101-0200/0161-0170/#169-majority-element-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int majorityElement ( vector < int >& nums ) { int ans ; int count = 0 ; for ( int num : nums ) { if ( count == 0 ) ans = num ; count += num == ans ? 1 : - 1 ; } return ans ; } };","title":"169. Majority Element $\\star$"},{"location":"cpp/0101-0200/0161-0170/#170-two-sum-iii-data-structure-design-star","text":"","title":"170. Two Sum III - Data structure design $\\star$"},{"location":"cpp/0101-0200/0171-0180/","text":"171. Excel Sheet Column Number $\\star$ 1 2 3 4 5 6 7 class Solution { public : int titleToNumber ( string s ) { return accumulate ( s . begin (), s . end (), 0 , []( int a , int b ) { return a * 26 + ( b - 'A' + 1 ); }); } }; 172. Factorial Trailing Zeroes $\\star$ 1 2 3 4 5 6 class Solution { public : int trailingZeroes ( int n ) { return n == 0 ? 0 : n / 5 + trailingZeroes ( n / 5 ); } }; 173. Binary Search Tree Iterator $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class BSTIterator { public : BSTIterator ( TreeNode * root ) { helper ( root ); } int next () { TreeNode * node = stack . top (); stack . pop (); if ( node -> right ) helper ( node -> right ); return node -> val ; } bool hasNext () { return ! stack . empty (); } private : std :: stack < TreeNode *> stack ; void helper ( TreeNode * root ) { while ( root ) { stack . push ( root ); root = root -> left ; } } }; 174. Dungeon Game $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int calculateMinimumHP ( vector < vector < int >>& dungeon ) { const int m = dungeon . size (); const int n = dungeon [ 0 ]. size (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , INT_MAX )); dp [ m ][ n - 1 ] = 1 ; dp [ m - 1 ][ n ] = 1 ; for ( int i = m - 1 ; i >= 0 ; i -- ) for ( int j = n - 1 ; j >= 0 ; j -- ) dp [ i ][ j ] = max ( 1 , min ( dp [ i + 1 ][ j ], dp [ i ][ j + 1 ]) - dungeon [ i ][ j ]); return dp [ 0 ][ 0 ]; } }; 175. Combine Two Tables $\\star$ 176. Second Highest Salary $\\star$ 177. Nth Highest Salary $\\star\\star$ 178. Rank Scores $\\star\\star$ 179. Largest Number $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : string largestNumber ( vector < int >& nums ) { string ans ; sort ( nums . begin (), nums . end (), []( int a , int b ) { return to_string ( a ) + to_string ( b ) > to_string ( b ) + to_string ( a ); }); for ( int num : nums ) ans += to_string ( num ); return ans [ 0 ] == '0' ? \"0\" : ans ; } }; 180. Consecutive Numbers $\\star\\star$","title":"0171-0180"},{"location":"cpp/0101-0200/0171-0180/#171-excel-sheet-column-number-star","text":"1 2 3 4 5 6 7 class Solution { public : int titleToNumber ( string s ) { return accumulate ( s . begin (), s . end (), 0 , []( int a , int b ) { return a * 26 + ( b - 'A' + 1 ); }); } };","title":"171. Excel Sheet Column Number $\\star$"},{"location":"cpp/0101-0200/0171-0180/#172-factorial-trailing-zeroes-star","text":"1 2 3 4 5 6 class Solution { public : int trailingZeroes ( int n ) { return n == 0 ? 0 : n / 5 + trailingZeroes ( n / 5 ); } };","title":"172. Factorial Trailing Zeroes $\\star$"},{"location":"cpp/0101-0200/0171-0180/#173-binary-search-tree-iterator-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class BSTIterator { public : BSTIterator ( TreeNode * root ) { helper ( root ); } int next () { TreeNode * node = stack . top (); stack . pop (); if ( node -> right ) helper ( node -> right ); return node -> val ; } bool hasNext () { return ! stack . empty (); } private : std :: stack < TreeNode *> stack ; void helper ( TreeNode * root ) { while ( root ) { stack . push ( root ); root = root -> left ; } } };","title":"173. Binary Search Tree Iterator $\\star\\star$"},{"location":"cpp/0101-0200/0171-0180/#174-dungeon-game-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int calculateMinimumHP ( vector < vector < int >>& dungeon ) { const int m = dungeon . size (); const int n = dungeon [ 0 ]. size (); vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , INT_MAX )); dp [ m ][ n - 1 ] = 1 ; dp [ m - 1 ][ n ] = 1 ; for ( int i = m - 1 ; i >= 0 ; i -- ) for ( int j = n - 1 ; j >= 0 ; j -- ) dp [ i ][ j ] = max ( 1 , min ( dp [ i + 1 ][ j ], dp [ i ][ j + 1 ]) - dungeon [ i ][ j ]); return dp [ 0 ][ 0 ]; } };","title":"174. Dungeon Game $\\star\\star\\star$"},{"location":"cpp/0101-0200/0171-0180/#175-combine-two-tables-star","text":"","title":"175. Combine Two Tables $\\star$"},{"location":"cpp/0101-0200/0171-0180/#176-second-highest-salary-star","text":"","title":"176. Second Highest Salary $\\star$"},{"location":"cpp/0101-0200/0171-0180/#177-nth-highest-salary-starstar","text":"","title":"177. Nth Highest Salary $\\star\\star$"},{"location":"cpp/0101-0200/0171-0180/#178-rank-scores-starstar","text":"","title":"178. Rank Scores $\\star\\star$"},{"location":"cpp/0101-0200/0171-0180/#179-largest-number-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : string largestNumber ( vector < int >& nums ) { string ans ; sort ( nums . begin (), nums . end (), []( int a , int b ) { return to_string ( a ) + to_string ( b ) > to_string ( b ) + to_string ( a ); }); for ( int num : nums ) ans += to_string ( num ); return ans [ 0 ] == '0' ? \"0\" : ans ; } };","title":"179. Largest Number $\\star\\star$"},{"location":"cpp/0101-0200/0171-0180/#180-consecutive-numbers-starstar","text":"","title":"180. Consecutive Numbers $\\star\\star$"},{"location":"cpp/0101-0200/0181-0190/","text":"181. Employees Earning More Than Their Managers $\\star$ 182. Duplicate Emails $\\star$ 183. Customers Who Never Order $\\star$ 184. Department Highest Salary $\\star\\star$ 185. Department Top Three Salaries $\\star\\star\\star$ 186. Reverse Words in a String II $\\star\\star$ 187. Repeated DNA Sequences $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < string > findRepeatedDnaSequences ( string s ) { const int n = s . length (); unordered_set < string > ans ; unordered_set < string > set ; for ( int i = 0 ; i <= n - 10 ; i ++ ) { string seq = s . substr ( i , 10 ); if ( set . count ( seq )) ans . insert ( seq ); set . insert ( seq ); } return vector < string > ( ans . begin (), ans . end ()); } }; 188. Best Time to Buy and Sell Stock IV $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int maxProfit ( int k , vector < int >& prices ) { if ( k >= prices . size () / 2 ) { int sell = 0 ; int hold = INT_MIN ; for ( int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price ); } return sell ; } vector < int > sell ( k + 1 ); vector < int > hold ( k + 1 , INT_MIN ); for ( int price : prices ) for ( int i = k ; i > 0 ; i -- ) { sell [ i ] = max ( sell [ i ], hold [ i ] + price ); hold [ i ] = max ( hold [ i ], sell [ i - 1 ] - price ); } return sell [ k ]; } }; 189. Rotate Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : void rotate ( vector < int >& nums , int k ) { k %= nums . size (); reverse ( nums , 0 , nums . size () - 1 ); reverse ( nums , 0 , k - 1 ); reverse ( nums , k , nums . size () - 1 ); } private : void reverse ( vector < int >& nums , int l , int r ) { while ( l < r ) { swap ( nums [ l ], nums [ r ]); l ++ ; r -- ; } } }; 190. Reverse Bits $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : uint32_t reverseBits ( uint32_t num ) { unsigned int NO_OF_BITS = sizeof ( num ) * 8 ; unsigned int reverse_num = 0 , temp ; for ( int i = 0 ; i < NO_OF_BITS ; i ++ ) { temp = ( num & ( 1 << i )); if ( temp ) reverse_num |= ( 1 << (( NO_OF_BITS - 1 ) - i )); } return reverse_num ; } };","title":"0181-0190"},{"location":"cpp/0101-0200/0181-0190/#181-employees-earning-more-than-their-managers-star","text":"","title":"181. Employees Earning More Than Their Managers $\\star$"},{"location":"cpp/0101-0200/0181-0190/#182-duplicate-emails-star","text":"","title":"182. Duplicate Emails $\\star$"},{"location":"cpp/0101-0200/0181-0190/#183-customers-who-never-order-star","text":"","title":"183. Customers Who Never Order $\\star$"},{"location":"cpp/0101-0200/0181-0190/#184-department-highest-salary-starstar","text":"","title":"184. Department Highest Salary $\\star\\star$"},{"location":"cpp/0101-0200/0181-0190/#185-department-top-three-salaries-starstarstar","text":"","title":"185. Department Top Three Salaries $\\star\\star\\star$"},{"location":"cpp/0101-0200/0181-0190/#186-reverse-words-in-a-string-ii-starstar","text":"","title":"186. Reverse Words in a String II $\\star\\star$"},{"location":"cpp/0101-0200/0181-0190/#187-repeated-dna-sequences-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < string > findRepeatedDnaSequences ( string s ) { const int n = s . length (); unordered_set < string > ans ; unordered_set < string > set ; for ( int i = 0 ; i <= n - 10 ; i ++ ) { string seq = s . substr ( i , 10 ); if ( set . count ( seq )) ans . insert ( seq ); set . insert ( seq ); } return vector < string > ( ans . begin (), ans . end ()); } };","title":"187. Repeated DNA Sequences $\\star\\star$"},{"location":"cpp/0101-0200/0181-0190/#188-best-time-to-buy-and-sell-stock-iv-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : int maxProfit ( int k , vector < int >& prices ) { if ( k >= prices . size () / 2 ) { int sell = 0 ; int hold = INT_MIN ; for ( int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price ); } return sell ; } vector < int > sell ( k + 1 ); vector < int > hold ( k + 1 , INT_MIN ); for ( int price : prices ) for ( int i = k ; i > 0 ; i -- ) { sell [ i ] = max ( sell [ i ], hold [ i ] + price ); hold [ i ] = max ( hold [ i ], sell [ i - 1 ] - price ); } return sell [ k ]; } };","title":"188. Best Time to Buy and Sell Stock IV $\\star\\star\\star$"},{"location":"cpp/0101-0200/0181-0190/#189-rotate-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : void rotate ( vector < int >& nums , int k ) { k %= nums . size (); reverse ( nums , 0 , nums . size () - 1 ); reverse ( nums , 0 , k - 1 ); reverse ( nums , k , nums . size () - 1 ); } private : void reverse ( vector < int >& nums , int l , int r ) { while ( l < r ) { swap ( nums [ l ], nums [ r ]); l ++ ; r -- ; } } };","title":"189. Rotate Array $\\star$"},{"location":"cpp/0101-0200/0181-0190/#190-reverse-bits-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : uint32_t reverseBits ( uint32_t num ) { unsigned int NO_OF_BITS = sizeof ( num ) * 8 ; unsigned int reverse_num = 0 , temp ; for ( int i = 0 ; i < NO_OF_BITS ; i ++ ) { temp = ( num & ( 1 << i )); if ( temp ) reverse_num |= ( 1 << (( NO_OF_BITS - 1 ) - i )); } return reverse_num ; } };","title":"190. Reverse Bits $\\star$"},{"location":"cpp/0101-0200/0191-0200/","text":"191. Number of 1 Bits $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int hammingWeight ( uint32_t n ) { int ans ; for ( ans = 0 ; n != 0 ; ans ++ ) n &= n - 1 ; return ans ; } }; 192. Word Frequency $\\star\\star$ 193. Valid Phone Numbers $\\star$ 194. Transpose File $\\star\\star$ 195. Tenth Line $\\star$ 196. Delete Duplicate Emails $\\star$ 197. Rising Temperature $\\star$ 198. House Robber $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int rob ( vector < int >& nums ) { int dp1 = 0 ; int dp2 = 0 ; for ( int num : nums ) { int temp = dp1 ; dp1 = max ( dp1 , dp2 + num ); dp2 = temp ; } return dp1 ; } }; 199. Binary Tree Right Side View $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : vector < int > rightSideView ( TreeNode * root ) { vector < int > ans ; dfs ( root , 1 , ans ); return ans ; } private : void dfs ( TreeNode * root , int level , vector < int >& ans ) { if ( ! root ) return ; if ( level > ans . size ()) ans . push_back ( root -> val ); dfs ( root -> right , level + 1 , ans ); dfs ( root -> left , level + 1 , ans ); } }; 200. Number of Islands $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : int numIslands ( vector < vector < char >>& grid ) { if ( grid . empty ()) return 0 ; const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; vector < vector < bool >> visited ( m , vector < bool > ( n )); for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ! visited [ i ][ j ] && grid [ i ][ j ] == '1' ) { ans ++ ; dfs ( grid , i , j , visited ); } return ans ; } private : void dfs ( vector < vector < char >>& grid , int i , int j , vector < vector < bool >>& visited ) { if ( i < 0 || j < 0 || i >= grid . size () || j >= grid [ 0 ]. size () || visited [ i ][ j ] || grid [ i ][ j ] == '0' ) return ; visited [ i ][ j ] = true ; dfs ( grid , i + 1 , j , visited ); dfs ( grid , i - 1 , j , visited ); dfs ( grid , i , j + 1 , visited ); dfs ( grid , i , j - 1 , visited ); } };","title":"0191-0200"},{"location":"cpp/0101-0200/0191-0200/#191-number-of-1-bits-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int hammingWeight ( uint32_t n ) { int ans ; for ( ans = 0 ; n != 0 ; ans ++ ) n &= n - 1 ; return ans ; } };","title":"191. Number of 1 Bits $\\star$"},{"location":"cpp/0101-0200/0191-0200/#192-word-frequency-starstar","text":"","title":"192. Word Frequency $\\star\\star$"},{"location":"cpp/0101-0200/0191-0200/#193-valid-phone-numbers-star","text":"","title":"193. Valid Phone Numbers $\\star$"},{"location":"cpp/0101-0200/0191-0200/#194-transpose-file-starstar","text":"","title":"194. Transpose File $\\star\\star$"},{"location":"cpp/0101-0200/0191-0200/#195-tenth-line-star","text":"","title":"195. Tenth Line $\\star$"},{"location":"cpp/0101-0200/0191-0200/#196-delete-duplicate-emails-star","text":"","title":"196. Delete Duplicate Emails $\\star$"},{"location":"cpp/0101-0200/0191-0200/#197-rising-temperature-star","text":"","title":"197. Rising Temperature $\\star$"},{"location":"cpp/0101-0200/0191-0200/#198-house-robber-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int rob ( vector < int >& nums ) { int dp1 = 0 ; int dp2 = 0 ; for ( int num : nums ) { int temp = dp1 ; dp1 = max ( dp1 , dp2 + num ); dp2 = temp ; } return dp1 ; } };","title":"198. House Robber $\\star$"},{"location":"cpp/0101-0200/0191-0200/#199-binary-tree-right-side-view-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : vector < int > rightSideView ( TreeNode * root ) { vector < int > ans ; dfs ( root , 1 , ans ); return ans ; } private : void dfs ( TreeNode * root , int level , vector < int >& ans ) { if ( ! root ) return ; if ( level > ans . size ()) ans . push_back ( root -> val ); dfs ( root -> right , level + 1 , ans ); dfs ( root -> left , level + 1 , ans ); } };","title":"199. Binary Tree Right Side View $\\star\\star$"},{"location":"cpp/0101-0200/0191-0200/#200-number-of-islands-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : int numIslands ( vector < vector < char >>& grid ) { if ( grid . empty ()) return 0 ; const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; vector < vector < bool >> visited ( m , vector < bool > ( n )); for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( ! visited [ i ][ j ] && grid [ i ][ j ] == '1' ) { ans ++ ; dfs ( grid , i , j , visited ); } return ans ; } private : void dfs ( vector < vector < char >>& grid , int i , int j , vector < vector < bool >>& visited ) { if ( i < 0 || j < 0 || i >= grid . size () || j >= grid [ 0 ]. size () || visited [ i ][ j ] || grid [ i ][ j ] == '0' ) return ; visited [ i ][ j ] = true ; dfs ( grid , i + 1 , j , visited ); dfs ( grid , i - 1 , j , visited ); dfs ( grid , i , j + 1 , visited ); dfs ( grid , i , j - 1 , visited ); } };","title":"200. Number of Islands $\\star\\star$"},{"location":"cpp/0201-0300/0201-0210/","text":"201. Bitwise AND of Numbers Range $\\star\\star$ 1 2 3 4 5 6 class Solution { public : int rangeBitwiseAnd ( int m , int n ) { return m < n ? rangeBitwiseAnd ( m >> 1 , n >> 1 ) << 1 : m ; } }; 202. Happy Number $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : bool isHappy ( int n ) { int slow = helper ( n ); int fast = helper ( helper ( n )); while ( slow != fast ) { slow = helper ( slow ); fast = helper ( helper ( fast )); } if ( slow == 1 ) return true ; return false ; } private : int helper ( int n ) { int sum = 0 ; while ( n ) { sum += pow ( n % 10 , 2 ); n /= 10 ; } return sum ; } }; 203. Remove Linked List Elements $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : ListNode * removeElements ( ListNode * head , int val ) { ListNode dummy ( 0 ); dummy . next = head ; ListNode * curr = & dummy ; while ( curr ) { ListNode * next = curr -> next ; while ( next && next -> val == val ) next = next -> next ; curr -> next = next ; curr = next ; } return dummy . next ; } }; 204. Count Primes $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int countPrimes ( int n ) { if ( n <= 2 ) return 0 ; vector < bool > prime ( n , true ); prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int i = 0 ; i < sqrt ( n ); i ++ ) if ( prime [ i ]) for ( int j = i * 2 ; j < n ; j += i ) prime [ j ] = false ; return count ( prime . begin (), prime . end (), true ); } }; 205. Isomorphic Strings $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool isIsomorphic ( string s , string t ) { unordered_map < char , int > map_s ; unordered_map < char , int > map_t ; for ( int i = 0 ; i < s . length (); i ++ ) { if ( map_s [ s [ i ]] != map_t [ t [ i ]]) return false ; map_s [ s [ i ]] = i + 1 ; map_t [ t [ i ]] = i + 1 ; } return true ; } }; 206. Reverse Linked List $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * prev = NULL ; ListNode * curr = head ; while ( curr ) { auto next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } }; 207. Course Schedule $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : bool canFinish ( int numCourses , vector < vector < int >>& prerequisites ) { vector < vector < int >> graph ( numCourses ); vector < int > visited ( numCourses , 0 ); for ( vector < int >& prerequisite : prerequisites ) graph [ prerequisite [ 1 ]]. push_back ( prerequisite [ 0 ]); for ( int i = 0 ; i < numCourses ; i ++ ) if ( dfs ( graph , visited , i )) return false ; return true ; } private : bool dfs ( vector < vector < int >>& graph , vector < int >& visited , int curr ) { if ( visited [ curr ] == 1 ) return true ; if ( visited [ curr ] == 2 ) return false ; visited [ curr ] = 1 ; for ( int neighbor : graph [ curr ]) if ( dfs ( graph , visited , neighbor )) return true ; visited [ curr ] = 2 ; return false ; } }; 208. Implement Trie (Prefix Tree) $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Trie { public : void insert ( string word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } node -> isWord = true ; } bool search ( string word ) { TrieNode * node = find ( word ); return node && node -> isWord ; } bool startsWith ( string prefix ) { return find ( prefix ); } private : struct TrieNode { TrieNode () : children ( 26 ), isWord ( false ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; bool isWord ; }; TrieNode root ; TrieNode * find ( string & prefix ) { TrieNode * node = & root ; for ( char c : prefix ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) return nullptr ; node = next ; } return node ; } }; 209. Minimum Size Subarray Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int minSubArrayLen ( int s , vector < int >& nums ) { int ans = INT_MAX ; int sum = 0 ; int j = 0 ; for ( int i = 0 ; i < nums . size (); i ++ ) { sum += nums [ i ]; while ( sum >= s ) { ans = min ( ans , i - j + 1 ); sum -= nums [ j ++ ]; } } return ans != INT_MAX ? ans : 0 ; } }; 210. Course Schedule II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < int > findOrder ( int numCourses , vector < vector < int >>& prerequisites ) { vector < int > ans ; vector < vector < int >> graph ( numCourses ); vector < int > visited ( numCourses , 0 ); for ( vector < int >& prerequisite : prerequisites ) graph [ prerequisite [ 0 ]]. push_back ( prerequisite [ 1 ]); for ( int i = 0 ; i < numCourses ; i ++ ) if ( dfs ( graph , visited , i , ans )) return {}; return ans ; } private : bool dfs ( vector < vector < int >>& graph , vector < int >& visited , int curr , vector < int >& ans ) { if ( visited [ curr ] == 1 ) return true ; if ( visited [ curr ] == 2 ) return false ; visited [ curr ] = 1 ; for ( int neighbor : graph [ curr ]) if ( dfs ( graph , visited , neighbor , ans )) return true ; visited [ curr ] = 2 ; ans . push_back ( curr ); return false ; } };","title":"0201-0210"},{"location":"cpp/0201-0300/0201-0210/#201-bitwise-and-of-numbers-range-starstar","text":"1 2 3 4 5 6 class Solution { public : int rangeBitwiseAnd ( int m , int n ) { return m < n ? rangeBitwiseAnd ( m >> 1 , n >> 1 ) << 1 : m ; } };","title":"201. Bitwise AND of Numbers Range $\\star\\star$"},{"location":"cpp/0201-0300/0201-0210/#202-happy-number-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public : bool isHappy ( int n ) { int slow = helper ( n ); int fast = helper ( helper ( n )); while ( slow != fast ) { slow = helper ( slow ); fast = helper ( helper ( fast )); } if ( slow == 1 ) return true ; return false ; } private : int helper ( int n ) { int sum = 0 ; while ( n ) { sum += pow ( n % 10 , 2 ); n /= 10 ; } return sum ; } };","title":"202. Happy Number $\\star$"},{"location":"cpp/0201-0300/0201-0210/#203-remove-linked-list-elements-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : ListNode * removeElements ( ListNode * head , int val ) { ListNode dummy ( 0 ); dummy . next = head ; ListNode * curr = & dummy ; while ( curr ) { ListNode * next = curr -> next ; while ( next && next -> val == val ) next = next -> next ; curr -> next = next ; curr = next ; } return dummy . next ; } };","title":"203. Remove Linked List Elements $\\star$"},{"location":"cpp/0201-0300/0201-0210/#204-count-primes-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int countPrimes ( int n ) { if ( n <= 2 ) return 0 ; vector < bool > prime ( n , true ); prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int i = 0 ; i < sqrt ( n ); i ++ ) if ( prime [ i ]) for ( int j = i * 2 ; j < n ; j += i ) prime [ j ] = false ; return count ( prime . begin (), prime . end (), true ); } };","title":"204. Count Primes $\\star$"},{"location":"cpp/0201-0300/0201-0210/#205-isomorphic-strings-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool isIsomorphic ( string s , string t ) { unordered_map < char , int > map_s ; unordered_map < char , int > map_t ; for ( int i = 0 ; i < s . length (); i ++ ) { if ( map_s [ s [ i ]] != map_t [ t [ i ]]) return false ; map_s [ s [ i ]] = i + 1 ; map_t [ t [ i ]] = i + 1 ; } return true ; } };","title":"205. Isomorphic Strings $\\star$"},{"location":"cpp/0201-0300/0201-0210/#206-reverse-linked-list-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : ListNode * reverseList ( ListNode * head ) { ListNode * prev = NULL ; ListNode * curr = head ; while ( curr ) { auto next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } };","title":"206. Reverse Linked List $\\star$"},{"location":"cpp/0201-0300/0201-0210/#207-course-schedule-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : bool canFinish ( int numCourses , vector < vector < int >>& prerequisites ) { vector < vector < int >> graph ( numCourses ); vector < int > visited ( numCourses , 0 ); for ( vector < int >& prerequisite : prerequisites ) graph [ prerequisite [ 1 ]]. push_back ( prerequisite [ 0 ]); for ( int i = 0 ; i < numCourses ; i ++ ) if ( dfs ( graph , visited , i )) return false ; return true ; } private : bool dfs ( vector < vector < int >>& graph , vector < int >& visited , int curr ) { if ( visited [ curr ] == 1 ) return true ; if ( visited [ curr ] == 2 ) return false ; visited [ curr ] = 1 ; for ( int neighbor : graph [ curr ]) if ( dfs ( graph , visited , neighbor )) return true ; visited [ curr ] = 2 ; return false ; } };","title":"207. Course Schedule $\\star\\star$"},{"location":"cpp/0201-0300/0201-0210/#208-implement-trie-prefix-tree-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Trie { public : void insert ( string word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } node -> isWord = true ; } bool search ( string word ) { TrieNode * node = find ( word ); return node && node -> isWord ; } bool startsWith ( string prefix ) { return find ( prefix ); } private : struct TrieNode { TrieNode () : children ( 26 ), isWord ( false ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; bool isWord ; }; TrieNode root ; TrieNode * find ( string & prefix ) { TrieNode * node = & root ; for ( char c : prefix ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) return nullptr ; node = next ; } return node ; } };","title":"208. Implement Trie (Prefix Tree) $\\star\\star$"},{"location":"cpp/0201-0300/0201-0210/#209-minimum-size-subarray-sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int minSubArrayLen ( int s , vector < int >& nums ) { int ans = INT_MAX ; int sum = 0 ; int j = 0 ; for ( int i = 0 ; i < nums . size (); i ++ ) { sum += nums [ i ]; while ( sum >= s ) { ans = min ( ans , i - j + 1 ); sum -= nums [ j ++ ]; } } return ans != INT_MAX ? ans : 0 ; } };","title":"209. Minimum Size Subarray Sum $\\star\\star$"},{"location":"cpp/0201-0300/0201-0210/#210-course-schedule-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public : vector < int > findOrder ( int numCourses , vector < vector < int >>& prerequisites ) { vector < int > ans ; vector < vector < int >> graph ( numCourses ); vector < int > visited ( numCourses , 0 ); for ( vector < int >& prerequisite : prerequisites ) graph [ prerequisite [ 0 ]]. push_back ( prerequisite [ 1 ]); for ( int i = 0 ; i < numCourses ; i ++ ) if ( dfs ( graph , visited , i , ans )) return {}; return ans ; } private : bool dfs ( vector < vector < int >>& graph , vector < int >& visited , int curr , vector < int >& ans ) { if ( visited [ curr ] == 1 ) return true ; if ( visited [ curr ] == 2 ) return false ; visited [ curr ] = 1 ; for ( int neighbor : graph [ curr ]) if ( dfs ( graph , visited , neighbor , ans )) return true ; visited [ curr ] = 2 ; ans . push_back ( curr ); return false ; } };","title":"210. Course Schedule II $\\star\\star$"},{"location":"cpp/0201-0300/0211-0220/","text":"211. Add and Search Word - Data structure design $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class WordDictionary { public : void addWord ( string word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } node -> isWord = true ; } bool search ( string word ) { return dfs ( word , 0 , & root ); } private : struct TrieNode { TrieNode () : children ( 26 ), isWord ( false ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; bool isWord ; }; TrieNode root ; bool dfs ( const string & word , int depth , TrieNode * node ) { if ( depth == word . length ()) return node -> isWord ; if ( word [ depth ] != '.' ) { TrieNode * next = node -> children [ word [ depth ] - 'a' ]; return next ? dfs ( word , depth + 1 , next ) : false ; } for ( int i = 0 ; i < 26 ; i ++ ) if ( node -> children [ i ] && dfs ( word , depth + 1 , node -> children [ i ])) return true ; return false ; } }; 212. Word Search II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Solution { public : vector < string > findWords ( vector < vector < char >>& board , vector < string >& words ) { for ( const string & word : words ) insert ( word ); vector < string > ans ; for ( int i = 0 ; i < board . size (); i ++ ) for ( int j = 0 ; j < board [ 0 ]. size (); j ++ ) dfs ( board , i , j , & root , ans ); return ans ; } private : struct TrieNode { TrieNode () : children ( 26 ), word ( nullptr ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete ( child ); } vector < TrieNode *> children ; const string * word ; }; TrieNode root ; void insert ( const string & word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } node -> word = & word ; } void dfs ( vector < vector < char >>& board , int i , int j , TrieNode * node , vector < string >& ans ) { if ( i < 0 || i >= board . size () || j < 0 || j >= board [ 0 ]. size () || board [ i ][ j ] == '*' ) return ; char c = board [ i ][ j ]; TrieNode * next = node -> children [ c - 'a' ]; if ( ! next ) return ; if ( next -> word ) { ans . push_back ( * next -> word ); next -> word = nullptr ; } board [ i ][ j ] = '*' ; dfs ( board , i + 1 , j , next , ans ); dfs ( board , i - 1 , j , next , ans ); dfs ( board , i , j + 1 , next , ans ); dfs ( board , i , j - 1 , next , ans ); board [ i ][ j ] = c ; } }; 213. House Robber II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int rob ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; if ( nums . size () < 2 ) return nums [ 0 ]; const int n = nums . size (); return max ( rob ( nums , 0 , n - 2 ), rob ( nums , 1 , n - 1 )); } private : int rob ( vector < int >& nums , int l , int r ) { int dp1 = 0 ; int dp2 = 0 ; for ( int i = l ; i <= r ; i ++ ) { int temp = dp1 ; dp1 = max ( dp1 , dp2 + nums [ i ]); dp2 = temp ; } return dp1 ; } }; 214. Shortest Palindrome $\\star\\star\\star$ 215. Kth Largest Element in an Array $\\star\\star$ 1 2 3 4 5 6 7 8 class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { nth_element ( nums . begin (), nums . begin () + k - 1 , nums . end (), greater < int > ()); return nums [ k - 1 ]; } }; 216. Combination Sum III $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < vector < int >> combinationSum3 ( int k , int n ) { vector < vector < int >> ans ; vector < int > path ; dfs ( k , n , 1 , path , ans ); return ans ; } private : void dfs ( int k , int n , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( k == 0 && n == 0 ) { ans . push_back ( path ); return ; } if ( k == 0 || n < 0 ) return ; for ( int i = s ; i <= 9 ; i ++ ) { path . push_back ( i ); dfs ( k - 1 , n - i , i + 1 , path , ans ); path . pop_back (); } } }; 217. Contains Duplicate $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool containsDuplicate ( vector < int >& nums ) { unordered_set < int > set ; for ( int num : nums ) { if ( set . count ( num )) return true ; set . insert ( num ); } return false ; } }; 218. The Skyline Problem $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : vector < vector < int >> getSkyline ( vector < vector < int >>& buildings ) { vector < vector < int >> ans ; vector < vector < int >> events ; for ( vector < int >& building : buildings ) { events . push_back ({ building [ 0 ], building [ 2 ]}); events . push_back ({ building [ 1 ], - building [ 2 ]}); } sort ( events . begin (), events . end (), []( const vector < int >& e1 , const vector < int >& e2 ) { return e1 [ 0 ] == e2 [ 0 ] ? e1 [ 1 ] > e2 [ 1 ] : e1 [ 0 ] < e2 [ 0 ]; }); for ( vector < int >& event : events ) { int x = event [ 0 ]; int h = abs ( event [ 1 ]); if ( event [ 1 ] > 0 ) { if ( h > maxHeight ()) ans . push_back ({ x , h }); set . insert ( h ); } else { set . erase ( set . equal_range ( h ). first ); if ( h > maxHeight ()) ans . push_back ({ x , maxHeight ()}); } } return ans ; } private : multiset < int > set ; int maxHeight () const { return set . empty () ? 0 : * set . rbegin (); } }; 219. Contains Duplicate II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool containsNearbyDuplicate ( vector < int >& nums , int k ) { unordered_set < int > set ; for ( int i = 0 ; i < nums . size (); i ++ ) { if ( i > k ) set . erase ( nums [ i - k - 1 ]); if ( set . count ( nums [ i ])) return true ; set . insert ( nums [ i ]); } return false ; } }; 220. Contains Duplicate III $\\star\\star$","title":"0211-0220"},{"location":"cpp/0201-0300/0211-0220/#211-add-and-search-word-data-structure-design-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 class WordDictionary { public : void addWord ( string word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } node -> isWord = true ; } bool search ( string word ) { return dfs ( word , 0 , & root ); } private : struct TrieNode { TrieNode () : children ( 26 ), isWord ( false ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; bool isWord ; }; TrieNode root ; bool dfs ( const string & word , int depth , TrieNode * node ) { if ( depth == word . length ()) return node -> isWord ; if ( word [ depth ] != '.' ) { TrieNode * next = node -> children [ word [ depth ] - 'a' ]; return next ? dfs ( word , depth + 1 , next ) : false ; } for ( int i = 0 ; i < 26 ; i ++ ) if ( node -> children [ i ] && dfs ( word , depth + 1 , node -> children [ i ])) return true ; return false ; } };","title":"211. Add and Search Word - Data structure design $\\star\\star$"},{"location":"cpp/0201-0300/0211-0220/#212-word-search-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Solution { public : vector < string > findWords ( vector < vector < char >>& board , vector < string >& words ) { for ( const string & word : words ) insert ( word ); vector < string > ans ; for ( int i = 0 ; i < board . size (); i ++ ) for ( int j = 0 ; j < board [ 0 ]. size (); j ++ ) dfs ( board , i , j , & root , ans ); return ans ; } private : struct TrieNode { TrieNode () : children ( 26 ), word ( nullptr ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete ( child ); } vector < TrieNode *> children ; const string * word ; }; TrieNode root ; void insert ( const string & word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } node -> word = & word ; } void dfs ( vector < vector < char >>& board , int i , int j , TrieNode * node , vector < string >& ans ) { if ( i < 0 || i >= board . size () || j < 0 || j >= board [ 0 ]. size () || board [ i ][ j ] == '*' ) return ; char c = board [ i ][ j ]; TrieNode * next = node -> children [ c - 'a' ]; if ( ! next ) return ; if ( next -> word ) { ans . push_back ( * next -> word ); next -> word = nullptr ; } board [ i ][ j ] = '*' ; dfs ( board , i + 1 , j , next , ans ); dfs ( board , i - 1 , j , next , ans ); dfs ( board , i , j + 1 , next , ans ); dfs ( board , i , j - 1 , next , ans ); board [ i ][ j ] = c ; } };","title":"212. Word Search II $\\star\\star\\star$"},{"location":"cpp/0201-0300/0211-0220/#213-house-robber-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int rob ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; if ( nums . size () < 2 ) return nums [ 0 ]; const int n = nums . size (); return max ( rob ( nums , 0 , n - 2 ), rob ( nums , 1 , n - 1 )); } private : int rob ( vector < int >& nums , int l , int r ) { int dp1 = 0 ; int dp2 = 0 ; for ( int i = l ; i <= r ; i ++ ) { int temp = dp1 ; dp1 = max ( dp1 , dp2 + nums [ i ]); dp2 = temp ; } return dp1 ; } };","title":"213. House Robber II $\\star\\star$"},{"location":"cpp/0201-0300/0211-0220/#214-shortest-palindrome-starstarstar","text":"","title":"214. Shortest Palindrome $\\star\\star\\star$"},{"location":"cpp/0201-0300/0211-0220/#215-kth-largest-element-in-an-array-starstar","text":"1 2 3 4 5 6 7 8 class Solution { public : int findKthLargest ( vector < int >& nums , int k ) { nth_element ( nums . begin (), nums . begin () + k - 1 , nums . end (), greater < int > ()); return nums [ k - 1 ]; } };","title":"215. Kth Largest Element in an Array $\\star\\star$"},{"location":"cpp/0201-0300/0211-0220/#216-combination-sum-iii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : vector < vector < int >> combinationSum3 ( int k , int n ) { vector < vector < int >> ans ; vector < int > path ; dfs ( k , n , 1 , path , ans ); return ans ; } private : void dfs ( int k , int n , int s , vector < int >& path , vector < vector < int >>& ans ) { if ( k == 0 && n == 0 ) { ans . push_back ( path ); return ; } if ( k == 0 || n < 0 ) return ; for ( int i = s ; i <= 9 ; i ++ ) { path . push_back ( i ); dfs ( k - 1 , n - i , i + 1 , path , ans ); path . pop_back (); } } };","title":"216. Combination Sum III $\\star\\star$"},{"location":"cpp/0201-0300/0211-0220/#217-contains-duplicate-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool containsDuplicate ( vector < int >& nums ) { unordered_set < int > set ; for ( int num : nums ) { if ( set . count ( num )) return true ; set . insert ( num ); } return false ; } };","title":"217. Contains Duplicate $\\star$"},{"location":"cpp/0201-0300/0211-0220/#218-the-skyline-problem-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution { public : vector < vector < int >> getSkyline ( vector < vector < int >>& buildings ) { vector < vector < int >> ans ; vector < vector < int >> events ; for ( vector < int >& building : buildings ) { events . push_back ({ building [ 0 ], building [ 2 ]}); events . push_back ({ building [ 1 ], - building [ 2 ]}); } sort ( events . begin (), events . end (), []( const vector < int >& e1 , const vector < int >& e2 ) { return e1 [ 0 ] == e2 [ 0 ] ? e1 [ 1 ] > e2 [ 1 ] : e1 [ 0 ] < e2 [ 0 ]; }); for ( vector < int >& event : events ) { int x = event [ 0 ]; int h = abs ( event [ 1 ]); if ( event [ 1 ] > 0 ) { if ( h > maxHeight ()) ans . push_back ({ x , h }); set . insert ( h ); } else { set . erase ( set . equal_range ( h ). first ); if ( h > maxHeight ()) ans . push_back ({ x , maxHeight ()}); } } return ans ; } private : multiset < int > set ; int maxHeight () const { return set . empty () ? 0 : * set . rbegin (); } };","title":"218. The Skyline Problem $\\star\\star\\star$"},{"location":"cpp/0201-0300/0211-0220/#219-contains-duplicate-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool containsNearbyDuplicate ( vector < int >& nums , int k ) { unordered_set < int > set ; for ( int i = 0 ; i < nums . size (); i ++ ) { if ( i > k ) set . erase ( nums [ i - k - 1 ]); if ( set . count ( nums [ i ])) return true ; set . insert ( nums [ i ]); } return false ; } };","title":"219. Contains Duplicate II $\\star$"},{"location":"cpp/0201-0300/0211-0220/#220-contains-duplicate-iii-starstar","text":"","title":"220. Contains Duplicate III $\\star\\star$"},{"location":"cpp/0201-0300/0221-0230/","text":"221. Maximal Square $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int maximalSquare ( vector < vector < char >>& matrix ) { if ( matrix . empty ()) return 0 ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); vector < int > dp ( n ); int max = 0 ; int prev = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int temp = dp [ j ]; dp [ j ] = ( i == 0 || j == 0 || matrix [ i ][ j ] == '0' ) ? matrix [ i ][ j ] - '0' : min ( dp [ j ], min ( dp [ j - 1 ], prev )) + 1 ; max = std :: max ( max , dp [ j ]); prev = temp ; } return max * max ; } }; 222. Count Complete Tree Nodes $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int countNodes ( TreeNode * root ) { if ( ! root ) return 0 ; int ans = 0 ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { ans ++ ; TreeNode * node = queue . front (); queue . pop (); if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } return ans ; } }; 223. Rectangle Area $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int computeArea ( int A , int B , int C , int D , int E , int F , int G , int H ) { long x = max ( A , E ) < min ( C , G ) ? ( min ( C , G ) - max ( A , E )) : 0 ; long y = max ( B , F ) < min ( D , H ) ? ( min ( D , H ) - max ( B , F )) : 0 ; return ( long )( C - A ) * ( long )( D - B ) + ( long )( G - E ) * ( long )( H - F ) - x * y ; } }; 224. Basic Calculator $\\star\\star\\star$ 225. Implement Stack using Queues $\\star$ 226. Invert Binary Tree $\\star$ 227. Basic Calculator II $\\star\\star$ 228. Summary Ranges $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < string > summaryRanges ( vector < int >& nums ) { vector < string > ans ; for ( int i = 0 ; i < nums . size (); i ++ ) { int begin = nums [ i ]; while ( i < nums . size () - 1 && nums [ i ] == nums [ i + 1 ] - 1 ) i ++ ; int end = nums [ i ]; if ( begin == end ) ans . push_back ( to_string ( begin )); else ans . push_back ( to_string ( begin ) + \"->\" + to_string ( end )); } return ans ; } }; 229. Majority Element II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public : vector < int > majorityElement ( vector < int >& nums ) { vector < int > ans ; int ans1 = 0 ; int ans2 = 1 ; int count1 = 0 ; int count2 = 0 ; for ( int num : nums ) { if ( num == ans1 ) count1 ++ ; else if ( num == ans2 ) count2 ++ ; else if ( count1 == 0 ) { ans1 = num ; count1 ++ ; } else if ( count2 == 0 ) { ans2 = num ; count2 ++ ; } else { count1 -- ; count2 -- ; } } count1 = 0 ; count2 = 0 ; for ( int num : nums ) { if ( num == ans1 ) count1 ++ ; else if ( num == ans2 ) count2 ++ ; } if ( count1 > nums . size () / 3 ) ans . push_back ( ans1 ); if ( count2 > nums . size () / 3 ) ans . push_back ( ans2 ); return ans ; } }; 230. Kth Smallest Element in a BST $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int kthSmallest ( TreeNode * root , int k ) { vector < int > nums ; inorder ( root , nums ); return nums [ k - 1 ]; } private : void inorder ( TreeNode * root , vector < int >& nums ) { if ( ! root ) return ; inorder ( root -> left , nums ); nums . push_back ( root -> val ); inorder ( root -> right , nums ); } };","title":"0221-0230"},{"location":"cpp/0201-0300/0221-0230/#221-maximal-square-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public : int maximalSquare ( vector < vector < char >>& matrix ) { if ( matrix . empty ()) return 0 ; const int m = matrix . size (); const int n = matrix [ 0 ]. size (); vector < int > dp ( n ); int max = 0 ; int prev = 0 ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int temp = dp [ j ]; dp [ j ] = ( i == 0 || j == 0 || matrix [ i ][ j ] == '0' ) ? matrix [ i ][ j ] - '0' : min ( dp [ j ], min ( dp [ j - 1 ], prev )) + 1 ; max = std :: max ( max , dp [ j ]); prev = temp ; } return max * max ; } };","title":"221. Maximal Square $\\star\\star$"},{"location":"cpp/0201-0300/0221-0230/#222-count-complete-tree-nodes-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int countNodes ( TreeNode * root ) { if ( ! root ) return 0 ; int ans = 0 ; queue < TreeNode *> queue ; queue . push ( root ); while ( ! queue . empty ()) { ans ++ ; TreeNode * node = queue . front (); queue . pop (); if ( node -> left ) queue . push ( node -> left ); if ( node -> right ) queue . push ( node -> right ); } return ans ; } };","title":"222. Count Complete Tree Nodes $\\star\\star$"},{"location":"cpp/0201-0300/0221-0230/#223-rectangle-area-starstar","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int computeArea ( int A , int B , int C , int D , int E , int F , int G , int H ) { long x = max ( A , E ) < min ( C , G ) ? ( min ( C , G ) - max ( A , E )) : 0 ; long y = max ( B , F ) < min ( D , H ) ? ( min ( D , H ) - max ( B , F )) : 0 ; return ( long )( C - A ) * ( long )( D - B ) + ( long )( G - E ) * ( long )( H - F ) - x * y ; } };","title":"223. Rectangle Area $\\star\\star$"},{"location":"cpp/0201-0300/0221-0230/#224-basic-calculator-starstarstar","text":"","title":"224. Basic Calculator $\\star\\star\\star$"},{"location":"cpp/0201-0300/0221-0230/#225-implement-stack-using-queues-star","text":"","title":"225. Implement Stack using Queues $\\star$"},{"location":"cpp/0201-0300/0221-0230/#226-invert-binary-tree-star","text":"","title":"226. Invert Binary Tree $\\star$"},{"location":"cpp/0201-0300/0221-0230/#227-basic-calculator-ii-starstar","text":"","title":"227. Basic Calculator II $\\star\\star$"},{"location":"cpp/0201-0300/0221-0230/#228-summary-ranges-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < string > summaryRanges ( vector < int >& nums ) { vector < string > ans ; for ( int i = 0 ; i < nums . size (); i ++ ) { int begin = nums [ i ]; while ( i < nums . size () - 1 && nums [ i ] == nums [ i + 1 ] - 1 ) i ++ ; int end = nums [ i ]; if ( begin == end ) ans . push_back ( to_string ( begin )); else ans . push_back ( to_string ( begin ) + \"->\" + to_string ( end )); } return ans ; } };","title":"228. Summary Ranges $\\star\\star$"},{"location":"cpp/0201-0300/0221-0230/#229-majority-element-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public : vector < int > majorityElement ( vector < int >& nums ) { vector < int > ans ; int ans1 = 0 ; int ans2 = 1 ; int count1 = 0 ; int count2 = 0 ; for ( int num : nums ) { if ( num == ans1 ) count1 ++ ; else if ( num == ans2 ) count2 ++ ; else if ( count1 == 0 ) { ans1 = num ; count1 ++ ; } else if ( count2 == 0 ) { ans2 = num ; count2 ++ ; } else { count1 -- ; count2 -- ; } } count1 = 0 ; count2 = 0 ; for ( int num : nums ) { if ( num == ans1 ) count1 ++ ; else if ( num == ans2 ) count2 ++ ; } if ( count1 > nums . size () / 3 ) ans . push_back ( ans1 ); if ( count2 > nums . size () / 3 ) ans . push_back ( ans2 ); return ans ; } };","title":"229. Majority Element II $\\star\\star$"},{"location":"cpp/0201-0300/0221-0230/#230-kth-smallest-element-in-a-bst-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int kthSmallest ( TreeNode * root , int k ) { vector < int > nums ; inorder ( root , nums ); return nums [ k - 1 ]; } private : void inorder ( TreeNode * root , vector < int >& nums ) { if ( ! root ) return ; inorder ( root -> left , nums ); nums . push_back ( root -> val ); inorder ( root -> right , nums ); } };","title":"230. Kth Smallest Element in a BST $\\star\\star$"},{"location":"cpp/0201-0300/0231-0240/","text":"231. Power of Two $\\star$ 232. Implement Queue using Stacks $\\star$ 233. Number of Digit One $\\star\\star\\star$ 234. Palindrome Linked List $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : bool isPalindrome ( ListNode * head ) { if ( ! head || ! head -> next ) return true ; auto slow = head ; auto fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } if ( fast ) slow = slow -> next ; slow = reverseList ( slow ); while ( slow ) { if ( slow -> val != head -> val ) return false ; slow = slow -> next ; head = head -> next ; } return true ; } private : ListNode * reverseList ( ListNode * head ) { ListNode * prev = NULL ; ListNode * curr = head ; while ( curr ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } }; 235. Lowest Common Ancestor of a Binary Search Tree $\\star$ 236. Lowest Common Ancestor of a Binary Tree $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { if ( ! root || root == p || root == q ) return root ; TreeNode * left = lowestCommonAncestor ( root -> left , p , q ); TreeNode * right = lowestCommonAncestor ( root -> right , p , q ); if ( ! left ) return right ; if ( ! right ) return left ; return root ; } }; 237. Delete Node in a Linked List $\\star$ 1 2 3 4 5 6 7 class Solution { public : void deleteNode ( ListNode * node ) { node -> val = node -> next -> val ; node -> next = node -> next -> next ; } }; 238. Product of Array Except Self $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > productExceptSelf ( vector < int >& nums ) { vector < int > ans ( nums . size (), 0 ); ans [ 0 ] = 1 ; int r = 1 ; for ( int i = 1 ; i < nums . size (); i ++ ) ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ]; for ( int i = nums . size () - 1 ; i >= 0 ; i -- ) { ans [ i ] *= r ; r *= nums [ i ]; } return ans ; } }; 239. Sliding Window Maximum $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { vector < int > ans ; deque < int > deque ; for ( int i = 0 ; i < nums . size (); i ++ ) { while ( ! deque . empty () && nums [ i ] > deque . back ()) deque . pop_back (); deque . push_back ( nums [ i ]); if ( i - k + 1 >= 0 ) { ans . push_back ( deque . front ()); if ( nums [ i - k + 1 ] == deque . front ()) deque . pop_front (); } } return ans ; } }; 240. Search a 2D Matrix II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { if ( matrix . empty ()) return false ; int r = 0 ; int c = matrix [ 0 ]. size () - 1 ; while ( r < matrix . size () && c >= 0 ) { if ( matrix [ r ][ c ] == target ) return true ; target < matrix [ r ][ c ] ? c -- : r ++ ; } return false ; } };","title":"0231-0240"},{"location":"cpp/0201-0300/0231-0240/#231-power-of-two-star","text":"","title":"231. Power of Two $\\star$"},{"location":"cpp/0201-0300/0231-0240/#232-implement-queue-using-stacks-star","text":"","title":"232. Implement Queue using Stacks $\\star$"},{"location":"cpp/0201-0300/0231-0240/#233-number-of-digit-one-starstarstar","text":"","title":"233. Number of Digit One $\\star\\star\\star$"},{"location":"cpp/0201-0300/0231-0240/#234-palindrome-linked-list-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 class Solution { public : bool isPalindrome ( ListNode * head ) { if ( ! head || ! head -> next ) return true ; auto slow = head ; auto fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } if ( fast ) slow = slow -> next ; slow = reverseList ( slow ); while ( slow ) { if ( slow -> val != head -> val ) return false ; slow = slow -> next ; head = head -> next ; } return true ; } private : ListNode * reverseList ( ListNode * head ) { ListNode * prev = NULL ; ListNode * curr = head ; while ( curr ) { ListNode * next = curr -> next ; curr -> next = prev ; prev = curr ; curr = next ; } return prev ; } };","title":"234. Palindrome Linked List $\\star$"},{"location":"cpp/0201-0300/0231-0240/#235-lowest-common-ancestor-of-a-binary-search-tree-star","text":"","title":"235. Lowest Common Ancestor of a Binary Search Tree $\\star$"},{"location":"cpp/0201-0300/0231-0240/#236-lowest-common-ancestor-of-a-binary-tree-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : TreeNode * lowestCommonAncestor ( TreeNode * root , TreeNode * p , TreeNode * q ) { if ( ! root || root == p || root == q ) return root ; TreeNode * left = lowestCommonAncestor ( root -> left , p , q ); TreeNode * right = lowestCommonAncestor ( root -> right , p , q ); if ( ! left ) return right ; if ( ! right ) return left ; return root ; } };","title":"236. Lowest Common Ancestor of a Binary Tree $\\star\\star$"},{"location":"cpp/0201-0300/0231-0240/#237-delete-node-in-a-linked-list-star","text":"1 2 3 4 5 6 7 class Solution { public : void deleteNode ( ListNode * node ) { node -> val = node -> next -> val ; node -> next = node -> next -> next ; } };","title":"237. Delete Node in a Linked List $\\star$"},{"location":"cpp/0201-0300/0231-0240/#238-product-of-array-except-self-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > productExceptSelf ( vector < int >& nums ) { vector < int > ans ( nums . size (), 0 ); ans [ 0 ] = 1 ; int r = 1 ; for ( int i = 1 ; i < nums . size (); i ++ ) ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ]; for ( int i = nums . size () - 1 ; i >= 0 ; i -- ) { ans [ i ] *= r ; r *= nums [ i ]; } return ans ; } };","title":"238. Product of Array Except Self $\\star\\star$"},{"location":"cpp/0201-0300/0231-0240/#239-sliding-window-maximum-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > maxSlidingWindow ( vector < int >& nums , int k ) { vector < int > ans ; deque < int > deque ; for ( int i = 0 ; i < nums . size (); i ++ ) { while ( ! deque . empty () && nums [ i ] > deque . back ()) deque . pop_back (); deque . push_back ( nums [ i ]); if ( i - k + 1 >= 0 ) { ans . push_back ( deque . front ()); if ( nums [ i - k + 1 ] == deque . front ()) deque . pop_front (); } } return ans ; } };","title":"239. Sliding Window Maximum $\\star\\star\\star$"},{"location":"cpp/0201-0300/0231-0240/#240-search-a-2d-matrix-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : bool searchMatrix ( vector < vector < int >>& matrix , int target ) { if ( matrix . empty ()) return false ; int r = 0 ; int c = matrix [ 0 ]. size () - 1 ; while ( r < matrix . size () && c >= 0 ) { if ( matrix [ r ][ c ] == target ) return true ; target < matrix [ r ][ c ] ? c -- : r ++ ; } return false ; } };","title":"240. Search a 2D Matrix II $\\star\\star$"},{"location":"cpp/0201-0300/0241-0250/","text":"241. Different Ways to Add Parentheses $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > diffWaysToCompute ( string input ) { vector < int > ans ; for ( int i = 0 ; i < input . size (); i ++ ) if ( ispunct ( input [ i ])) { vector < int > left = diffWaysToCompute ( input . substr ( 0 , i )); vector < int > right = diffWaysToCompute ( input . substr ( i + 1 )); for ( int a : left ) for ( int b : right ) ans . push_back ( input [ i ] == '+' ? a + b : input [ i ] == '-' ? a - b : a * b ); } return ans . empty () ? vector < int > { stoi ( input )} : ans ; } }; 242. Valid Anagram $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool isAnagram ( string s , string t ) { if ( s . length () != t . length ()) return false ; unordered_map < char , int > map ; for ( char c : s ) map [ c ] ++ ; for ( char c : t ) if ( -- map [ c ] < 0 ) return false ; return true ; } }; 243. Shortest Word Distance $\\star$ 244. Shortest Word Distance II $\\star\\star$ 245. Shortest Word Distance III $\\star\\star$ 246. Strobogrammatic Number $\\star$ 247. Strobogrammatic Number II $\\star\\star$ 248. Strobogrammatic Number III $\\star\\star\\star$ 249. Group Shifted Strings $\\star\\star$ 250. Count Univalue Subtrees $\\star\\star$","title":"0241-0250"},{"location":"cpp/0201-0300/0241-0250/#241-different-ways-to-add-parentheses-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > diffWaysToCompute ( string input ) { vector < int > ans ; for ( int i = 0 ; i < input . size (); i ++ ) if ( ispunct ( input [ i ])) { vector < int > left = diffWaysToCompute ( input . substr ( 0 , i )); vector < int > right = diffWaysToCompute ( input . substr ( i + 1 )); for ( int a : left ) for ( int b : right ) ans . push_back ( input [ i ] == '+' ? a + b : input [ i ] == '-' ? a - b : a * b ); } return ans . empty () ? vector < int > { stoi ( input )} : ans ; } };","title":"241. Different Ways to Add Parentheses $\\star\\star$"},{"location":"cpp/0201-0300/0241-0250/#242-valid-anagram-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool isAnagram ( string s , string t ) { if ( s . length () != t . length ()) return false ; unordered_map < char , int > map ; for ( char c : s ) map [ c ] ++ ; for ( char c : t ) if ( -- map [ c ] < 0 ) return false ; return true ; } };","title":"242. Valid Anagram $\\star$"},{"location":"cpp/0201-0300/0241-0250/#243-shortest-word-distance-star","text":"","title":"243. Shortest Word Distance $\\star$"},{"location":"cpp/0201-0300/0241-0250/#244-shortest-word-distance-ii-starstar","text":"","title":"244. Shortest Word Distance II $\\star\\star$"},{"location":"cpp/0201-0300/0241-0250/#245-shortest-word-distance-iii-starstar","text":"","title":"245. Shortest Word Distance III $\\star\\star$"},{"location":"cpp/0201-0300/0241-0250/#246-strobogrammatic-number-star","text":"","title":"246. Strobogrammatic Number $\\star$"},{"location":"cpp/0201-0300/0241-0250/#247-strobogrammatic-number-ii-starstar","text":"","title":"247. Strobogrammatic Number II $\\star\\star$"},{"location":"cpp/0201-0300/0241-0250/#248-strobogrammatic-number-iii-starstarstar","text":"","title":"248. Strobogrammatic Number III $\\star\\star\\star$"},{"location":"cpp/0201-0300/0241-0250/#249-group-shifted-strings-starstar","text":"","title":"249. Group Shifted Strings $\\star\\star$"},{"location":"cpp/0201-0300/0241-0250/#250-count-univalue-subtrees-starstar","text":"","title":"250. Count Univalue Subtrees $\\star\\star$"},{"location":"cpp/0201-0300/0251-0260/","text":"251. Flatten 2D Vector $\\star\\star$ 252. Meeting Rooms $\\star$ 253. Meeting Rooms II $\\star\\star$ 254. Factor Combinations $\\star\\star$ 255. Verify Preorder Sequence in Binary Search Tree $\\star\\star$ 256. Paint House $\\star$ 257. Binary Tree Paths $\\star$ 258. Add Digits $\\star$ 259. 3Sum Smaller $\\star\\star$ 260. Single Number III $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > singleNumber ( vector < int >& nums ) { vector < int > ans ( 2 ); int xor_ = accumulate ( nums . begin (), nums . end (), 0 , bit_xor < int > ()); xor_ &= - xor_ ; for ( int num : nums ) { if ( num & xor_ ) ans [ 0 ] ^= num ; else ans [ 1 ] ^= num ; } return ans ; } };","title":"0251-0260"},{"location":"cpp/0201-0300/0251-0260/#251-flatten-2d-vector-starstar","text":"","title":"251. Flatten 2D Vector $\\star\\star$"},{"location":"cpp/0201-0300/0251-0260/#252-meeting-rooms-star","text":"","title":"252. Meeting Rooms $\\star$"},{"location":"cpp/0201-0300/0251-0260/#253-meeting-rooms-ii-starstar","text":"","title":"253. Meeting Rooms II $\\star\\star$"},{"location":"cpp/0201-0300/0251-0260/#254-factor-combinations-starstar","text":"","title":"254. Factor Combinations $\\star\\star$"},{"location":"cpp/0201-0300/0251-0260/#255-verify-preorder-sequence-in-binary-search-tree-starstar","text":"","title":"255. Verify Preorder Sequence in Binary Search Tree $\\star\\star$"},{"location":"cpp/0201-0300/0251-0260/#256-paint-house-star","text":"","title":"256. Paint House $\\star$"},{"location":"cpp/0201-0300/0251-0260/#257-binary-tree-paths-star","text":"","title":"257. Binary Tree Paths $\\star$"},{"location":"cpp/0201-0300/0251-0260/#258-add-digits-star","text":"","title":"258. Add Digits $\\star$"},{"location":"cpp/0201-0300/0251-0260/#259-3sum-smaller-starstar","text":"","title":"259. 3Sum Smaller $\\star\\star$"},{"location":"cpp/0201-0300/0251-0260/#260-single-number-iii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > singleNumber ( vector < int >& nums ) { vector < int > ans ( 2 ); int xor_ = accumulate ( nums . begin (), nums . end (), 0 , bit_xor < int > ()); xor_ &= - xor_ ; for ( int num : nums ) { if ( num & xor_ ) ans [ 0 ] ^= num ; else ans [ 1 ] ^= num ; } return ans ; } };","title":"260. Single Number III $\\star\\star$"},{"location":"cpp/0201-0300/0261-0270/","text":"261. Graph Valid Tree $\\star\\star$ 262. Trips and Users $\\star\\star\\star$ 263. Ugly Number $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool isUgly ( int num ) { if ( num == 0 ) return false ; vector < int > factors { 2 , 3 , 5 }; for ( int factor : factors ) while ( num % factor == 0 ) num /= factor ; return num == 1 ; } }; 264. Ugly Number II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int nthUglyNumber ( int n ) { vector < int > nums { 1 }; int i2 = 0 ; int i3 = 0 ; int i5 = 0 ; while ( nums . size () < n ) { int next2 = nums [ i2 ] * 2 ; int next3 = nums [ i3 ] * 3 ; int next5 = nums [ i5 ] * 5 ; int next = min ( next2 , min ( next3 , next5 )); if ( next == next2 ) i2 ++ ; if ( next == next3 ) i3 ++ ; if ( next == next5 ) i5 ++ ; nums . push_back ( next ); } return nums . back (); } }; 265. Paint House II $\\star\\star\\star$ 266. Palindrome Permutation $\\star$ 267. Palindrome Permutation II $\\star\\star$ 268. Missing Number $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int missingNumber ( vector < int >& nums ) { int ans = nums . size (); for ( int i = 0 ; i < nums . size (); i ++ ) ans ^= i ^ nums [ i ]; return ans ; } }; 269. Alien Dictionary $\\star\\star\\star$ 270. Closest Binary Search Tree Value $\\star$","title":"0261-0270"},{"location":"cpp/0201-0300/0261-0270/#261-graph-valid-tree-starstar","text":"","title":"261. Graph Valid Tree $\\star\\star$"},{"location":"cpp/0201-0300/0261-0270/#262-trips-and-users-starstarstar","text":"","title":"262. Trips and Users $\\star\\star\\star$"},{"location":"cpp/0201-0300/0261-0270/#263-ugly-number-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : bool isUgly ( int num ) { if ( num == 0 ) return false ; vector < int > factors { 2 , 3 , 5 }; for ( int factor : factors ) while ( num % factor == 0 ) num /= factor ; return num == 1 ; } };","title":"263. Ugly Number $\\star$"},{"location":"cpp/0201-0300/0261-0270/#264-ugly-number-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int nthUglyNumber ( int n ) { vector < int > nums { 1 }; int i2 = 0 ; int i3 = 0 ; int i5 = 0 ; while ( nums . size () < n ) { int next2 = nums [ i2 ] * 2 ; int next3 = nums [ i3 ] * 3 ; int next5 = nums [ i5 ] * 5 ; int next = min ( next2 , min ( next3 , next5 )); if ( next == next2 ) i2 ++ ; if ( next == next3 ) i3 ++ ; if ( next == next5 ) i5 ++ ; nums . push_back ( next ); } return nums . back (); } };","title":"264. Ugly Number II $\\star\\star$"},{"location":"cpp/0201-0300/0261-0270/#265-paint-house-ii-starstarstar","text":"","title":"265. Paint House II $\\star\\star\\star$"},{"location":"cpp/0201-0300/0261-0270/#266-palindrome-permutation-star","text":"","title":"266. Palindrome Permutation $\\star$"},{"location":"cpp/0201-0300/0261-0270/#267-palindrome-permutation-ii-starstar","text":"","title":"267. Palindrome Permutation II $\\star\\star$"},{"location":"cpp/0201-0300/0261-0270/#268-missing-number-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int missingNumber ( vector < int >& nums ) { int ans = nums . size (); for ( int i = 0 ; i < nums . size (); i ++ ) ans ^= i ^ nums [ i ]; return ans ; } };","title":"268. Missing Number $\\star$"},{"location":"cpp/0201-0300/0261-0270/#269-alien-dictionary-starstarstar","text":"","title":"269. Alien Dictionary $\\star\\star\\star$"},{"location":"cpp/0201-0300/0261-0270/#270-closest-binary-search-tree-value-star","text":"","title":"270. Closest Binary Search Tree Value $\\star$"},{"location":"cpp/0201-0300/0271-0280/","text":"271. Encode and Decode Strings $\\star\\star$ 272. Closest Binary Search Tree Value II $\\star\\star\\star$ 273. Integer to English Words $\\star\\star\\star$ 274. H-Index $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int hIndex ( vector < int >& citations ) { sort ( citations . begin (), citations . end ()); for ( int i = 0 ; i < citations . size (); i ++ ) if ( citations [ i ] >= citations . size () - i ) return citations . size () - i ; return 0 ; } }; 275. H-Index II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int hIndex ( vector < int >& citations ) { int l = 0 ; int r = citations . size () - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( citations [ m ] == citations . size () - m ) return citations [ m ]; else if ( citations [ m ] > citations . size () - m ) r = m - 1 ; else l = m + 1 ; } return citations . size () - ( r + 1 ); } }; 276. Paint Fence $\\star$ 277. Find the Celebrity $\\star\\star$ 278. First Bad Version $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bool isBadVersion ( int version ); class Solution { public : int firstBadVersion ( int n ) { int l = 1 ; int r = n ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( isBadVersion ( m )) r = m ; else l = m + 1 ; } return l ; } }; 279. Perfect Squares $\\star\\star$ 280. Wiggle Sort $\\star\\star$","title":"0271-0280"},{"location":"cpp/0201-0300/0271-0280/#271-encode-and-decode-strings-starstar","text":"","title":"271. Encode and Decode Strings $\\star\\star$"},{"location":"cpp/0201-0300/0271-0280/#272-closest-binary-search-tree-value-ii-starstarstar","text":"","title":"272. Closest Binary Search Tree Value II $\\star\\star\\star$"},{"location":"cpp/0201-0300/0271-0280/#273-integer-to-english-words-starstarstar","text":"","title":"273. Integer to English Words $\\star\\star\\star$"},{"location":"cpp/0201-0300/0271-0280/#274-h-index-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int hIndex ( vector < int >& citations ) { sort ( citations . begin (), citations . end ()); for ( int i = 0 ; i < citations . size (); i ++ ) if ( citations [ i ] >= citations . size () - i ) return citations . size () - i ; return 0 ; } };","title":"274. H-Index $\\star\\star$"},{"location":"cpp/0201-0300/0271-0280/#275-h-index-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int hIndex ( vector < int >& citations ) { int l = 0 ; int r = citations . size () - 1 ; while ( l <= r ) { int m = ( l + r ) >> 1 ; if ( citations [ m ] == citations . size () - m ) return citations [ m ]; else if ( citations [ m ] > citations . size () - m ) r = m - 1 ; else l = m + 1 ; } return citations . size () - ( r + 1 ); } };","title":"275. H-Index II $\\star\\star$"},{"location":"cpp/0201-0300/0271-0280/#276-paint-fence-star","text":"","title":"276. Paint Fence $\\star$"},{"location":"cpp/0201-0300/0271-0280/#277-find-the-celebrity-starstar","text":"","title":"277. Find the Celebrity $\\star\\star$"},{"location":"cpp/0201-0300/0271-0280/#278-first-bad-version-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 bool isBadVersion ( int version ); class Solution { public : int firstBadVersion ( int n ) { int l = 1 ; int r = n ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( isBadVersion ( m )) r = m ; else l = m + 1 ; } return l ; } };","title":"278. First Bad Version $\\star$"},{"location":"cpp/0201-0300/0271-0280/#279-perfect-squares-starstar","text":"","title":"279. Perfect Squares $\\star\\star$"},{"location":"cpp/0201-0300/0271-0280/#280-wiggle-sort-starstar","text":"","title":"280. Wiggle Sort $\\star\\star$"},{"location":"cpp/0201-0300/0281-0290/","text":"281. Zigzag Iterator $\\star\\star$ 282. Expression Add Operators $\\star\\star\\star$ 283. Move Zeroes $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : void moveZeroes ( vector < int >& nums ) { int j = 0 ; for ( int num : nums ) if ( num != 0 ) nums [ j ++ ] = num ; for ( int i = j ; i < nums . size (); i ++ ) nums [ i ] = 0 ; } }; 284. Peeking Iterator $\\star\\star$ 285. Inorder Successor in BST $\\star\\star$ 286. Walls and Gates $\\star\\star$ 287. Find the Duplicate Number $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int findDuplicate ( vector < int >& nums ) { int slow = nums [ nums [ 0 ]]; int fast = nums [ nums [ nums [ 0 ]]]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ nums [ fast ]]; } slow = nums [ 0 ]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ fast ]; } return slow ; } }; 288. Unique Word Abbreviation $\\star\\star$ 289. Game of Life $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : void gameOfLife ( vector < vector < int >>& board ) { const int m = board . size (); const int n = board [ 0 ]. size (); for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int ones = 0 ; for ( int y = max ( 0 , i - 1 ); y < min ( m , i + 2 ); y ++ ) for ( int x = max ( 0 , j - 1 ); x < min ( n , j + 2 ); x ++ ) ones += board [ y ][ x ] & 1 ; if (( board [ i ][ j ] == 1 && ( ones == 3 || ones == 4 )) || ( board [ i ][ j ] == 0 && ones == 3 )) board [ i ][ j ] |= 0 b10 ; } for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) board [ i ][ j ] >>= 1 ; } }; 290. Word Pattern $\\star$","title":"0281-0290"},{"location":"cpp/0201-0300/0281-0290/#281-zigzag-iterator-starstar","text":"","title":"281. Zigzag Iterator $\\star\\star$"},{"location":"cpp/0201-0300/0281-0290/#282-expression-add-operators-starstarstar","text":"","title":"282. Expression Add Operators $\\star\\star\\star$"},{"location":"cpp/0201-0300/0281-0290/#283-move-zeroes-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : void moveZeroes ( vector < int >& nums ) { int j = 0 ; for ( int num : nums ) if ( num != 0 ) nums [ j ++ ] = num ; for ( int i = j ; i < nums . size (); i ++ ) nums [ i ] = 0 ; } };","title":"283. Move Zeroes $\\star$"},{"location":"cpp/0201-0300/0281-0290/#284-peeking-iterator-starstar","text":"","title":"284. Peeking Iterator $\\star\\star$"},{"location":"cpp/0201-0300/0281-0290/#285-inorder-successor-in-bst-starstar","text":"","title":"285. Inorder Successor in BST $\\star\\star$"},{"location":"cpp/0201-0300/0281-0290/#286-walls-and-gates-starstar","text":"","title":"286. Walls and Gates $\\star\\star$"},{"location":"cpp/0201-0300/0281-0290/#287-find-the-duplicate-number-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int findDuplicate ( vector < int >& nums ) { int slow = nums [ nums [ 0 ]]; int fast = nums [ nums [ nums [ 0 ]]]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ nums [ fast ]]; } slow = nums [ 0 ]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ fast ]; } return slow ; } };","title":"287. Find the Duplicate Number $\\star\\star$"},{"location":"cpp/0201-0300/0281-0290/#288-unique-word-abbreviation-starstar","text":"","title":"288. Unique Word Abbreviation $\\star\\star$"},{"location":"cpp/0201-0300/0281-0290/#289-game-of-life-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : void gameOfLife ( vector < vector < int >>& board ) { const int m = board . size (); const int n = board [ 0 ]. size (); for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int ones = 0 ; for ( int y = max ( 0 , i - 1 ); y < min ( m , i + 2 ); y ++ ) for ( int x = max ( 0 , j - 1 ); x < min ( n , j + 2 ); x ++ ) ones += board [ y ][ x ] & 1 ; if (( board [ i ][ j ] == 1 && ( ones == 3 || ones == 4 )) || ( board [ i ][ j ] == 0 && ones == 3 )) board [ i ][ j ] |= 0 b10 ; } for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) board [ i ][ j ] >>= 1 ; } };","title":"289. Game of Life $\\star\\star$"},{"location":"cpp/0201-0300/0281-0290/#290-word-pattern-star","text":"","title":"290. Word Pattern $\\star$"},{"location":"cpp/0201-0300/0291-0300/","text":"291. Word Pattern II $\\star\\star\\star$ 292. Nim Game $\\star$ 293. Flip Game $\\star$ 294. Flip Game II $\\star\\star$ 295. Find Median from Data Stream $\\star\\star\\star$ 296. Best Meeting Point $\\star\\star\\star$ 297. Serialize and Deserialize Binary Tree $\\star\\star\\star$ 298. Binary Tree Longest Consecutive Sequence $\\star\\star$ 299. Bulls and Cows $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : string getHint ( string secans , string guess ) { int A = 0 ; int B = 0 ; map < char , int > map1 ; map < char , int > map2 ; for ( int i = 0 ; i < secans . length (); i ++ ) { if ( secans [ i ] == guess [ i ]) A ++ ; else { map1 [ secans [ i ]] ++ ; map2 [ guess [ i ]] ++ ; } } for ( int i = 0 ; i <= 9 ; i ++ ) B += min ( map1 [ '0' + i ], map2 [ '0' + i ]); return to_string ( A ) + \"A\" + to_string ( B ) + \"B\" ; } }; 300. Longest Increasing Subsequence $\\star\\star$","title":"0291-0300"},{"location":"cpp/0201-0300/0291-0300/#291-word-pattern-ii-starstarstar","text":"","title":"291. Word Pattern II $\\star\\star\\star$"},{"location":"cpp/0201-0300/0291-0300/#292-nim-game-star","text":"","title":"292. Nim Game $\\star$"},{"location":"cpp/0201-0300/0291-0300/#293-flip-game-star","text":"","title":"293. Flip Game $\\star$"},{"location":"cpp/0201-0300/0291-0300/#294-flip-game-ii-starstar","text":"","title":"294. Flip Game II $\\star\\star$"},{"location":"cpp/0201-0300/0291-0300/#295-find-median-from-data-stream-starstarstar","text":"","title":"295. Find Median from Data Stream $\\star\\star\\star$"},{"location":"cpp/0201-0300/0291-0300/#296-best-meeting-point-starstarstar","text":"","title":"296. Best Meeting Point $\\star\\star\\star$"},{"location":"cpp/0201-0300/0291-0300/#297-serialize-and-deserialize-binary-tree-starstarstar","text":"","title":"297. Serialize and Deserialize Binary Tree $\\star\\star\\star$"},{"location":"cpp/0201-0300/0291-0300/#298-binary-tree-longest-consecutive-sequence-starstar","text":"","title":"298. Binary Tree Longest Consecutive Sequence $\\star\\star$"},{"location":"cpp/0201-0300/0291-0300/#299-bulls-and-cows-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : string getHint ( string secans , string guess ) { int A = 0 ; int B = 0 ; map < char , int > map1 ; map < char , int > map2 ; for ( int i = 0 ; i < secans . length (); i ++ ) { if ( secans [ i ] == guess [ i ]) A ++ ; else { map1 [ secans [ i ]] ++ ; map2 [ guess [ i ]] ++ ; } } for ( int i = 0 ; i <= 9 ; i ++ ) B += min ( map1 [ '0' + i ], map2 [ '0' + i ]); return to_string ( A ) + \"A\" + to_string ( B ) + \"B\" ; } };","title":"299. Bulls and Cows $\\star$"},{"location":"cpp/0201-0300/0291-0300/#300-longest-increasing-subsequence-starstar","text":"","title":"300. Longest Increasing Subsequence $\\star\\star$"},{"location":"cpp/0301-0400/0301-0310/","text":"301. Remove Invalid Parentheses $\\star\\star\\star$ 302. Smallest Rectangle Enclosing Black Pixels $\\star\\star\\star$ 303. Range Sum Query - Immutable $\\star$ 304. Range Sum Query 2D - Immutable $\\star\\star$ 305. Number of Islands II $\\star\\star\\star$ 306. Additive Number $\\star\\star$ 307. Range Sum Query - Mutable $\\star\\star$ 308. Range Sum Query 2D - Mutable $\\star\\star\\star$ 309. Best Time to Buy and Sell Stock with Cooldown $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxProfit ( vector < int >& prices ) { int sell = 0 ; int hold = INT_MIN ; int prev = 0 ; for ( int price : prices ) { int cache = sell ; sell = max ( sell , hold + price ); hold = max ( hold , prev - price ); prev = cache ; } return sell ; } }; 310. Minimum Height Trees $\\star\\star$","title":"0301-0310"},{"location":"cpp/0301-0400/0301-0310/#301-remove-invalid-parentheses-starstarstar","text":"","title":"301. Remove Invalid Parentheses $\\star\\star\\star$"},{"location":"cpp/0301-0400/0301-0310/#302-smallest-rectangle-enclosing-black-pixels-starstarstar","text":"","title":"302. Smallest Rectangle Enclosing Black Pixels $\\star\\star\\star$"},{"location":"cpp/0301-0400/0301-0310/#303-range-sum-query-immutable-star","text":"","title":"303. Range Sum Query - Immutable $\\star$"},{"location":"cpp/0301-0400/0301-0310/#304-range-sum-query-2d-immutable-starstar","text":"","title":"304. Range Sum Query 2D - Immutable $\\star\\star$"},{"location":"cpp/0301-0400/0301-0310/#305-number-of-islands-ii-starstarstar","text":"","title":"305. Number of Islands II $\\star\\star\\star$"},{"location":"cpp/0301-0400/0301-0310/#306-additive-number-starstar","text":"","title":"306. Additive Number $\\star\\star$"},{"location":"cpp/0301-0400/0301-0310/#307-range-sum-query-mutable-starstar","text":"","title":"307. Range Sum Query - Mutable $\\star\\star$"},{"location":"cpp/0301-0400/0301-0310/#308-range-sum-query-2d-mutable-starstarstar","text":"","title":"308. Range Sum Query 2D - Mutable $\\star\\star\\star$"},{"location":"cpp/0301-0400/0301-0310/#309-best-time-to-buy-and-sell-stock-with-cooldown-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxProfit ( vector < int >& prices ) { int sell = 0 ; int hold = INT_MIN ; int prev = 0 ; for ( int price : prices ) { int cache = sell ; sell = max ( sell , hold + price ); hold = max ( hold , prev - price ); prev = cache ; } return sell ; } };","title":"309. Best Time to Buy and Sell Stock with Cooldown $\\star\\star$"},{"location":"cpp/0301-0400/0301-0310/#310-minimum-height-trees-starstar","text":"","title":"310. Minimum Height Trees $\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/","text":"311. Sparse Matrix Multiplication $\\star\\star$ 312. Burst Balloons $\\star\\star\\star$ 313. Super Ugly Number $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int nthSuperUglyNumber ( int n , vector < int >& primes ) { const int k = primes . size (); vector < int > nums { 1 }; vector < int > indices ( k ); while ( nums . size () < n ) { vector < int > nexts ( k ); for ( int i = 0 ; i < k ; i ++ ) nexts [ i ] = nums [ indices [ i ]] * primes [ i ]; int next = accumulate ( nexts . begin (), nexts . end (), INT_MAX , []( int a , int b ) { return min ( a , b ); }); for ( int i = 0 ; i < k ; i ++ ) if ( next == nexts [ i ]) indices [ i ] ++ ; nums . push_back ( next ); } return nums . back (); } }; 314. Binary Tree Vertical Order Traversal $\\star\\star$ 315. Count of Smaller Numbers After Self $\\star\\star\\star$ 316. Remove Duplicate Letters $\\star\\star\\star$ 317. Shortest Distance from All Buildings $\\star\\star\\star$ 318. Maximum Product of Word Lengths $\\star\\star$ 319. Bulb Switcher $\\star\\star$ 1 2 3 4 class Solution { public : int bulbSwitch ( int n ) { return sqrt ( n ); } }; 320. Generalized Abbreviation $\\star\\star$","title":"0311-0320"},{"location":"cpp/0301-0400/0311-0320/#311-sparse-matrix-multiplication-starstar","text":"","title":"311. Sparse Matrix Multiplication $\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/#312-burst-balloons-starstarstar","text":"","title":"312. Burst Balloons $\\star\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/#313-super-ugly-number-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int nthSuperUglyNumber ( int n , vector < int >& primes ) { const int k = primes . size (); vector < int > nums { 1 }; vector < int > indices ( k ); while ( nums . size () < n ) { vector < int > nexts ( k ); for ( int i = 0 ; i < k ; i ++ ) nexts [ i ] = nums [ indices [ i ]] * primes [ i ]; int next = accumulate ( nexts . begin (), nexts . end (), INT_MAX , []( int a , int b ) { return min ( a , b ); }); for ( int i = 0 ; i < k ; i ++ ) if ( next == nexts [ i ]) indices [ i ] ++ ; nums . push_back ( next ); } return nums . back (); } };","title":"313. Super Ugly Number $\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/#314-binary-tree-vertical-order-traversal-starstar","text":"","title":"314. Binary Tree Vertical Order Traversal $\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/#315-count-of-smaller-numbers-after-self-starstarstar","text":"","title":"315. Count of Smaller Numbers After Self $\\star\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/#316-remove-duplicate-letters-starstarstar","text":"","title":"316. Remove Duplicate Letters $\\star\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/#317-shortest-distance-from-all-buildings-starstarstar","text":"","title":"317. Shortest Distance from All Buildings $\\star\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/#318-maximum-product-of-word-lengths-starstar","text":"","title":"318. Maximum Product of Word Lengths $\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/#319-bulb-switcher-starstar","text":"1 2 3 4 class Solution { public : int bulbSwitch ( int n ) { return sqrt ( n ); } };","title":"319. Bulb Switcher $\\star\\star$"},{"location":"cpp/0301-0400/0311-0320/#320-generalized-abbreviation-starstar","text":"","title":"320. Generalized Abbreviation $\\star\\star$"},{"location":"cpp/0301-0400/0321-0330/","text":"321. Create Maximum Number $\\star\\star\\star$ 322. Coin Change $\\star\\star$ 323. Number of Connected Components in an Undirected Graph $\\star\\star$ 324. Wiggle Sort II $\\star\\star$ 325. Maximum Size Subarray Sum Equals k $\\star\\star$ 326. Power of Three $\\star$ 327. Count of Range Sum $\\star\\star\\star$ 328. Odd Even Linked List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : ListNode * oddEvenList ( ListNode * head ) { if ( ! head ) return NULL ; ListNode dummyOdd ( 0 ); ListNode dummyEven ( 0 ); ListNode * prevOdd = & dummyOdd ; ListNode * prevEven = & dummyEven ; int index = 0 ; while ( head ) { auto next = head -> next ; head -> next = NULL ; if ( index ++ & 1 ) { prevEven -> next = head ; prevEven = head ; } else { prevOdd -> next = head ; prevOdd = head ; } head = next ; } prevOdd -> next = dummyEven . next ; return dummyOdd . next ; } }; 329. Longest Increasing Path in a Matrix $\\star\\star\\star$ 330. Patching Array $\\star\\star\\star$","title":"0321-0330"},{"location":"cpp/0301-0400/0321-0330/#321-create-maximum-number-starstarstar","text":"","title":"321. Create Maximum Number $\\star\\star\\star$"},{"location":"cpp/0301-0400/0321-0330/#322-coin-change-starstar","text":"","title":"322. Coin Change $\\star\\star$"},{"location":"cpp/0301-0400/0321-0330/#323-number-of-connected-components-in-an-undirected-graph-starstar","text":"","title":"323. Number of Connected Components in an Undirected Graph $\\star\\star$"},{"location":"cpp/0301-0400/0321-0330/#324-wiggle-sort-ii-starstar","text":"","title":"324. Wiggle Sort II $\\star\\star$"},{"location":"cpp/0301-0400/0321-0330/#325-maximum-size-subarray-sum-equals-k-starstar","text":"","title":"325. Maximum Size Subarray Sum Equals k $\\star\\star$"},{"location":"cpp/0301-0400/0321-0330/#326-power-of-three-star","text":"","title":"326. Power of Three $\\star$"},{"location":"cpp/0301-0400/0321-0330/#327-count-of-range-sum-starstarstar","text":"","title":"327. Count of Range Sum $\\star\\star\\star$"},{"location":"cpp/0301-0400/0321-0330/#328-odd-even-linked-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : ListNode * oddEvenList ( ListNode * head ) { if ( ! head ) return NULL ; ListNode dummyOdd ( 0 ); ListNode dummyEven ( 0 ); ListNode * prevOdd = & dummyOdd ; ListNode * prevEven = & dummyEven ; int index = 0 ; while ( head ) { auto next = head -> next ; head -> next = NULL ; if ( index ++ & 1 ) { prevEven -> next = head ; prevEven = head ; } else { prevOdd -> next = head ; prevOdd = head ; } head = next ; } prevOdd -> next = dummyEven . next ; return dummyOdd . next ; } };","title":"328. Odd Even Linked List $\\star\\star$"},{"location":"cpp/0301-0400/0321-0330/#329-longest-increasing-path-in-a-matrix-starstarstar","text":"","title":"329. Longest Increasing Path in a Matrix $\\star\\star\\star$"},{"location":"cpp/0301-0400/0321-0330/#330-patching-array-starstarstar","text":"","title":"330. Patching Array $\\star\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/","text":"331. Verify Preorder Serialization of a Binary Tree $\\star\\star$ 332. Reconstruct Itinerary $\\star\\star$ 333. Largest BST Subtree $\\star\\star$ 334. Increasing Triplet Subsequence $\\star\\star$ 335. Self Crossing $\\star\\star\\star$ 336. Palindrome Pairs $\\star\\star\\star$ 337. House Robber III $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int rob ( TreeNode * root ) { vector < int > ans = helper ( root ); return max ( ans [ 0 ], ans [ 1 ]); } vector < int > helper ( TreeNode * root ) { if ( ! root ) return { 0 , 0 }; vector < int > left = helper ( root -> left ); vector < int > right = helper ( root -> right ); return { max ( left [ 0 ], left [ 1 ]) + max ( right [ 0 ], right [ 1 ]), root -> val + left [ 0 ] + right [ 0 ]}; } }; 338. Counting Bits $\\star\\star$ 339. Nested List Weight Sum $\\star$ 340. Longest Substring with At Most K Distinct Characters $\\star\\star\\star$","title":"0331-0340"},{"location":"cpp/0301-0400/0331-0340/#331-verify-preorder-serialization-of-a-binary-tree-starstar","text":"","title":"331. Verify Preorder Serialization of a Binary Tree $\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/#332-reconstruct-itinerary-starstar","text":"","title":"332. Reconstruct Itinerary $\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/#333-largest-bst-subtree-starstar","text":"","title":"333. Largest BST Subtree $\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/#334-increasing-triplet-subsequence-starstar","text":"","title":"334. Increasing Triplet Subsequence $\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/#335-self-crossing-starstarstar","text":"","title":"335. Self Crossing $\\star\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/#336-palindrome-pairs-starstarstar","text":"","title":"336. Palindrome Pairs $\\star\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/#337-house-robber-iii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int rob ( TreeNode * root ) { vector < int > ans = helper ( root ); return max ( ans [ 0 ], ans [ 1 ]); } vector < int > helper ( TreeNode * root ) { if ( ! root ) return { 0 , 0 }; vector < int > left = helper ( root -> left ); vector < int > right = helper ( root -> right ); return { max ( left [ 0 ], left [ 1 ]) + max ( right [ 0 ], right [ 1 ]), root -> val + left [ 0 ] + right [ 0 ]}; } };","title":"337. House Robber III $\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/#338-counting-bits-starstar","text":"","title":"338. Counting Bits $\\star\\star$"},{"location":"cpp/0301-0400/0331-0340/#339-nested-list-weight-sum-star","text":"","title":"339. Nested List Weight Sum $\\star$"},{"location":"cpp/0301-0400/0331-0340/#340-longest-substring-with-at-most-k-distinct-characters-starstarstar","text":"","title":"340. Longest Substring with At Most K Distinct Characters $\\star\\star\\star$"},{"location":"cpp/0301-0400/0341-0350/","text":"341. Flatten Nested List Iterator $\\star\\star$ 342. Power of Four $\\star$ 343. Integer Break $\\star\\star$ 344. Reverse String $\\star$ 345. Reverse Vowels of a String $\\star$ 346. Moving Average from Data Stream $\\star$ 347. Top K Frequent Elements $\\star\\star$ 348. Design Tic-Tac-Toe $\\star\\star$ 349. Intersection of Two Arrays $\\star$ 350. Intersection of Two Arrays II $\\star$","title":"0341-0350"},{"location":"cpp/0301-0400/0341-0350/#341-flatten-nested-list-iterator-starstar","text":"","title":"341. Flatten Nested List Iterator $\\star\\star$"},{"location":"cpp/0301-0400/0341-0350/#342-power-of-four-star","text":"","title":"342. Power of Four $\\star$"},{"location":"cpp/0301-0400/0341-0350/#343-integer-break-starstar","text":"","title":"343. Integer Break $\\star\\star$"},{"location":"cpp/0301-0400/0341-0350/#344-reverse-string-star","text":"","title":"344. Reverse String $\\star$"},{"location":"cpp/0301-0400/0341-0350/#345-reverse-vowels-of-a-string-star","text":"","title":"345. Reverse Vowels of a String $\\star$"},{"location":"cpp/0301-0400/0341-0350/#346-moving-average-from-data-stream-star","text":"","title":"346. Moving Average from Data Stream $\\star$"},{"location":"cpp/0301-0400/0341-0350/#347-top-k-frequent-elements-starstar","text":"","title":"347. Top K Frequent Elements $\\star\\star$"},{"location":"cpp/0301-0400/0341-0350/#348-design-tic-tac-toe-starstar","text":"","title":"348. Design Tic-Tac-Toe $\\star\\star$"},{"location":"cpp/0301-0400/0341-0350/#349-intersection-of-two-arrays-star","text":"","title":"349. Intersection of Two Arrays $\\star$"},{"location":"cpp/0301-0400/0341-0350/#350-intersection-of-two-arrays-ii-star","text":"","title":"350. Intersection of Two Arrays II $\\star$"},{"location":"cpp/0301-0400/0351-0360/","text":"351. Android Unlock Patterns $\\star\\star$ 352. Data Stream as Disjoint Intervals $\\star\\star\\star$ 353. Design Snake Game $\\star\\star$ 354. Russian Doll Envelopes $\\star\\star\\star$ 355. Design Twitter $\\star\\star$ 356. Line Reflection $\\star\\star$ 357. Count Numbers with Unique Digits $\\star\\star$ 358. Rearrange String k Distance Apart $\\star\\star\\star$ 359. Logger Rate Limiter $\\star$ 360. Sort Transformed Array $\\star\\star$","title":"0351-0360"},{"location":"cpp/0301-0400/0351-0360/#351-android-unlock-patterns-starstar","text":"","title":"351. Android Unlock Patterns $\\star\\star$"},{"location":"cpp/0301-0400/0351-0360/#352-data-stream-as-disjoint-intervals-starstarstar","text":"","title":"352. Data Stream as Disjoint Intervals $\\star\\star\\star$"},{"location":"cpp/0301-0400/0351-0360/#353-design-snake-game-starstar","text":"","title":"353. Design Snake Game $\\star\\star$"},{"location":"cpp/0301-0400/0351-0360/#354-russian-doll-envelopes-starstarstar","text":"","title":"354. Russian Doll Envelopes $\\star\\star\\star$"},{"location":"cpp/0301-0400/0351-0360/#355-design-twitter-starstar","text":"","title":"355. Design Twitter $\\star\\star$"},{"location":"cpp/0301-0400/0351-0360/#356-line-reflection-starstar","text":"","title":"356. Line Reflection $\\star\\star$"},{"location":"cpp/0301-0400/0351-0360/#357-count-numbers-with-unique-digits-starstar","text":"","title":"357. Count Numbers with Unique Digits $\\star\\star$"},{"location":"cpp/0301-0400/0351-0360/#358-rearrange-string-k-distance-apart-starstarstar","text":"","title":"358. Rearrange String k Distance Apart $\\star\\star\\star$"},{"location":"cpp/0301-0400/0351-0360/#359-logger-rate-limiter-star","text":"","title":"359. Logger Rate Limiter $\\star$"},{"location":"cpp/0301-0400/0351-0360/#360-sort-transformed-array-starstar","text":"","title":"360. Sort Transformed Array $\\star\\star$"},{"location":"cpp/0301-0400/0361-0370/","text":"361. Bomb Enemy $\\star\\star$ 362. Design Hit Counter $\\star\\star$ 363. Max Sum of Rectangle No Larger Than K $\\star\\star\\star$ 364. Nested List Weight Sum II $\\star\\star$ 365. Water and Jug Problem $\\star\\star$ 366. Find Leaves of Binary Tree $\\star\\star$ 367. Valid Perfect Square $\\star$ 368. Largest Divisible Subset $\\star\\star$ 369. Plus One Linked List $\\star\\star$ 370. Range Addition $\\star\\star$","title":"0361-0370"},{"location":"cpp/0301-0400/0361-0370/#361-bomb-enemy-starstar","text":"","title":"361. Bomb Enemy $\\star\\star$"},{"location":"cpp/0301-0400/0361-0370/#362-design-hit-counter-starstar","text":"","title":"362. Design Hit Counter $\\star\\star$"},{"location":"cpp/0301-0400/0361-0370/#363-max-sum-of-rectangle-no-larger-than-k-starstarstar","text":"","title":"363. Max Sum of Rectangle No Larger Than K $\\star\\star\\star$"},{"location":"cpp/0301-0400/0361-0370/#364-nested-list-weight-sum-ii-starstar","text":"","title":"364. Nested List Weight Sum II $\\star\\star$"},{"location":"cpp/0301-0400/0361-0370/#365-water-and-jug-problem-starstar","text":"","title":"365. Water and Jug Problem $\\star\\star$"},{"location":"cpp/0301-0400/0361-0370/#366-find-leaves-of-binary-tree-starstar","text":"","title":"366. Find Leaves of Binary Tree $\\star\\star$"},{"location":"cpp/0301-0400/0361-0370/#367-valid-perfect-square-star","text":"","title":"367. Valid Perfect Square $\\star$"},{"location":"cpp/0301-0400/0361-0370/#368-largest-divisible-subset-starstar","text":"","title":"368. Largest Divisible Subset $\\star\\star$"},{"location":"cpp/0301-0400/0361-0370/#369-plus-one-linked-list-starstar","text":"","title":"369. Plus One Linked List $\\star\\star$"},{"location":"cpp/0301-0400/0361-0370/#370-range-addition-starstar","text":"","title":"370. Range Addition $\\star\\star$"},{"location":"cpp/0301-0400/0371-0380/","text":"371. Sum of Two Integers $\\star$ 372. Super Pow $\\star\\star$ 373. Find K Pairs with Smallest Sums $\\star\\star$ 374. Guess Number Higher or Lower $\\star$ 375. Guess Number Higher or Lower II $\\star\\star$ 376. Wiggle Subsequence $\\star\\star$ 377. Combination Sum IV $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int combinationSum4 ( vector < int >& nums , int target ) { vector < int > m ( target + 1 , - 1 ); m [ 0 ] = 1 ; return dp ( nums , target , m ); } private : int dp ( vector < int >& nums , int target , vector < int >& m ) { if ( target < 0 ) return 0 ; if ( m [ target ] != - 1 ) return m [ target ]; int ans = 0 ; for ( int num : nums ) ans += dp ( nums , target - num , m ); return m [ target ] = ans ; } }; 378. Kth Smallest Element in a Sorted Matrix $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int kthSmallest ( vector < vector < int >>& matrix , int k ) { int l = matrix [ 0 ][ 0 ]; int r = matrix . back (). back (); while ( l < r ) { int m = ( l + r ) >> 1 ; int count = 0 ; for ( auto & row : matrix ) count += upper_bound ( row . begin (), row . end (), m ) - row . begin (); if ( count >= k ) r = m ; else l = m + 1 ; } return l ; } }; 379. Design Phone Directory $\\star\\star$ 380. Insert Delete GetRandom O(1) $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class RandomizedSet { public : bool insert ( int val ) { if ( map . count ( val )) return false ; map [ val ] = vals . size (); vals . push_back ( val ); return true ; } bool remove ( int val ) { if ( ! map . count ( val )) return false ; int index = map [ val ]; map [ vals . back ()] = index ; map . erase ( val ); swap ( vals [ index ], vals . back ()); vals . pop_back (); return true ; } int getRandom () { int index = rand () % vals . size (); return vals [ index ]; } private : vector < int > vals ; unordered_map < int , int > map ; };","title":"0371-0380"},{"location":"cpp/0301-0400/0371-0380/#371-sum-of-two-integers-star","text":"","title":"371. Sum of Two Integers $\\star$"},{"location":"cpp/0301-0400/0371-0380/#372-super-pow-starstar","text":"","title":"372. Super Pow $\\star\\star$"},{"location":"cpp/0301-0400/0371-0380/#373-find-k-pairs-with-smallest-sums-starstar","text":"","title":"373. Find K Pairs with Smallest Sums $\\star\\star$"},{"location":"cpp/0301-0400/0371-0380/#374-guess-number-higher-or-lower-star","text":"","title":"374. Guess Number Higher or Lower $\\star$"},{"location":"cpp/0301-0400/0371-0380/#375-guess-number-higher-or-lower-ii-starstar","text":"","title":"375. Guess Number Higher or Lower II $\\star\\star$"},{"location":"cpp/0301-0400/0371-0380/#376-wiggle-subsequence-starstar","text":"","title":"376. Wiggle Subsequence $\\star\\star$"},{"location":"cpp/0301-0400/0371-0380/#377-combination-sum-iv-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int combinationSum4 ( vector < int >& nums , int target ) { vector < int > m ( target + 1 , - 1 ); m [ 0 ] = 1 ; return dp ( nums , target , m ); } private : int dp ( vector < int >& nums , int target , vector < int >& m ) { if ( target < 0 ) return 0 ; if ( m [ target ] != - 1 ) return m [ target ]; int ans = 0 ; for ( int num : nums ) ans += dp ( nums , target - num , m ); return m [ target ] = ans ; } };","title":"377. Combination Sum IV $\\star\\star$"},{"location":"cpp/0301-0400/0371-0380/#378-kth-smallest-element-in-a-sorted-matrix-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int kthSmallest ( vector < vector < int >>& matrix , int k ) { int l = matrix [ 0 ][ 0 ]; int r = matrix . back (). back (); while ( l < r ) { int m = ( l + r ) >> 1 ; int count = 0 ; for ( auto & row : matrix ) count += upper_bound ( row . begin (), row . end (), m ) - row . begin (); if ( count >= k ) r = m ; else l = m + 1 ; } return l ; } };","title":"378. Kth Smallest Element in a Sorted Matrix $\\star\\star$"},{"location":"cpp/0301-0400/0371-0380/#379-design-phone-directory-starstar","text":"","title":"379. Design Phone Directory $\\star\\star$"},{"location":"cpp/0301-0400/0371-0380/#380-insert-delete-getrandom-o1-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class RandomizedSet { public : bool insert ( int val ) { if ( map . count ( val )) return false ; map [ val ] = vals . size (); vals . push_back ( val ); return true ; } bool remove ( int val ) { if ( ! map . count ( val )) return false ; int index = map [ val ]; map [ vals . back ()] = index ; map . erase ( val ); swap ( vals [ index ], vals . back ()); vals . pop_back (); return true ; } int getRandom () { int index = rand () % vals . size (); return vals [ index ]; } private : vector < int > vals ; unordered_map < int , int > map ; };","title":"380. Insert Delete GetRandom O(1) $\\star\\star$"},{"location":"cpp/0301-0400/0381-0390/","text":"381. Insert Delete GetRandom O(1) - Duplicates allowed $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class RandomizedCollection { public : bool insert ( int val ) { map [ val ]. push_back ( vals . size ()); vals . emplace_back ( val , map [ val ]. size () - 1 ); return map [ val ]. size () == 1 ; } bool remove ( int val ) { if ( ! map . count ( val ) || map [ val ]. empty ()) return false ; int index = map [ val ]. back (); map [ vals . back (). first ][ vals . back (). second ] = index ; map [ val ]. pop_back (); swap ( vals [ index ], vals . back ()); vals . pop_back (); return true ; } int getRandom () { int index = rand () % vals . size (); return vals [ index ]. first ; } private : vector < pair < int , int >> vals ; unordered_map < int , vector < int >> map ; }; 382. Linked List Random Node $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Solution ( ListNode * head ) { privateHead = head ; for ( auto curr = head ; curr ; curr = curr -> next ) length ++ ; } int getRandom () { int n = rand () % length ; ListNode * curr = privateHead ; while ( n -- > 0 ) curr = curr -> next ; return curr -> val ; } private : ListNode * privateHead ; int length = 0 ; }; 383. Ransom Note $\\star$ 384. Shuffle an Array $\\star\\star$ 385. Mini Parser $\\star\\star$ 386. Lexicographical Numbers $\\star\\star$ 387. First Unique Character in a String $\\star$ 388. Longest Absolute File Path $\\star\\star$ 389. Find the Difference $\\star$ 390. Elimination Game $\\star\\star$","title":"0381-0390"},{"location":"cpp/0301-0400/0381-0390/#381-insert-delete-getrandom-o1-duplicates-allowed-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class RandomizedCollection { public : bool insert ( int val ) { map [ val ]. push_back ( vals . size ()); vals . emplace_back ( val , map [ val ]. size () - 1 ); return map [ val ]. size () == 1 ; } bool remove ( int val ) { if ( ! map . count ( val ) || map [ val ]. empty ()) return false ; int index = map [ val ]. back (); map [ vals . back (). first ][ vals . back (). second ] = index ; map [ val ]. pop_back (); swap ( vals [ index ], vals . back ()); vals . pop_back (); return true ; } int getRandom () { int index = rand () % vals . size (); return vals [ index ]. first ; } private : vector < pair < int , int >> vals ; unordered_map < int , vector < int >> map ; };","title":"381. Insert Delete GetRandom O(1) - Duplicates allowed $\\star\\star\\star$"},{"location":"cpp/0301-0400/0381-0390/#382-linked-list-random-node-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Solution ( ListNode * head ) { privateHead = head ; for ( auto curr = head ; curr ; curr = curr -> next ) length ++ ; } int getRandom () { int n = rand () % length ; ListNode * curr = privateHead ; while ( n -- > 0 ) curr = curr -> next ; return curr -> val ; } private : ListNode * privateHead ; int length = 0 ; };","title":"382. Linked List Random Node $\\star\\star$"},{"location":"cpp/0301-0400/0381-0390/#383-ransom-note-star","text":"","title":"383. Ransom Note $\\star$"},{"location":"cpp/0301-0400/0381-0390/#384-shuffle-an-array-starstar","text":"","title":"384. Shuffle an Array $\\star\\star$"},{"location":"cpp/0301-0400/0381-0390/#385-mini-parser-starstar","text":"","title":"385. Mini Parser $\\star\\star$"},{"location":"cpp/0301-0400/0381-0390/#386-lexicographical-numbers-starstar","text":"","title":"386. Lexicographical Numbers $\\star\\star$"},{"location":"cpp/0301-0400/0381-0390/#387-first-unique-character-in-a-string-star","text":"","title":"387. First Unique Character in a String $\\star$"},{"location":"cpp/0301-0400/0381-0390/#388-longest-absolute-file-path-starstar","text":"","title":"388. Longest Absolute File Path $\\star\\star$"},{"location":"cpp/0301-0400/0381-0390/#389-find-the-difference-star","text":"","title":"389. Find the Difference $\\star$"},{"location":"cpp/0301-0400/0381-0390/#390-elimination-game-starstar","text":"","title":"390. Elimination Game $\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/","text":"391. Perfect Rectangle $\\star\\star\\star$ 392. Is Subsequence $\\star$ 393. UTF-8 Validation $\\star\\star$ 394. Decode String $\\star\\star$ 395. Longest Substring with At Least K Repeating Characters $\\star\\star$ 396. Rotate Function $\\star\\star$ 397. Integer Replacement $\\star\\star$ 398. Random Pick Index $\\star\\star$ 399. Evaluate Division $\\star\\star$ 400. Nth Digit $\\star\\star$","title":"0391-0300"},{"location":"cpp/0301-0400/0391-0400/#391-perfect-rectangle-starstarstar","text":"","title":"391. Perfect Rectangle $\\star\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/#392-is-subsequence-star","text":"","title":"392. Is Subsequence $\\star$"},{"location":"cpp/0301-0400/0391-0400/#393-utf-8-validation-starstar","text":"","title":"393. UTF-8 Validation $\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/#394-decode-string-starstar","text":"","title":"394. Decode String $\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/#395-longest-substring-with-at-least-k-repeating-characters-starstar","text":"","title":"395. Longest Substring with At Least K Repeating Characters $\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/#396-rotate-function-starstar","text":"","title":"396. Rotate Function $\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/#397-integer-replacement-starstar","text":"","title":"397. Integer Replacement $\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/#398-random-pick-index-starstar","text":"","title":"398. Random Pick Index $\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/#399-evaluate-division-starstar","text":"","title":"399. Evaluate Division $\\star\\star$"},{"location":"cpp/0301-0400/0391-0400/#400-nth-digit-starstar","text":"","title":"400. Nth Digit $\\star\\star$"},{"location":"cpp/0401-0500/0401-0410/","text":"401. Binary Watch $\\star$ 402. Remove K Digits $\\star\\star$ 403. Frog Jump $\\star\\star\\star$ 404. Sum of Left Leaves $\\star$ 405. Convert a Number to Hexadecimal $\\star$ 406. Queue Reconstruction by Height $\\star\\star$ 407. Trapping Rain Water II $\\star\\star\\star$ 408. Valid Word Abbreviation $\\star$ 409. Longest Palindrome $\\star$ 410. Split Array Largest Sum $\\star\\star\\star$","title":"0401-0410"},{"location":"cpp/0401-0500/0401-0410/#401-binary-watch-star","text":"","title":"401. Binary Watch $\\star$"},{"location":"cpp/0401-0500/0401-0410/#402-remove-k-digits-starstar","text":"","title":"402. Remove K Digits $\\star\\star$"},{"location":"cpp/0401-0500/0401-0410/#403-frog-jump-starstarstar","text":"","title":"403. Frog Jump $\\star\\star\\star$"},{"location":"cpp/0401-0500/0401-0410/#404-sum-of-left-leaves-star","text":"","title":"404. Sum of Left Leaves $\\star$"},{"location":"cpp/0401-0500/0401-0410/#405-convert-a-number-to-hexadecimal-star","text":"","title":"405. Convert a Number to Hexadecimal $\\star$"},{"location":"cpp/0401-0500/0401-0410/#406-queue-reconstruction-by-height-starstar","text":"","title":"406. Queue Reconstruction by Height $\\star\\star$"},{"location":"cpp/0401-0500/0401-0410/#407-trapping-rain-water-ii-starstarstar","text":"","title":"407. Trapping Rain Water II $\\star\\star\\star$"},{"location":"cpp/0401-0500/0401-0410/#408-valid-word-abbreviation-star","text":"","title":"408. Valid Word Abbreviation $\\star$"},{"location":"cpp/0401-0500/0401-0410/#409-longest-palindrome-star","text":"","title":"409. Longest Palindrome $\\star$"},{"location":"cpp/0401-0500/0401-0410/#410-split-array-largest-sum-starstarstar","text":"","title":"410. Split Array Largest Sum $\\star\\star\\star$"},{"location":"cpp/0401-0500/0411-0420/","text":"411. Minimum Unique Word Abbreviation $\\star\\star\\star$ 412. Fizz Buzz $\\star$ 413. Arithmetic Slices $\\star\\star$ 414. Third Maximum Number $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int thirdMax ( vector < int >& nums ) { priority_queue < int , vector < int > , compare > pq ; unordered_set < int > set ; for ( int num : nums ) if ( ! set . count ( num )) { set . insert ( num ); pq . push ( num ); if ( pq . size () > 3 ) pq . pop (); } if ( pq . size () == 2 ) pq . pop (); return pq . top (); } private : struct compare { bool operator ()( const int a , const int b ) { return a > b ; } }; }; 415. Add Strings $\\star$ 416. Partition Equal Subset Sum $\\star\\star$ 417. Pacific Atlantic Water Flow $\\star\\star$ 418. Sentence Screen Fitting $\\star\\star$ 419. Battleships in a Board $\\star\\star$ 420. Strong Password Checker $\\star\\star\\star$","title":"0411-0420"},{"location":"cpp/0401-0500/0411-0420/#411-minimum-unique-word-abbreviation-starstarstar","text":"","title":"411. Minimum Unique Word Abbreviation $\\star\\star\\star$"},{"location":"cpp/0401-0500/0411-0420/#412-fizz-buzz-star","text":"","title":"412. Fizz Buzz $\\star$"},{"location":"cpp/0401-0500/0411-0420/#413-arithmetic-slices-starstar","text":"","title":"413. Arithmetic Slices $\\star\\star$"},{"location":"cpp/0401-0500/0411-0420/#414-third-maximum-number-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int thirdMax ( vector < int >& nums ) { priority_queue < int , vector < int > , compare > pq ; unordered_set < int > set ; for ( int num : nums ) if ( ! set . count ( num )) { set . insert ( num ); pq . push ( num ); if ( pq . size () > 3 ) pq . pop (); } if ( pq . size () == 2 ) pq . pop (); return pq . top (); } private : struct compare { bool operator ()( const int a , const int b ) { return a > b ; } }; };","title":"414. Third Maximum Number $\\star$"},{"location":"cpp/0401-0500/0411-0420/#415-add-strings-star","text":"","title":"415. Add Strings $\\star$"},{"location":"cpp/0401-0500/0411-0420/#416-partition-equal-subset-sum-starstar","text":"","title":"416. Partition Equal Subset Sum $\\star\\star$"},{"location":"cpp/0401-0500/0411-0420/#417-pacific-atlantic-water-flow-starstar","text":"","title":"417. Pacific Atlantic Water Flow $\\star\\star$"},{"location":"cpp/0401-0500/0411-0420/#418-sentence-screen-fitting-starstar","text":"","title":"418. Sentence Screen Fitting $\\star\\star$"},{"location":"cpp/0401-0500/0411-0420/#419-battleships-in-a-board-starstar","text":"","title":"419. Battleships in a Board $\\star\\star$"},{"location":"cpp/0401-0500/0411-0420/#420-strong-password-checker-starstarstar","text":"","title":"420. Strong Password Checker $\\star\\star\\star$"},{"location":"cpp/0401-0500/0421-0430/","text":"421. Maximum XOR of Two Numbers in an Array $\\star\\star$ 422. Valid Word Square $\\star$ 423. Reconstruct Original Digits from English $\\star\\star$ 424. Longest Repeating Character Replacement $\\star\\star$ 425. Word Squares $\\star\\star\\star$ 426. Convert Binary Search Tree to Sorted Doubly Linked List $\\star\\star$ 427. Construct Quad Tree $\\star\\star$ 428. Serialize and Deserialize N-ary Tree $\\star\\star\\star$ 429. N-ary Tree Level Order Traversal $\\star\\star$ 430. Flatten a Multilevel Doubly Linked List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Node * flatten ( Node * head ) { for ( Node * curr = head ; curr ; curr = curr -> next ) if ( curr -> child ) { Node * next = curr -> next ; curr -> next = curr -> child ; curr -> next -> prev = curr ; curr -> child = NULL ; Node * tail = curr -> next ; while ( tail -> next ) tail = tail -> next ; tail -> next = next ; if ( next ) next -> prev = tail ; } return head ; } };","title":"0421-0430"},{"location":"cpp/0401-0500/0421-0430/#421-maximum-xor-of-two-numbers-in-an-array-starstar","text":"","title":"421. Maximum XOR of Two Numbers in an Array $\\star\\star$"},{"location":"cpp/0401-0500/0421-0430/#422-valid-word-square-star","text":"","title":"422. Valid Word Square $\\star$"},{"location":"cpp/0401-0500/0421-0430/#423-reconstruct-original-digits-from-english-starstar","text":"","title":"423. Reconstruct Original Digits from English $\\star\\star$"},{"location":"cpp/0401-0500/0421-0430/#424-longest-repeating-character-replacement-starstar","text":"","title":"424. Longest Repeating Character Replacement $\\star\\star$"},{"location":"cpp/0401-0500/0421-0430/#425-word-squares-starstarstar","text":"","title":"425. Word Squares $\\star\\star\\star$"},{"location":"cpp/0401-0500/0421-0430/#426-convert-binary-search-tree-to-sorted-doubly-linked-list-starstar","text":"","title":"426. Convert Binary Search Tree to Sorted Doubly Linked List $\\star\\star$"},{"location":"cpp/0401-0500/0421-0430/#427-construct-quad-tree-starstar","text":"","title":"427. Construct Quad Tree $\\star\\star$"},{"location":"cpp/0401-0500/0421-0430/#428-serialize-and-deserialize-n-ary-tree-starstarstar","text":"","title":"428. Serialize and Deserialize N-ary Tree $\\star\\star\\star$"},{"location":"cpp/0401-0500/0421-0430/#429-n-ary-tree-level-order-traversal-starstar","text":"","title":"429. N-ary Tree Level Order Traversal $\\star\\star$"},{"location":"cpp/0401-0500/0421-0430/#430-flatten-a-multilevel-doubly-linked-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : Node * flatten ( Node * head ) { for ( Node * curr = head ; curr ; curr = curr -> next ) if ( curr -> child ) { Node * next = curr -> next ; curr -> next = curr -> child ; curr -> next -> prev = curr ; curr -> child = NULL ; Node * tail = curr -> next ; while ( tail -> next ) tail = tail -> next ; tail -> next = next ; if ( next ) next -> prev = tail ; } return head ; } };","title":"430. Flatten a Multilevel Doubly Linked List $\\star\\star$"},{"location":"cpp/0401-0500/0431-0440/","text":"431. Encode N-ary Tree to Binary Tree $\\star\\star\\star$ 432. All O`one Data Structure $\\star\\star\\star$ 433. Minimum Genetic Mutation $\\star\\star$ 434. Number of Segments in a String $\\star$ 435. Non-overlapping Intervals $\\star\\star$ 436. Find Right Interval $\\star\\star$ 437. Path Sum III $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int pathSum ( TreeNode * root , int sum ) { if ( ! root ) return 0 ; return helper ( root , sum ) + pathSum ( root -> left , sum ) + pathSum ( root -> right , sum ); } private : int helper ( TreeNode * root , int sum ) { if ( ! root ) return 0 ; return ( sum == root -> val ) + helper ( root -> left , sum - root -> val ) + helper ( root -> right , sum - root -> val ); } }; 438. Find All Anagrams in a String $\\star\\star$ 439. Ternary Expression Parser $\\star\\star$ 440. K-th Smallest in Lexicographical Order $\\star\\star\\star$","title":"0431-0440"},{"location":"cpp/0401-0500/0431-0440/#431-encode-n-ary-tree-to-binary-tree-starstarstar","text":"","title":"431. Encode N-ary Tree to Binary Tree $\\star\\star\\star$"},{"location":"cpp/0401-0500/0431-0440/#432-all-oone-data-structure-starstarstar","text":"","title":"432. All O`one Data Structure $\\star\\star\\star$"},{"location":"cpp/0401-0500/0431-0440/#433-minimum-genetic-mutation-starstar","text":"","title":"433. Minimum Genetic Mutation $\\star\\star$"},{"location":"cpp/0401-0500/0431-0440/#434-number-of-segments-in-a-string-star","text":"","title":"434. Number of Segments in a String $\\star$"},{"location":"cpp/0401-0500/0431-0440/#435-non-overlapping-intervals-starstar","text":"","title":"435. Non-overlapping Intervals $\\star\\star$"},{"location":"cpp/0401-0500/0431-0440/#436-find-right-interval-starstar","text":"","title":"436. Find Right Interval $\\star\\star$"},{"location":"cpp/0401-0500/0431-0440/#437-path-sum-iii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int pathSum ( TreeNode * root , int sum ) { if ( ! root ) return 0 ; return helper ( root , sum ) + pathSum ( root -> left , sum ) + pathSum ( root -> right , sum ); } private : int helper ( TreeNode * root , int sum ) { if ( ! root ) return 0 ; return ( sum == root -> val ) + helper ( root -> left , sum - root -> val ) + helper ( root -> right , sum - root -> val ); } };","title":"437. Path Sum III $\\star$"},{"location":"cpp/0401-0500/0431-0440/#438-find-all-anagrams-in-a-string-starstar","text":"","title":"438. Find All Anagrams in a String $\\star\\star$"},{"location":"cpp/0401-0500/0431-0440/#439-ternary-expression-parser-starstar","text":"","title":"439. Ternary Expression Parser $\\star\\star$"},{"location":"cpp/0401-0500/0431-0440/#440-k-th-smallest-in-lexicographical-order-starstarstar","text":"","title":"440. K-th Smallest in Lexicographical Order $\\star\\star\\star$"},{"location":"cpp/0401-0500/0441-0450/","text":"441. Arranging Coins $\\star$ 442. Find All Duplicates in an Array $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector < int > findDuplicates ( vector < int >& nums ) { vector < int > ans ; for ( int num : nums ) { nums [ abs ( num ) - 1 ] *= - 1 ; if ( nums [ abs ( num ) - 1 ] > 0 ) ans . push_back ( abs ( num )); } return ans ; } }; 443. String Compression $\\star$ 444. Sequence Reconstruction $\\star\\star$ 445. Add Two Numbers II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { stack < ListNode *> stack1 ; stack < ListNode *> stack2 ; while ( l1 ) { stack1 . push ( l1 ); l1 = l1 -> next ; } while ( l2 ) { stack2 . push ( l2 ); l2 = l2 -> next ; } ListNode * head = NULL ; int carry = 0 ; while ( carry || ! stack1 . empty () || ! stack2 . empty ()) { if ( ! stack1 . empty ()) { carry += stack1 . top () -> val ; stack1 . pop (); } if ( ! stack2 . empty ()) { carry += stack2 . top () -> val ; stack2 . pop (); } ListNode * node = new ListNode ( carry % 10 ); node -> next = head ; head = node ; carry /= 10 ; } return head ; } }; 446. Arithmetic Slices II - Subsequence $\\star\\star\\star$ 447. Number of Boomerangs $\\star$ 448. Find All Numbers Disappeared in an Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > findDisappearedNumbers ( vector < int >& nums ) { vector < int > ans ; for ( int num : nums ) { int index = abs ( num ) - 1 ; nums [ index ] = - abs ( nums [ index ]); } for ( int i = 0 ; i < nums . size (); i ++ ) if ( nums [ i ] > 0 ) ans . push_back ( i + 1 ); return ans ; } }; 449. Serialize and Deserialize BST $\\star\\star$ 450. Delete Node in a BST $\\star\\star$","title":"0441-0450"},{"location":"cpp/0401-0500/0441-0450/#441-arranging-coins-star","text":"","title":"441. Arranging Coins $\\star$"},{"location":"cpp/0401-0500/0441-0450/#442-find-all-duplicates-in-an-array-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : vector < int > findDuplicates ( vector < int >& nums ) { vector < int > ans ; for ( int num : nums ) { nums [ abs ( num ) - 1 ] *= - 1 ; if ( nums [ abs ( num ) - 1 ] > 0 ) ans . push_back ( abs ( num )); } return ans ; } };","title":"442. Find All Duplicates in an Array $\\star\\star$"},{"location":"cpp/0401-0500/0441-0450/#443-string-compression-star","text":"","title":"443. String Compression $\\star$"},{"location":"cpp/0401-0500/0441-0450/#444-sequence-reconstruction-starstar","text":"","title":"444. Sequence Reconstruction $\\star\\star$"},{"location":"cpp/0401-0500/0441-0450/#445-add-two-numbers-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : ListNode * addTwoNumbers ( ListNode * l1 , ListNode * l2 ) { stack < ListNode *> stack1 ; stack < ListNode *> stack2 ; while ( l1 ) { stack1 . push ( l1 ); l1 = l1 -> next ; } while ( l2 ) { stack2 . push ( l2 ); l2 = l2 -> next ; } ListNode * head = NULL ; int carry = 0 ; while ( carry || ! stack1 . empty () || ! stack2 . empty ()) { if ( ! stack1 . empty ()) { carry += stack1 . top () -> val ; stack1 . pop (); } if ( ! stack2 . empty ()) { carry += stack2 . top () -> val ; stack2 . pop (); } ListNode * node = new ListNode ( carry % 10 ); node -> next = head ; head = node ; carry /= 10 ; } return head ; } };","title":"445. Add Two Numbers II $\\star\\star$"},{"location":"cpp/0401-0500/0441-0450/#446-arithmetic-slices-ii-subsequence-starstarstar","text":"","title":"446. Arithmetic Slices II - Subsequence $\\star\\star\\star$"},{"location":"cpp/0401-0500/0441-0450/#447-number-of-boomerangs-star","text":"","title":"447. Number of Boomerangs $\\star$"},{"location":"cpp/0401-0500/0441-0450/#448-find-all-numbers-disappeared-in-an-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > findDisappearedNumbers ( vector < int >& nums ) { vector < int > ans ; for ( int num : nums ) { int index = abs ( num ) - 1 ; nums [ index ] = - abs ( nums [ index ]); } for ( int i = 0 ; i < nums . size (); i ++ ) if ( nums [ i ] > 0 ) ans . push_back ( i + 1 ); return ans ; } };","title":"448. Find All Numbers Disappeared in an Array $\\star$"},{"location":"cpp/0401-0500/0441-0450/#449-serialize-and-deserialize-bst-starstar","text":"","title":"449. Serialize and Deserialize BST $\\star\\star$"},{"location":"cpp/0401-0500/0441-0450/#450-delete-node-in-a-bst-starstar","text":"","title":"450. Delete Node in a BST $\\star\\star$"},{"location":"cpp/0401-0500/0451-0460/","text":"451. Sort Characters By Frequency $\\star\\star$ 452. Minimum Number of Arrows to Burst Balloons $\\star\\star$ 453. Minimum Moves to Equal Array Elements $\\star$ 454. 4Sum II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int fourSumCount ( vector < int >& A , vector < int >& B , vector < int >& C , vector < int >& D ) { int ans = 0 ; unordered_map < int , int > map ; for ( int a : A ) for ( int b : B ) map [ a + b ] ++ ; for ( int c : C ) for ( int d : D ) ans += map . count ( - c - d ) ? map [ - c - d ] : 0 ; return ans ; } }; 455. Assign Cookies $\\star$ 456. 132 Pattern $\\star\\star$ 457. Circular Array Loop $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : bool circularArrayLoop ( vector < int >& nums ) { if ( nums . size () < 2 ) return false ; function < int ( int ) > advance = [ & ]( int i ) { const int n = nums . size (); int val = ( i + nums [ i ]) % n ; return i + nums [ i ] >= 0 ? val : n + val ; }; for ( int i = 0 ; i < nums . size (); i ++ ) { if ( nums [ i ] == 0 ) continue ; int slow = i ; int fast = advance ( slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( fast )] > 0 ) { if ( slow == fast ) { if ( slow == advance ( slow )) break ; return true ; } slow = advance ( slow ); fast = advance ( advance ( fast )); } slow = i ; int sign = nums [ i ]; while ( sign * nums [ slow ] > 0 ) { int next = advance ( slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; } }; 458. Poor Pigs $\\star\\star\\star$ 459. Repeated Substring Pattern $\\star$ 460. LFU Cache $\\star\\star\\star$","title":"0451-0460"},{"location":"cpp/0401-0500/0451-0460/#451-sort-characters-by-frequency-starstar","text":"","title":"451. Sort Characters By Frequency $\\star\\star$"},{"location":"cpp/0401-0500/0451-0460/#452-minimum-number-of-arrows-to-burst-balloons-starstar","text":"","title":"452. Minimum Number of Arrows to Burst Balloons $\\star\\star$"},{"location":"cpp/0401-0500/0451-0460/#453-minimum-moves-to-equal-array-elements-star","text":"","title":"453. Minimum Moves to Equal Array Elements $\\star$"},{"location":"cpp/0401-0500/0451-0460/#454-4sum-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int fourSumCount ( vector < int >& A , vector < int >& B , vector < int >& C , vector < int >& D ) { int ans = 0 ; unordered_map < int , int > map ; for ( int a : A ) for ( int b : B ) map [ a + b ] ++ ; for ( int c : C ) for ( int d : D ) ans += map . count ( - c - d ) ? map [ - c - d ] : 0 ; return ans ; } };","title":"454. 4Sum II $\\star\\star$"},{"location":"cpp/0401-0500/0451-0460/#455-assign-cookies-star","text":"","title":"455. Assign Cookies $\\star$"},{"location":"cpp/0401-0500/0451-0460/#456-132-pattern-starstar","text":"","title":"456. 132 Pattern $\\star\\star$"},{"location":"cpp/0401-0500/0451-0460/#457-circular-array-loop-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public : bool circularArrayLoop ( vector < int >& nums ) { if ( nums . size () < 2 ) return false ; function < int ( int ) > advance = [ & ]( int i ) { const int n = nums . size (); int val = ( i + nums [ i ]) % n ; return i + nums [ i ] >= 0 ? val : n + val ; }; for ( int i = 0 ; i < nums . size (); i ++ ) { if ( nums [ i ] == 0 ) continue ; int slow = i ; int fast = advance ( slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( fast )] > 0 ) { if ( slow == fast ) { if ( slow == advance ( slow )) break ; return true ; } slow = advance ( slow ); fast = advance ( advance ( fast )); } slow = i ; int sign = nums [ i ]; while ( sign * nums [ slow ] > 0 ) { int next = advance ( slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; } };","title":"457. Circular Array Loop $\\star\\star$"},{"location":"cpp/0401-0500/0451-0460/#458-poor-pigs-starstarstar","text":"","title":"458. Poor Pigs $\\star\\star\\star$"},{"location":"cpp/0401-0500/0451-0460/#459-repeated-substring-pattern-star","text":"","title":"459. Repeated Substring Pattern $\\star$"},{"location":"cpp/0401-0500/0451-0460/#460-lfu-cache-starstarstar","text":"","title":"460. LFU Cache $\\star\\star\\star$"},{"location":"cpp/0401-0500/0461-0470/","text":"461. Hamming Distance $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int hammingDistance ( int x , int y ) { int ans = 0 ; while ( x || y ) { ans += ( x % 2 ) ^ ( y % 2 ); x /= 2 ; y /= 2 ; } return ans ; } }; 462. Minimum Moves to Equal Array Elements II $\\star\\star$ 463. Island Perimeter $\\star$ 464. Can I Win $\\star\\star$ 465. Optimal Account Balancing $\\star\\star\\star$ 466. Count The Repetitions $\\star\\star\\star$ 467. Unique Substrings in Wraparound String $\\star\\star$ 468. Validate IP Address $\\star\\star$ 469. Convex Polygon $\\star\\star$ 470. Implement Rand10() Using Rand7() $\\star\\star$","title":"0461-0470"},{"location":"cpp/0401-0500/0461-0470/#461-hamming-distance-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int hammingDistance ( int x , int y ) { int ans = 0 ; while ( x || y ) { ans += ( x % 2 ) ^ ( y % 2 ); x /= 2 ; y /= 2 ; } return ans ; } };","title":"461. Hamming Distance $\\star$"},{"location":"cpp/0401-0500/0461-0470/#462-minimum-moves-to-equal-array-elements-ii-starstar","text":"","title":"462. Minimum Moves to Equal Array Elements II $\\star\\star$"},{"location":"cpp/0401-0500/0461-0470/#463-island-perimeter-star","text":"","title":"463. Island Perimeter $\\star$"},{"location":"cpp/0401-0500/0461-0470/#464-can-i-win-starstar","text":"","title":"464. Can I Win $\\star\\star$"},{"location":"cpp/0401-0500/0461-0470/#465-optimal-account-balancing-starstarstar","text":"","title":"465. Optimal Account Balancing $\\star\\star\\star$"},{"location":"cpp/0401-0500/0461-0470/#466-count-the-repetitions-starstarstar","text":"","title":"466. Count The Repetitions $\\star\\star\\star$"},{"location":"cpp/0401-0500/0461-0470/#467-unique-substrings-in-wraparound-string-starstar","text":"","title":"467. Unique Substrings in Wraparound String $\\star\\star$"},{"location":"cpp/0401-0500/0461-0470/#468-validate-ip-address-starstar","text":"","title":"468. Validate IP Address $\\star\\star$"},{"location":"cpp/0401-0500/0461-0470/#469-convex-polygon-starstar","text":"","title":"469. Convex Polygon $\\star\\star$"},{"location":"cpp/0401-0500/0461-0470/#470-implement-rand10-using-rand7-starstar","text":"","title":"470. Implement Rand10() Using Rand7() $\\star\\star$"},{"location":"cpp/0401-0500/0471-0480/","text":"471. Encode String with Shortest Length $\\star\\star\\star$ 472. Concatenated Words $\\star\\star\\star$ 473. Matchsticks to Square $\\star\\star$ 474. Ones and Zeroes $\\star\\star$ 475. Heaters $\\star$ 476. Number Complement $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int findComplement ( int num ) { unsigned int mask = ~ 0 ; while ( num & mask ) mask <<= 1 ; return ~ num ^ mask ; } }; 477. Total Hamming Distance $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int totalHammingDistance ( vector < int >& nums ) { int ans = 0 ; int mask = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) { int onesCount = 0 ; for ( int num : nums ) if ( num & mask ) onesCount ++ ; ans += ( nums . size () - onesCount ) * onesCount ; mask = mask << 1 ; } return ans ; } }; 478. Generate Random Point in a Circle $\\star\\star$ 479. Largest Palindrome Product $\\star\\star\\star$ 480. Sliding Window Median $\\star\\star\\star$","title":"0471-0480"},{"location":"cpp/0401-0500/0471-0480/#471-encode-string-with-shortest-length-starstarstar","text":"","title":"471. Encode String with Shortest Length $\\star\\star\\star$"},{"location":"cpp/0401-0500/0471-0480/#472-concatenated-words-starstarstar","text":"","title":"472. Concatenated Words $\\star\\star\\star$"},{"location":"cpp/0401-0500/0471-0480/#473-matchsticks-to-square-starstar","text":"","title":"473. Matchsticks to Square $\\star\\star$"},{"location":"cpp/0401-0500/0471-0480/#474-ones-and-zeroes-starstar","text":"","title":"474. Ones and Zeroes $\\star\\star$"},{"location":"cpp/0401-0500/0471-0480/#475-heaters-star","text":"","title":"475. Heaters $\\star$"},{"location":"cpp/0401-0500/0471-0480/#476-number-complement-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int findComplement ( int num ) { unsigned int mask = ~ 0 ; while ( num & mask ) mask <<= 1 ; return ~ num ^ mask ; } };","title":"476. Number Complement $\\star$"},{"location":"cpp/0401-0500/0471-0480/#477-total-hamming-distance-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int totalHammingDistance ( vector < int >& nums ) { int ans = 0 ; int mask = 1 ; for ( int i = 0 ; i < 30 ; i ++ ) { int onesCount = 0 ; for ( int num : nums ) if ( num & mask ) onesCount ++ ; ans += ( nums . size () - onesCount ) * onesCount ; mask = mask << 1 ; } return ans ; } };","title":"477. Total Hamming Distance $\\star\\star$"},{"location":"cpp/0401-0500/0471-0480/#478-generate-random-point-in-a-circle-starstar","text":"","title":"478. Generate Random Point in a Circle $\\star\\star$"},{"location":"cpp/0401-0500/0471-0480/#479-largest-palindrome-product-starstarstar","text":"","title":"479. Largest Palindrome Product $\\star\\star\\star$"},{"location":"cpp/0401-0500/0471-0480/#480-sliding-window-median-starstarstar","text":"","title":"480. Sliding Window Median $\\star\\star\\star$"},{"location":"cpp/0401-0500/0481-0490/","text":"481. Magical String $\\star\\star$ 482. License Key Formatting $\\star$ 483. Smallest Good Base $\\star\\star\\star$ 484. Find Permutation $\\star\\star$ 485. Max Consecutive Ones $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int findMaxConsecutiveOnes ( vector < int >& nums ) { int ans = 0 ; int sum = 0 ; for ( int num : nums ) { if ( num == 0 ) sum = 0 ; else { sum += num ; ans = max ( ans , sum ); } } return ans ; } }; 486. Predict the Winner $\\star\\star$ 487. Max Consecutive Ones II $\\star\\star$ 488. Zuma Game $\\star\\star\\star$ 489. Robot Room Cleaner $\\star\\star\\star$ 490. The Maze $\\star\\star$","title":"0481-0490"},{"location":"cpp/0401-0500/0481-0490/#481-magical-string-starstar","text":"","title":"481. Magical String $\\star\\star$"},{"location":"cpp/0401-0500/0481-0490/#482-license-key-formatting-star","text":"","title":"482. License Key Formatting $\\star$"},{"location":"cpp/0401-0500/0481-0490/#483-smallest-good-base-starstarstar","text":"","title":"483. Smallest Good Base $\\star\\star\\star$"},{"location":"cpp/0401-0500/0481-0490/#484-find-permutation-starstar","text":"","title":"484. Find Permutation $\\star\\star$"},{"location":"cpp/0401-0500/0481-0490/#485-max-consecutive-ones-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int findMaxConsecutiveOnes ( vector < int >& nums ) { int ans = 0 ; int sum = 0 ; for ( int num : nums ) { if ( num == 0 ) sum = 0 ; else { sum += num ; ans = max ( ans , sum ); } } return ans ; } };","title":"485. Max Consecutive Ones $\\star$"},{"location":"cpp/0401-0500/0481-0490/#486-predict-the-winner-starstar","text":"","title":"486. Predict the Winner $\\star\\star$"},{"location":"cpp/0401-0500/0481-0490/#487-max-consecutive-ones-ii-starstar","text":"","title":"487. Max Consecutive Ones II $\\star\\star$"},{"location":"cpp/0401-0500/0481-0490/#488-zuma-game-starstarstar","text":"","title":"488. Zuma Game $\\star\\star\\star$"},{"location":"cpp/0401-0500/0481-0490/#489-robot-room-cleaner-starstarstar","text":"","title":"489. Robot Room Cleaner $\\star\\star\\star$"},{"location":"cpp/0401-0500/0481-0490/#490-the-maze-starstar","text":"","title":"490. The Maze $\\star\\star$"},{"location":"cpp/0401-0500/0491-0500/","text":"491. Increasing Subsequences $\\star\\star$ 492. Construct the Rectangle $\\star$ 493. Reverse Pairs $\\star\\star\\star$ 494. Target Sum $\\star\\star$ 495. Teemo Attacking $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int findPoisonedDuration ( vector < int >& timeSeries , int duration ) { if ( timeSeries . empty () || duration == 0 ) return 0 ; int ans = 0 ; for ( int i = 0 ; i + 1 < timeSeries . size (); i ++ ) ans += min ( timeSeries [ i + 1 ] - timeSeries [ i ], duration ); return ans + duration ; } }; 496. Next Greater Element I $\\star$ 497. Random Point in Non-overlapping Rectangles $\\star\\star$ 498. Diagonal Traverse $\\star\\star$ 499. The Maze III $\\star\\star\\star$ 500. Keyboard Row $\\star$","title":"0491-0500"},{"location":"cpp/0401-0500/0491-0500/#491-increasing-subsequences-starstar","text":"","title":"491. Increasing Subsequences $\\star\\star$"},{"location":"cpp/0401-0500/0491-0500/#492-construct-the-rectangle-star","text":"","title":"492. Construct the Rectangle $\\star$"},{"location":"cpp/0401-0500/0491-0500/#493-reverse-pairs-starstarstar","text":"","title":"493. Reverse Pairs $\\star\\star\\star$"},{"location":"cpp/0401-0500/0491-0500/#494-target-sum-starstar","text":"","title":"494. Target Sum $\\star\\star$"},{"location":"cpp/0401-0500/0491-0500/#495-teemo-attacking-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int findPoisonedDuration ( vector < int >& timeSeries , int duration ) { if ( timeSeries . empty () || duration == 0 ) return 0 ; int ans = 0 ; for ( int i = 0 ; i + 1 < timeSeries . size (); i ++ ) ans += min ( timeSeries [ i + 1 ] - timeSeries [ i ], duration ); return ans + duration ; } };","title":"495. Teemo Attacking $\\star\\star$"},{"location":"cpp/0401-0500/0491-0500/#496-next-greater-element-i-star","text":"","title":"496. Next Greater Element I $\\star$"},{"location":"cpp/0401-0500/0491-0500/#497-random-point-in-non-overlapping-rectangles-starstar","text":"","title":"497. Random Point in Non-overlapping Rectangles $\\star\\star$"},{"location":"cpp/0401-0500/0491-0500/#498-diagonal-traverse-starstar","text":"","title":"498. Diagonal Traverse $\\star\\star$"},{"location":"cpp/0401-0500/0491-0500/#499-the-maze-iii-starstarstar","text":"","title":"499. The Maze III $\\star\\star\\star$"},{"location":"cpp/0401-0500/0491-0500/#500-keyboard-row-star","text":"","title":"500. Keyboard Row $\\star$"},{"location":"cpp/0501-0600/0501-0510/","text":"501. Find Mode in Binary Search Tree $\\star$ 502. IPO $\\star\\star\\star$ 503. Next Greater Element II $\\star\\star$ 504. Base 7 $\\star$ 505. The Maze II $\\star\\star$ 506. Relative Ranks $\\star$ 507. Perfect Number $\\star$ 508. Most Frequent Subtree Sum $\\star\\star$ 509. Fibonacci Number $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int fib ( int N ) { if ( N < 2 ) return N ; int dp [] = { 0 , 0 , 1 }; for ( int i = 2 ; i <= N ; i ++ ) { dp [ 0 ] = dp [ 1 ]; dp [ 1 ] = dp [ 2 ]; dp [ 2 ] = dp [ 0 ] + dp [ 1 ]; } return dp [ 2 ]; } }; 510. Inorder Successor in BST II $\\star\\star$","title":"0501-0510"},{"location":"cpp/0501-0600/0501-0510/#501-find-mode-in-binary-search-tree-star","text":"","title":"501. Find Mode in Binary Search Tree $\\star$"},{"location":"cpp/0501-0600/0501-0510/#502-ipo-starstarstar","text":"","title":"502. IPO $\\star\\star\\star$"},{"location":"cpp/0501-0600/0501-0510/#503-next-greater-element-ii-starstar","text":"","title":"503. Next Greater Element II $\\star\\star$"},{"location":"cpp/0501-0600/0501-0510/#504-base-7-star","text":"","title":"504. Base 7 $\\star$"},{"location":"cpp/0501-0600/0501-0510/#505-the-maze-ii-starstar","text":"","title":"505. The Maze II $\\star\\star$"},{"location":"cpp/0501-0600/0501-0510/#506-relative-ranks-star","text":"","title":"506. Relative Ranks $\\star$"},{"location":"cpp/0501-0600/0501-0510/#507-perfect-number-star","text":"","title":"507. Perfect Number $\\star$"},{"location":"cpp/0501-0600/0501-0510/#508-most-frequent-subtree-sum-starstar","text":"","title":"508. Most Frequent Subtree Sum $\\star\\star$"},{"location":"cpp/0501-0600/0501-0510/#509-fibonacci-number-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int fib ( int N ) { if ( N < 2 ) return N ; int dp [] = { 0 , 0 , 1 }; for ( int i = 2 ; i <= N ; i ++ ) { dp [ 0 ] = dp [ 1 ]; dp [ 1 ] = dp [ 2 ]; dp [ 2 ] = dp [ 0 ] + dp [ 1 ]; } return dp [ 2 ]; } };","title":"509. Fibonacci Number $\\star$"},{"location":"cpp/0501-0600/0501-0510/#510-inorder-successor-in-bst-ii-starstar","text":"","title":"510. Inorder Successor in BST II $\\star\\star$"},{"location":"cpp/0501-0600/0511-0520/","text":"511. Game Play Analysis I $\\star$ 512. Game Play Analysis II $\\star$ 513. Find Bottom Left Tree Value $\\star\\star$ 514. Freedom Trail $\\star\\star\\star$ 515. Find Largest Value in Each Tree Row $\\star\\star$ 516. Longest Palindromic Subsequence $\\star\\star$ 517. Super Washing Machines $\\star\\star\\star$ 518. Coin Change 2 $\\star\\star$ 519. Random Flip Matrix $\\star\\star$ 520. Detect Capital $\\star$","title":"0511-0520"},{"location":"cpp/0501-0600/0511-0520/#511-game-play-analysis-i-star","text":"","title":"511. Game Play Analysis I $\\star$"},{"location":"cpp/0501-0600/0511-0520/#512-game-play-analysis-ii-star","text":"","title":"512. Game Play Analysis II $\\star$"},{"location":"cpp/0501-0600/0511-0520/#513-find-bottom-left-tree-value-starstar","text":"","title":"513. Find Bottom Left Tree Value $\\star\\star$"},{"location":"cpp/0501-0600/0511-0520/#514-freedom-trail-starstarstar","text":"","title":"514. Freedom Trail $\\star\\star\\star$"},{"location":"cpp/0501-0600/0511-0520/#515-find-largest-value-in-each-tree-row-starstar","text":"","title":"515. Find Largest Value in Each Tree Row $\\star\\star$"},{"location":"cpp/0501-0600/0511-0520/#516-longest-palindromic-subsequence-starstar","text":"","title":"516. Longest Palindromic Subsequence $\\star\\star$"},{"location":"cpp/0501-0600/0511-0520/#517-super-washing-machines-starstarstar","text":"","title":"517. Super Washing Machines $\\star\\star\\star$"},{"location":"cpp/0501-0600/0511-0520/#518-coin-change-2-starstar","text":"","title":"518. Coin Change 2 $\\star\\star$"},{"location":"cpp/0501-0600/0511-0520/#519-random-flip-matrix-starstar","text":"","title":"519. Random Flip Matrix $\\star\\star$"},{"location":"cpp/0501-0600/0511-0520/#520-detect-capital-star","text":"","title":"520. Detect Capital $\\star$"},{"location":"cpp/0501-0600/0521-0530/","text":"521. Longest Uncommon Subsequence I $\\star$ 522. Longest Uncommon Subsequence II $\\star\\star$ 523. Continuous Subarray Sum $\\star\\star$ 524. Longest Word in Dictionary through Deleting $\\star\\star$ 525. Contiguous Array $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int findMaxLength ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; int ans = 0 ; int sum = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < nums . size (); i ++ ) { sum += nums [ i ] ? 1 : - 1 ; if ( sum == 0 ) { ans = i + 1 ; } else if ( map . count ( sum )) { ans = max ( ans , i - map [ sum ]); } else { map [ sum ] = i ; } } return ans ; } }; 526. Beautiful Arrangement $\\star\\star$ 527. Word Abbreviation $\\star\\star\\star$ 528. Random Pick with Weight $\\star\\star$ 529. Minesweeper $\\star\\star$ 530. Minimum Absolute Difference in BST $\\star$","title":"0521-0530"},{"location":"cpp/0501-0600/0521-0530/#521-longest-uncommon-subsequence-i-star","text":"","title":"521. Longest Uncommon Subsequence I  $\\star$"},{"location":"cpp/0501-0600/0521-0530/#522-longest-uncommon-subsequence-ii-starstar","text":"","title":"522. Longest Uncommon Subsequence II $\\star\\star$"},{"location":"cpp/0501-0600/0521-0530/#523-continuous-subarray-sum-starstar","text":"","title":"523. Continuous Subarray Sum $\\star\\star$"},{"location":"cpp/0501-0600/0521-0530/#524-longest-word-in-dictionary-through-deleting-starstar","text":"","title":"524. Longest Word in Dictionary through Deleting $\\star\\star$"},{"location":"cpp/0501-0600/0521-0530/#525-contiguous-array-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int findMaxLength ( vector < int >& nums ) { if ( nums . empty ()) return 0 ; int ans = 0 ; int sum = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < nums . size (); i ++ ) { sum += nums [ i ] ? 1 : - 1 ; if ( sum == 0 ) { ans = i + 1 ; } else if ( map . count ( sum )) { ans = max ( ans , i - map [ sum ]); } else { map [ sum ] = i ; } } return ans ; } };","title":"525. Contiguous Array $\\star\\star$"},{"location":"cpp/0501-0600/0521-0530/#526-beautiful-arrangement-starstar","text":"","title":"526. Beautiful Arrangement $\\star\\star$"},{"location":"cpp/0501-0600/0521-0530/#527-word-abbreviation-starstarstar","text":"","title":"527. Word Abbreviation $\\star\\star\\star$"},{"location":"cpp/0501-0600/0521-0530/#528-random-pick-with-weight-starstar","text":"","title":"528. Random Pick with Weight $\\star\\star$"},{"location":"cpp/0501-0600/0521-0530/#529-minesweeper-starstar","text":"","title":"529. Minesweeper $\\star\\star$"},{"location":"cpp/0501-0600/0521-0530/#530-minimum-absolute-difference-in-bst-star","text":"","title":"530. Minimum Absolute Difference in BST $\\star$"},{"location":"cpp/0501-0600/0531-0540/","text":"531. Lonely Pixel I $\\star\\star$ 532. K-diff Pairs in an Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int findPairs ( vector < int >& nums , int k ) { if ( k < 0 ) return 0 ; int ans = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < nums . size (); i ++ ) map [ nums [ i ]] = i ; for ( int i = 0 ; i < nums . size (); i ++ ) { int target = nums [ i ] + k ; if ( map . count ( target ) && map [ target ] != i ) { ans ++ ; map . erase ( target ); } } return ans ; } }; 533. Lonely Pixel II $\\star\\star$ 534. Game Play Analysis III $\\star\\star$ 535. Encode and Decode TinyURL $\\star\\star$ 536. Construct Binary Tree from String $\\star\\star$ 537. Complex Number Multiplication $\\star\\star$ 538. Convert BST to Greater Tree $\\star$ 539. Minimum Time Difference $\\star\\star$ 540. Single Element in a Sorted Array $\\star\\star$","title":"0531-0540"},{"location":"cpp/0501-0600/0531-0540/#531-lonely-pixel-i-starstar","text":"","title":"531. Lonely Pixel I $\\star\\star$"},{"location":"cpp/0501-0600/0531-0540/#532-k-diff-pairs-in-an-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int findPairs ( vector < int >& nums , int k ) { if ( k < 0 ) return 0 ; int ans = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < nums . size (); i ++ ) map [ nums [ i ]] = i ; for ( int i = 0 ; i < nums . size (); i ++ ) { int target = nums [ i ] + k ; if ( map . count ( target ) && map [ target ] != i ) { ans ++ ; map . erase ( target ); } } return ans ; } };","title":"532. K-diff Pairs in an Array $\\star$"},{"location":"cpp/0501-0600/0531-0540/#533-lonely-pixel-ii-starstar","text":"","title":"533. Lonely Pixel II $\\star\\star$"},{"location":"cpp/0501-0600/0531-0540/#534-game-play-analysis-iii-starstar","text":"","title":"534. Game Play Analysis III $\\star\\star$"},{"location":"cpp/0501-0600/0531-0540/#535-encode-and-decode-tinyurl-starstar","text":"","title":"535. Encode and Decode TinyURL $\\star\\star$"},{"location":"cpp/0501-0600/0531-0540/#536-construct-binary-tree-from-string-starstar","text":"","title":"536. Construct Binary Tree from String $\\star\\star$"},{"location":"cpp/0501-0600/0531-0540/#537-complex-number-multiplication-starstar","text":"","title":"537. Complex Number Multiplication $\\star\\star$"},{"location":"cpp/0501-0600/0531-0540/#538-convert-bst-to-greater-tree-star","text":"","title":"538. Convert BST to Greater Tree $\\star$"},{"location":"cpp/0501-0600/0531-0540/#539-minimum-time-difference-starstar","text":"","title":"539. Minimum Time Difference $\\star\\star$"},{"location":"cpp/0501-0600/0531-0540/#540-single-element-in-a-sorted-array-starstar","text":"","title":"540. Single Element in a Sorted Array $\\star\\star$"},{"location":"cpp/0501-0600/0541-0550/","text":"541. Reverse String II $\\star$ 542. 01 Matrix $\\star\\star$ 543. Diameter of Binary Tree $\\star$ 544. Output Contest Matches $\\star\\star$ 545. Boundary of Binary Tree $\\star\\star$ 546. Remove Boxes $\\star\\star\\star$ 547. Friend Circles $\\star\\star$ 548. Split Array with Equal Sum $\\star\\star$ 549. Binary Tree Longest Consecutive Sequence II $\\star\\star$ 550. Game Play Analysis IV $\\star\\star$","title":"0541-0550"},{"location":"cpp/0501-0600/0541-0550/#541-reverse-string-ii-star","text":"","title":"541. Reverse String II $\\star$"},{"location":"cpp/0501-0600/0541-0550/#542-01-matrix-starstar","text":"","title":"542. 01 Matrix $\\star\\star$"},{"location":"cpp/0501-0600/0541-0550/#543-diameter-of-binary-tree-star","text":"","title":"543. Diameter of Binary Tree $\\star$"},{"location":"cpp/0501-0600/0541-0550/#544-output-contest-matches-starstar","text":"","title":"544. Output Contest Matches $\\star\\star$"},{"location":"cpp/0501-0600/0541-0550/#545-boundary-of-binary-tree-starstar","text":"","title":"545. Boundary of Binary Tree $\\star\\star$"},{"location":"cpp/0501-0600/0541-0550/#546-remove-boxes-starstarstar","text":"","title":"546. Remove Boxes $\\star\\star\\star$"},{"location":"cpp/0501-0600/0541-0550/#547-friend-circles-starstar","text":"","title":"547. Friend Circles $\\star\\star$"},{"location":"cpp/0501-0600/0541-0550/#548-split-array-with-equal-sum-starstar","text":"","title":"548. Split Array with Equal Sum $\\star\\star$"},{"location":"cpp/0501-0600/0541-0550/#549-binary-tree-longest-consecutive-sequence-ii-starstar","text":"","title":"549. Binary Tree Longest Consecutive Sequence II $\\star\\star$"},{"location":"cpp/0501-0600/0541-0550/#550-game-play-analysis-iv-starstar","text":"","title":"550. Game Play Analysis IV $\\star\\star$"},{"location":"cpp/0501-0600/0551-0560/","text":"551. Student Attendance Record I $\\star$ 552. Student Attendance Record II $\\star\\star\\star$ 553. Optimal Division $\\star\\star$ 554. Brick Wall $\\star\\star$ 555. Split Concatenated Strings $\\star\\star$ 556. Next Greater Element III $\\star\\star$ 557. Reverse Words in a String III $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : string reverseWords ( string s ) { int i = 0 ; int j = 0 ; while ( i < s . length ()) { while ( i < j || i < s . length () && s [ i ] == ' ' ) i ++ ; while ( j < i || j < s . length () && s [ j ] != ' ' ) j ++ ; reverse ( s . begin () + i , s . begin () + j ); } return s ; } }; 558. Quad Tree Intersection $\\star$ 559. Maximum Depth of N-ary Tree $\\star$ 560. Subarray Sum Equals K $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int subarraySum ( vector < int >& nums , int k ) { int ans = 0 ; int sum = 0 ; unordered_map < int , int > map ; map [ 0 ] = 1 ; for ( int num : nums ) { sum += num ; ans += map [ sum - k ]; map [ sum ] ++ ; } return ans ; } };","title":"0551-0560"},{"location":"cpp/0501-0600/0551-0560/#551-student-attendance-record-i-star","text":"","title":"551. Student Attendance Record I $\\star$"},{"location":"cpp/0501-0600/0551-0560/#552-student-attendance-record-ii-starstarstar","text":"","title":"552. Student Attendance Record II $\\star\\star\\star$"},{"location":"cpp/0501-0600/0551-0560/#553-optimal-division-starstar","text":"","title":"553. Optimal Division $\\star\\star$"},{"location":"cpp/0501-0600/0551-0560/#554-brick-wall-starstar","text":"","title":"554. Brick Wall $\\star\\star$"},{"location":"cpp/0501-0600/0551-0560/#555-split-concatenated-strings-starstar","text":"","title":"555. Split Concatenated Strings $\\star\\star$"},{"location":"cpp/0501-0600/0551-0560/#556-next-greater-element-iii-starstar","text":"","title":"556. Next Greater Element III $\\star\\star$"},{"location":"cpp/0501-0600/0551-0560/#557-reverse-words-in-a-string-iii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : string reverseWords ( string s ) { int i = 0 ; int j = 0 ; while ( i < s . length ()) { while ( i < j || i < s . length () && s [ i ] == ' ' ) i ++ ; while ( j < i || j < s . length () && s [ j ] != ' ' ) j ++ ; reverse ( s . begin () + i , s . begin () + j ); } return s ; } };","title":"557. Reverse Words in a String III $\\star$"},{"location":"cpp/0501-0600/0551-0560/#558-quad-tree-intersection-star","text":"","title":"558. Quad Tree Intersection $\\star$"},{"location":"cpp/0501-0600/0551-0560/#559-maximum-depth-of-n-ary-tree-star","text":"","title":"559. Maximum Depth of N-ary Tree $\\star$"},{"location":"cpp/0501-0600/0551-0560/#560-subarray-sum-equals-k-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int subarraySum ( vector < int >& nums , int k ) { int ans = 0 ; int sum = 0 ; unordered_map < int , int > map ; map [ 0 ] = 1 ; for ( int num : nums ) { sum += num ; ans += map [ sum - k ]; map [ sum ] ++ ; } return ans ; } };","title":"560. Subarray Sum Equals K $\\star\\star$"},{"location":"cpp/0501-0600/0561-0570/","text":"561. Array Partition I $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int arrayPairSum ( vector < int >& nums ) { int ans = 0 ; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < nums . size (); i += 2 ) ans += nums [ i ]; return ans ; } }; 562. Longest Line of Consecutive One in Matrix $\\star\\star$ 563. Binary Tree Tilt $\\star$ 564. Find the Closest Palindrome $\\star\\star\\star$ 565. Array Nesting $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int arrayNesting ( vector < int >& nums ) { int ans = 0 ; for ( int num : nums ) { if ( num == - 1 ) continue ; int index = num ; int count = 0 ; while ( nums [ index ] != - 1 ) { int temp = index ; index = nums [ index ]; nums [ temp ] = - 1 ; count ++ ; } ans = max ( ans , count ); } return ans ; } }; 566. Reshape the Matrix $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < vector < int >> matrixReshape ( vector < vector < int >>& nums , int r , int c ) { if ( nums . empty () || r * c != nums . size () * nums [ 0 ]. size ()) return nums ; vector < vector < int >> ans ( r , vector < int > ( c )); int k = 0 ; for ( vector < int >& row : nums ) for ( int num : row ) { ans [ k / c ][ k % c ] = num ; k ++ ; } return ans ; } }; 567. Permutation in String $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : bool checkInclusion ( string s1 , string s2 ) { const int m = s1 . length (); const int n = s2 . length (); vector < int > map1 ( 26 ); vector < int > map2 ( 26 ); for ( char c : s1 ) map1 [ c - 'a' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( i >= m ) map2 [ s2 [ i - m ] - 'a' ] -- ; map2 [ s2 [ i ] - 'a' ] ++ ; if ( map1 == map2 ) return true ; } return false ; } }; 568. Maximum Vacation Days $\\star\\star\\star$ 569. Median Employee Salary $\\star\\star\\star$ 570. Managers with at Least 5 Direct Reports $\\star\\star$","title":"0561-0570"},{"location":"cpp/0501-0600/0561-0570/#561-array-partition-i-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int arrayPairSum ( vector < int >& nums ) { int ans = 0 ; sort ( nums . begin (), nums . end ()); for ( int i = 0 ; i < nums . size (); i += 2 ) ans += nums [ i ]; return ans ; } };","title":"561. Array Partition I $\\star$"},{"location":"cpp/0501-0600/0561-0570/#562-longest-line-of-consecutive-one-in-matrix-starstar","text":"","title":"562. Longest Line of Consecutive One in Matrix $\\star\\star$"},{"location":"cpp/0501-0600/0561-0570/#563-binary-tree-tilt-star","text":"","title":"563. Binary Tree Tilt $\\star$"},{"location":"cpp/0501-0600/0561-0570/#564-find-the-closest-palindrome-starstarstar","text":"","title":"564. Find the Closest Palindrome $\\star\\star\\star$"},{"location":"cpp/0501-0600/0561-0570/#565-array-nesting-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int arrayNesting ( vector < int >& nums ) { int ans = 0 ; for ( int num : nums ) { if ( num == - 1 ) continue ; int index = num ; int count = 0 ; while ( nums [ index ] != - 1 ) { int temp = index ; index = nums [ index ]; nums [ temp ] = - 1 ; count ++ ; } ans = max ( ans , count ); } return ans ; } };","title":"565. Array Nesting $\\star\\star$"},{"location":"cpp/0501-0600/0561-0570/#566-reshape-the-matrix-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < vector < int >> matrixReshape ( vector < vector < int >>& nums , int r , int c ) { if ( nums . empty () || r * c != nums . size () * nums [ 0 ]. size ()) return nums ; vector < vector < int >> ans ( r , vector < int > ( c )); int k = 0 ; for ( vector < int >& row : nums ) for ( int num : row ) { ans [ k / c ][ k % c ] = num ; k ++ ; } return ans ; } };","title":"566. Reshape the Matrix $\\star$"},{"location":"cpp/0501-0600/0561-0570/#567-permutation-in-string-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : bool checkInclusion ( string s1 , string s2 ) { const int m = s1 . length (); const int n = s2 . length (); vector < int > map1 ( 26 ); vector < int > map2 ( 26 ); for ( char c : s1 ) map1 [ c - 'a' ] ++ ; for ( int i = 0 ; i < n ; i ++ ) { if ( i >= m ) map2 [ s2 [ i - m ] - 'a' ] -- ; map2 [ s2 [ i ] - 'a' ] ++ ; if ( map1 == map2 ) return true ; } return false ; } };","title":"567. Permutation in String $\\star\\star$"},{"location":"cpp/0501-0600/0561-0570/#568-maximum-vacation-days-starstarstar","text":"","title":"568. Maximum Vacation Days $\\star\\star\\star$"},{"location":"cpp/0501-0600/0561-0570/#569-median-employee-salary-starstarstar","text":"","title":"569. Median Employee Salary $\\star\\star\\star$"},{"location":"cpp/0501-0600/0561-0570/#570-managers-with-at-least-5-direct-reports-starstar","text":"","title":"570. Managers with at Least 5 Direct Reports $\\star\\star$"},{"location":"cpp/0501-0600/0571-0580/","text":"571. Find Median Given Frequency of Numbers $\\star\\star\\star$ 572. Subtree of Another Tree $\\star$ 573. Squirrel Simulation $\\star\\star$ 574. Winning Candidate $\\star\\star$ 575. Distribute Candies $\\star$ 576. Out of Boundary Paths $\\star\\star$ 577. Employee Bonus $\\star$ 578. Get Highest Answer Rate Question $\\star\\star$ 579. Find Cumulative Salary of an Employee $\\star\\star\\star$ 580. Count Student Number in Departments $\\star\\star$","title":"0571-0580"},{"location":"cpp/0501-0600/0571-0580/#571-find-median-given-frequency-of-numbers-starstarstar","text":"","title":"571. Find Median Given Frequency of Numbers $\\star\\star\\star$"},{"location":"cpp/0501-0600/0571-0580/#572-subtree-of-another-tree-star","text":"","title":"572. Subtree of Another Tree $\\star$"},{"location":"cpp/0501-0600/0571-0580/#573-squirrel-simulation-starstar","text":"","title":"573. Squirrel Simulation $\\star\\star$"},{"location":"cpp/0501-0600/0571-0580/#574-winning-candidate-starstar","text":"","title":"574. Winning Candidate $\\star\\star$"},{"location":"cpp/0501-0600/0571-0580/#575-distribute-candies-star","text":"","title":"575. Distribute Candies $\\star$"},{"location":"cpp/0501-0600/0571-0580/#576-out-of-boundary-paths-starstar","text":"","title":"576. Out of Boundary Paths $\\star\\star$"},{"location":"cpp/0501-0600/0571-0580/#577-employee-bonus-star","text":"","title":"577. Employee Bonus $\\star$"},{"location":"cpp/0501-0600/0571-0580/#578-get-highest-answer-rate-question-starstar","text":"","title":"578. Get Highest Answer Rate Question $\\star\\star$"},{"location":"cpp/0501-0600/0571-0580/#579-find-cumulative-salary-of-an-employee-starstarstar","text":"","title":"579. Find Cumulative Salary of an Employee $\\star\\star\\star$"},{"location":"cpp/0501-0600/0571-0580/#580-count-student-number-in-departments-starstar","text":"","title":"580. Count Student Number in Departments $\\star\\star$"},{"location":"cpp/0501-0600/0581-0590/","text":"581. Shortest Unsorted Continuous Subarray $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int findUnsortedSubarray ( vector < int >& nums ) { int min = INT_MAX ; int max = INT_MIN ; bool flag = false ; for ( int i = 1 ; i < nums . size (); i ++ ) { if ( nums [ i ] < nums [ i - 1 ]) flag = true ; if ( flag ) min = std :: min ( min , nums [ i ]); } flag = false ; for ( int i = nums . size () - 2 ; i >= 0 ; i -- ) { if ( nums [ i ] > nums [ i + 1 ]) flag = true ; if ( flag ) max = std :: max ( max , nums [ i ]); } int l ; for ( l = 0 ; l < nums . size (); l ++ ) if ( nums [ l ] > min ) break ; int r ; for ( r = nums . size () - 1 ; r >= 0 ; r -- ) if ( nums [ r ] < max ) break ; return l > r ? 0 : r - l + 1 ; } }; 582. Kill Process $\\star\\star$ 583. Delete Operation for Two Strings $\\star\\star$ 584. Find Customer Referee $\\star$ 585. Investments in 2016 $\\star\\star$ 586. Customer Placing the Largest Number of Orders $\\star$ 587. Erect the Fence $\\star\\star\\star$ 588. Design In-Memory File System $\\star\\star\\star$ 589. N-ary Tree Preorder Traversal $\\star$ 590. N-ary Tree Postorder Traversal $\\star$","title":"0581-0590"},{"location":"cpp/0501-0600/0581-0590/#581-shortest-unsorted-continuous-subarray-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int findUnsortedSubarray ( vector < int >& nums ) { int min = INT_MAX ; int max = INT_MIN ; bool flag = false ; for ( int i = 1 ; i < nums . size (); i ++ ) { if ( nums [ i ] < nums [ i - 1 ]) flag = true ; if ( flag ) min = std :: min ( min , nums [ i ]); } flag = false ; for ( int i = nums . size () - 2 ; i >= 0 ; i -- ) { if ( nums [ i ] > nums [ i + 1 ]) flag = true ; if ( flag ) max = std :: max ( max , nums [ i ]); } int l ; for ( l = 0 ; l < nums . size (); l ++ ) if ( nums [ l ] > min ) break ; int r ; for ( r = nums . size () - 1 ; r >= 0 ; r -- ) if ( nums [ r ] < max ) break ; return l > r ? 0 : r - l + 1 ; } };","title":"581. Shortest Unsorted Continuous Subarray $\\star$"},{"location":"cpp/0501-0600/0581-0590/#582-kill-process-starstar","text":"","title":"582. Kill Process $\\star\\star$"},{"location":"cpp/0501-0600/0581-0590/#583-delete-operation-for-two-strings-starstar","text":"","title":"583. Delete Operation for Two Strings $\\star\\star$"},{"location":"cpp/0501-0600/0581-0590/#584-find-customer-referee-star","text":"","title":"584. Find Customer Referee $\\star$"},{"location":"cpp/0501-0600/0581-0590/#585-investments-in-2016-starstar","text":"","title":"585. Investments in 2016 $\\star\\star$"},{"location":"cpp/0501-0600/0581-0590/#586-customer-placing-the-largest-number-of-orders-star","text":"","title":"586. Customer Placing the Largest Number of Orders $\\star$"},{"location":"cpp/0501-0600/0581-0590/#587-erect-the-fence-starstarstar","text":"","title":"587. Erect the Fence $\\star\\star\\star$"},{"location":"cpp/0501-0600/0581-0590/#588-design-in-memory-file-system-starstarstar","text":"","title":"588. Design In-Memory File System $\\star\\star\\star$"},{"location":"cpp/0501-0600/0581-0590/#589-n-ary-tree-preorder-traversal-star","text":"","title":"589. N-ary Tree Preorder Traversal $\\star$"},{"location":"cpp/0501-0600/0581-0590/#590-n-ary-tree-postorder-traversal-star","text":"","title":"590. N-ary Tree Postorder Traversal $\\star$"},{"location":"cpp/0501-0600/0591-0600/","text":"591. Tag Validator $\\star\\star\\star$ 592. Fraction Addition and Subtraction $\\star\\star$ 593. Valid Square $\\star\\star$ 594. Longest Harmonious Subsequence $\\star$ 595. Big Countries $\\star$ 596. Classes More Than 5 Students $\\star$ 597. Friend Requests I: Overall Acceptance Rate $\\star$ 598. Range Addition II $\\star$ 599. Minimum Index Sum of Two Lists $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < string > findRestaurant ( vector < string >& list1 , vector < string >& list2 ) { vector < string > ans ; unordered_map < string , int > map ; for ( int i = 0 ; i < list1 . size (); i ++ ) map [ list1 [ i ]] = i ; int min = INT_MAX ; for ( int i = 0 ; i < list2 . size (); i ++ ) { if ( ! map . count ( list2 [ i ])) continue ; int sum = map [ list2 [ i ]] + i ; if ( sum < min ) ans . clear (); if ( sum <= min ) { min = sum ; ans . push_back ( list2 [ i ]); } } return ans ; } }; 600. Non-negative Integers without Consecutive Ones $\\star\\star\\star$","title":"0591-0600"},{"location":"cpp/0501-0600/0591-0600/#591-tag-validator-starstarstar","text":"","title":"591. Tag Validator $\\star\\star\\star$"},{"location":"cpp/0501-0600/0591-0600/#592-fraction-addition-and-subtraction-starstar","text":"","title":"592. Fraction Addition and Subtraction $\\star\\star$"},{"location":"cpp/0501-0600/0591-0600/#593-valid-square-starstar","text":"","title":"593. Valid Square $\\star\\star$"},{"location":"cpp/0501-0600/0591-0600/#594-longest-harmonious-subsequence-star","text":"","title":"594. Longest Harmonious Subsequence $\\star$"},{"location":"cpp/0501-0600/0591-0600/#595-big-countries-star","text":"","title":"595. Big Countries $\\star$"},{"location":"cpp/0501-0600/0591-0600/#596-classes-more-than-5-students-star","text":"","title":"596. Classes More Than 5 Students $\\star$"},{"location":"cpp/0501-0600/0591-0600/#597-friend-requests-i-overall-acceptance-rate-star","text":"","title":"597. Friend Requests I: Overall Acceptance Rate $\\star$"},{"location":"cpp/0501-0600/0591-0600/#598-range-addition-ii-star","text":"","title":"598. Range Addition II $\\star$"},{"location":"cpp/0501-0600/0591-0600/#599-minimum-index-sum-of-two-lists-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < string > findRestaurant ( vector < string >& list1 , vector < string >& list2 ) { vector < string > ans ; unordered_map < string , int > map ; for ( int i = 0 ; i < list1 . size (); i ++ ) map [ list1 [ i ]] = i ; int min = INT_MAX ; for ( int i = 0 ; i < list2 . size (); i ++ ) { if ( ! map . count ( list2 [ i ])) continue ; int sum = map [ list2 [ i ]] + i ; if ( sum < min ) ans . clear (); if ( sum <= min ) { min = sum ; ans . push_back ( list2 [ i ]); } } return ans ; } };","title":"599. Minimum Index Sum of Two Lists $\\star$"},{"location":"cpp/0501-0600/0591-0600/#600-non-negative-integers-without-consecutive-ones-starstarstar","text":"","title":"600. Non-negative Integers without Consecutive Ones $\\star\\star\\star$"},{"location":"cpp/0601-0700/0601-0610/","text":"601. Human Traffic of Stadium $\\star\\star\\star$ 602. Friend Requests II: Who Has the Most Friends $\\star\\star$ 603. Consecutive Available Seats $\\star$ 604. Design Compressed String Iterator $\\star$ 605. Can Place Flowers $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool canPlaceFlowers ( vector < int >& flowerbed , int n ) { for ( int i = 0 ; i < flowerbed . size (); i ++ ) { if ( flowerbed [ i ] == 0 && ( i == 0 || flowerbed [ i - 1 ] == 0 ) && ( i == flowerbed . size () - 1 || flowerbed [ i + 1 ] == 0 )) { flowerbed [ i ] = 1 ; n -- ; } if ( n <= 0 ) return true ; } return false ; } }; 606. Construct String from Binary Tree $\\star$ 607. Sales Person $\\star$ 608. Tree Node $\\star\\star$ 609. Find Duplicate File in System $\\star\\star$ 610. Triangle Judgement $\\star$","title":"0601-0610"},{"location":"cpp/0601-0700/0601-0610/#601-human-traffic-of-stadium-starstarstar","text":"","title":"601. Human Traffic of Stadium $\\star\\star\\star$"},{"location":"cpp/0601-0700/0601-0610/#602-friend-requests-ii-who-has-the-most-friends-starstar","text":"","title":"602. Friend Requests II: Who Has the Most Friends $\\star\\star$"},{"location":"cpp/0601-0700/0601-0610/#603-consecutive-available-seats-star","text":"","title":"603. Consecutive Available Seats $\\star$"},{"location":"cpp/0601-0700/0601-0610/#604-design-compressed-string-iterator-star","text":"","title":"604. Design Compressed String Iterator $\\star$"},{"location":"cpp/0601-0700/0601-0610/#605-can-place-flowers-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool canPlaceFlowers ( vector < int >& flowerbed , int n ) { for ( int i = 0 ; i < flowerbed . size (); i ++ ) { if ( flowerbed [ i ] == 0 && ( i == 0 || flowerbed [ i - 1 ] == 0 ) && ( i == flowerbed . size () - 1 || flowerbed [ i + 1 ] == 0 )) { flowerbed [ i ] = 1 ; n -- ; } if ( n <= 0 ) return true ; } return false ; } };","title":"605. Can Place Flowers $\\star$"},{"location":"cpp/0601-0700/0601-0610/#606-construct-string-from-binary-tree-star","text":"","title":"606. Construct String from Binary Tree $\\star$"},{"location":"cpp/0601-0700/0601-0610/#607-sales-person-star","text":"","title":"607. Sales Person $\\star$"},{"location":"cpp/0601-0700/0601-0610/#608-tree-node-starstar","text":"","title":"608. Tree Node $\\star\\star$"},{"location":"cpp/0601-0700/0601-0610/#609-find-duplicate-file-in-system-starstar","text":"","title":"609. Find Duplicate File in System $\\star\\star$"},{"location":"cpp/0601-0700/0601-0610/#610-triangle-judgement-star","text":"","title":"610. Triangle Judgement $\\star$"},{"location":"cpp/0601-0700/0611-0620/","text":"611. Valid Triangle Number $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int triangleNumber ( vector < int >& nums ) { int ans = 0 ; sort ( nums . begin (), nums . end ()); for ( int k = nums . size () - 1 ; k > 1 ; k -- ) for ( int i = 0 , j = k - 1 ; i < j ;) { if ( nums [ i ] + nums [ j ] > nums [ k ]) { ans += j - i ; j -- ; } else i ++ ; } return ans ; } }; 612. Shortest Distance in a Plane $\\star\\star$ 613. Shortest Distance in a Line $\\star$ 614. Second Degree Follower $\\star\\star$ 615. Average Salary: Departments VS Company $\\star\\star\\star$ 616. Add Bold Tag in String $\\star\\star$ 617. Merge Two Binary Trees $\\star$ 618. Students Report By Geography $\\star\\star\\star$ 619. Biggest Single Number $\\star$ 620. Not Boring Movies $\\star$","title":"0611-0620"},{"location":"cpp/0601-0700/0611-0620/#611-valid-triangle-number-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int triangleNumber ( vector < int >& nums ) { int ans = 0 ; sort ( nums . begin (), nums . end ()); for ( int k = nums . size () - 1 ; k > 1 ; k -- ) for ( int i = 0 , j = k - 1 ; i < j ;) { if ( nums [ i ] + nums [ j ] > nums [ k ]) { ans += j - i ; j -- ; } else i ++ ; } return ans ; } };","title":"611. Valid Triangle Number $\\star\\star$"},{"location":"cpp/0601-0700/0611-0620/#612-shortest-distance-in-a-plane-starstar","text":"","title":"612. Shortest Distance in a Plane $\\star\\star$"},{"location":"cpp/0601-0700/0611-0620/#613-shortest-distance-in-a-line-star","text":"","title":"613. Shortest Distance in a Line $\\star$"},{"location":"cpp/0601-0700/0611-0620/#614-second-degree-follower-starstar","text":"","title":"614. Second Degree Follower $\\star\\star$"},{"location":"cpp/0601-0700/0611-0620/#615-average-salary-departments-vs-company-starstarstar","text":"","title":"615. Average Salary: Departments VS Company $\\star\\star\\star$"},{"location":"cpp/0601-0700/0611-0620/#616-add-bold-tag-in-string-starstar","text":"","title":"616. Add Bold Tag in String $\\star\\star$"},{"location":"cpp/0601-0700/0611-0620/#617-merge-two-binary-trees-star","text":"","title":"617. Merge Two Binary Trees $\\star$"},{"location":"cpp/0601-0700/0611-0620/#618-students-report-by-geography-starstarstar","text":"","title":"618. Students Report By Geography $\\star\\star\\star$"},{"location":"cpp/0601-0700/0611-0620/#619-biggest-single-number-star","text":"","title":"619. Biggest Single Number $\\star$"},{"location":"cpp/0601-0700/0611-0620/#620-not-boring-movies-star","text":"","title":"620. Not Boring Movies $\\star$"},{"location":"cpp/0601-0700/0621-0630/","text":"621. Task Scheduler $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int leastInterval ( vector < char >& tasks , int n ) { vector < int > count ( 26 , 0 ); for ( char task : tasks ) count [ task - 'A' ] ++ ; const int maxCount = * max_element ( count . begin (), count . end ()); int ans = ( maxCount - 1 ) * ( n + 1 ); ans += count_if ( count . begin (), count . end (), [ maxCount ]( int freq ) { return freq == maxCount ; }); return max ( ans , ( int ) tasks . size ()); } }; 622. Design Circular Queue $\\star\\star$ 623. Add One Row to Tree $\\star\\star$ 624. Maximum Distance in Arrays $\\star$ 625. Minimum Factorization $\\star\\star$ 626. Exchange Seats $\\star\\star$ 627. Swap Salary $\\star$ 628. Maximum Product of Three Numbers $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int maximumProduct ( vector < int >& nums ) { int min = INT_MAX ; int secondMin = INT_MAX ; int max = INT_MIN ; int secondMax = INT_MIN ; int thirdMax = INT_MIN ; for ( int num : nums ) { if ( num <= min ) { secondMin = min ; min = num ; } else if ( num <= secondMin ) secondMin = num ; if ( num >= max ) { thirdMax = secondMax ; secondMax = max ; max = num ; } else if ( num >= secondMax ) { thirdMax = secondMax ; secondMax = num ; } else if ( num >= thirdMax ) thirdMax = num ; } return std :: max ( min * secondMin * max , max * secondMax * thirdMax ); } }; 629. K Inverse Pairs Array $\\star\\star\\star$ 630. Course Schedule III $\\star\\star\\star$","title":"0621-0630"},{"location":"cpp/0601-0700/0621-0630/#621-task-scheduler-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int leastInterval ( vector < char >& tasks , int n ) { vector < int > count ( 26 , 0 ); for ( char task : tasks ) count [ task - 'A' ] ++ ; const int maxCount = * max_element ( count . begin (), count . end ()); int ans = ( maxCount - 1 ) * ( n + 1 ); ans += count_if ( count . begin (), count . end (), [ maxCount ]( int freq ) { return freq == maxCount ; }); return max ( ans , ( int ) tasks . size ()); } };","title":"621. Task Scheduler $\\star\\star$"},{"location":"cpp/0601-0700/0621-0630/#622-design-circular-queue-starstar","text":"","title":"622. Design Circular Queue $\\star\\star$"},{"location":"cpp/0601-0700/0621-0630/#623-add-one-row-to-tree-starstar","text":"","title":"623. Add One Row to Tree $\\star\\star$"},{"location":"cpp/0601-0700/0621-0630/#624-maximum-distance-in-arrays-star","text":"","title":"624. Maximum Distance in Arrays $\\star$"},{"location":"cpp/0601-0700/0621-0630/#625-minimum-factorization-starstar","text":"","title":"625. Minimum Factorization $\\star\\star$"},{"location":"cpp/0601-0700/0621-0630/#626-exchange-seats-starstar","text":"","title":"626. Exchange Seats $\\star\\star$"},{"location":"cpp/0601-0700/0621-0630/#627-swap-salary-star","text":"","title":"627. Swap Salary $\\star$"},{"location":"cpp/0601-0700/0621-0630/#628-maximum-product-of-three-numbers-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int maximumProduct ( vector < int >& nums ) { int min = INT_MAX ; int secondMin = INT_MAX ; int max = INT_MIN ; int secondMax = INT_MIN ; int thirdMax = INT_MIN ; for ( int num : nums ) { if ( num <= min ) { secondMin = min ; min = num ; } else if ( num <= secondMin ) secondMin = num ; if ( num >= max ) { thirdMax = secondMax ; secondMax = max ; max = num ; } else if ( num >= secondMax ) { thirdMax = secondMax ; secondMax = num ; } else if ( num >= thirdMax ) thirdMax = num ; } return std :: max ( min * secondMin * max , max * secondMax * thirdMax ); } };","title":"628. Maximum Product of Three Numbers $\\star$"},{"location":"cpp/0601-0700/0621-0630/#629-k-inverse-pairs-array-starstarstar","text":"","title":"629. K Inverse Pairs Array $\\star\\star\\star$"},{"location":"cpp/0601-0700/0621-0630/#630-course-schedule-iii-starstarstar","text":"","title":"630. Course Schedule III $\\star\\star\\star$"},{"location":"cpp/0601-0700/0631-0640/","text":"631. Design Excel Sum Formula $\\star\\star\\star$ 632. Smallest Range Covering Elements from K Lists $\\star\\star\\star$ 633. Sum of Square Numbers $\\star$ 634. Find the Derangement of An Array $\\star\\star$ 635. Design Log Storage System $\\star\\star$ 636. Exclusive Time of Functions $\\star\\star$ 637. Average of Levels in Binary Tree $\\star$ 638. Shopping Offers $\\star\\star$ 639. Decode Ways II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : int numDecodings ( string s ) { if ( s . empty ()) return 0 ; long dp1 = count ( s [ 0 ]); long dp2 = 1 ; for ( int i = 1 ; i < s . length (); i ++ ) { long dp = count ( s [ i ]) * dp1 + count ( s [ i - 1 ], s [ i ]) * dp2 ; dp %= int ( 1e9 + 7 ); dp2 = dp1 ; dp1 = dp ; } return dp1 ; } private : int count ( char c ) { if ( c == '*' ) return 9 ; return c != '0' ; } int count ( char c1 , char c2 ) { if ( c1 == '*' && c2 == '*' ) return 15 ; if ( c1 == '*' ) return ( c2 >= '0' && c2 <= '6' ) ? 2 : 1 ; if ( c2 == '*' ) { if ( c1 == '1' ) return 9 ; if ( c1 == '2' ) return 6 ; return 0 ; } return c1 == '1' || ( c1 == '2' && c2 <= '6' ); } }; 640. Solve the Equation $\\star\\star$","title":"0631-0640"},{"location":"cpp/0601-0700/0631-0640/#631-design-excel-sum-formula-starstarstar","text":"","title":"631. Design Excel Sum Formula $\\star\\star\\star$"},{"location":"cpp/0601-0700/0631-0640/#632-smallest-range-covering-elements-from-k-lists-starstarstar","text":"","title":"632. Smallest Range Covering Elements from K Lists $\\star\\star\\star$"},{"location":"cpp/0601-0700/0631-0640/#633-sum-of-square-numbers-star","text":"","title":"633. Sum of Square Numbers $\\star$"},{"location":"cpp/0601-0700/0631-0640/#634-find-the-derangement-of-an-array-starstar","text":"","title":"634. Find the Derangement of An Array $\\star\\star$"},{"location":"cpp/0601-0700/0631-0640/#635-design-log-storage-system-starstar","text":"","title":"635. Design Log Storage System $\\star\\star$"},{"location":"cpp/0601-0700/0631-0640/#636-exclusive-time-of-functions-starstar","text":"","title":"636. Exclusive Time of Functions $\\star\\star$"},{"location":"cpp/0601-0700/0631-0640/#637-average-of-levels-in-binary-tree-star","text":"","title":"637. Average of Levels in Binary Tree $\\star$"},{"location":"cpp/0601-0700/0631-0640/#638-shopping-offers-starstar","text":"","title":"638. Shopping Offers $\\star\\star$"},{"location":"cpp/0601-0700/0631-0640/#639-decode-ways-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public : int numDecodings ( string s ) { if ( s . empty ()) return 0 ; long dp1 = count ( s [ 0 ]); long dp2 = 1 ; for ( int i = 1 ; i < s . length (); i ++ ) { long dp = count ( s [ i ]) * dp1 + count ( s [ i - 1 ], s [ i ]) * dp2 ; dp %= int ( 1e9 + 7 ); dp2 = dp1 ; dp1 = dp ; } return dp1 ; } private : int count ( char c ) { if ( c == '*' ) return 9 ; return c != '0' ; } int count ( char c1 , char c2 ) { if ( c1 == '*' && c2 == '*' ) return 15 ; if ( c1 == '*' ) return ( c2 >= '0' && c2 <= '6' ) ? 2 : 1 ; if ( c2 == '*' ) { if ( c1 == '1' ) return 9 ; if ( c1 == '2' ) return 6 ; return 0 ; } return c1 == '1' || ( c1 == '2' && c2 <= '6' ); } };","title":"639. Decode Ways II $\\star\\star\\star$"},{"location":"cpp/0601-0700/0631-0640/#640-solve-the-equation-starstar","text":"","title":"640. Solve the Equation $\\star\\star$"},{"location":"cpp/0601-0700/0641-0650/","text":"641. Design Circular Deque $\\star\\star$ 642. Design Search Autocomplete System $\\star\\star\\star$ 643. Maximum Average Subarray I $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : double findMaxAverage ( vector < int >& nums , int k ) { double sum = accumulate ( nums . begin (), nums . begin () + k , 0 ); double ans = sum ; for ( int i = k ; i < nums . size (); i ++ ) { sum += nums [ i ] - nums [ i - k ]; ans = max ( ans , sum ); } return ans / k ; } }; 644. Maximum Average Subarray II $\\star\\star\\star$ 645. Set Mismatch $\\star$ 646. Maximum Length of Pair Chain $\\star\\star$ 647. Palindromic Substrings $\\star\\star$ 648. Replace Words $\\star\\star$ 649. Dota2 Senate $\\star\\star$ 650. 2 Keys Keyboard $\\star\\star$","title":"0641-0650"},{"location":"cpp/0601-0700/0641-0650/#641-design-circular-deque-starstar","text":"","title":"641. Design Circular Deque $\\star\\star$"},{"location":"cpp/0601-0700/0641-0650/#642-design-search-autocomplete-system-starstarstar","text":"","title":"642. Design Search Autocomplete System $\\star\\star\\star$"},{"location":"cpp/0601-0700/0641-0650/#643-maximum-average-subarray-i-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : double findMaxAverage ( vector < int >& nums , int k ) { double sum = accumulate ( nums . begin (), nums . begin () + k , 0 ); double ans = sum ; for ( int i = k ; i < nums . size (); i ++ ) { sum += nums [ i ] - nums [ i - k ]; ans = max ( ans , sum ); } return ans / k ; } };","title":"643. Maximum Average Subarray I $\\star$"},{"location":"cpp/0601-0700/0641-0650/#644-maximum-average-subarray-ii-starstarstar","text":"","title":"644. Maximum Average Subarray II $\\star\\star\\star$"},{"location":"cpp/0601-0700/0641-0650/#645-set-mismatch-star","text":"","title":"645. Set Mismatch $\\star$"},{"location":"cpp/0601-0700/0641-0650/#646-maximum-length-of-pair-chain-starstar","text":"","title":"646. Maximum Length of Pair Chain $\\star\\star$"},{"location":"cpp/0601-0700/0641-0650/#647-palindromic-substrings-starstar","text":"","title":"647. Palindromic Substrings $\\star\\star$"},{"location":"cpp/0601-0700/0641-0650/#648-replace-words-starstar","text":"","title":"648. Replace Words $\\star\\star$"},{"location":"cpp/0601-0700/0641-0650/#649-dota2-senate-starstar","text":"","title":"649. Dota2 Senate $\\star\\star$"},{"location":"cpp/0601-0700/0641-0650/#650-2-keys-keyboard-starstar","text":"","title":"650. 2 Keys Keyboard $\\star\\star$"},{"location":"cpp/0601-0700/0651-0660/","text":"651. 4 Keys Keyboard $\\star\\star$ 652. Find Duplicate Subtrees $\\star\\star$ 653. Two Sum IV - Input is a BST $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : bool findTarget ( TreeNode * root , int k ) { vector < int > nums ; inorder ( root , nums ); int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int sum = nums [ l ] + nums [ r ]; if ( sum == k ) return true ; if ( sum < k ) l ++ ; else r -- ; } return false ; } void inorder ( TreeNode * root , vector < int >& nums ) { if ( ! root ) return ; inorder ( root -> left , nums ); nums . push_back ( root -> val ); inorder ( root -> right , nums ); } }; 654. Maximum Binary Tree $\\star\\star$ 655. Print Binary Tree $\\star\\star$ 656. Coin Path $\\star\\star\\star$ 657. Robot Return to Origin $\\star$ 658. Find K Closest Elements $\\star\\star$ 659. Split Array into Consecutive Subsequences $\\star\\star$ 660. Remove 9 $\\star\\star\\star$","title":"0651-0660"},{"location":"cpp/0601-0700/0651-0660/#651-4-keys-keyboard-starstar","text":"","title":"651. 4 Keys Keyboard $\\star\\star$"},{"location":"cpp/0601-0700/0651-0660/#652-find-duplicate-subtrees-starstar","text":"","title":"652. Find Duplicate Subtrees $\\star\\star$"},{"location":"cpp/0601-0700/0651-0660/#653-two-sum-iv-input-is-a-bst-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : bool findTarget ( TreeNode * root , int k ) { vector < int > nums ; inorder ( root , nums ); int l = 0 ; int r = nums . size () - 1 ; while ( l < r ) { int sum = nums [ l ] + nums [ r ]; if ( sum == k ) return true ; if ( sum < k ) l ++ ; else r -- ; } return false ; } void inorder ( TreeNode * root , vector < int >& nums ) { if ( ! root ) return ; inorder ( root -> left , nums ); nums . push_back ( root -> val ); inorder ( root -> right , nums ); } };","title":"653. Two Sum IV - Input is a BST $\\star$"},{"location":"cpp/0601-0700/0651-0660/#654-maximum-binary-tree-starstar","text":"","title":"654. Maximum Binary Tree $\\star\\star$"},{"location":"cpp/0601-0700/0651-0660/#655-print-binary-tree-starstar","text":"","title":"655. Print Binary Tree $\\star\\star$"},{"location":"cpp/0601-0700/0651-0660/#656-coin-path-starstarstar","text":"","title":"656. Coin Path $\\star\\star\\star$"},{"location":"cpp/0601-0700/0651-0660/#657-robot-return-to-origin-star","text":"","title":"657. Robot Return to Origin $\\star$"},{"location":"cpp/0601-0700/0651-0660/#658-find-k-closest-elements-starstar","text":"","title":"658. Find K Closest Elements $\\star\\star$"},{"location":"cpp/0601-0700/0651-0660/#659-split-array-into-consecutive-subsequences-starstar","text":"","title":"659. Split Array into Consecutive Subsequences $\\star\\star$"},{"location":"cpp/0601-0700/0651-0660/#660-remove-9-starstarstar","text":"","title":"660. Remove 9 $\\star\\star\\star$"},{"location":"cpp/0601-0700/0661-0670/","text":"661. Image Smoother $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < vector < int >> imageSmoother ( vector < vector < int >>& M ) { const int m = M . size (); const int n = M [ 0 ]. size (); vector < vector < int >> ans ( m , vector < int > ( n )); for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int ones = 0 ; int count = 0 ; for ( int y = max ( 0 , i - 1 ); y < min ( m , i + 2 ); y ++ ) for ( int x = max ( 0 , j - 1 ); x < min ( n , j + 2 ); x ++ ) { ones += M [ y ][ x ]; count ++ ; } ans [ i ][ j ] = ones / count ; } return ans ; } }; 662. Maximum Width of Binary Tree $\\star\\star$ 663. Equal Tree Partition $\\star\\star$ 664. Strange Printer $\\star\\star\\star$ 665. Non-decreasing Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool checkPossibility ( vector < int >& nums ) { int j = - 1 ; for ( int i = 0 ; i + 1 < nums . size (); i ++ ) if ( nums [ i ] > nums [ i + 1 ]) { if ( j != - 1 ) return false ; j = i ; } return j == - 1 || j == 0 || j == nums . size () - 2 || nums [ j - 1 ] <= nums [ j + 1 ] || nums [ j ] <= nums [ j + 2 ]; } }; 666. Path Sum IV $\\star\\star$ 667. Beautiful Arrangement II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > constructArray ( int n , int k ) { vector < int > ans ; for ( int i = 0 ; i < n - k ; i ++ ) ans . push_back ( i + 1 ); for ( int i = 0 ; i < k ; i ++ ) { if ( i % 2 == 0 ) ans . push_back ( n - i / 2 ); else ans . push_back ( n - k + ( i + 1 ) / 2 ); } return ans ; } }; 668. Kth Smallest Number in Multiplication Table $\\star\\star\\star$ 669. Trim a Binary Search Tree $\\star$ 670. Maximum Swap $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int maximumSwap ( int num ) { string s = to_string ( num ); unordered_map < char , int > map ; for ( int i = 0 ; i < s . length (); i ++ ) map [ s [ i ]] = i ; for ( int i = 0 ; i < s . length (); i ++ ) for ( char digit = '9' ; digit > s [ i ]; digit -- ) if ( map [ digit ] > i ) { s [ map [ digit ]] = s [ i ]; s [ i ] = digit ; return stoi ( s ); } return num ; } };","title":"0661-0670"},{"location":"cpp/0601-0700/0661-0670/#661-image-smoother-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < vector < int >> imageSmoother ( vector < vector < int >>& M ) { const int m = M . size (); const int n = M [ 0 ]. size (); vector < vector < int >> ans ( m , vector < int > ( n )); for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { int ones = 0 ; int count = 0 ; for ( int y = max ( 0 , i - 1 ); y < min ( m , i + 2 ); y ++ ) for ( int x = max ( 0 , j - 1 ); x < min ( n , j + 2 ); x ++ ) { ones += M [ y ][ x ]; count ++ ; } ans [ i ][ j ] = ones / count ; } return ans ; } };","title":"661. Image Smoother $\\star$"},{"location":"cpp/0601-0700/0661-0670/#662-maximum-width-of-binary-tree-starstar","text":"","title":"662. Maximum Width of Binary Tree $\\star\\star$"},{"location":"cpp/0601-0700/0661-0670/#663-equal-tree-partition-starstar","text":"","title":"663. Equal Tree Partition $\\star\\star$"},{"location":"cpp/0601-0700/0661-0670/#664-strange-printer-starstarstar","text":"","title":"664. Strange Printer $\\star\\star\\star$"},{"location":"cpp/0601-0700/0661-0670/#665-non-decreasing-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool checkPossibility ( vector < int >& nums ) { int j = - 1 ; for ( int i = 0 ; i + 1 < nums . size (); i ++ ) if ( nums [ i ] > nums [ i + 1 ]) { if ( j != - 1 ) return false ; j = i ; } return j == - 1 || j == 0 || j == nums . size () - 2 || nums [ j - 1 ] <= nums [ j + 1 ] || nums [ j ] <= nums [ j + 2 ]; } };","title":"665. Non-decreasing Array $\\star$"},{"location":"cpp/0601-0700/0661-0670/#666-path-sum-iv-starstar","text":"","title":"666. Path Sum IV $\\star\\star$"},{"location":"cpp/0601-0700/0661-0670/#667-beautiful-arrangement-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > constructArray ( int n , int k ) { vector < int > ans ; for ( int i = 0 ; i < n - k ; i ++ ) ans . push_back ( i + 1 ); for ( int i = 0 ; i < k ; i ++ ) { if ( i % 2 == 0 ) ans . push_back ( n - i / 2 ); else ans . push_back ( n - k + ( i + 1 ) / 2 ); } return ans ; } };","title":"667. Beautiful Arrangement II $\\star\\star$"},{"location":"cpp/0601-0700/0661-0670/#668-kth-smallest-number-in-multiplication-table-starstarstar","text":"","title":"668. Kth Smallest Number in Multiplication Table $\\star\\star\\star$"},{"location":"cpp/0601-0700/0661-0670/#669-trim-a-binary-search-tree-star","text":"","title":"669. Trim a Binary Search Tree $\\star$"},{"location":"cpp/0601-0700/0661-0670/#670-maximum-swap-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int maximumSwap ( int num ) { string s = to_string ( num ); unordered_map < char , int > map ; for ( int i = 0 ; i < s . length (); i ++ ) map [ s [ i ]] = i ; for ( int i = 0 ; i < s . length (); i ++ ) for ( char digit = '9' ; digit > s [ i ]; digit -- ) if ( map [ digit ] > i ) { s [ map [ digit ]] = s [ i ]; s [ i ] = digit ; return stoi ( s ); } return num ; } };","title":"670. Maximum Swap $\\star\\star$"},{"location":"cpp/0601-0700/0671-0680/","text":"671. Second Minimum Node In a Binary Tree $\\star$ 672. Bulb Switcher II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int flipLights ( int n , int m ) { n = min ( n , 3 ); if ( m == 0 ) return 1 ; if ( m == 1 ) return n == 1 ? 2 : n == 2 ? 3 : 4 ; if ( m == 2 ) return n == 1 ? 2 : n == 2 ? 4 : 7 ; return n == 1 ? 2 : n == 2 ? 4 : 8 ; } }; 673. Number of Longest Increasing Subsequence $\\star\\star$ 674. Longest Continuous Increasing Subsequence $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int findLengthOfLCIS ( vector < int >& nums ) { int ans = 0 ; int j = 0 ; for ( int i = 0 ; i < nums . size (); i ++ ) { if ( i > 0 && nums [ i ] <= nums [ i - 1 ]) j = i ; ans = max ( ans , i - j + 1 ); } return ans ; } }; 675. Cut Off Trees for Golf Event $\\star\\star\\star$ 676. Implement Magic Dictionary $\\star\\star$ 677. Map Sum Pairs $\\star\\star$ 678. Valid Parenthesis String $\\star\\star$ 679. 24 Game $\\star\\star\\star$ 680. Valid Palindrome II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool validPalindrome ( string s ) { const int n = s . length (); for ( int i = 0 ; i < n / 2 ; i ++ ) if ( s [ i ] != s [ n - 1 - i ]) return validPalindrome ( s , i + 1 , n - 1 - i ) || validPalindrome ( s , i , n - 2 - i ); return true ; } private : bool validPalindrome ( string & s , int l , int r ) { for ( int i = l ; i <= l + ( r - l ) / 2 ; i ++ ) if ( s [ i ] != s [ r - i + l ]) return false ; return true ; } };","title":"0671-0680"},{"location":"cpp/0601-0700/0671-0680/#671-second-minimum-node-in-a-binary-tree-star","text":"","title":"671. Second Minimum Node In a Binary Tree $\\star$"},{"location":"cpp/0601-0700/0671-0680/#672-bulb-switcher-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : int flipLights ( int n , int m ) { n = min ( n , 3 ); if ( m == 0 ) return 1 ; if ( m == 1 ) return n == 1 ? 2 : n == 2 ? 3 : 4 ; if ( m == 2 ) return n == 1 ? 2 : n == 2 ? 4 : 7 ; return n == 1 ? 2 : n == 2 ? 4 : 8 ; } };","title":"672. Bulb Switcher II $\\star\\star$"},{"location":"cpp/0601-0700/0671-0680/#673-number-of-longest-increasing-subsequence-starstar","text":"","title":"673. Number of Longest Increasing Subsequence $\\star\\star$"},{"location":"cpp/0601-0700/0671-0680/#674-longest-continuous-increasing-subsequence-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int findLengthOfLCIS ( vector < int >& nums ) { int ans = 0 ; int j = 0 ; for ( int i = 0 ; i < nums . size (); i ++ ) { if ( i > 0 && nums [ i ] <= nums [ i - 1 ]) j = i ; ans = max ( ans , i - j + 1 ); } return ans ; } };","title":"674. Longest Continuous Increasing Subsequence $\\star$"},{"location":"cpp/0601-0700/0671-0680/#675-cut-off-trees-for-golf-event-starstarstar","text":"","title":"675. Cut Off Trees for Golf Event $\\star\\star\\star$"},{"location":"cpp/0601-0700/0671-0680/#676-implement-magic-dictionary-starstar","text":"","title":"676. Implement Magic Dictionary $\\star\\star$"},{"location":"cpp/0601-0700/0671-0680/#677-map-sum-pairs-starstar","text":"","title":"677. Map Sum Pairs $\\star\\star$"},{"location":"cpp/0601-0700/0671-0680/#678-valid-parenthesis-string-starstar","text":"","title":"678. Valid Parenthesis String $\\star\\star$"},{"location":"cpp/0601-0700/0671-0680/#679-24-game-starstarstar","text":"","title":"679. 24 Game $\\star\\star\\star$"},{"location":"cpp/0601-0700/0671-0680/#680-valid-palindrome-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : bool validPalindrome ( string s ) { const int n = s . length (); for ( int i = 0 ; i < n / 2 ; i ++ ) if ( s [ i ] != s [ n - 1 - i ]) return validPalindrome ( s , i + 1 , n - 1 - i ) || validPalindrome ( s , i , n - 2 - i ); return true ; } private : bool validPalindrome ( string & s , int l , int r ) { for ( int i = l ; i <= l + ( r - l ) / 2 ; i ++ ) if ( s [ i ] != s [ r - i + l ]) return false ; return true ; } };","title":"680. Valid Palindrome II $\\star$"},{"location":"cpp/0601-0700/0681-0690/","text":"681. Next Closest Time $\\star\\star$ 682. Baseball Game $\\star$ 683. K Empty Slots $\\star\\star\\star$ 684. Redundant Connection $\\star\\star$ 685. Redundant Connection II $\\star\\star\\star$ 686. Repeated String Match $\\star$ 687. Longest Univalue Path $\\star$ 688. Knight Probability in Chessboard $\\star\\star$ 689. Maximum Sum of 3 Non-Overlapping Subarrays $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : vector < int > maxSumOfThreeSubarrays ( vector < int >& nums , int k ) { vector < int > ans = { - 1 , - 1 , - 1 }; int subarrayCount = nums . size () - k + 1 ; vector < int > dp ( subarrayCount ); int sum = 0 ; for ( int i = 0 ; i < nums . size (); i ++ ) { sum += nums [ i ]; if ( i >= k ) sum -= nums [ i - k ]; if ( i >= k - 1 ) dp [ i - k + 1 ] = sum ; } vector < int > left ( subarrayCount ); int maxIndex = 0 ; for ( int i = 0 ; i < subarrayCount ; i ++ ) { if ( dp [ i ] > dp [ maxIndex ]) maxIndex = i ; left [ i ] = maxIndex ; } vector < int > right ( subarrayCount ); maxIndex = subarrayCount - 1 ; for ( int i = subarrayCount - 1 ; i >= 0 ; i -- ) { if ( dp [ i ] >= dp [ maxIndex ]) maxIndex = i ; right [ i ] = maxIndex ; } for ( int i = k ; i < subarrayCount - k ; i ++ ) if ( ans [ 0 ] == - 1 || dp [ left [ i - k ]] + dp [ i ] + dp [ right [ i + k ]] > dp [ ans [ 0 ]] + dp [ ans [ 1 ]] + dp [ ans [ 2 ]]) ans = { left [ i - k ], i , right [ i + k ]}; return ans ; } }; 690. Employee Importance $\\star$","title":"0681-0690"},{"location":"cpp/0601-0700/0681-0690/#681-next-closest-time-starstar","text":"","title":"681. Next Closest Time $\\star\\star$"},{"location":"cpp/0601-0700/0681-0690/#682-baseball-game-star","text":"","title":"682. Baseball Game $\\star$"},{"location":"cpp/0601-0700/0681-0690/#683-k-empty-slots-starstarstar","text":"","title":"683. K Empty Slots $\\star\\star\\star$"},{"location":"cpp/0601-0700/0681-0690/#684-redundant-connection-starstar","text":"","title":"684. Redundant Connection $\\star\\star$"},{"location":"cpp/0601-0700/0681-0690/#685-redundant-connection-ii-starstarstar","text":"","title":"685. Redundant Connection II $\\star\\star\\star$"},{"location":"cpp/0601-0700/0681-0690/#686-repeated-string-match-star","text":"","title":"686. Repeated String Match $\\star$"},{"location":"cpp/0601-0700/0681-0690/#687-longest-univalue-path-star","text":"","title":"687. Longest Univalue Path $\\star$"},{"location":"cpp/0601-0700/0681-0690/#688-knight-probability-in-chessboard-starstar","text":"","title":"688. Knight Probability in Chessboard $\\star\\star$"},{"location":"cpp/0601-0700/0681-0690/#689-maximum-sum-of-3-non-overlapping-subarrays-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution { public : vector < int > maxSumOfThreeSubarrays ( vector < int >& nums , int k ) { vector < int > ans = { - 1 , - 1 , - 1 }; int subarrayCount = nums . size () - k + 1 ; vector < int > dp ( subarrayCount ); int sum = 0 ; for ( int i = 0 ; i < nums . size (); i ++ ) { sum += nums [ i ]; if ( i >= k ) sum -= nums [ i - k ]; if ( i >= k - 1 ) dp [ i - k + 1 ] = sum ; } vector < int > left ( subarrayCount ); int maxIndex = 0 ; for ( int i = 0 ; i < subarrayCount ; i ++ ) { if ( dp [ i ] > dp [ maxIndex ]) maxIndex = i ; left [ i ] = maxIndex ; } vector < int > right ( subarrayCount ); maxIndex = subarrayCount - 1 ; for ( int i = subarrayCount - 1 ; i >= 0 ; i -- ) { if ( dp [ i ] >= dp [ maxIndex ]) maxIndex = i ; right [ i ] = maxIndex ; } for ( int i = k ; i < subarrayCount - k ; i ++ ) if ( ans [ 0 ] == - 1 || dp [ left [ i - k ]] + dp [ i ] + dp [ right [ i + k ]] > dp [ ans [ 0 ]] + dp [ ans [ 1 ]] + dp [ ans [ 2 ]]) ans = { left [ i - k ], i , right [ i + k ]}; return ans ; } };","title":"689. Maximum Sum of 3 Non-Overlapping Subarrays $\\star\\star\\star$"},{"location":"cpp/0601-0700/0681-0690/#690-employee-importance-star","text":"","title":"690. Employee Importance $\\star$"},{"location":"cpp/0601-0700/0691-0700/","text":"691. Stickers to Spell Word $\\star\\star\\star$ 692. Top K Frequent Words $\\star\\star$ 693. Binary Number with Alternating Bits $\\star$ 694. Number of Distinct Islands $\\star\\star$ 695. Max Area of Island $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int maxAreaOfIsland ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; vector < vector < bool >> visited ( m , vector < bool > ( n )); for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) ans = max ( ans , dfs ( grid , i , j , visited )); return ans ; } private : int dfs ( vector < vector < int >>& grid , int i , int j , vector < vector < bool >>& visited ) { if ( i < 0 || i >= grid . size () || j < 0 || j >= grid [ 0 ]. size () || visited [ i ][ j ] || grid [ i ][ j ] == 0 ) return 0 ; visited [ i ][ j ] = true ; return 1 + dfs ( grid , i + 1 , j , visited ) + dfs ( grid , i - 1 , j , visited ) + dfs ( grid , i , j + 1 , visited ) + dfs ( grid , i , j - 1 , visited ); } }; 696. Count Binary Substrings $\\star$ 697. Degree of an Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int findShortestSubArray ( vector < int >& nums ) { int ans = 0 ; int degree = 0 ; unordered_map < int , int > firstSeen ; unordered_map < int , int > numCounts ; for ( int i = 0 ; i < nums . size (); i ++ ) { if ( ! firstSeen . count ( nums [ i ])) firstSeen [ nums [ i ]] = i ; numCounts [ nums [ i ]] ++ ; if ( numCounts [ nums [ i ]] > degree ) { degree = numCounts [ nums [ i ]]; ans = i - firstSeen [ nums [ i ]] + 1 ; } else if ( numCounts [ nums [ i ]] == degree ) ans = min ( ans , i - firstSeen [ nums [ i ]] + 1 ); } return ans ; } }; 698. Partition to K Equal Sum Subsets $\\star\\star$ 699. Falling Squares $\\star\\star\\star$ 700. Search in a Binary Search Tree $\\star$","title":"0691-0700"},{"location":"cpp/0601-0700/0691-0700/#691-stickers-to-spell-word-starstarstar","text":"","title":"691. Stickers to Spell Word $\\star\\star\\star$"},{"location":"cpp/0601-0700/0691-0700/#692-top-k-frequent-words-starstar","text":"","title":"692. Top K Frequent Words $\\star\\star$"},{"location":"cpp/0601-0700/0691-0700/#693-binary-number-with-alternating-bits-star","text":"","title":"693. Binary Number with Alternating Bits $\\star$"},{"location":"cpp/0601-0700/0691-0700/#694-number-of-distinct-islands-starstar","text":"","title":"694. Number of Distinct Islands $\\star\\star$"},{"location":"cpp/0601-0700/0691-0700/#695-max-area-of-island-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public : int maxAreaOfIsland ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; vector < vector < bool >> visited ( m , vector < bool > ( n )); for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) ans = max ( ans , dfs ( grid , i , j , visited )); return ans ; } private : int dfs ( vector < vector < int >>& grid , int i , int j , vector < vector < bool >>& visited ) { if ( i < 0 || i >= grid . size () || j < 0 || j >= grid [ 0 ]. size () || visited [ i ][ j ] || grid [ i ][ j ] == 0 ) return 0 ; visited [ i ][ j ] = true ; return 1 + dfs ( grid , i + 1 , j , visited ) + dfs ( grid , i - 1 , j , visited ) + dfs ( grid , i , j + 1 , visited ) + dfs ( grid , i , j - 1 , visited ); } };","title":"695. Max Area of Island $\\star\\star$"},{"location":"cpp/0601-0700/0691-0700/#696-count-binary-substrings-star","text":"","title":"696. Count Binary Substrings $\\star$"},{"location":"cpp/0601-0700/0691-0700/#697-degree-of-an-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public : int findShortestSubArray ( vector < int >& nums ) { int ans = 0 ; int degree = 0 ; unordered_map < int , int > firstSeen ; unordered_map < int , int > numCounts ; for ( int i = 0 ; i < nums . size (); i ++ ) { if ( ! firstSeen . count ( nums [ i ])) firstSeen [ nums [ i ]] = i ; numCounts [ nums [ i ]] ++ ; if ( numCounts [ nums [ i ]] > degree ) { degree = numCounts [ nums [ i ]]; ans = i - firstSeen [ nums [ i ]] + 1 ; } else if ( numCounts [ nums [ i ]] == degree ) ans = min ( ans , i - firstSeen [ nums [ i ]] + 1 ); } return ans ; } };","title":"697. Degree of an Array $\\star$"},{"location":"cpp/0601-0700/0691-0700/#698-partition-to-k-equal-sum-subsets-starstar","text":"","title":"698. Partition to K Equal Sum Subsets $\\star\\star$"},{"location":"cpp/0601-0700/0691-0700/#699-falling-squares-starstarstar","text":"","title":"699. Falling Squares $\\star\\star\\star$"},{"location":"cpp/0601-0700/0691-0700/#700-search-in-a-binary-search-tree-star","text":"","title":"700. Search in a Binary Search Tree $\\star$"},{"location":"cpp/0701-0800/0701-0710/","text":"701. Insert into a Binary Search Tree $\\star\\star$ 702. Search in a Sorted Array of Unknown Size $\\star\\star$ 703. Kth Largest Element in a Stream $\\star$ 704. Binary Search $\\star$ 705. Design HashSet $\\star$ 706. Design HashMap $\\star$ 707. Design Linked List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class MyLinkedList { public : MyLinkedList () : len ( 0 ) { head = new ListNode ( 0 ); } int get ( int index ) { if ( index < 0 || index >= len ) return - 1 ; ListNode * curr = head -> next ; for ( int i = 0 ; i < index ; i ++ ) curr = curr -> next ; return curr -> val ; } void addAtHead ( int val ) { ListNode * curr = head -> next ; head -> next = new ListNode ( val ); head -> next -> next = curr ; len ++ ; } void addAtTail ( int val ) { ListNode * curr = head ; while ( curr -> next ) curr = curr -> next ; curr -> next = new ListNode ( val ); len ++ ; } void addAtIndex ( int index , int val ) { if ( index > len ) return ; ListNode * curr = head ; for ( int i = 0 ; i < index ; i ++ ) curr = curr -> next ; ListNode * temp = curr -> next ; curr -> next = new ListNode ( val ); curr -> next -> next = temp ; len ++ ; } void deleteAtIndex ( int index ) { if ( index < 0 || index >= len ) return ; ListNode * curr = head ; for ( int i = 0 ; i < index ; i ++ ) curr = curr -> next ; ListNode * temp = curr -> next ; curr -> next = temp -> next ; len -- ; delete temp ; } private : struct ListNode { int val ; ListNode * next ; ListNode ( int x ) : val ( x ), next ( nullptr ) {} }; int len ; ListNode * head ; }; 708. Insert into a Sorted Circular Linked List $\\star\\star$ 709. To Lower Case $\\star$ 710. Random Pick with Blacklist $\\star\\star\\star$","title":"0701-0710"},{"location":"cpp/0701-0800/0701-0710/#701-insert-into-a-binary-search-tree-starstar","text":"","title":"701. Insert into a Binary Search Tree $\\star\\star$"},{"location":"cpp/0701-0800/0701-0710/#702-search-in-a-sorted-array-of-unknown-size-starstar","text":"","title":"702. Search in a Sorted Array of Unknown Size $\\star\\star$"},{"location":"cpp/0701-0800/0701-0710/#703-kth-largest-element-in-a-stream-star","text":"","title":"703. Kth Largest Element in a Stream $\\star$"},{"location":"cpp/0701-0800/0701-0710/#704-binary-search-star","text":"","title":"704. Binary Search $\\star$"},{"location":"cpp/0701-0800/0701-0710/#705-design-hashset-star","text":"","title":"705. Design HashSet $\\star$"},{"location":"cpp/0701-0800/0701-0710/#706-design-hashmap-star","text":"","title":"706. Design HashMap $\\star$"},{"location":"cpp/0701-0800/0701-0710/#707-design-linked-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 class MyLinkedList { public : MyLinkedList () : len ( 0 ) { head = new ListNode ( 0 ); } int get ( int index ) { if ( index < 0 || index >= len ) return - 1 ; ListNode * curr = head -> next ; for ( int i = 0 ; i < index ; i ++ ) curr = curr -> next ; return curr -> val ; } void addAtHead ( int val ) { ListNode * curr = head -> next ; head -> next = new ListNode ( val ); head -> next -> next = curr ; len ++ ; } void addAtTail ( int val ) { ListNode * curr = head ; while ( curr -> next ) curr = curr -> next ; curr -> next = new ListNode ( val ); len ++ ; } void addAtIndex ( int index , int val ) { if ( index > len ) return ; ListNode * curr = head ; for ( int i = 0 ; i < index ; i ++ ) curr = curr -> next ; ListNode * temp = curr -> next ; curr -> next = new ListNode ( val ); curr -> next -> next = temp ; len ++ ; } void deleteAtIndex ( int index ) { if ( index < 0 || index >= len ) return ; ListNode * curr = head ; for ( int i = 0 ; i < index ; i ++ ) curr = curr -> next ; ListNode * temp = curr -> next ; curr -> next = temp -> next ; len -- ; delete temp ; } private : struct ListNode { int val ; ListNode * next ; ListNode ( int x ) : val ( x ), next ( nullptr ) {} }; int len ; ListNode * head ; };","title":"707. Design Linked List $\\star\\star$"},{"location":"cpp/0701-0800/0701-0710/#708-insert-into-a-sorted-circular-linked-list-starstar","text":"","title":"708. Insert into a Sorted Circular Linked List $\\star\\star$"},{"location":"cpp/0701-0800/0701-0710/#709-to-lower-case-star","text":"","title":"709. To Lower Case $\\star$"},{"location":"cpp/0701-0800/0701-0710/#710-random-pick-with-blacklist-starstarstar","text":"","title":"710. Random Pick with Blacklist $\\star\\star\\star$"},{"location":"cpp/0701-0800/0711-0720/","text":"711. Number of Distinct Islands II $\\star\\star\\star$ 712. Minimum ASCII Delete Sum for Two Strings $\\star\\star$ 713. Subarray Product Less Than K $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int numSubarrayProductLessThanK ( vector < int >& nums , int k ) { if ( k <= 1 ) return 0 ; int ans = 0 ; int prod = 1 ; int j = 0 ; for ( int i = 0 ; i < nums . size (); i ++ ) { prod *= nums [ i ]; while ( prod >= k ) prod /= nums [ j ++ ]; ans += i - j + 1 ; } return ans ; } }; 714. Best Time to Buy and Sell Stock with Transaction Fee $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxProfit ( vector < int >& prices , int fee ) { int sell = 0 ; int hold = INT_MIN ; for ( int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price - fee ); } return sell ; } }; 715. Range Module $\\star\\star\\star$ 716. Max Stack $\\star$ 717. 1-bit and 2-bit Characters $\\star$ 1 2 3 4 5 6 7 8 9 class Solution { public : bool isOneBitCharacter ( vector < int >& bits ) { int i = 0 ; while ( i < bits . size () - 1 ) i += bits [ i ] + 1 ; return i == bits . size () - 1 ; } }; 718. Maximum Length of Repeated Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int findLength ( vector < int >& A , vector < int >& B ) { const int m = A . size (); const int n = B . size (); int ans = 0 ; vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , 0 )); for ( int i = m - 1 ; i >= 0 ; i -- ) for ( int j = n - 1 ; j >= 0 ; j -- ) if ( A [ i ] == B [ j ]) dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 ; for ( vector < int >& row : dp ) ans = max ( ans , * max_element ( row . begin (), row . end ())); return ans ; } }; 719. Find K-th Smallest Pair Distance $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int smallestDistancePair ( vector < int >& nums , int k ) { sort ( nums . begin (), nums . end ()); int l = 0 ; int r = nums . back () - nums . front (); while ( l < r ) { int m = l + ( r - l ) / 2 ; int count = 0 ; for ( int i = 0 , j = 0 ; i < nums . size (); i ++ ) { while ( j < nums . size () && nums [ j ] <= nums [ i ] + m ) j ++ ; count += j - i - 1 ; } if ( count < k ) l = m + 1 ; else r = m ; } return l ; } }; 720. Longest Word in Dictionary $\\star$","title":"0711-0720"},{"location":"cpp/0701-0800/0711-0720/#711-number-of-distinct-islands-ii-starstarstar","text":"","title":"711. Number of Distinct Islands II $\\star\\star\\star$"},{"location":"cpp/0701-0800/0711-0720/#712-minimum-ascii-delete-sum-for-two-strings-starstar","text":"","title":"712. Minimum ASCII Delete Sum for Two Strings $\\star\\star$"},{"location":"cpp/0701-0800/0711-0720/#713-subarray-product-less-than-k-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int numSubarrayProductLessThanK ( vector < int >& nums , int k ) { if ( k <= 1 ) return 0 ; int ans = 0 ; int prod = 1 ; int j = 0 ; for ( int i = 0 ; i < nums . size (); i ++ ) { prod *= nums [ i ]; while ( prod >= k ) prod /= nums [ j ++ ]; ans += i - j + 1 ; } return ans ; } };","title":"713. Subarray Product Less Than K $\\star\\star$"},{"location":"cpp/0701-0800/0711-0720/#714-best-time-to-buy-and-sell-stock-with-transaction-fee-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxProfit ( vector < int >& prices , int fee ) { int sell = 0 ; int hold = INT_MIN ; for ( int price : prices ) { sell = max ( sell , hold + price ); hold = max ( hold , sell - price - fee ); } return sell ; } };","title":"714. Best Time to Buy and Sell Stock with Transaction Fee $\\star\\star$"},{"location":"cpp/0701-0800/0711-0720/#715-range-module-starstarstar","text":"","title":"715. Range Module $\\star\\star\\star$"},{"location":"cpp/0701-0800/0711-0720/#716-max-stack-star","text":"","title":"716. Max Stack $\\star$"},{"location":"cpp/0701-0800/0711-0720/#717-1-bit-and-2-bit-characters-star","text":"1 2 3 4 5 6 7 8 9 class Solution { public : bool isOneBitCharacter ( vector < int >& bits ) { int i = 0 ; while ( i < bits . size () - 1 ) i += bits [ i ] + 1 ; return i == bits . size () - 1 ; } };","title":"717. 1-bit and 2-bit Characters $\\star$"},{"location":"cpp/0701-0800/0711-0720/#718-maximum-length-of-repeated-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int findLength ( vector < int >& A , vector < int >& B ) { const int m = A . size (); const int n = B . size (); int ans = 0 ; vector < vector < int >> dp ( m + 1 , vector < int > ( n + 1 , 0 )); for ( int i = m - 1 ; i >= 0 ; i -- ) for ( int j = n - 1 ; j >= 0 ; j -- ) if ( A [ i ] == B [ j ]) dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 ; for ( vector < int >& row : dp ) ans = max ( ans , * max_element ( row . begin (), row . end ())); return ans ; } };","title":"718. Maximum Length of Repeated Subarray $\\star\\star$"},{"location":"cpp/0701-0800/0711-0720/#719-find-k-th-smallest-pair-distance-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int smallestDistancePair ( vector < int >& nums , int k ) { sort ( nums . begin (), nums . end ()); int l = 0 ; int r = nums . back () - nums . front (); while ( l < r ) { int m = l + ( r - l ) / 2 ; int count = 0 ; for ( int i = 0 , j = 0 ; i < nums . size (); i ++ ) { while ( j < nums . size () && nums [ j ] <= nums [ i ] + m ) j ++ ; count += j - i - 1 ; } if ( count < k ) l = m + 1 ; else r = m ; } return l ; } };","title":"719. Find K-th Smallest Pair Distance $\\star\\star\\star$"},{"location":"cpp/0701-0800/0711-0720/#720-longest-word-in-dictionary-star","text":"","title":"720. Longest Word in Dictionary $\\star$"},{"location":"cpp/0701-0800/0721-0730/","text":"721. Accounts Merge $\\star\\star$ 722. Remove Comments $\\star\\star$ 723. Candy Crush $\\star\\star$ 724. Find Pivot Index $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int pivotIndex ( vector < int >& nums ) { int sum = accumulate ( nums . begin (), nums . end (), 0 ); int presum = 0 ; for ( int i = 0 ; i < nums . size (); i ++ ) { if ( presum == sum - presum - nums [ i ]) return i ; presum += nums [ i ]; } return - 1 ; } }; 725. Split Linked List in Parts $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < ListNode *> splitListToParts ( ListNode * root , int k ) { vector < ListNode *> ans ( k , NULL ); int length = 0 ; for ( auto curr = root ; curr ; curr = curr -> next ) length ++ ; int l = length / k ; int r = length % k ; ListNode * head = root ; ListNode * prev = NULL ; for ( int i = 0 ; i < k ; i ++ , r -- ) { ans [ i ] = head ; for ( int j = 0 ; j < l + ( r > 0 ); j ++ ) { prev = head ; head = head -> next ; } if ( prev ) prev -> next = NULL ; } return ans ; } }; 726. Number of Atoms $\\star\\star\\star$ 727. Minimum Window Subsequence $\\star\\star\\star$ 728. Self Dividing Numbers $\\star$ 729. My Calendar I $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class MyCalendar { public : bool book ( int start , int end ) { for ( pair < int , int >& book : books ) if ( max ( book . first , start ) < min ( book . second , end )) return false ; books . push_back ({ start , end }); return true ; } private : vector < pair < int , int >> books ; }; 730. Count Different Palindromic Subsequences $\\star\\star\\star$","title":"0721-0730"},{"location":"cpp/0701-0800/0721-0730/#721-accounts-merge-starstar","text":"","title":"721. Accounts Merge $\\star\\star$"},{"location":"cpp/0701-0800/0721-0730/#722-remove-comments-starstar","text":"","title":"722. Remove Comments $\\star\\star$"},{"location":"cpp/0701-0800/0721-0730/#723-candy-crush-starstar","text":"","title":"723. Candy Crush $\\star\\star$"},{"location":"cpp/0701-0800/0721-0730/#724-find-pivot-index-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int pivotIndex ( vector < int >& nums ) { int sum = accumulate ( nums . begin (), nums . end (), 0 ); int presum = 0 ; for ( int i = 0 ; i < nums . size (); i ++ ) { if ( presum == sum - presum - nums [ i ]) return i ; presum += nums [ i ]; } return - 1 ; } };","title":"724. Find Pivot Index $\\star$"},{"location":"cpp/0701-0800/0721-0730/#725-split-linked-list-in-parts-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : vector < ListNode *> splitListToParts ( ListNode * root , int k ) { vector < ListNode *> ans ( k , NULL ); int length = 0 ; for ( auto curr = root ; curr ; curr = curr -> next ) length ++ ; int l = length / k ; int r = length % k ; ListNode * head = root ; ListNode * prev = NULL ; for ( int i = 0 ; i < k ; i ++ , r -- ) { ans [ i ] = head ; for ( int j = 0 ; j < l + ( r > 0 ); j ++ ) { prev = head ; head = head -> next ; } if ( prev ) prev -> next = NULL ; } return ans ; } };","title":"725. Split Linked List in Parts $\\star\\star$"},{"location":"cpp/0701-0800/0721-0730/#726-number-of-atoms-starstarstar","text":"","title":"726. Number of Atoms $\\star\\star\\star$"},{"location":"cpp/0701-0800/0721-0730/#727-minimum-window-subsequence-starstarstar","text":"","title":"727. Minimum Window Subsequence $\\star\\star\\star$"},{"location":"cpp/0701-0800/0721-0730/#728-self-dividing-numbers-star","text":"","title":"728. Self Dividing Numbers $\\star$"},{"location":"cpp/0701-0800/0721-0730/#729-my-calendar-i-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class MyCalendar { public : bool book ( int start , int end ) { for ( pair < int , int >& book : books ) if ( max ( book . first , start ) < min ( book . second , end )) return false ; books . push_back ({ start , end }); return true ; } private : vector < pair < int , int >> books ; };","title":"729. My Calendar I $\\star\\star$"},{"location":"cpp/0701-0800/0721-0730/#730-count-different-palindromic-subsequences-starstarstar","text":"","title":"730. Count Different Palindromic Subsequences $\\star\\star\\star$"},{"location":"cpp/0701-0800/0731-0740/","text":"731. My Calendar II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class MyCalendarTwo { public : MyCalendarTwo () {} bool book ( int start , int end ) { for ( auto & [ first , second ] : overlaps ) if ( max ( start , first ) < min ( end , second )) return false ; for ( auto & [ first , second ] : booked ) { int s = max ( start , first ); int e = min ( end , second ); if ( s < e ) overlaps . emplace_back ( s , e ); } booked . emplace_back ( start , end ); return true ; } private : vector < pair < int , int >> booked ; vector < pair < int , int >> overlaps ; }; 732. My Calendar III $\\star\\star\\star$ 733. Flood Fill $\\star$ 734. Sentence Similarity $\\star$ 735. Asteroid Collision $\\star\\star$ 736. Parse Lisp Expression $\\star\\star\\star$ 737. Sentence Similarity II $\\star\\star$ 738. Monotone Increasing Digits $\\star\\star$ 739. Daily Temperatures $\\star\\star$ 740. Delete and Earn $\\star\\star$","title":"0731-0740"},{"location":"cpp/0701-0800/0731-0740/#731-my-calendar-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class MyCalendarTwo { public : MyCalendarTwo () {} bool book ( int start , int end ) { for ( auto & [ first , second ] : overlaps ) if ( max ( start , first ) < min ( end , second )) return false ; for ( auto & [ first , second ] : booked ) { int s = max ( start , first ); int e = min ( end , second ); if ( s < e ) overlaps . emplace_back ( s , e ); } booked . emplace_back ( start , end ); return true ; } private : vector < pair < int , int >> booked ; vector < pair < int , int >> overlaps ; };","title":"731. My Calendar II $\\star\\star$"},{"location":"cpp/0701-0800/0731-0740/#732-my-calendar-iii-starstarstar","text":"","title":"732. My Calendar III $\\star\\star\\star$"},{"location":"cpp/0701-0800/0731-0740/#733-flood-fill-star","text":"","title":"733. Flood Fill $\\star$"},{"location":"cpp/0701-0800/0731-0740/#734-sentence-similarity-star","text":"","title":"734. Sentence Similarity $\\star$"},{"location":"cpp/0701-0800/0731-0740/#735-asteroid-collision-starstar","text":"","title":"735. Asteroid Collision $\\star\\star$"},{"location":"cpp/0701-0800/0731-0740/#736-parse-lisp-expression-starstarstar","text":"","title":"736. Parse Lisp Expression $\\star\\star\\star$"},{"location":"cpp/0701-0800/0731-0740/#737-sentence-similarity-ii-starstar","text":"","title":"737. Sentence Similarity II $\\star\\star$"},{"location":"cpp/0701-0800/0731-0740/#738-monotone-increasing-digits-starstar","text":"","title":"738. Monotone Increasing Digits $\\star\\star$"},{"location":"cpp/0701-0800/0731-0740/#739-daily-temperatures-starstar","text":"","title":"739. Daily Temperatures $\\star\\star$"},{"location":"cpp/0701-0800/0731-0740/#740-delete-and-earn-starstar","text":"","title":"740. Delete and Earn $\\star\\star$"},{"location":"cpp/0701-0800/0741-0750/","text":"741. Cherry Pickup $\\star\\star\\star$ 742. Closest Leaf in a Binary Tree $\\star\\star$ 743. Network Delay Time $\\star\\star$ 744. Find Smallest Letter Greater Than Target $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : char nextGreatestLetter ( vector < char >& letters , char target ) { int l = 0 ; int r = letters . size (); while ( l < r ) { int m = ( l + r ) >> 1 ; if ( letters [ m ] <= target ) l = m + 1 ; else r = m ; } return letters [ l % letters . size ()]; } }; 745. Prefix and Suffix Search $\\star\\star\\star$ 746. Min Cost Climbing Stairs $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int minCostClimbingStairs ( vector < int >& cost ) { const int n = cost . size (); for ( int i = 2 ; i < n ; i ++ ) cost [ i ] += min ( cost [ i - 1 ], cost [ i - 2 ]); return min ( cost [ n - 1 ], cost [ n - 2 ]); } }; 747. Largest Number At Least Twice of Others $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int dominantIndex ( vector < int >& nums ) { int ans ; int max = 0 ; int secondMax = 0 ; for ( int i = 0 ; i < nums . size (); i ++ ) { if ( nums [ i ] > max ) { secondMax = max ; max = nums [ i ]; ans = i ; } else if ( nums [ i ] > secondMax ) secondMax = nums [ i ]; } return max >= 2 * secondMax ? ans : - 1 ; } }; 748. Shortest Completing Word $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : string shortestCompletingWord ( string licensePlate , vector < string >& words ) { string ans ; vector < int > map ( 26 ); for ( char c : licensePlate ) if ( isalpha ( c )) map [ tolower ( c ) - 'a' ] ++ ; int min = INT_MAX ; for ( string & word : words ) { if ( word . length () >= min ) continue ; if ( ! isMatch ( word , map )) continue ; min = word . length (); ans = word ; } return ans ; } private : bool isMatch ( string & word , vector < int >& map ) { vector < int > wordMap ( 26 ); for ( char c : word ) wordMap [ c - 'a' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( wordMap [ i ] < map [ i ]) return false ; return true ; } }; 749. Contain Virus $\\star\\star\\star$ 750. Number Of Corner Rectangles $\\star\\star$","title":"0741-0750"},{"location":"cpp/0701-0800/0741-0750/#741-cherry-pickup-starstarstar","text":"","title":"741. Cherry Pickup $\\star\\star\\star$"},{"location":"cpp/0701-0800/0741-0750/#742-closest-leaf-in-a-binary-tree-starstar","text":"","title":"742. Closest Leaf in a Binary Tree $\\star\\star$"},{"location":"cpp/0701-0800/0741-0750/#743-network-delay-time-starstar","text":"","title":"743. Network Delay Time $\\star\\star$"},{"location":"cpp/0701-0800/0741-0750/#744-find-smallest-letter-greater-than-target-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : char nextGreatestLetter ( vector < char >& letters , char target ) { int l = 0 ; int r = letters . size (); while ( l < r ) { int m = ( l + r ) >> 1 ; if ( letters [ m ] <= target ) l = m + 1 ; else r = m ; } return letters [ l % letters . size ()]; } };","title":"744. Find Smallest Letter Greater Than Target $\\star$"},{"location":"cpp/0701-0800/0741-0750/#745-prefix-and-suffix-search-starstarstar","text":"","title":"745. Prefix and Suffix Search $\\star\\star\\star$"},{"location":"cpp/0701-0800/0741-0750/#746-min-cost-climbing-stairs-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int minCostClimbingStairs ( vector < int >& cost ) { const int n = cost . size (); for ( int i = 2 ; i < n ; i ++ ) cost [ i ] += min ( cost [ i - 1 ], cost [ i - 2 ]); return min ( cost [ n - 1 ], cost [ n - 2 ]); } };","title":"746. Min Cost Climbing Stairs $\\star$"},{"location":"cpp/0701-0800/0741-0750/#747-largest-number-at-least-twice-of-others-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int dominantIndex ( vector < int >& nums ) { int ans ; int max = 0 ; int secondMax = 0 ; for ( int i = 0 ; i < nums . size (); i ++ ) { if ( nums [ i ] > max ) { secondMax = max ; max = nums [ i ]; ans = i ; } else if ( nums [ i ] > secondMax ) secondMax = nums [ i ]; } return max >= 2 * secondMax ? ans : - 1 ; } };","title":"747. Largest Number At Least Twice of Others $\\star$"},{"location":"cpp/0701-0800/0741-0750/#748-shortest-completing-word-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution { public : string shortestCompletingWord ( string licensePlate , vector < string >& words ) { string ans ; vector < int > map ( 26 ); for ( char c : licensePlate ) if ( isalpha ( c )) map [ tolower ( c ) - 'a' ] ++ ; int min = INT_MAX ; for ( string & word : words ) { if ( word . length () >= min ) continue ; if ( ! isMatch ( word , map )) continue ; min = word . length (); ans = word ; } return ans ; } private : bool isMatch ( string & word , vector < int >& map ) { vector < int > wordMap ( 26 ); for ( char c : word ) wordMap [ c - 'a' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) if ( wordMap [ i ] < map [ i ]) return false ; return true ; } };","title":"748. Shortest Completing Word $\\star$"},{"location":"cpp/0701-0800/0741-0750/#749-contain-virus-starstarstar","text":"","title":"749. Contain Virus $\\star\\star\\star$"},{"location":"cpp/0701-0800/0741-0750/#750-number-of-corner-rectangles-starstar","text":"","title":"750. Number Of Corner Rectangles $\\star\\star$"},{"location":"cpp/0701-0800/0751-0760/","text":"751. IP to CIDR $\\star$ 752. Open the Lock $\\star\\star$ 753. Cracking the Safe $\\star\\star\\star$ 754. Reach a Number $\\star\\star$ 755. Pour Water $\\star\\star$ 756. Pyramid Transition Matrix $\\star\\star$ 757. Set Intersection Size At Least Two $\\star\\star\\star$ 758. Bold Words in String $\\star$ 759. Employee Free Time $\\star\\star\\star$ 760. Find Anagram Mappings $\\star$","title":"0751-0760"},{"location":"cpp/0701-0800/0751-0760/#751-ip-to-cidr-star","text":"","title":"751. IP to CIDR $\\star$"},{"location":"cpp/0701-0800/0751-0760/#752-open-the-lock-starstar","text":"","title":"752. Open the Lock $\\star\\star$"},{"location":"cpp/0701-0800/0751-0760/#753-cracking-the-safe-starstarstar","text":"","title":"753. Cracking the Safe $\\star\\star\\star$"},{"location":"cpp/0701-0800/0751-0760/#754-reach-a-number-starstar","text":"","title":"754. Reach a Number $\\star\\star$"},{"location":"cpp/0701-0800/0751-0760/#755-pour-water-starstar","text":"","title":"755. Pour Water $\\star\\star$"},{"location":"cpp/0701-0800/0751-0760/#756-pyramid-transition-matrix-starstar","text":"","title":"756. Pyramid Transition Matrix $\\star\\star$"},{"location":"cpp/0701-0800/0751-0760/#757-set-intersection-size-at-least-two-starstarstar","text":"","title":"757. Set Intersection Size At Least Two $\\star\\star\\star$"},{"location":"cpp/0701-0800/0751-0760/#758-bold-words-in-string-star","text":"","title":"758. Bold Words in String $\\star$"},{"location":"cpp/0701-0800/0751-0760/#759-employee-free-time-starstarstar","text":"","title":"759. Employee Free Time $\\star\\star\\star$"},{"location":"cpp/0701-0800/0751-0760/#760-find-anagram-mappings-star","text":"","title":"760. Find Anagram Mappings $\\star$"},{"location":"cpp/0701-0800/0761-0770/","text":"761. Special Binary String $\\star\\star\\star$ 762. Prime Number of Set Bits in Binary Representation $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int countPrimeSetBits ( int L , int R ) { // (10100010100010101100)2 = (665772)10 constexpr int magic = 665772 ; int ans = 0 ; for ( int n = L ; n <= R ; n ++ ) if ( magic & ( 1 << __builtin_popcountll ( n ))) ans ++ ; return ans ; } }; 763. Partition Labels $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < int > partitionLabels ( string S ) { vector < int > ans ; vector < int > map ( 26 ); for ( int i = 0 ; i < S . length (); i ++ ) map [ S [ i ] - 'a' ] = i ; int start = 0 ; int end = 0 ; for ( int i = 0 ; i < S . length (); i ++ ) { end = max ( end , map [ S [ i ] - 'a' ]); if ( i == end ) { ans . push_back ( end - start + 1 ); start = end + 1 ; } } return ans ; } }; 764. Largest Plus Sign $\\star\\star$ 765. Couples Holding Hands $\\star\\star\\star$ 766. Toeplitz Matrix $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : bool isToeplitzMatrix ( vector < vector < int >>& matrix ) { for ( int i = 0 ; i < matrix . size () - 1 ; i ++ ) for ( int j = 0 ; j < matrix [ 0 ]. size () - 1 ; j ++ ) if ( matrix [ i ][ j ] != matrix [ i + 1 ][ j + 1 ]) return false ; return true ; } }; 767. Reorganize String $\\star\\star$ 768. Max Chunks To Make Sorted II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int maxChunksToSorted ( vector < int >& arr ) { const int n = arr . size (); int ans = 0 ; int max = INT_MIN ; vector < int > min ( n , arr . back ()); for ( int i = n - 2 ; i >= 0 ; i -- ) min [ i ] = std :: min ( min [ i + 1 ], arr [ i ]); for ( int i = 0 ; i < n - 1 ; i ++ ) { max = std :: max ( max , arr [ i ]); if ( max <= min [ i + 1 ]) ans ++ ; } return ans + 1 ; } }; 769. Max Chunks To Make Sorted $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxChunksToSorted ( vector < int >& arr ) { int ans = 0 ; int max = INT_MIN ; for ( int i = 0 ; i < arr . size (); i ++ ) { max = std :: max ( max , arr [ i ]); if ( max == i ) ans ++ ; } return ans ; } }; 770. Basic Calculator IV $\\star\\star\\star$","title":"0761-0770"},{"location":"cpp/0701-0800/0761-0770/#761-special-binary-string-starstarstar","text":"","title":"761. Special Binary String $\\star\\star\\star$"},{"location":"cpp/0701-0800/0761-0770/#762-prime-number-of-set-bits-in-binary-representation-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public : int countPrimeSetBits ( int L , int R ) { // (10100010100010101100)2 = (665772)10 constexpr int magic = 665772 ; int ans = 0 ; for ( int n = L ; n <= R ; n ++ ) if ( magic & ( 1 << __builtin_popcountll ( n ))) ans ++ ; return ans ; } };","title":"762. Prime Number of Set Bits in Binary Representation $\\star$"},{"location":"cpp/0701-0800/0761-0770/#763-partition-labels-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : vector < int > partitionLabels ( string S ) { vector < int > ans ; vector < int > map ( 26 ); for ( int i = 0 ; i < S . length (); i ++ ) map [ S [ i ] - 'a' ] = i ; int start = 0 ; int end = 0 ; for ( int i = 0 ; i < S . length (); i ++ ) { end = max ( end , map [ S [ i ] - 'a' ]); if ( i == end ) { ans . push_back ( end - start + 1 ); start = end + 1 ; } } return ans ; } };","title":"763. Partition Labels $\\star\\star$"},{"location":"cpp/0701-0800/0761-0770/#764-largest-plus-sign-starstar","text":"","title":"764. Largest Plus Sign $\\star\\star$"},{"location":"cpp/0701-0800/0761-0770/#765-couples-holding-hands-starstarstar","text":"","title":"765. Couples Holding Hands $\\star\\star\\star$"},{"location":"cpp/0701-0800/0761-0770/#766-toeplitz-matrix-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : bool isToeplitzMatrix ( vector < vector < int >>& matrix ) { for ( int i = 0 ; i < matrix . size () - 1 ; i ++ ) for ( int j = 0 ; j < matrix [ 0 ]. size () - 1 ; j ++ ) if ( matrix [ i ][ j ] != matrix [ i + 1 ][ j + 1 ]) return false ; return true ; } };","title":"766. Toeplitz Matrix $\\star$"},{"location":"cpp/0701-0800/0761-0770/#767-reorganize-string-starstar","text":"","title":"767. Reorganize String $\\star\\star$"},{"location":"cpp/0701-0800/0761-0770/#768-max-chunks-to-make-sorted-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int maxChunksToSorted ( vector < int >& arr ) { const int n = arr . size (); int ans = 0 ; int max = INT_MIN ; vector < int > min ( n , arr . back ()); for ( int i = n - 2 ; i >= 0 ; i -- ) min [ i ] = std :: min ( min [ i + 1 ], arr [ i ]); for ( int i = 0 ; i < n - 1 ; i ++ ) { max = std :: max ( max , arr [ i ]); if ( max <= min [ i + 1 ]) ans ++ ; } return ans + 1 ; } };","title":"768. Max Chunks To Make Sorted II $\\star\\star\\star$"},{"location":"cpp/0701-0800/0761-0770/#769-max-chunks-to-make-sorted-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxChunksToSorted ( vector < int >& arr ) { int ans = 0 ; int max = INT_MIN ; for ( int i = 0 ; i < arr . size (); i ++ ) { max = std :: max ( max , arr [ i ]); if ( max == i ) ans ++ ; } return ans ; } };","title":"769. Max Chunks To Make Sorted $\\star\\star$"},{"location":"cpp/0701-0800/0761-0770/#770-basic-calculator-iv-starstarstar","text":"","title":"770. Basic Calculator IV $\\star\\star\\star$"},{"location":"cpp/0701-0800/0771-0780/","text":"771. Jewels and Stones $\\star$ 772. Basic Calculator III $\\star\\star\\star$ 773. Sliding Puzzle $\\star\\star\\star$ 774. Minimize Max Distance to Gas Station $\\star\\star\\star$ 775. Global and Local Inversions $\\star\\star$ 1 2 3 4 5 6 7 8 9 class Solution { public : bool isIdealPermutation ( vector < int >& A ) { for ( int i = 0 ; i < A . size (); i ++ ) if ( abs ( A [ i ] - i ) > 1 ) return false ; return true ; } }; 776. Split BST $\\star\\star$ 777. Swap Adjacent in LR String $\\star\\star$ 778. Swim in Rising Water $\\star\\star\\star$ 779. K-th Symbol in Grammar $\\star\\star$ 780. Reaching Points $\\star\\star\\star$","title":"0771-0780"},{"location":"cpp/0701-0800/0771-0780/#771-jewels-and-stones-star","text":"","title":"771. Jewels and Stones $\\star$"},{"location":"cpp/0701-0800/0771-0780/#772-basic-calculator-iii-starstarstar","text":"","title":"772. Basic Calculator III $\\star\\star\\star$"},{"location":"cpp/0701-0800/0771-0780/#773-sliding-puzzle-starstarstar","text":"","title":"773. Sliding Puzzle $\\star\\star\\star$"},{"location":"cpp/0701-0800/0771-0780/#774-minimize-max-distance-to-gas-station-starstarstar","text":"","title":"774. Minimize Max Distance to Gas Station $\\star\\star\\star$"},{"location":"cpp/0701-0800/0771-0780/#775-global-and-local-inversions-starstar","text":"1 2 3 4 5 6 7 8 9 class Solution { public : bool isIdealPermutation ( vector < int >& A ) { for ( int i = 0 ; i < A . size (); i ++ ) if ( abs ( A [ i ] - i ) > 1 ) return false ; return true ; } };","title":"775. Global and Local Inversions $\\star\\star$"},{"location":"cpp/0701-0800/0771-0780/#776-split-bst-starstar","text":"","title":"776. Split BST $\\star\\star$"},{"location":"cpp/0701-0800/0771-0780/#777-swap-adjacent-in-lr-string-starstar","text":"","title":"777. Swap Adjacent in LR String $\\star\\star$"},{"location":"cpp/0701-0800/0771-0780/#778-swim-in-rising-water-starstarstar","text":"","title":"778. Swim in Rising Water $\\star\\star\\star$"},{"location":"cpp/0701-0800/0771-0780/#779-k-th-symbol-in-grammar-starstar","text":"","title":"779. K-th Symbol in Grammar $\\star\\star$"},{"location":"cpp/0701-0800/0771-0780/#780-reaching-points-starstarstar","text":"","title":"780. Reaching Points $\\star\\star\\star$"},{"location":"cpp/0701-0800/0781-0790/","text":"781. Rabbits in Forest $\\star\\star$ 782. Transform to Chessboard $\\star\\star\\star$ 783. Minimum Distance Between BST Nodes $\\star$ 784. Letter Case Permutation $\\star$ 785. Is Graph Bipartite? $\\star\\star$ 786. K-th Smallest Prime Fraction $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < int > kthSmallestPrimeFraction ( vector < int >& A , int K ) { const int n = A . size (); vector < int > ans = { 0 , 1 }; double l = 0 ; double r = 1 ; while ( true ) { double m = ( l + r ) / 2 ; ans [ 0 ] = 0 ; int count = 0 ; int j = 1 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n && A [ i ] > m * A [ j ]) j ++ ; count += n - j ; if ( j == n ) break ; if ( ans [ 0 ] * A [ j ] < ans [ 1 ] * A [ i ]) { ans [ 0 ] = A [ i ]; ans [ 1 ] = A [ j ]; } } if ( count < K ) l = m ; else if ( count > K ) r = m ; else return ans ; } } }; 787. Cheapest Flights Within K Stops $\\star\\star$ 788. Rotated Digits $\\star$ 789. Escape The Ghosts $\\star\\star$ 790. Domino and Tromino Tiling $\\star\\star$","title":"0781-0790"},{"location":"cpp/0701-0800/0781-0790/#781-rabbits-in-forest-starstar","text":"","title":"781. Rabbits in Forest $\\star\\star$"},{"location":"cpp/0701-0800/0781-0790/#782-transform-to-chessboard-starstarstar","text":"","title":"782. Transform to Chessboard $\\star\\star\\star$"},{"location":"cpp/0701-0800/0781-0790/#783-minimum-distance-between-bst-nodes-star","text":"","title":"783. Minimum Distance Between BST Nodes $\\star$"},{"location":"cpp/0701-0800/0781-0790/#784-letter-case-permutation-star","text":"","title":"784. Letter Case Permutation $\\star$"},{"location":"cpp/0701-0800/0781-0790/#785-is-graph-bipartite-starstar","text":"","title":"785. Is Graph Bipartite? $\\star\\star$"},{"location":"cpp/0701-0800/0781-0790/#786-k-th-smallest-prime-fraction-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution { public : vector < int > kthSmallestPrimeFraction ( vector < int >& A , int K ) { const int n = A . size (); vector < int > ans = { 0 , 1 }; double l = 0 ; double r = 1 ; while ( true ) { double m = ( l + r ) / 2 ; ans [ 0 ] = 0 ; int count = 0 ; int j = 1 ; for ( int i = 0 ; i < n ; i ++ ) { while ( j < n && A [ i ] > m * A [ j ]) j ++ ; count += n - j ; if ( j == n ) break ; if ( ans [ 0 ] * A [ j ] < ans [ 1 ] * A [ i ]) { ans [ 0 ] = A [ i ]; ans [ 1 ] = A [ j ]; } } if ( count < K ) l = m ; else if ( count > K ) r = m ; else return ans ; } } };","title":"786. K-th Smallest Prime Fraction $\\star\\star\\star$"},{"location":"cpp/0701-0800/0781-0790/#787-cheapest-flights-within-k-stops-starstar","text":"","title":"787. Cheapest Flights Within K Stops $\\star\\star$"},{"location":"cpp/0701-0800/0781-0790/#788-rotated-digits-star","text":"","title":"788. Rotated Digits $\\star$"},{"location":"cpp/0701-0800/0781-0790/#789-escape-the-ghosts-starstar","text":"","title":"789. Escape The Ghosts $\\star\\star$"},{"location":"cpp/0701-0800/0781-0790/#790-domino-and-tromino-tiling-starstar","text":"","title":"790. Domino and Tromino Tiling $\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/","text":"791. Custom Sort String $\\star\\star$ 792. Number of Matching Subsequences $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public : int numMatchingSubseq ( string S , vector < string >& words ) { for ( const string & word : words ) insert ( word ); return dfs ( S , 0 , & root ); } private : struct TrieNode { TrieNode () : children ( 26 ), count ( 0 ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; int count ; }; void insert ( const string & word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } node -> count ++ ; } int dfs ( const string & S , int s , TrieNode * node ) { int ans = node -> count ; if ( s >= S . length ()) return ans ; for ( int i = 0 ; i < 26 ; i ++ ) if ( node -> children [ i ]) { int index = indexOf ( S , i + 'a' , s ); if ( index != - 1 ) ans += dfs ( S , index + 1 , node -> children [ i ]); } return ans ; } int indexOf ( const string & S , char c , int s ) { for ( int i = s ; i < S . length (); i ++ ) if ( S [ i ] == c ) return i ; return - 1 ; } TrieNode root ; }; 793. Preimage Size of Factorial Zeroes Function $\\star\\star\\star$ 794. Valid Tic-Tac-Toe State $\\star\\star$ 795. Number of Subarrays with Bounded Maximum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int numSubarrayBoundedMax ( vector < int >& A , int L , int R ) { int ans = 0 ; int l = - 1 ; int r = - 1 ; for ( int i = 0 ; i < A . size (); i ++ ) { if ( A [ i ] > R ) l = i ; if ( A [ i ] >= L ) r = i ; ans += r - l ; } return ans ; } }; 796. Rotate String $\\star$ 797. All Paths From Source to Target $\\star\\star$ 798. Smallest Rotation with Highest Score $\\star\\star\\star$ 799. Champagne Tower $\\star\\star$ 800. Similar RGB Color $\\star$","title":"0791-0800"},{"location":"cpp/0701-0800/0791-0800/#791-custom-sort-string-starstar","text":"","title":"791. Custom Sort String $\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/#792-number-of-matching-subsequences-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 class Solution { public : int numMatchingSubseq ( string S , vector < string >& words ) { for ( const string & word : words ) insert ( word ); return dfs ( S , 0 , & root ); } private : struct TrieNode { TrieNode () : children ( 26 ), count ( 0 ) {} ~ TrieNode () { for ( TrieNode * child : children ) delete child ; } vector < TrieNode *> children ; int count ; }; void insert ( const string & word ) { TrieNode * node = & root ; for ( char c : word ) { TrieNode *& next = node -> children [ c - 'a' ]; if ( ! next ) next = new TrieNode ; node = next ; } node -> count ++ ; } int dfs ( const string & S , int s , TrieNode * node ) { int ans = node -> count ; if ( s >= S . length ()) return ans ; for ( int i = 0 ; i < 26 ; i ++ ) if ( node -> children [ i ]) { int index = indexOf ( S , i + 'a' , s ); if ( index != - 1 ) ans += dfs ( S , index + 1 , node -> children [ i ]); } return ans ; } int indexOf ( const string & S , char c , int s ) { for ( int i = s ; i < S . length (); i ++ ) if ( S [ i ] == c ) return i ; return - 1 ; } TrieNode root ; };","title":"792. Number of Matching Subsequences $\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/#793-preimage-size-of-factorial-zeroes-function-starstarstar","text":"","title":"793. Preimage Size of Factorial Zeroes Function $\\star\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/#794-valid-tic-tac-toe-state-starstar","text":"","title":"794. Valid Tic-Tac-Toe State $\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/#795-number-of-subarrays-with-bounded-maximum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int numSubarrayBoundedMax ( vector < int >& A , int L , int R ) { int ans = 0 ; int l = - 1 ; int r = - 1 ; for ( int i = 0 ; i < A . size (); i ++ ) { if ( A [ i ] > R ) l = i ; if ( A [ i ] >= L ) r = i ; ans += r - l ; } return ans ; } };","title":"795. Number of Subarrays with Bounded Maximum $\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/#796-rotate-string-star","text":"","title":"796. Rotate String $\\star$"},{"location":"cpp/0701-0800/0791-0800/#797-all-paths-from-source-to-target-starstar","text":"","title":"797. All Paths From Source to Target $\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/#798-smallest-rotation-with-highest-score-starstarstar","text":"","title":"798. Smallest Rotation with Highest Score $\\star\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/#799-champagne-tower-starstar","text":"","title":"799. Champagne Tower $\\star\\star$"},{"location":"cpp/0701-0800/0791-0800/#800-similar-rgb-color-star","text":"","title":"800. Similar RGB Color $\\star$"},{"location":"cpp/0801-0900/0801-0810/","text":"801. Minimum Swaps To Make Sequences Increasing $\\star\\star$ 802. Find Eventual Safe States $\\star\\star$ 803. Bricks Falling When Hit $\\star\\star\\star$ 804. Unique Morse Code Words $\\star$ 805. Split Array With Same Average $\\star\\star\\star$ 806. Number of Lines To Write String $\\star$ 807. Max Increase to Keep City Skyline $\\star\\star$ 808. Soup Servings $\\star\\star$ 809. Expressive Words $\\star\\star$ 810. Chalkboard XOR Game $\\star\\star\\star$","title":"0801-0810"},{"location":"cpp/0801-0900/0801-0810/#801-minimum-swaps-to-make-sequences-increasing-starstar","text":"","title":"801. Minimum Swaps To Make Sequences Increasing $\\star\\star$"},{"location":"cpp/0801-0900/0801-0810/#802-find-eventual-safe-states-starstar","text":"","title":"802. Find Eventual Safe States $\\star\\star$"},{"location":"cpp/0801-0900/0801-0810/#803-bricks-falling-when-hit-starstarstar","text":"","title":"803. Bricks Falling When Hit $\\star\\star\\star$"},{"location":"cpp/0801-0900/0801-0810/#804-unique-morse-code-words-star","text":"","title":"804. Unique Morse Code Words $\\star$"},{"location":"cpp/0801-0900/0801-0810/#805-split-array-with-same-average-starstarstar","text":"","title":"805. Split Array With Same Average $\\star\\star\\star$"},{"location":"cpp/0801-0900/0801-0810/#806-number-of-lines-to-write-string-star","text":"","title":"806. Number of Lines To Write String $\\star$"},{"location":"cpp/0801-0900/0801-0810/#807-max-increase-to-keep-city-skyline-starstar","text":"","title":"807. Max Increase to Keep City Skyline $\\star\\star$"},{"location":"cpp/0801-0900/0801-0810/#808-soup-servings-starstar","text":"","title":"808. Soup Servings $\\star\\star$"},{"location":"cpp/0801-0900/0801-0810/#809-expressive-words-starstar","text":"","title":"809. Expressive Words $\\star\\star$"},{"location":"cpp/0801-0900/0801-0810/#810-chalkboard-xor-game-starstarstar","text":"","title":"810. Chalkboard XOR Game $\\star\\star\\star$"},{"location":"cpp/0801-0900/0811-0820/","text":"811. Subdomain Visit Count $\\star$ 812. Largest Triangle Area $\\star$ 813. Largest Sum of Averages $\\star\\star$ 814. Binary Tree Pruning $\\star\\star$ 815. Bus Routes $\\star\\star\\star$ 816. Ambiguous Coordinates $\\star\\star$ 817. Linked List Components $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numComponents ( ListNode * head , vector < int >& G ) { int ans = 0 ; unordered_set < int > g ( G . begin (), G . end ()); while ( head ) { if ( g . count ( head -> val ) && ( ! head -> next || ! g . count ( head -> next -> val ))) ans ++ ; head = head -> next ; } return ans ; } }; 818. Race Car $\\star\\star\\star$ 819. Most Common Word $\\star$ 820. Short Encoding of Words $\\star\\star$","title":"0811-0820"},{"location":"cpp/0801-0900/0811-0820/#811-subdomain-visit-count-star","text":"","title":"811. Subdomain Visit Count $\\star$"},{"location":"cpp/0801-0900/0811-0820/#812-largest-triangle-area-star","text":"","title":"812. Largest Triangle Area $\\star$"},{"location":"cpp/0801-0900/0811-0820/#813-largest-sum-of-averages-starstar","text":"","title":"813. Largest Sum of Averages $\\star\\star$"},{"location":"cpp/0801-0900/0811-0820/#814-binary-tree-pruning-starstar","text":"","title":"814. Binary Tree Pruning $\\star\\star$"},{"location":"cpp/0801-0900/0811-0820/#815-bus-routes-starstarstar","text":"","title":"815. Bus Routes $\\star\\star\\star$"},{"location":"cpp/0801-0900/0811-0820/#816-ambiguous-coordinates-starstar","text":"","title":"816. Ambiguous Coordinates $\\star\\star$"},{"location":"cpp/0801-0900/0811-0820/#817-linked-list-components-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numComponents ( ListNode * head , vector < int >& G ) { int ans = 0 ; unordered_set < int > g ( G . begin (), G . end ()); while ( head ) { if ( g . count ( head -> val ) && ( ! head -> next || ! g . count ( head -> next -> val ))) ans ++ ; head = head -> next ; } return ans ; } };","title":"817. Linked List Components $\\star\\star$"},{"location":"cpp/0801-0900/0811-0820/#818-race-car-starstarstar","text":"","title":"818. Race Car $\\star\\star\\star$"},{"location":"cpp/0801-0900/0811-0820/#819-most-common-word-star","text":"","title":"819. Most Common Word $\\star$"},{"location":"cpp/0801-0900/0811-0820/#820-short-encoding-of-words-starstar","text":"","title":"820. Short Encoding of Words $\\star\\star$"},{"location":"cpp/0801-0900/0821-0830/","text":"821. Shortest Distance to a Character $\\star$ 822. Card Flipping Game $\\star\\star$ 823. Binary Trees With Factors $\\star\\star$ 824. Goat Latin $\\star$ 825. Friends Of Appropriate Ages $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int numFriendRequests ( vector < int >& ages ) { int ans = 0 ; vector < int > count ( 121 ); for ( int age : ages ) count [ age ] ++ ; for ( int i = 15 ; i <= 120 ; i ++ ) ans += count [ i ] * ( count [ i ] - 1 ); for ( int i = 15 ; i <= 120 ; i ++ ) for ( int j = i / 2 + 8 ; j < i ; j ++ ) ans += count [ i ] * count [ j ]; return ans ; } }; 826. Most Profit Assigning Work $\\star\\star$ 827. Making A Large Island $\\star\\star\\star$ 828. Unique Letter String $\\star\\star\\star$ 829. Consecutive Numbers Sum $\\star\\star\\star$ 830. Positions of Large Groups $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < vector < int >> largeGroupPositions ( string S ) { const int n = S . length (); vector < vector < int >> ans ; for ( int i = 0 , j = 0 ; i < n ; i = j ) { while ( j < n && S [ j ] == S [ i ]) j ++ ; if ( j - i >= 3 ) ans . push_back ({ i , j - 1 }); } return ans ; } };","title":"0821-0830"},{"location":"cpp/0801-0900/0821-0830/#821-shortest-distance-to-a-character-star","text":"","title":"821. Shortest Distance to a Character $\\star$"},{"location":"cpp/0801-0900/0821-0830/#822-card-flipping-game-starstar","text":"","title":"822. Card Flipping Game $\\star\\star$"},{"location":"cpp/0801-0900/0821-0830/#823-binary-trees-with-factors-starstar","text":"","title":"823. Binary Trees With Factors $\\star\\star$"},{"location":"cpp/0801-0900/0821-0830/#824-goat-latin-star","text":"","title":"824. Goat Latin $\\star$"},{"location":"cpp/0801-0900/0821-0830/#825-friends-of-appropriate-ages-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int numFriendRequests ( vector < int >& ages ) { int ans = 0 ; vector < int > count ( 121 ); for ( int age : ages ) count [ age ] ++ ; for ( int i = 15 ; i <= 120 ; i ++ ) ans += count [ i ] * ( count [ i ] - 1 ); for ( int i = 15 ; i <= 120 ; i ++ ) for ( int j = i / 2 + 8 ; j < i ; j ++ ) ans += count [ i ] * count [ j ]; return ans ; } };","title":"825. Friends Of Appropriate Ages $\\star\\star$"},{"location":"cpp/0801-0900/0821-0830/#826-most-profit-assigning-work-starstar","text":"","title":"826. Most Profit Assigning Work $\\star\\star$"},{"location":"cpp/0801-0900/0821-0830/#827-making-a-large-island-starstarstar","text":"","title":"827. Making A Large Island $\\star\\star\\star$"},{"location":"cpp/0801-0900/0821-0830/#828-unique-letter-string-starstarstar","text":"","title":"828. Unique Letter String $\\star\\star\\star$"},{"location":"cpp/0801-0900/0821-0830/#829-consecutive-numbers-sum-starstarstar","text":"","title":"829. Consecutive Numbers Sum $\\star\\star\\star$"},{"location":"cpp/0801-0900/0821-0830/#830-positions-of-large-groups-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < vector < int >> largeGroupPositions ( string S ) { const int n = S . length (); vector < vector < int >> ans ; for ( int i = 0 , j = 0 ; i < n ; i = j ) { while ( j < n && S [ j ] == S [ i ]) j ++ ; if ( j - i >= 3 ) ans . push_back ({ i , j - 1 }); } return ans ; } };","title":"830. Positions of Large Groups $\\star$"},{"location":"cpp/0801-0900/0831-0840/","text":"831. Masking Personal Information $\\star\\star$ 832. Flipping an Image $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < vector < int >> flipAndInvertImage ( vector < vector < int >>& A ) { const int n = A . size (); for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < ( n + 1 ) / 2 ; j ++ ) { int temp = A [ i ][ j ]; A [ i ][ j ] = A [ i ][ n - j - 1 ] ^ 1 ; A [ i ][ n - j - 1 ] = temp ^ 1 ; } return A ; } }; 833. Find And Replace in String $\\star\\star$ 834. Sum of Distances in Tree $\\star\\star\\star$ 835. Image Overlap $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int largestOverlap ( vector < vector < int >>& A , vector < vector < int >>& B ) { const int n = A . size (); const int magic = 100 ; int ans = 0 ; vector < pair < int , int >> onesA ; vector < pair < int , int >> onesB ; unordered_map < int , int > map ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { if ( A [ i ][ j ] == 1 ) onesA . push_back ({ i , j }); if ( B [ i ][ j ] == 1 ) onesB . push_back ({ i , j }); } for ( pair < int , int >& a : onesA ) for ( pair < int , int >& b : onesB ) map [( a . first - b . first ) * magic + ( a . second - b . second )] ++ ; for ( auto & [ _ , value ] : map ) ans = max ( ans , value ); return ans ; } }; 836. Rectangle Overlap $\\star$ 837. New 21 Game $\\star\\star$ 838. Push Dominoes $\\star\\star$ 839. Similar String Groups $\\star\\star\\star$ 840. Magic Squares In Grid $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int numMagicSquaresInside ( vector < vector < int >>& grid ) { int ans = 0 ; for ( int i = 0 ; i + 2 < grid . size (); i ++ ) for ( int j = 0 ; j + 2 < grid [ 0 ]. size (); j ++ ) if ( grid [ i ][ j ] % 2 == 0 && grid [ i + 1 ][ j + 1 ] == 5 ) ans += isMagic ( grid , i , j ); return ans ; } private : int isMagic ( vector < vector < int >>& grid , int i , int j ) { string s ; for ( int num : { 0 , 1 , 2 , 5 , 8 , 7 , 6 , 3 }) s += to_string ( grid [ i + num / 3 ][ j + num % 3 ]); return string ( \"4381672943816729\" ). find ( s ) != string :: npos || string ( \"9276183492761834\" ). find ( s ) != string :: npos ; } };","title":"0831-0840"},{"location":"cpp/0801-0900/0831-0840/#831-masking-personal-information-starstar","text":"","title":"831. Masking Personal Information $\\star\\star$"},{"location":"cpp/0801-0900/0831-0840/#832-flipping-an-image-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < vector < int >> flipAndInvertImage ( vector < vector < int >>& A ) { const int n = A . size (); for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < ( n + 1 ) / 2 ; j ++ ) { int temp = A [ i ][ j ]; A [ i ][ j ] = A [ i ][ n - j - 1 ] ^ 1 ; A [ i ][ n - j - 1 ] = temp ^ 1 ; } return A ; } };","title":"832. Flipping an Image $\\star$"},{"location":"cpp/0801-0900/0831-0840/#833-find-and-replace-in-string-starstar","text":"","title":"833. Find And Replace in String $\\star\\star$"},{"location":"cpp/0801-0900/0831-0840/#834-sum-of-distances-in-tree-starstarstar","text":"","title":"834. Sum of Distances in Tree $\\star\\star\\star$"},{"location":"cpp/0801-0900/0831-0840/#835-image-overlap-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int largestOverlap ( vector < vector < int >>& A , vector < vector < int >>& B ) { const int n = A . size (); const int magic = 100 ; int ans = 0 ; vector < pair < int , int >> onesA ; vector < pair < int , int >> onesB ; unordered_map < int , int > map ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { if ( A [ i ][ j ] == 1 ) onesA . push_back ({ i , j }); if ( B [ i ][ j ] == 1 ) onesB . push_back ({ i , j }); } for ( pair < int , int >& a : onesA ) for ( pair < int , int >& b : onesB ) map [( a . first - b . first ) * magic + ( a . second - b . second )] ++ ; for ( auto & [ _ , value ] : map ) ans = max ( ans , value ); return ans ; } };","title":"835. Image Overlap $\\star\\star$"},{"location":"cpp/0801-0900/0831-0840/#836-rectangle-overlap-star","text":"","title":"836. Rectangle Overlap $\\star$"},{"location":"cpp/0801-0900/0831-0840/#837-new-21-game-starstar","text":"","title":"837. New 21 Game $\\star\\star$"},{"location":"cpp/0801-0900/0831-0840/#838-push-dominoes-starstar","text":"","title":"838. Push Dominoes $\\star\\star$"},{"location":"cpp/0801-0900/0831-0840/#839-similar-string-groups-starstarstar","text":"","title":"839. Similar String Groups $\\star\\star\\star$"},{"location":"cpp/0801-0900/0831-0840/#840-magic-squares-in-grid-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int numMagicSquaresInside ( vector < vector < int >>& grid ) { int ans = 0 ; for ( int i = 0 ; i + 2 < grid . size (); i ++ ) for ( int j = 0 ; j + 2 < grid [ 0 ]. size (); j ++ ) if ( grid [ i ][ j ] % 2 == 0 && grid [ i + 1 ][ j + 1 ] == 5 ) ans += isMagic ( grid , i , j ); return ans ; } private : int isMagic ( vector < vector < int >>& grid , int i , int j ) { string s ; for ( int num : { 0 , 1 , 2 , 5 , 8 , 7 , 6 , 3 }) s += to_string ( grid [ i + num / 3 ][ j + num % 3 ]); return string ( \"4381672943816729\" ). find ( s ) != string :: npos || string ( \"9276183492761834\" ). find ( s ) != string :: npos ; } };","title":"840. Magic Squares In Grid $\\star$"},{"location":"cpp/0801-0900/0841-0850/","text":"841. Keys and Rooms $\\star\\star$ 842. Split Array into Fibonacci Sequence $\\star\\star$ 843. Guess the Word $\\star\\star\\star$ 844. Backspace String Compare $\\star$ 845. Longest Mountain in Array $\\star\\star$ 846. Hand of Straights $\\star\\star$ 847. Shortest Path Visiting All Nodes $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int shortestPathLength ( vector < vector < int >>& graph ) { const int n = graph . size (); const int goal = ( 1 << n ) - 1 ; int ans = 0 ; queue < pair < int , int >> q ; vector < vector < int >> visited ( n , vector < int > ( 1 << n )); for ( int i = 0 ; i < graph . size (); i ++ ) q . push ({ i , 1 << i }); while ( ! q . empty ()) { int s = q . size (); while ( s -- ) { auto p = q . front (); q . pop (); int node = p . first ; int state = p . second ; if ( state == goal ) return ans ; if ( visited [ node ][ state ]) continue ; visited [ node ][ state ] = 1 ; for ( int next : graph [ node ]) q . push ({ next , state | ( 1 << next )}); } ans ++ ; } return - 1 ; } }; 848. Shifting Letters $\\star\\star$ 849. Maximize Distance to Closest Person $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxDistToClosest ( vector < int >& seats ) { const int n = seats . size (); int ans = 0 ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( seats [ i ] == 1 ) { ans = j == - 1 ? i : max ( ans , ( i - j ) / 2 ); j = i ; } return max ( ans , n - j - 1 ); } }; 850. Rectangle Area II $\\star\\star\\star$","title":"0841-0850"},{"location":"cpp/0801-0900/0841-0850/#841-keys-and-rooms-starstar","text":"","title":"841. Keys and Rooms $\\star\\star$"},{"location":"cpp/0801-0900/0841-0850/#842-split-array-into-fibonacci-sequence-starstar","text":"","title":"842. Split Array into Fibonacci Sequence $\\star\\star$"},{"location":"cpp/0801-0900/0841-0850/#843-guess-the-word-starstarstar","text":"","title":"843. Guess the Word $\\star\\star\\star$"},{"location":"cpp/0801-0900/0841-0850/#844-backspace-string-compare-star","text":"","title":"844. Backspace String Compare $\\star$"},{"location":"cpp/0801-0900/0841-0850/#845-longest-mountain-in-array-starstar","text":"","title":"845. Longest Mountain in Array $\\star\\star$"},{"location":"cpp/0801-0900/0841-0850/#846-hand-of-straights-starstar","text":"","title":"846. Hand of Straights $\\star\\star$"},{"location":"cpp/0801-0900/0841-0850/#847-shortest-path-visiting-all-nodes-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public : int shortestPathLength ( vector < vector < int >>& graph ) { const int n = graph . size (); const int goal = ( 1 << n ) - 1 ; int ans = 0 ; queue < pair < int , int >> q ; vector < vector < int >> visited ( n , vector < int > ( 1 << n )); for ( int i = 0 ; i < graph . size (); i ++ ) q . push ({ i , 1 << i }); while ( ! q . empty ()) { int s = q . size (); while ( s -- ) { auto p = q . front (); q . pop (); int node = p . first ; int state = p . second ; if ( state == goal ) return ans ; if ( visited [ node ][ state ]) continue ; visited [ node ][ state ] = 1 ; for ( int next : graph [ node ]) q . push ({ next , state | ( 1 << next )}); } ans ++ ; } return - 1 ; } };","title":"847. Shortest Path Visiting All Nodes $\\star\\star\\star$"},{"location":"cpp/0801-0900/0841-0850/#848-shifting-letters-starstar","text":"","title":"848. Shifting Letters $\\star\\star$"},{"location":"cpp/0801-0900/0841-0850/#849-maximize-distance-to-closest-person-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxDistToClosest ( vector < int >& seats ) { const int n = seats . size (); int ans = 0 ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( seats [ i ] == 1 ) { ans = j == - 1 ? i : max ( ans , ( i - j ) / 2 ); j = i ; } return max ( ans , n - j - 1 ); } };","title":"849. Maximize Distance to Closest Person $\\star$"},{"location":"cpp/0801-0900/0841-0850/#850-rectangle-area-ii-starstarstar","text":"","title":"850. Rectangle Area II $\\star\\star\\star$"},{"location":"cpp/0801-0900/0851-0860/","text":"851. Loud and Rich $\\star\\star$ 852. Peak Index in a Mountain Array $\\star$ 853. Car Fleet $\\star\\star$ 854. K-Similar Strings $\\star\\star\\star$ 855. Exam Room $\\star\\star$ 856. Score of Parentheses $\\star\\star$ 857. Minimum Cost to Hire K Workers $\\star\\star\\star$ 858. Mirror Reflection $\\star\\star$ 859. Buddy Strings $\\star$ 860. Lemonade Change $\\star$","title":"0851-0860"},{"location":"cpp/0801-0900/0851-0860/#851-loud-and-rich-starstar","text":"","title":"851. Loud and Rich $\\star\\star$"},{"location":"cpp/0801-0900/0851-0860/#852-peak-index-in-a-mountain-array-star","text":"","title":"852. Peak Index in a Mountain Array $\\star$"},{"location":"cpp/0801-0900/0851-0860/#853-car-fleet-starstar","text":"","title":"853. Car Fleet $\\star\\star$"},{"location":"cpp/0801-0900/0851-0860/#854-k-similar-strings-starstarstar","text":"","title":"854. K-Similar Strings $\\star\\star\\star$"},{"location":"cpp/0801-0900/0851-0860/#855-exam-room-starstar","text":"","title":"855. Exam Room $\\star\\star$"},{"location":"cpp/0801-0900/0851-0860/#856-score-of-parentheses-starstar","text":"","title":"856. Score of Parentheses $\\star\\star$"},{"location":"cpp/0801-0900/0851-0860/#857-minimum-cost-to-hire-k-workers-starstarstar","text":"","title":"857. Minimum Cost to Hire K Workers $\\star\\star\\star$"},{"location":"cpp/0801-0900/0851-0860/#858-mirror-reflection-starstar","text":"","title":"858. Mirror Reflection $\\star\\star$"},{"location":"cpp/0801-0900/0851-0860/#859-buddy-strings-star","text":"","title":"859. Buddy Strings $\\star$"},{"location":"cpp/0801-0900/0851-0860/#860-lemonade-change-star","text":"","title":"860. Lemonade Change $\\star$"},{"location":"cpp/0801-0900/0861-0870/","text":"861. Score After Flipping Matrix $\\star\\star$ 862. Shortest Subarray with Sum at Least K $\\star\\star\\star$ 863. All Nodes Distance K in Binary Tree $\\star\\star$ 864. Shortest Path to Get All Keys $\\star\\star\\star$ 865. Smallest Subtree with all the Deepest Nodes $\\star\\star$ 866. Prime Palindrome $\\star\\star$ 867. Transpose Matrix $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < vector < int >> transpose ( vector < vector < int >>& A ) { vector < vector < int >> ans ( A [ 0 ]. size (), vector < int > ( A . size ())); for ( int i = 0 ; i < A . size (); i ++ ) for ( int j = 0 ; j < A [ 0 ]. size (); j ++ ) ans [ j ][ i ] = A [ i ][ j ]; return ans ; } }; 868. Binary Gap $\\star$ 869. Reordered Power of 2 $\\star\\star$ 870. Advantage Shuffle $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > advantageCount ( vector < int >& A , vector < int >& B ) { multiset < int > set ( A . begin (), A . end ()); for ( int i = 0 ; i < B . size (); i ++ ) { auto p = * set . rbegin () <= B [ i ] ? set . begin () : set . upper_bound ( B [ i ]); A [ i ] = * p ; set . erase ( p ); } return A ; } };","title":"0861-0870"},{"location":"cpp/0801-0900/0861-0870/#861-score-after-flipping-matrix-starstar","text":"","title":"861. Score After Flipping Matrix $\\star\\star$"},{"location":"cpp/0801-0900/0861-0870/#862-shortest-subarray-with-sum-at-least-k-starstarstar","text":"","title":"862. Shortest Subarray with Sum at Least K $\\star\\star\\star$"},{"location":"cpp/0801-0900/0861-0870/#863-all-nodes-distance-k-in-binary-tree-starstar","text":"","title":"863. All Nodes Distance K in Binary Tree $\\star\\star$"},{"location":"cpp/0801-0900/0861-0870/#864-shortest-path-to-get-all-keys-starstarstar","text":"","title":"864. Shortest Path to Get All Keys $\\star\\star\\star$"},{"location":"cpp/0801-0900/0861-0870/#865-smallest-subtree-with-all-the-deepest-nodes-starstar","text":"","title":"865. Smallest Subtree with all the Deepest Nodes $\\star\\star$"},{"location":"cpp/0801-0900/0861-0870/#866-prime-palindrome-starstar","text":"","title":"866. Prime Palindrome $\\star\\star$"},{"location":"cpp/0801-0900/0861-0870/#867-transpose-matrix-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : vector < vector < int >> transpose ( vector < vector < int >>& A ) { vector < vector < int >> ans ( A [ 0 ]. size (), vector < int > ( A . size ())); for ( int i = 0 ; i < A . size (); i ++ ) for ( int j = 0 ; j < A [ 0 ]. size (); j ++ ) ans [ j ][ i ] = A [ i ][ j ]; return ans ; } };","title":"867. Transpose Matrix $\\star$"},{"location":"cpp/0801-0900/0861-0870/#868-binary-gap-star","text":"","title":"868. Binary Gap $\\star$"},{"location":"cpp/0801-0900/0861-0870/#869-reordered-power-of-2-starstar","text":"","title":"869. Reordered Power of 2 $\\star\\star$"},{"location":"cpp/0801-0900/0861-0870/#870-advantage-shuffle-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > advantageCount ( vector < int >& A , vector < int >& B ) { multiset < int > set ( A . begin (), A . end ()); for ( int i = 0 ; i < B . size (); i ++ ) { auto p = * set . rbegin () <= B [ i ] ? set . begin () : set . upper_bound ( B [ i ]); A [ i ] = * p ; set . erase ( p ); } return A ; } };","title":"870. Advantage Shuffle $\\star\\star$"},{"location":"cpp/0801-0900/0871-0880/","text":"871. Minimum Number of Refueling Stops $\\star\\star\\star$ 872. Leaf-Similar Trees $\\star$ 873. Length of Longest Fibonacci Subsequence $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { const int n = A . size (); int ans = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < n ; i ++ ) map [ A [ i ]] = i ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); for ( int j = 0 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) { int ai = A [ k ] - A [ j ]; if ( ai < A [ j ] && map . count ( ai )) { int i = map [ ai ]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } } return ans ; } }; 874. Walking Robot Simulation $\\star$ 875. Koko Eating Bananas $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int minEatingSpeed ( vector < int >& piles , int H ) { int l = 1 ; int r = * max_element ( piles . begin (), piles . end ()) + 1 ; while ( l < r ) { int m = ( l + r ) >> 1 ; int hour = 0 ; for ( int pile : piles ) hour += ( pile - 1 ) / m + 1 ; if ( hour <= H ) r = m ; else l = m + 1 ; } return l ; } }; 876. Middle of the Linked List $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : ListNode * middleNode ( ListNode * head ) { if ( ! head || ! head -> next ) return head ; auto slow = head ; auto fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } }; 877. Stone Game $\\star\\star$ 878. Nth Magical Number $\\star\\star\\star$ 879. Profitable Schemes $\\star\\star\\star$ 880. Decoded String at Index $\\star\\star$","title":"0871-0880"},{"location":"cpp/0801-0900/0871-0880/#871-minimum-number-of-refueling-stops-starstarstar","text":"","title":"871. Minimum Number of Refueling Stops $\\star\\star\\star$"},{"location":"cpp/0801-0900/0871-0880/#872-leaf-similar-trees-star","text":"","title":"872. Leaf-Similar Trees $\\star$"},{"location":"cpp/0801-0900/0871-0880/#873-length-of-longest-fibonacci-subsequence-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int lenLongestFibSubseq ( vector < int >& A ) { const int n = A . size (); int ans = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < n ; i ++ ) map [ A [ i ]] = i ; vector < vector < int >> dp ( n , vector < int > ( n , 2 )); for ( int j = 0 ; j < n ; j ++ ) for ( int k = j + 1 ; k < n ; k ++ ) { int ai = A [ k ] - A [ j ]; if ( ai < A [ j ] && map . count ( ai )) { int i = map [ ai ]; dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = max ( ans , dp [ j ][ k ]); } } return ans ; } };","title":"873. Length of Longest Fibonacci Subsequence $\\star\\star$"},{"location":"cpp/0801-0900/0871-0880/#874-walking-robot-simulation-star","text":"","title":"874. Walking Robot Simulation $\\star$"},{"location":"cpp/0801-0900/0871-0880/#875-koko-eating-bananas-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int minEatingSpeed ( vector < int >& piles , int H ) { int l = 1 ; int r = * max_element ( piles . begin (), piles . end ()) + 1 ; while ( l < r ) { int m = ( l + r ) >> 1 ; int hour = 0 ; for ( int pile : piles ) hour += ( pile - 1 ) / m + 1 ; if ( hour <= H ) r = m ; else l = m + 1 ; } return l ; } };","title":"875. Koko Eating Bananas $\\star\\star$"},{"location":"cpp/0801-0900/0871-0880/#876-middle-of-the-linked-list-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : ListNode * middleNode ( ListNode * head ) { if ( ! head || ! head -> next ) return head ; auto slow = head ; auto fast = head ; while ( fast && fast -> next ) { slow = slow -> next ; fast = fast -> next -> next ; } return slow ; } };","title":"876. Middle of the Linked List $\\star$"},{"location":"cpp/0801-0900/0871-0880/#877-stone-game-starstar","text":"","title":"877. Stone Game $\\star\\star$"},{"location":"cpp/0801-0900/0871-0880/#878-nth-magical-number-starstarstar","text":"","title":"878. Nth Magical Number $\\star\\star\\star$"},{"location":"cpp/0801-0900/0871-0880/#879-profitable-schemes-starstarstar","text":"","title":"879. Profitable Schemes $\\star\\star\\star$"},{"location":"cpp/0801-0900/0871-0880/#880-decoded-string-at-index-starstar","text":"","title":"880. Decoded String at Index $\\star\\star$"},{"location":"cpp/0801-0900/0881-0890/","text":"881. Boats to Save People $\\star\\star$ 882. Reachable Nodes In Subdivided Graph $\\star\\star\\star$ 883. Projection Area of 3D Shapes $\\star$ 884. Uncommon Words from Two Sentences $\\star$ 885. Spiral Matrix III $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < vector < int >> spiralMatrixIII ( int R , int C , int r0 , int c0 ) { vector < vector < int >> ans = {{ r0 , c0 }}; int x = 0 ; int y = 1 ; for ( int i = 0 ; ans . size () < R * C ; i ++ ) { for ( int j = 0 ; j < i / 2 + 1 ; j ++ ) { r0 += x ; c0 += y ; if ( 0 <= r0 && r0 < R && 0 <= c0 && c0 < C ) ans . push_back ({ r0 , c0 }); } swap ( x , y ); y *= - 1 ; } return ans ; } }; 886. Possible Bipartition $\\star\\star$ 887. Super Egg Drop $\\star\\star\\star$ 888. Fair Candy Swap $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > fairCandySwap ( vector < int >& A , vector < int >& B ) { int diff = ( accumulate ( A . begin (), A . end (), 0 ) - accumulate ( B . begin (), B . end (), 0 )) / 2 ; unordered_set < int > set ( B . begin (), B . end ()); for ( int a : A ) if ( set . count ( a - diff )) return { a , a - diff }; throw ; } }; 889. Construct Binary Tree from Preorder and Postorder Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : TreeNode * constructFromPrePost ( vector < int >& pre , vector < int >& post ) { return helper ( 0 , 0 , pre . size (), pre , post ); } private : TreeNode * helper ( int i , int j , int n , vector < int >& pre , vector < int >& post ) { if ( n == 0 ) return NULL ; TreeNode * root = new TreeNode ( pre [ i ]); if ( n == 1 ) return root ; int k = j ; while ( post [ k ] != pre [ i + 1 ]) k ++ ; int l = k - j + 1 ; root -> left = helper ( i + 1 , j , l , pre , post ); root -> right = helper ( i + l + 1 , j + l , n - l - 1 , pre , post ); return root ; } }; 890. Find and Replace Pattern $\\star\\star$","title":"0881-0890"},{"location":"cpp/0801-0900/0881-0890/#881-boats-to-save-people-starstar","text":"","title":"881. Boats to Save People $\\star\\star$"},{"location":"cpp/0801-0900/0881-0890/#882-reachable-nodes-in-subdivided-graph-starstarstar","text":"","title":"882. Reachable Nodes In Subdivided Graph $\\star\\star\\star$"},{"location":"cpp/0801-0900/0881-0890/#883-projection-area-of-3d-shapes-star","text":"","title":"883. Projection Area of 3D Shapes $\\star$"},{"location":"cpp/0801-0900/0881-0890/#884-uncommon-words-from-two-sentences-star","text":"","title":"884. Uncommon Words from Two Sentences $\\star$"},{"location":"cpp/0801-0900/0881-0890/#885-spiral-matrix-iii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < vector < int >> spiralMatrixIII ( int R , int C , int r0 , int c0 ) { vector < vector < int >> ans = {{ r0 , c0 }}; int x = 0 ; int y = 1 ; for ( int i = 0 ; ans . size () < R * C ; i ++ ) { for ( int j = 0 ; j < i / 2 + 1 ; j ++ ) { r0 += x ; c0 += y ; if ( 0 <= r0 && r0 < R && 0 <= c0 && c0 < C ) ans . push_back ({ r0 , c0 }); } swap ( x , y ); y *= - 1 ; } return ans ; } };","title":"885. Spiral Matrix III $\\star\\star$"},{"location":"cpp/0801-0900/0881-0890/#886-possible-bipartition-starstar","text":"","title":"886. Possible Bipartition $\\star\\star$"},{"location":"cpp/0801-0900/0881-0890/#887-super-egg-drop-starstarstar","text":"","title":"887. Super Egg Drop $\\star\\star\\star$"},{"location":"cpp/0801-0900/0881-0890/#888-fair-candy-swap-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > fairCandySwap ( vector < int >& A , vector < int >& B ) { int diff = ( accumulate ( A . begin (), A . end (), 0 ) - accumulate ( B . begin (), B . end (), 0 )) / 2 ; unordered_set < int > set ( B . begin (), B . end ()); for ( int a : A ) if ( set . count ( a - diff )) return { a , a - diff }; throw ; } };","title":"888. Fair Candy Swap $\\star$"},{"location":"cpp/0801-0900/0881-0890/#889-construct-binary-tree-from-preorder-and-postorder-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : TreeNode * constructFromPrePost ( vector < int >& pre , vector < int >& post ) { return helper ( 0 , 0 , pre . size (), pre , post ); } private : TreeNode * helper ( int i , int j , int n , vector < int >& pre , vector < int >& post ) { if ( n == 0 ) return NULL ; TreeNode * root = new TreeNode ( pre [ i ]); if ( n == 1 ) return root ; int k = j ; while ( post [ k ] != pre [ i + 1 ]) k ++ ; int l = k - j + 1 ; root -> left = helper ( i + 1 , j , l , pre , post ); root -> right = helper ( i + l + 1 , j + l , n - l - 1 , pre , post ); return root ; } };","title":"889. Construct Binary Tree from Preorder and Postorder Traversal $\\star\\star$"},{"location":"cpp/0801-0900/0881-0890/#890-find-and-replace-pattern-starstar","text":"","title":"890. Find and Replace Pattern $\\star\\star$"},{"location":"cpp/0801-0900/0891-0900/","text":"891. Sum of Subsequence Widths $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int sumSubseqWidths ( vector < int >& A ) { const int n = A . size (); const int kMod = 1e9 + 7 ; int ans = 0 ; long exp = 1 ; sort ( A . begin (), A . end ()); for ( int i = 0 ; i < n ; i ++ , exp = exp * 2 % kMod ) ans = ( ans + A [ i ] * exp - A [ n - i - 1 ] * exp ) % kMod ; return ans ; } }; 892. Surface Area of 3D Shapes $\\star$ 893. Groups of Special-Equivalent Strings $\\star$ 894. All Possible Full Binary Trees $\\star\\star$ 895. Maximum Frequency Stack $\\star\\star\\star$ 896. Monotonic Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool isMonotonic ( vector < int >& A ) { bool increasing = true ; bool decreasing = true ; for ( int i = 1 ; i < A . size (); i ++ ) { increasing &= A [ i - 1 ] <= A [ i ]; decreasing &= A [ i - 1 ] >= A [ i ]; } return increasing || decreasing ; } }; 897. Increasing Order Search Tree $\\star$ 898. Bitwise ORs of Subarrays $\\star\\star$ 899. Orderly Queue $\\star\\star\\star$ 900. RLE Iterator $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class RLEIterator { public : RLEIterator ( vector < int >& A ) { this -> A = A ; } int next ( int n ) { while ( index < A . size () && A [ index ] < n ) { n -= A [ index ]; index += 2 ; } if ( index == A . size ()) return - 1 ; A [ index ] -= n ; return A [ index + 1 ]; } private : int index = 0 ; vector < int > A ; };","title":"0891-0900"},{"location":"cpp/0801-0900/0891-0900/#891-sum-of-subsequence-widths-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int sumSubseqWidths ( vector < int >& A ) { const int n = A . size (); const int kMod = 1e9 + 7 ; int ans = 0 ; long exp = 1 ; sort ( A . begin (), A . end ()); for ( int i = 0 ; i < n ; i ++ , exp = exp * 2 % kMod ) ans = ( ans + A [ i ] * exp - A [ n - i - 1 ] * exp ) % kMod ; return ans ; } };","title":"891. Sum of Subsequence Widths $\\star\\star\\star$"},{"location":"cpp/0801-0900/0891-0900/#892-surface-area-of-3d-shapes-star","text":"","title":"892. Surface Area of 3D Shapes $\\star$"},{"location":"cpp/0801-0900/0891-0900/#893-groups-of-special-equivalent-strings-star","text":"","title":"893. Groups of Special-Equivalent Strings $\\star$"},{"location":"cpp/0801-0900/0891-0900/#894-all-possible-full-binary-trees-starstar","text":"","title":"894. All Possible Full Binary Trees $\\star\\star$"},{"location":"cpp/0801-0900/0891-0900/#895-maximum-frequency-stack-starstarstar","text":"","title":"895. Maximum Frequency Stack $\\star\\star\\star$"},{"location":"cpp/0801-0900/0891-0900/#896-monotonic-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool isMonotonic ( vector < int >& A ) { bool increasing = true ; bool decreasing = true ; for ( int i = 1 ; i < A . size (); i ++ ) { increasing &= A [ i - 1 ] <= A [ i ]; decreasing &= A [ i - 1 ] >= A [ i ]; } return increasing || decreasing ; } };","title":"896. Monotonic Array $\\star$"},{"location":"cpp/0801-0900/0891-0900/#897-increasing-order-search-tree-star","text":"","title":"897. Increasing Order Search Tree $\\star$"},{"location":"cpp/0801-0900/0891-0900/#898-bitwise-ors-of-subarrays-starstar","text":"","title":"898. Bitwise ORs of Subarrays $\\star\\star$"},{"location":"cpp/0801-0900/0891-0900/#899-orderly-queue-starstarstar","text":"","title":"899. Orderly Queue $\\star\\star\\star$"},{"location":"cpp/0801-0900/0891-0900/#900-rle-iterator-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class RLEIterator { public : RLEIterator ( vector < int >& A ) { this -> A = A ; } int next ( int n ) { while ( index < A . size () && A [ index ] < n ) { n -= A [ index ]; index += 2 ; } if ( index == A . size ()) return - 1 ; A [ index ] -= n ; return A [ index + 1 ]; } private : int index = 0 ; vector < int > A ; };","title":"900. RLE Iterator $\\star\\star$"},{"location":"cpp/0901-1000/0901-0910/","text":"901. Online Stock Span $\\star\\star$ 902. Numbers At Most N Given Digit Set $\\star\\star\\star$ 903. Valid Permutations for DI Sequence $\\star\\star\\star$ 904. Fruit Into Baskets $\\star\\star$ 905. Sort Array By Parity $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < int > sortArrayByParity ( vector < int >& A ) { int l = 0 ; int r = A . size () - 1 ; while ( l < r ) { if ( A [ l ] % 2 == 1 && A [ r ] % 2 == 0 ) swap ( A [ l ], A [ r ]); if ( A [ l ] % 2 == 0 ) l ++ ; if ( A [ r ] % 2 == 1 ) r -- ; } return A ; } }; 906. Super Palindromes $\\star\\star\\star$ 907. Sum of Subarray Minimums $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int sumSubarrayMins ( vector < int >& A ) { const int n = A . size (); const int kMod = 1e9 + 7 ; int ans = 0 ; vector < int > prev ( n , - 1 ); vector < int > next ( n , n ); stack < int > stack1 ; stack < int > stack2 ; for ( int i = 0 ; i < n ; i ++ ) { while ( ! stack1 . empty () && A [ stack1 . top ()] > A [ i ]) stack1 . pop (); prev [ i ] = stack1 . empty () ? - 1 : stack1 . top (); stack1 . push ( i ); while ( ! stack2 . empty () && A [ stack2 . top ()] > A [ i ]) { int index = stack2 . top (); stack2 . pop (); next [ index ] = i ; } stack2 . push ( i ); } for ( int i = 0 ; i < n ; i ++ ) ans = ( ans + A [ i ] * ( i - prev [ i ]) * ( next [ i ] - i )) % kMod ; return ans ; } }; 908. Smallest Range I $\\star$ 909. Snakes and Ladders $\\star\\star$ 910. Smallest Range II $\\star\\star$","title":"0901-0910"},{"location":"cpp/0901-1000/0901-0910/#901-online-stock-span-starstar","text":"","title":"901. Online Stock Span $\\star\\star$"},{"location":"cpp/0901-1000/0901-0910/#902-numbers-at-most-n-given-digit-set-starstarstar","text":"","title":"902. Numbers At Most N Given Digit Set $\\star\\star\\star$"},{"location":"cpp/0901-1000/0901-0910/#903-valid-permutations-for-di-sequence-starstarstar","text":"","title":"903. Valid Permutations for DI Sequence $\\star\\star\\star$"},{"location":"cpp/0901-1000/0901-0910/#904-fruit-into-baskets-starstar","text":"","title":"904. Fruit Into Baskets $\\star\\star$"},{"location":"cpp/0901-1000/0901-0910/#905-sort-array-by-parity-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < int > sortArrayByParity ( vector < int >& A ) { int l = 0 ; int r = A . size () - 1 ; while ( l < r ) { if ( A [ l ] % 2 == 1 && A [ r ] % 2 == 0 ) swap ( A [ l ], A [ r ]); if ( A [ l ] % 2 == 0 ) l ++ ; if ( A [ r ] % 2 == 1 ) r -- ; } return A ; } };","title":"905. Sort Array By Parity $\\star$"},{"location":"cpp/0901-1000/0901-0910/#906-super-palindromes-starstarstar","text":"","title":"906. Super Palindromes $\\star\\star\\star$"},{"location":"cpp/0901-1000/0901-0910/#907-sum-of-subarray-minimums-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public : int sumSubarrayMins ( vector < int >& A ) { const int n = A . size (); const int kMod = 1e9 + 7 ; int ans = 0 ; vector < int > prev ( n , - 1 ); vector < int > next ( n , n ); stack < int > stack1 ; stack < int > stack2 ; for ( int i = 0 ; i < n ; i ++ ) { while ( ! stack1 . empty () && A [ stack1 . top ()] > A [ i ]) stack1 . pop (); prev [ i ] = stack1 . empty () ? - 1 : stack1 . top (); stack1 . push ( i ); while ( ! stack2 . empty () && A [ stack2 . top ()] > A [ i ]) { int index = stack2 . top (); stack2 . pop (); next [ index ] = i ; } stack2 . push ( i ); } for ( int i = 0 ; i < n ; i ++ ) ans = ( ans + A [ i ] * ( i - prev [ i ]) * ( next [ i ] - i )) % kMod ; return ans ; } };","title":"907. Sum of Subarray Minimums $\\star\\star$"},{"location":"cpp/0901-1000/0901-0910/#908-smallest-range-i-star","text":"","title":"908. Smallest Range I $\\star$"},{"location":"cpp/0901-1000/0901-0910/#909-snakes-and-ladders-starstar","text":"","title":"909. Snakes and Ladders $\\star\\star$"},{"location":"cpp/0901-1000/0901-0910/#910-smallest-range-ii-starstar","text":"","title":"910. Smallest Range II $\\star\\star$"},{"location":"cpp/0901-1000/0911-0920/","text":"911. Online Election $\\star\\star$ 912. Sort an Array $\\star\\star$ 913. Cat and Mouse $\\star\\star\\star$ 914. X of a Kind in a Deck of Cards $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : bool hasGroupsSizeX ( vector < int >& deck ) { unordered_map < int , int > numCounts ; for ( int d : deck ) numCounts [ d ] ++ ; int gcd = 0 ; for ( auto & [ _ , value ] : numCounts ) gcd = __gcd ( gcd , value ); return gcd >= 2 ; } }; 915. Partition Array into Disjoint Intervals $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int partitionDisjoint ( vector < int >& A ) { const int n = A . size (); vector < int > min ( n ); min [ n - 1 ] = A [ n - 1 ]; int max = INT_MIN ; for ( int i = n - 2 ; i >= 0 ; i -- ) min [ i ] = std :: min ( min [ i + 1 ], A [ i ]); for ( int i = 0 ; i < n ; i ++ ) { max = std :: max ( max , A [ i ]); if ( max <= min [ i + 1 ]) return i + 1 ; } throw ; } }; 916. Word Subsets $\\star\\star$ 917. Reverse Only Letters $\\star$ 918. Maximum Sum Circular Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int maxSubarraySumCircular ( vector < int >& A ) { int totalSum = 0 ; int currMaxSum = 0 ; int currMinSum = 0 ; int maxSum = INT_MIN ; int minSum = INT_MAX ; for ( int a : A ) { totalSum += a ; currMaxSum = max ( currMaxSum + a , a ); currMinSum = min ( currMinSum + a , a ); maxSum = max ( maxSum , currMaxSum ); minSum = min ( minSum , currMinSum ); } return maxSum < 0 ? maxSum : max ( maxSum , totalSum - minSum ); } }; 919. Complete Binary Tree Inserter $\\star\\star$ 920. Number of Music Playlists $\\star\\star\\star$","title":"0911-0920"},{"location":"cpp/0901-1000/0911-0920/#911-online-election-starstar","text":"","title":"911. Online Election $\\star\\star$"},{"location":"cpp/0901-1000/0911-0920/#912-sort-an-array-starstar","text":"","title":"912. Sort an Array $\\star\\star$"},{"location":"cpp/0901-1000/0911-0920/#913-cat-and-mouse-starstarstar","text":"","title":"913. Cat and Mouse $\\star\\star\\star$"},{"location":"cpp/0901-1000/0911-0920/#914-x-of-a-kind-in-a-deck-of-cards-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public : bool hasGroupsSizeX ( vector < int >& deck ) { unordered_map < int , int > numCounts ; for ( int d : deck ) numCounts [ d ] ++ ; int gcd = 0 ; for ( auto & [ _ , value ] : numCounts ) gcd = __gcd ( gcd , value ); return gcd >= 2 ; } };","title":"914. X of a Kind in a Deck of Cards $\\star$"},{"location":"cpp/0901-1000/0911-0920/#915-partition-array-into-disjoint-intervals-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int partitionDisjoint ( vector < int >& A ) { const int n = A . size (); vector < int > min ( n ); min [ n - 1 ] = A [ n - 1 ]; int max = INT_MIN ; for ( int i = n - 2 ; i >= 0 ; i -- ) min [ i ] = std :: min ( min [ i + 1 ], A [ i ]); for ( int i = 0 ; i < n ; i ++ ) { max = std :: max ( max , A [ i ]); if ( max <= min [ i + 1 ]) return i + 1 ; } throw ; } };","title":"915. Partition Array into Disjoint Intervals $\\star\\star$"},{"location":"cpp/0901-1000/0911-0920/#916-word-subsets-starstar","text":"","title":"916. Word Subsets $\\star\\star$"},{"location":"cpp/0901-1000/0911-0920/#917-reverse-only-letters-star","text":"","title":"917. Reverse Only Letters $\\star$"},{"location":"cpp/0901-1000/0911-0920/#918-maximum-sum-circular-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int maxSubarraySumCircular ( vector < int >& A ) { int totalSum = 0 ; int currMaxSum = 0 ; int currMinSum = 0 ; int maxSum = INT_MIN ; int minSum = INT_MAX ; for ( int a : A ) { totalSum += a ; currMaxSum = max ( currMaxSum + a , a ); currMinSum = min ( currMinSum + a , a ); maxSum = max ( maxSum , currMaxSum ); minSum = min ( minSum , currMinSum ); } return maxSum < 0 ? maxSum : max ( maxSum , totalSum - minSum ); } };","title":"918. Maximum Sum Circular Subarray $\\star\\star$"},{"location":"cpp/0901-1000/0911-0920/#919-complete-binary-tree-inserter-starstar","text":"","title":"919. Complete Binary Tree Inserter $\\star\\star$"},{"location":"cpp/0901-1000/0911-0920/#920-number-of-music-playlists-starstarstar","text":"","title":"920. Number of Music Playlists $\\star\\star\\star$"},{"location":"cpp/0901-1000/0921-0930/","text":"921. Minimum Add to Make Parentheses Valid $\\star\\star$ 922. Sort Array By Parity II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > sortArrayByParityII ( vector < int >& A ) { const int n = A . size (); for ( int i = 0 , j = 1 ; i < n ; i += 2 , j += 2 ) { while ( i < n && A [ i ] % 2 == 0 ) i += 2 ; while ( j < n && A [ j ] % 2 == 1 ) j += 2 ; if ( i < n ) swap ( A [ i ], A [ j ]); } return A ; } }; 923. 3Sum With Multiplicity $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int threeSumMulti ( vector < int >& A , int target ) { long ans = 0 ; unordered_map < int , long > map ; for ( int a : A ) map [ a ] ++ ; for ( auto & [ i , x ] : map ) for ( auto & [ j , y ] : map ) { int k = target - i - j ; if ( ! map . count ( k )) continue ; if ( i == j && j == k ) ans += x * ( x - 1 ) * ( x - 2 ) / 6 ; else if ( i == j && j != k ) ans += x * ( x - 1 ) / 2 * map [ k ]; else if ( i < j && j < k ) ans += x * y * map [ k ]; } return ans % int ( 1e9 + 7 ); } }; 924. Minimize Malware Spread $\\star\\star\\star$ 925. Long Pressed Name $\\star$ 926. Flip String to Monotone Increasing $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int minFlipsMonoIncr ( string S ) { vector < int > dp ( 2 ); for ( int i = 0 ; i < S . length (); i ++ ) { int temp = dp [ 0 ] + ( S [ i ] == '1' ); dp [ 1 ] = min ( dp [ 0 ], dp [ 1 ]) + ( S [ i ] == '0' ); dp [ 0 ] = temp ; } return min ( dp [ 0 ], dp [ 1 ]); } }; 927. Three Equal Parts $\\star\\star\\star$ 928. Minimize Malware Spread II $\\star\\star\\star$ 929. Unique Email Addresses $\\star$ 930. Binary Subarrays With Sum $\\star\\star$","title":"0921-0930"},{"location":"cpp/0901-1000/0921-0930/#921-minimum-add-to-make-parentheses-valid-starstar","text":"","title":"921. Minimum Add to Make Parentheses Valid $\\star\\star$"},{"location":"cpp/0901-1000/0921-0930/#922-sort-array-by-parity-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > sortArrayByParityII ( vector < int >& A ) { const int n = A . size (); for ( int i = 0 , j = 1 ; i < n ; i += 2 , j += 2 ) { while ( i < n && A [ i ] % 2 == 0 ) i += 2 ; while ( j < n && A [ j ] % 2 == 1 ) j += 2 ; if ( i < n ) swap ( A [ i ], A [ j ]); } return A ; } };","title":"922. Sort Array By Parity II $\\star$"},{"location":"cpp/0901-1000/0921-0930/#923-3sum-with-multiplicity-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : int threeSumMulti ( vector < int >& A , int target ) { long ans = 0 ; unordered_map < int , long > map ; for ( int a : A ) map [ a ] ++ ; for ( auto & [ i , x ] : map ) for ( auto & [ j , y ] : map ) { int k = target - i - j ; if ( ! map . count ( k )) continue ; if ( i == j && j == k ) ans += x * ( x - 1 ) * ( x - 2 ) / 6 ; else if ( i == j && j != k ) ans += x * ( x - 1 ) / 2 * map [ k ]; else if ( i < j && j < k ) ans += x * y * map [ k ]; } return ans % int ( 1e9 + 7 ); } };","title":"923. 3Sum With Multiplicity $\\star\\star$"},{"location":"cpp/0901-1000/0921-0930/#924-minimize-malware-spread-starstarstar","text":"","title":"924. Minimize Malware Spread $\\star\\star\\star$"},{"location":"cpp/0901-1000/0921-0930/#925-long-pressed-name-star","text":"","title":"925. Long Pressed Name $\\star$"},{"location":"cpp/0901-1000/0921-0930/#926-flip-string-to-monotone-increasing-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int minFlipsMonoIncr ( string S ) { vector < int > dp ( 2 ); for ( int i = 0 ; i < S . length (); i ++ ) { int temp = dp [ 0 ] + ( S [ i ] == '1' ); dp [ 1 ] = min ( dp [ 0 ], dp [ 1 ]) + ( S [ i ] == '0' ); dp [ 0 ] = temp ; } return min ( dp [ 0 ], dp [ 1 ]); } };","title":"926. Flip String to Monotone Increasing $\\star\\star$"},{"location":"cpp/0901-1000/0921-0930/#927-three-equal-parts-starstarstar","text":"","title":"927. Three Equal Parts $\\star\\star\\star$"},{"location":"cpp/0901-1000/0921-0930/#928-minimize-malware-spread-ii-starstarstar","text":"","title":"928. Minimize Malware Spread II $\\star\\star\\star$"},{"location":"cpp/0901-1000/0921-0930/#929-unique-email-addresses-star","text":"","title":"929. Unique Email Addresses $\\star$"},{"location":"cpp/0901-1000/0921-0930/#930-binary-subarrays-with-sum-starstar","text":"","title":"930. Binary Subarrays With Sum $\\star\\star$"},{"location":"cpp/0901-1000/0931-0940/","text":"931. Minimum Falling Path Sum $\\star\\star$ 932. Beautiful Array $\\star\\star$ 933. Number of Recent Calls $\\star$ 934. Shortest Bridge $\\star\\star$ 935. Knight Dialer $\\star\\star$ 936. Stamping The Sequence $\\star\\star\\star$ 937. Reorder Data in Log Files $\\star$ 938. Range Sum of BST $\\star$ 939. Minimum Area Rectangle $\\star\\star$ 940. Distinct Subsequences II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int distinctSubseqII ( string S ) { vector < long > map ( 26 ); for ( char c : S ) map [ c - 'a' ] = accumulate ( map . begin (), map . end (), 1L ) % int ( 1e9 + 7 ); return accumulate ( map . begin (), map . end (), 0L ) % int ( 1e9 + 7 ); } };","title":"0931-0940"},{"location":"cpp/0901-1000/0931-0940/#931-minimum-falling-path-sum-starstar","text":"","title":"931. Minimum Falling Path Sum $\\star\\star$"},{"location":"cpp/0901-1000/0931-0940/#932-beautiful-array-starstar","text":"","title":"932. Beautiful Array $\\star\\star$"},{"location":"cpp/0901-1000/0931-0940/#933-number-of-recent-calls-star","text":"","title":"933. Number of Recent Calls $\\star$"},{"location":"cpp/0901-1000/0931-0940/#934-shortest-bridge-starstar","text":"","title":"934. Shortest Bridge $\\star\\star$"},{"location":"cpp/0901-1000/0931-0940/#935-knight-dialer-starstar","text":"","title":"935. Knight Dialer $\\star\\star$"},{"location":"cpp/0901-1000/0931-0940/#936-stamping-the-sequence-starstarstar","text":"","title":"936. Stamping The Sequence $\\star\\star\\star$"},{"location":"cpp/0901-1000/0931-0940/#937-reorder-data-in-log-files-star","text":"","title":"937. Reorder Data in Log Files $\\star$"},{"location":"cpp/0901-1000/0931-0940/#938-range-sum-of-bst-star","text":"","title":"938. Range Sum of BST $\\star$"},{"location":"cpp/0901-1000/0931-0940/#939-minimum-area-rectangle-starstar","text":"","title":"939. Minimum Area Rectangle $\\star\\star$"},{"location":"cpp/0901-1000/0931-0940/#940-distinct-subsequences-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public : int distinctSubseqII ( string S ) { vector < long > map ( 26 ); for ( char c : S ) map [ c - 'a' ] = accumulate ( map . begin (), map . end (), 1L ) % int ( 1e9 + 7 ); return accumulate ( map . begin (), map . end (), 0L ) % int ( 1e9 + 7 ); } };","title":"940. Distinct Subsequences II $\\star\\star\\star$"},{"location":"cpp/0901-1000/0941-0950/","text":"941. Valid Mountain Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool validMountainArray ( vector < int >& A ) { if ( A . size () < 3 ) return false ; int l = 0 ; int r = A . size () - 1 ; while ( l + 1 < A . size () && A [ l ] < A [ l + 1 ]) l ++ ; while ( r > 0 && A [ r ] < A [ r - 1 ]) r -- ; return l > 0 && r < A . size () - 1 && l == r ; } }; 942. DI String Match $\\star$ 943. Find the Shortest Superstring $\\star\\star\\star$ 944. Delete Columns to Make Sorted $\\star$ 945. Minimum Increment to Make Array Unique $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int minIncrementForUnique ( vector < int >& A ) { int ans = 0 ; int minAvailable = 0 ; sort ( A . begin (), A . end ()); for ( int a : A ) { ans += max ( minAvailable - a , 0 ); minAvailable = max ( minAvailable , a ) + 1 ; } return ans ; } }; 946. Validate Stack Sequences $\\star\\star$ 947. Most Stones Removed with Same Row or Column $\\star\\star$ 948. Bag of Tokens $\\star\\star$ 949. Largest Time for Given Digits $\\star$ 950. Reveal Cards In Increasing Order $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > deckRevealedIncreasing ( vector < int >& deck ) { sort ( deck . begin (), deck . end (), greater < int > ()); deque < int > deque = { deck [ 0 ]}; for ( int i = 1 ; i < deck . size (); i ++ ) { deque . push_front ( deque . back ()); deque . pop_back (); deque . push_front ( deck [ i ]); } return vector < int > ( deque . begin (), deque . end ()); } };","title":"0941-0950"},{"location":"cpp/0901-1000/0941-0950/#941-valid-mountain-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool validMountainArray ( vector < int >& A ) { if ( A . size () < 3 ) return false ; int l = 0 ; int r = A . size () - 1 ; while ( l + 1 < A . size () && A [ l ] < A [ l + 1 ]) l ++ ; while ( r > 0 && A [ r ] < A [ r - 1 ]) r -- ; return l > 0 && r < A . size () - 1 && l == r ; } };","title":"941. Valid Mountain Array $\\star$"},{"location":"cpp/0901-1000/0941-0950/#942-di-string-match-star","text":"","title":"942. DI String Match $\\star$"},{"location":"cpp/0901-1000/0941-0950/#943-find-the-shortest-superstring-starstarstar","text":"","title":"943. Find the Shortest Superstring $\\star\\star\\star$"},{"location":"cpp/0901-1000/0941-0950/#944-delete-columns-to-make-sorted-star","text":"","title":"944. Delete Columns to Make Sorted $\\star$"},{"location":"cpp/0901-1000/0941-0950/#945-minimum-increment-to-make-array-unique-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int minIncrementForUnique ( vector < int >& A ) { int ans = 0 ; int minAvailable = 0 ; sort ( A . begin (), A . end ()); for ( int a : A ) { ans += max ( minAvailable - a , 0 ); minAvailable = max ( minAvailable , a ) + 1 ; } return ans ; } };","title":"945. Minimum Increment to Make Array Unique $\\star\\star$"},{"location":"cpp/0901-1000/0941-0950/#946-validate-stack-sequences-starstar","text":"","title":"946. Validate Stack Sequences $\\star\\star$"},{"location":"cpp/0901-1000/0941-0950/#947-most-stones-removed-with-same-row-or-column-starstar","text":"","title":"947. Most Stones Removed with Same Row or Column $\\star\\star$"},{"location":"cpp/0901-1000/0941-0950/#948-bag-of-tokens-starstar","text":"","title":"948. Bag of Tokens $\\star\\star$"},{"location":"cpp/0901-1000/0941-0950/#949-largest-time-for-given-digits-star","text":"","title":"949. Largest Time for Given Digits $\\star$"},{"location":"cpp/0901-1000/0941-0950/#950-reveal-cards-in-increasing-order-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : vector < int > deckRevealedIncreasing ( vector < int >& deck ) { sort ( deck . begin (), deck . end (), greater < int > ()); deque < int > deque = { deck [ 0 ]}; for ( int i = 1 ; i < deck . size (); i ++ ) { deque . push_front ( deque . back ()); deque . pop_back (); deque . push_front ( deck [ i ]); } return vector < int > ( deque . begin (), deque . end ()); } };","title":"950. Reveal Cards In Increasing Order $\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/","text":"951. Flip Equivalent Binary Trees $\\star\\star$ 952. Largest Component Size by Common Factor $\\star\\star\\star$ 953. Verifying an Alien Dictionary $\\star$ 954. Array of Doubled Pairs $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : bool canReorderDoubled ( vector < int >& A ) { unordered_map < int , int > count ; for ( int a : A ) count [ a ] ++ ; sort ( A . begin (), A . end (), []( int a , int b ) { return abs ( a ) < abs ( b ); }); for ( int a : A ) { if ( count [ a ] == 0 ) continue ; if ( count [ 2 * a ] == 0 ) return false ; count [ a ] -- ; count [ 2 * a ] -- ; } return true ; } }; 955. Delete Columns to Make Sorted II $\\star\\star$ 956. Tallest Billboard $\\star\\star\\star$ 957. Prison Cells After N Days $\\star\\star$ 958. Check Completeness of a Binary Tree $\\star\\star$ 959. Regions Cut By Slashes $\\star\\star$ 960. Delete Columns to Make Sorted III $\\star\\star\\star$","title":"0951-0960"},{"location":"cpp/0901-1000/0951-0960/#951-flip-equivalent-binary-trees-starstar","text":"","title":"951. Flip Equivalent Binary Trees $\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/#952-largest-component-size-by-common-factor-starstarstar","text":"","title":"952. Largest Component Size by Common Factor $\\star\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/#953-verifying-an-alien-dictionary-star","text":"","title":"953. Verifying an Alien Dictionary $\\star$"},{"location":"cpp/0901-1000/0951-0960/#954-array-of-doubled-pairs-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : bool canReorderDoubled ( vector < int >& A ) { unordered_map < int , int > count ; for ( int a : A ) count [ a ] ++ ; sort ( A . begin (), A . end (), []( int a , int b ) { return abs ( a ) < abs ( b ); }); for ( int a : A ) { if ( count [ a ] == 0 ) continue ; if ( count [ 2 * a ] == 0 ) return false ; count [ a ] -- ; count [ 2 * a ] -- ; } return true ; } };","title":"954. Array of Doubled Pairs $\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/#955-delete-columns-to-make-sorted-ii-starstar","text":"","title":"955. Delete Columns to Make Sorted II $\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/#956-tallest-billboard-starstarstar","text":"","title":"956. Tallest Billboard $\\star\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/#957-prison-cells-after-n-days-starstar","text":"","title":"957. Prison Cells After N Days $\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/#958-check-completeness-of-a-binary-tree-starstar","text":"","title":"958. Check Completeness of a Binary Tree $\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/#959-regions-cut-by-slashes-starstar","text":"","title":"959. Regions Cut By Slashes $\\star\\star$"},{"location":"cpp/0901-1000/0951-0960/#960-delete-columns-to-make-sorted-iii-starstarstar","text":"","title":"960. Delete Columns to Make Sorted III $\\star\\star\\star$"},{"location":"cpp/0901-1000/0961-0970/","text":"961. N-Repeated Element in Size 2N Array $\\star$ 962. Maximum Width Ramp $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int maxWidthRamp ( vector < int >& A ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i < A . size (); i ++ ) if ( stack . empty () || A [ i ] < A [ stack . top ()]) stack . push ( i ); for ( int i = A . size () - 1 ; i > ans ; i -- ) while ( ! stack . empty () && A [ i ] >= A [ stack . top ()]) ans = max ( ans , i - stack . top ()), stack . pop (); return ans ; } }; 963. Minimum Area Rectangle II $\\star\\star$ 964. Least Operators to Express Number $\\star\\star\\star$ 965. Univalued Binary Tree $\\star$ 966. Vowel Spellchecker $\\star\\star$ 967. Numbers With Same Consecutive Differences $\\star\\star$ 968. Binary Tree Cameras $\\star\\star\\star$ 969. Pancake Sorting $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < int > pancakeSort ( vector < int >& A ) { vector < int > ans ; for ( int target = A . size (); target >= 1 ; target -- ) { int index = find ( A , target ); reverse ( A . begin (), A . begin () + index + 1 ); reverse ( A . begin (), A . begin () + target ); ans . push_back ( index + 1 ); ans . push_back ( target ); } return ans ; } private : int find ( vector < int >& A , int target ) { for ( int i = 0 ; i < A . size (); i ++ ) if ( A [ i ] == target ) return i ; throw ; } }; 970. Powerful Integers $\\star$","title":"0961-0970"},{"location":"cpp/0901-1000/0961-0970/#961-n-repeated-element-in-size-2n-array-star","text":"","title":"961. N-Repeated Element in Size 2N Array $\\star$"},{"location":"cpp/0901-1000/0961-0970/#962-maximum-width-ramp-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int maxWidthRamp ( vector < int >& A ) { int ans = 0 ; stack < int > stack ; for ( int i = 0 ; i < A . size (); i ++ ) if ( stack . empty () || A [ i ] < A [ stack . top ()]) stack . push ( i ); for ( int i = A . size () - 1 ; i > ans ; i -- ) while ( ! stack . empty () && A [ i ] >= A [ stack . top ()]) ans = max ( ans , i - stack . top ()), stack . pop (); return ans ; } };","title":"962. Maximum Width Ramp $\\star\\star$"},{"location":"cpp/0901-1000/0961-0970/#963-minimum-area-rectangle-ii-starstar","text":"","title":"963. Minimum Area Rectangle II $\\star\\star$"},{"location":"cpp/0901-1000/0961-0970/#964-least-operators-to-express-number-starstarstar","text":"","title":"964. Least Operators to Express Number $\\star\\star\\star$"},{"location":"cpp/0901-1000/0961-0970/#965-univalued-binary-tree-star","text":"","title":"965. Univalued Binary Tree $\\star$"},{"location":"cpp/0901-1000/0961-0970/#966-vowel-spellchecker-starstar","text":"","title":"966. Vowel Spellchecker $\\star\\star$"},{"location":"cpp/0901-1000/0961-0970/#967-numbers-with-same-consecutive-differences-starstar","text":"","title":"967. Numbers With Same Consecutive Differences $\\star\\star$"},{"location":"cpp/0901-1000/0961-0970/#968-binary-tree-cameras-starstarstar","text":"","title":"968. Binary Tree Cameras $\\star\\star\\star$"},{"location":"cpp/0901-1000/0961-0970/#969-pancake-sorting-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public : vector < int > pancakeSort ( vector < int >& A ) { vector < int > ans ; for ( int target = A . size (); target >= 1 ; target -- ) { int index = find ( A , target ); reverse ( A . begin (), A . begin () + index + 1 ); reverse ( A . begin (), A . begin () + target ); ans . push_back ( index + 1 ); ans . push_back ( target ); } return ans ; } private : int find ( vector < int >& A , int target ) { for ( int i = 0 ; i < A . size (); i ++ ) if ( A [ i ] == target ) return i ; throw ; } };","title":"969. Pancake Sorting $\\star\\star$"},{"location":"cpp/0901-1000/0961-0970/#970-powerful-integers-star","text":"","title":"970. Powerful Integers $\\star$"},{"location":"cpp/0901-1000/0971-0980/","text":"971. Flip Binary Tree To Match Preorder Traversal $\\star\\star$ 972. Equal Rational Numbers $\\star\\star\\star$ 973. K Closest Points to Origin $\\star\\star$ 974. Subarray Sums Divisible by K $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int subarraysDivByK ( vector < int >& A , int K ) { int ans = 0 ; int presum = 0 ; vector < int > count ( K ); count [ 0 ] = 1 ; for ( int a : A ) { presum = ( presum + a % K + K ) % K ; ans += count [ presum ]; count [ presum ] ++ ; } return ans ; } }; 975. Odd Even Jump $\\star\\star\\star$ 976. Largest Perimeter Triangle $\\star$ 977. Squares of a Sorted Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > sortedSquares ( vector < int >& A ) { int n = A . size (); int l = 0 ; int r = n - 1 ; vector < int > ans ( n ); while ( l <= r ) ans [ -- n ] = abs ( A [ l ]) > abs ( A [ r ]) ? A [ l ] * A [ l ++ ] : A [ r ] * A [ r -- ]; return ans ; } }; 978. Longest Turbulent Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int maxTurbulenceSize ( vector < int >& A ) { int ans = 1 ; int increasing = 1 ; int decreasing = 1 ; for ( int i = 1 ; i < A . size (); i ++ ) { if ( A [ i ] > A [ i - 1 ]) { increasing = decreasing + 1 ; decreasing = 1 ; } else if ( A [ i ] < A [ i - 1 ]) { decreasing = increasing + 1 ; increasing = 1 ; } else { increasing = 1 ; decreasing = 1 ; } ans = max ( ans , max ( increasing , decreasing )); } return ans ; } }; 979. Distribute Coins in Binary Tree $\\star\\star$ 980. Unique Paths III $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public : int uniquePathsIII ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; int empty = 1 ; int sx ; int sy ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { if ( grid [ i ][ j ] == 0 ) { empty ++ ; } else if ( grid [ i ][ j ] == 1 ) { sx = i ; sy = j ; } else if ( grid [ i ][ j ] == 2 ) { ex = i ; ey = j ; } } dfs ( grid , empty , sx , sy , ans ); return ans ; } private : int ex ; int ey ; void dfs ( vector < vector < int >>& grid , int empty , int i , int j , int & ans ) { if ( i < 0 || i >= grid . size () || j < 0 || j >= grid [ 0 ]. size () || grid [ i ][ j ] < 0 ) return ; if ( i == ex && j == ey ) { if ( empty == 0 ) ans ++ ; return ; } grid [ i ][ j ] = - 2 ; dfs ( grid , empty - 1 , i + 1 , j , ans ); dfs ( grid , empty - 1 , i - 1 , j , ans ); dfs ( grid , empty - 1 , i , j + 1 , ans ); dfs ( grid , empty - 1 , i , j - 1 , ans ); grid [ i ][ j ] = 0 ; } };","title":"0971-0980"},{"location":"cpp/0901-1000/0971-0980/#971-flip-binary-tree-to-match-preorder-traversal-starstar","text":"","title":"971. Flip Binary Tree To Match Preorder Traversal $\\star\\star$"},{"location":"cpp/0901-1000/0971-0980/#972-equal-rational-numbers-starstarstar","text":"","title":"972. Equal Rational Numbers $\\star\\star\\star$"},{"location":"cpp/0901-1000/0971-0980/#973-k-closest-points-to-origin-starstar","text":"","title":"973. K Closest Points to Origin $\\star\\star$"},{"location":"cpp/0901-1000/0971-0980/#974-subarray-sums-divisible-by-k-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int subarraysDivByK ( vector < int >& A , int K ) { int ans = 0 ; int presum = 0 ; vector < int > count ( K ); count [ 0 ] = 1 ; for ( int a : A ) { presum = ( presum + a % K + K ) % K ; ans += count [ presum ]; count [ presum ] ++ ; } return ans ; } };","title":"974. Subarray Sums Divisible by K $\\star\\star$"},{"location":"cpp/0901-1000/0971-0980/#975-odd-even-jump-starstarstar","text":"","title":"975. Odd Even Jump $\\star\\star\\star$"},{"location":"cpp/0901-1000/0971-0980/#976-largest-perimeter-triangle-star","text":"","title":"976. Largest Perimeter Triangle $\\star$"},{"location":"cpp/0901-1000/0971-0980/#977-squares-of-a-sorted-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > sortedSquares ( vector < int >& A ) { int n = A . size (); int l = 0 ; int r = n - 1 ; vector < int > ans ( n ); while ( l <= r ) ans [ -- n ] = abs ( A [ l ]) > abs ( A [ r ]) ? A [ l ] * A [ l ++ ] : A [ r ] * A [ r -- ]; return ans ; } };","title":"977. Squares of a Sorted Array $\\star$"},{"location":"cpp/0901-1000/0971-0980/#978-longest-turbulent-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int maxTurbulenceSize ( vector < int >& A ) { int ans = 1 ; int increasing = 1 ; int decreasing = 1 ; for ( int i = 1 ; i < A . size (); i ++ ) { if ( A [ i ] > A [ i - 1 ]) { increasing = decreasing + 1 ; decreasing = 1 ; } else if ( A [ i ] < A [ i - 1 ]) { decreasing = increasing + 1 ; increasing = 1 ; } else { increasing = 1 ; decreasing = 1 ; } ans = max ( ans , max ( increasing , decreasing )); } return ans ; } };","title":"978. Longest Turbulent Subarray $\\star\\star$"},{"location":"cpp/0901-1000/0971-0980/#979-distribute-coins-in-binary-tree-starstar","text":"","title":"979. Distribute Coins in Binary Tree $\\star\\star$"},{"location":"cpp/0901-1000/0971-0980/#980-unique-paths-iii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class Solution { public : int uniquePathsIII ( vector < vector < int >>& grid ) { const int m = grid . size (); const int n = grid [ 0 ]. size (); int ans = 0 ; int empty = 1 ; int sx ; int sy ; for ( int i = 0 ; i < m ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { if ( grid [ i ][ j ] == 0 ) { empty ++ ; } else if ( grid [ i ][ j ] == 1 ) { sx = i ; sy = j ; } else if ( grid [ i ][ j ] == 2 ) { ex = i ; ey = j ; } } dfs ( grid , empty , sx , sy , ans ); return ans ; } private : int ex ; int ey ; void dfs ( vector < vector < int >>& grid , int empty , int i , int j , int & ans ) { if ( i < 0 || i >= grid . size () || j < 0 || j >= grid [ 0 ]. size () || grid [ i ][ j ] < 0 ) return ; if ( i == ex && j == ey ) { if ( empty == 0 ) ans ++ ; return ; } grid [ i ][ j ] = - 2 ; dfs ( grid , empty - 1 , i + 1 , j , ans ); dfs ( grid , empty - 1 , i - 1 , j , ans ); dfs ( grid , empty - 1 , i , j + 1 , ans ); dfs ( grid , empty - 1 , i , j - 1 , ans ); grid [ i ][ j ] = 0 ; } };","title":"980. Unique Paths III $\\star\\star\\star$"},{"location":"cpp/0901-1000/0981-0990/","text":"981. Time Based Key-Value Store $\\star\\star$ 982. Triples with Bitwise AND Equal To Zero $\\star\\star\\star$ 983. Minimum Cost For Tickets $\\star\\star$ 984. String Without AAA or BBB $\\star\\star$ 985. Sum of Even Numbers After Queries $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > sumEvenAfterQueries ( vector < int >& A , vector < vector < int >>& queries ) { vector < int > ans ; int sum = accumulate ( A . begin (), A . end (), 0 , []( int a , int b ) { return a + ( b % 2 == 0 ? b : 0 ); }); for ( vector < int >& query : queries ) { if ( A [ query [ 1 ]] % 2 == 0 ) sum -= A [ query [ 1 ]]; A [ query [ 1 ]] += query [ 0 ]; if ( A [ query [ 1 ]] % 2 == 0 ) sum += A [ query [ 1 ]]; ans . push_back ( sum ); } return ans ; } }; 986. Interval List Intersections $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < vector < int >> intervalIntersection ( vector < vector < int >>& A , vector < vector < int >>& B ) { vector < vector < int >> ans ; short i = 0 ; short j = 0 ; while ( i < A . size () && j < B . size ()) { int start = max ( A [ i ][ 0 ], B [ j ][ 0 ]); int end = min ( A [ i ][ 1 ], B [ j ][ 1 ]); if ( end >= start ) ans . push_back ({ start , end }); if ( A [ i ][ 1 ] > B [ j ][ 1 ]) j ++ ; else i ++ ; } return ans ; } }; 987. Vertical Order Traversal of a Binary Tree $\\star\\star$ 988. Smallest String Starting From Leaf $\\star\\star$ 989. Add to Array-Form of Integer $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > addToArrayForm ( vector < int >& A , int K ) { for ( int i = A . size () - 1 ; i >= 0 ; i -- ) { A [ i ] += K ; K = A [ i ] / 10 ; A [ i ] %= 10 ; } while ( K > 0 ) { A . insert ( A . begin (), K % 10 ); K /= 10 ; } return A ; } }; 990. Satisfiability of Equality Equations $\\star\\star$","title":"0981-0990"},{"location":"cpp/0901-1000/0981-0990/#981-time-based-key-value-store-starstar","text":"","title":"981. Time Based Key-Value Store $\\star\\star$"},{"location":"cpp/0901-1000/0981-0990/#982-triples-with-bitwise-and-equal-to-zero-starstarstar","text":"","title":"982. Triples with Bitwise AND Equal To Zero $\\star\\star\\star$"},{"location":"cpp/0901-1000/0981-0990/#983-minimum-cost-for-tickets-starstar","text":"","title":"983. Minimum Cost For Tickets $\\star\\star$"},{"location":"cpp/0901-1000/0981-0990/#984-string-without-aaa-or-bbb-starstar","text":"","title":"984. String Without AAA or BBB $\\star\\star$"},{"location":"cpp/0901-1000/0981-0990/#985-sum-of-even-numbers-after-queries-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : vector < int > sumEvenAfterQueries ( vector < int >& A , vector < vector < int >>& queries ) { vector < int > ans ; int sum = accumulate ( A . begin (), A . end (), 0 , []( int a , int b ) { return a + ( b % 2 == 0 ? b : 0 ); }); for ( vector < int >& query : queries ) { if ( A [ query [ 1 ]] % 2 == 0 ) sum -= A [ query [ 1 ]]; A [ query [ 1 ]] += query [ 0 ]; if ( A [ query [ 1 ]] % 2 == 0 ) sum += A [ query [ 1 ]]; ans . push_back ( sum ); } return ans ; } };","title":"985. Sum of Even Numbers After Queries $\\star$"},{"location":"cpp/0901-1000/0981-0990/#986-interval-list-intersections-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < vector < int >> intervalIntersection ( vector < vector < int >>& A , vector < vector < int >>& B ) { vector < vector < int >> ans ; short i = 0 ; short j = 0 ; while ( i < A . size () && j < B . size ()) { int start = max ( A [ i ][ 0 ], B [ j ][ 0 ]); int end = min ( A [ i ][ 1 ], B [ j ][ 1 ]); if ( end >= start ) ans . push_back ({ start , end }); if ( A [ i ][ 1 ] > B [ j ][ 1 ]) j ++ ; else i ++ ; } return ans ; } };","title":"986. Interval List Intersections $\\star\\star$"},{"location":"cpp/0901-1000/0981-0990/#987-vertical-order-traversal-of-a-binary-tree-starstar","text":"","title":"987. Vertical Order Traversal of a Binary Tree $\\star\\star$"},{"location":"cpp/0901-1000/0981-0990/#988-smallest-string-starting-from-leaf-starstar","text":"","title":"988. Smallest String Starting From Leaf $\\star\\star$"},{"location":"cpp/0901-1000/0981-0990/#989-add-to-array-form-of-integer-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : vector < int > addToArrayForm ( vector < int >& A , int K ) { for ( int i = A . size () - 1 ; i >= 0 ; i -- ) { A [ i ] += K ; K = A [ i ] / 10 ; A [ i ] %= 10 ; } while ( K > 0 ) { A . insert ( A . begin (), K % 10 ); K /= 10 ; } return A ; } };","title":"989. Add to Array-Form of Integer $\\star$"},{"location":"cpp/0901-1000/0981-0990/#990-satisfiability-of-equality-equations-starstar","text":"","title":"990. Satisfiability of Equality Equations $\\star\\star$"},{"location":"cpp/0901-1000/0991-1000/","text":"991. Broken Calculator $\\star\\star$ 992. Subarrays with K Different Integers $\\star\\star\\star$ 993. Cousins in Binary Tree $\\star$ 994. Rotting Oranges $\\star$ 995. Minimum Number of K Consecutive Bit Flips $\\star\\star\\star$ 996. Number of Squareful Arrays $\\star\\star\\star$ 997. Find the Town Judge $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int findJudge ( int N , vector < vector < int >>& trust ) { vector < int > count ( N ); for ( vector < int >& t : trust ) { count [ t [ 0 ] - 1 ] -- ; count [ t [ 1 ] - 1 ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) if ( count [ i ] == N - 1 ) return i + 1 ; return - 1 ; } }; 998. Maximum Binary Tree II $\\star\\star$ 999. Available Captures for Rook $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int numRookCaptures ( vector < vector < char >>& board ) { int ans = 0 ; int i0 = 0 ; int j0 = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) for ( int j = 0 ; j < 8 ; j ++ ) if ( board [ i ][ j ] == 'R' ) { i0 = i ; j0 = j ; } for ( auto d : vector < vector < int >> ({{ 1 , 0 }, { 0 , 1 }, { - 1 , 0 }, { 0 , - 1 }})) for ( int i = i0 + d [ 0 ], j = j0 + d [ 1 ]; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ], j += d [ 1 ]) { if ( board [ i ][ j ] == 'p' ) ans ++ ; if ( board [ i ][ j ] != '.' ) break ; } return ans ; } }; 1000. Minimum Cost to Merge Stones $\\star\\star\\star$","title":"0991-1000"},{"location":"cpp/0901-1000/0991-1000/#991-broken-calculator-starstar","text":"","title":"991. Broken Calculator $\\star\\star$"},{"location":"cpp/0901-1000/0991-1000/#992-subarrays-with-k-different-integers-starstarstar","text":"","title":"992. Subarrays with K Different Integers $\\star\\star\\star$"},{"location":"cpp/0901-1000/0991-1000/#993-cousins-in-binary-tree-star","text":"","title":"993. Cousins in Binary Tree $\\star$"},{"location":"cpp/0901-1000/0991-1000/#994-rotting-oranges-star","text":"","title":"994. Rotting Oranges $\\star$"},{"location":"cpp/0901-1000/0991-1000/#995-minimum-number-of-k-consecutive-bit-flips-starstarstar","text":"","title":"995. Minimum Number of K Consecutive Bit Flips $\\star\\star\\star$"},{"location":"cpp/0901-1000/0991-1000/#996-number-of-squareful-arrays-starstarstar","text":"","title":"996. Number of Squareful Arrays $\\star\\star\\star$"},{"location":"cpp/0901-1000/0991-1000/#997-find-the-town-judge-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int findJudge ( int N , vector < vector < int >>& trust ) { vector < int > count ( N ); for ( vector < int >& t : trust ) { count [ t [ 0 ] - 1 ] -- ; count [ t [ 1 ] - 1 ] ++ ; } for ( int i = 0 ; i < N ; i ++ ) if ( count [ i ] == N - 1 ) return i + 1 ; return - 1 ; } };","title":"997. Find the Town Judge $\\star$"},{"location":"cpp/0901-1000/0991-1000/#998-maximum-binary-tree-ii-starstar","text":"","title":"998. Maximum Binary Tree II $\\star\\star$"},{"location":"cpp/0901-1000/0991-1000/#999-available-captures-for-rook-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public : int numRookCaptures ( vector < vector < char >>& board ) { int ans = 0 ; int i0 = 0 ; int j0 = 0 ; for ( int i = 0 ; i < 8 ; i ++ ) for ( int j = 0 ; j < 8 ; j ++ ) if ( board [ i ][ j ] == 'R' ) { i0 = i ; j0 = j ; } for ( auto d : vector < vector < int >> ({{ 1 , 0 }, { 0 , 1 }, { - 1 , 0 }, { 0 , - 1 }})) for ( int i = i0 + d [ 0 ], j = j0 + d [ 1 ]; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ], j += d [ 1 ]) { if ( board [ i ][ j ] == 'p' ) ans ++ ; if ( board [ i ][ j ] != '.' ) break ; } return ans ; } };","title":"999. Available Captures for Rook $\\star$"},{"location":"cpp/0901-1000/0991-1000/#1000-minimum-cost-to-merge-stones-starstarstar","text":"","title":"1000. Minimum Cost to Merge Stones $\\star\\star\\star$"},{"location":"cpp/1001-1100/1001-1010/","text":"1001. Grid Illumination $\\star\\star\\star$ 1002. Find Common Characters $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < string > commonChars ( vector < string >& A ) { vector < string > ans ; vector < int > commonCount ( 26 , INT_MAX ); for ( string & a : A ) { vector < int > count ( 26 ); for ( char c : a ) count [ c - 'a' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) commonCount [ i ] = min ( commonCount [ i ], count [ i ]); } for ( char c = 'a' ; c <= 'z' ; c ++ ) for ( int i = 0 ; i < commonCount [ c - 'a' ]; i ++ ) ans . push_back ( string ( 1 , c )); return ans ; } }; 1003. Check If Word Is Valid After Substitutions $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : bool isValid ( string S ) { vector < char > stack ; for ( char c : S ) { if ( c == 'c' ) { int n = stack . size (); if ( n < 2 || stack [ n - 2 ] != 'a' || stack [ n - 1 ] != 'b' ) return false ; stack . pop_back (); stack . pop_back (); } else { stack . push_back ( c ); } } return stack . empty (); } }; 1004. Max Consecutive Ones III $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int longestOnes ( vector < int >& A , int K ) { int i = 0 ; for ( int a : A ) { if ( a == 0 ) K -- ; if ( K < 0 ) { if ( A [ i ] == 0 ) K ++ ; i ++ ; } } return A . size () - i ; } }; 1005. Maximize Sum Of Array After K Negations $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int largestSumAfterKNegations ( vector < int >& A , int K ) { sort ( A . begin (), A . end ()); for ( int i = 0 ; i < A . size (); i ++ ) { if ( A [ i ] > 0 || K == 0 ) break ; A [ i ] = - A [ i ]; K -- ; } return accumulate ( A . begin (), A . end (), 0 ) - ( K % 2 ) * * min_element ( A . begin (), A . end ()) * 2 ; } }; 1006. Clumsy Factorial $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public : int clumsy ( int N ) { if ( N <= 2 ) return N ; if ( N <= 4 ) return N + 3 ; if (( N - 4 ) % 4 == 0 ) return N + 1 ; if (( N - 4 ) % 4 <= 2 ) return N + 2 ; return N - 1 ; } }; 1007. Minimum Domino Rotations For Equal Row $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int minDominoRotations ( vector < int >& A , vector < int >& B ) { const int n = A . size (); vector < int > countA ( 7 ); vector < int > countB ( 7 ); vector < int > countBoth ( 7 ); for ( int i = 0 ; i < n ; i ++ ) { countA [ A [ i ]] ++ ; countB [ B [ i ]] ++ ; if ( A [ i ] == B [ i ]) countBoth [ A [ i ]] ++ ; } for ( int i = 1 ; i <= 6 ; i ++ ) if ( countA [ i ] + countB [ i ] - countBoth [ i ] == n ) return n - max ( countA [ i ], countB [ i ]); return - 1 ; } }; 1008. Construct Binary Search Tree from Preorder Traversal $\\star\\star$ 1009. Complement of Base 10 Integer $\\star$ 1010. Pairs of Songs With Total Durations Divisible by 60 $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numPairsDivisibleBy60 ( vector < int >& time ) { int ans = 0 ; vector < int > count ( 60 ); for ( int t : time ) { t %= 60 ; ans += t == 0 ? count [ 0 ] : count [ 60 - t ]; count [ t ] ++ ; } return ans ; } };","title":"1001-1010"},{"location":"cpp/1001-1100/1001-1010/#1001-grid-illumination-starstarstar","text":"","title":"1001. Grid Illumination $\\star\\star\\star$"},{"location":"cpp/1001-1100/1001-1010/#1002-find-common-characters-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < string > commonChars ( vector < string >& A ) { vector < string > ans ; vector < int > commonCount ( 26 , INT_MAX ); for ( string & a : A ) { vector < int > count ( 26 ); for ( char c : a ) count [ c - 'a' ] ++ ; for ( int i = 0 ; i < 26 ; i ++ ) commonCount [ i ] = min ( commonCount [ i ], count [ i ]); } for ( char c = 'a' ; c <= 'z' ; c ++ ) for ( int i = 0 ; i < commonCount [ c - 'a' ]; i ++ ) ans . push_back ( string ( 1 , c )); return ans ; } };","title":"1002. Find Common Characters $\\star$"},{"location":"cpp/1001-1100/1001-1010/#1003-check-if-word-is-valid-after-substitutions-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : bool isValid ( string S ) { vector < char > stack ; for ( char c : S ) { if ( c == 'c' ) { int n = stack . size (); if ( n < 2 || stack [ n - 2 ] != 'a' || stack [ n - 1 ] != 'b' ) return false ; stack . pop_back (); stack . pop_back (); } else { stack . push_back ( c ); } } return stack . empty (); } };","title":"1003. Check If Word Is Valid After Substitutions $\\star\\star$"},{"location":"cpp/1001-1100/1001-1010/#1004-max-consecutive-ones-iii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public : int longestOnes ( vector < int >& A , int K ) { int i = 0 ; for ( int a : A ) { if ( a == 0 ) K -- ; if ( K < 0 ) { if ( A [ i ] == 0 ) K ++ ; i ++ ; } } return A . size () - i ; } };","title":"1004. Max Consecutive Ones III $\\star\\star$"},{"location":"cpp/1001-1100/1001-1010/#1005-maximize-sum-of-array-after-k-negations-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int largestSumAfterKNegations ( vector < int >& A , int K ) { sort ( A . begin (), A . end ()); for ( int i = 0 ; i < A . size (); i ++ ) { if ( A [ i ] > 0 || K == 0 ) break ; A [ i ] = - A [ i ]; K -- ; } return accumulate ( A . begin (), A . end (), 0 ) - ( K % 2 ) * * min_element ( A . begin (), A . end ()) * 2 ; } };","title":"1005. Maximize Sum Of Array After K Negations $\\star$"},{"location":"cpp/1001-1100/1001-1010/#1006-clumsy-factorial-starstar","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public : int clumsy ( int N ) { if ( N <= 2 ) return N ; if ( N <= 4 ) return N + 3 ; if (( N - 4 ) % 4 == 0 ) return N + 1 ; if (( N - 4 ) % 4 <= 2 ) return N + 2 ; return N - 1 ; } };","title":"1006. Clumsy Factorial $\\star\\star$"},{"location":"cpp/1001-1100/1001-1010/#1007-minimum-domino-rotations-for-equal-row-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public : int minDominoRotations ( vector < int >& A , vector < int >& B ) { const int n = A . size (); vector < int > countA ( 7 ); vector < int > countB ( 7 ); vector < int > countBoth ( 7 ); for ( int i = 0 ; i < n ; i ++ ) { countA [ A [ i ]] ++ ; countB [ B [ i ]] ++ ; if ( A [ i ] == B [ i ]) countBoth [ A [ i ]] ++ ; } for ( int i = 1 ; i <= 6 ; i ++ ) if ( countA [ i ] + countB [ i ] - countBoth [ i ] == n ) return n - max ( countA [ i ], countB [ i ]); return - 1 ; } };","title":"1007. Minimum Domino Rotations For Equal Row $\\star\\star$"},{"location":"cpp/1001-1100/1001-1010/#1008-construct-binary-search-tree-from-preorder-traversal-starstar","text":"","title":"1008. Construct Binary Search Tree from Preorder Traversal $\\star\\star$"},{"location":"cpp/1001-1100/1001-1010/#1009-complement-of-base-10-integer-star","text":"","title":"1009. Complement of Base 10 Integer $\\star$"},{"location":"cpp/1001-1100/1001-1010/#1010-pairs-of-songs-with-total-durations-divisible-by-60-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : int numPairsDivisibleBy60 ( vector < int >& time ) { int ans = 0 ; vector < int > count ( 60 ); for ( int t : time ) { t %= 60 ; ans += t == 0 ? count [ 0 ] : count [ 60 - t ]; count [ t ] ++ ; } return ans ; } };","title":"1010. Pairs of Songs With Total Durations Divisible by 60 $\\star$"},{"location":"cpp/1001-1100/1011-1020/","text":"1011. Capacity To Ship Packages Within D Days $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int shipWithinDays ( vector < int >& weights , int D ) { int l = * max_element ( weights . begin (), weights . end ()); int r = accumulate ( weights . begin (), weights . end (), 0 ); while ( l < r ) { int m = l + ( r - l ) / 2 ; int day = 1 ; int capacity = 0 ; for ( int weight : weights ) { if ( capacity + weight > m ) { day ++ ; capacity = weight ; } else capacity += weight ; } if ( day <= D ) r = m ; else l = m + 1 ; } return l ; } }; 1012. Numbers With Repeated Digits $\\star\\star\\star$ 1013. Partition Array Into Three Parts With Equal Sum $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool canThreePartsEqualSum ( vector < int >& A ) { int sum = accumulate ( A . begin (), A . end (), 0 ); int presum = 0 ; int parts = 1 ; for ( int a : A ) { presum += a ; if ( presum == sum * parts / 3 ) parts ++ ; } return sum % 3 == 0 && parts >= 3 ; } }; 1014. Best Sightseeing Pair $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxScoreSightseeingPair ( vector < int >& A ) { int ans = 0 ; int bestPrev = 0 ; for ( int a : A ) { ans = max ( ans , a + bestPrev ); bestPrev = max ( bestPrev , a ) - 1 ; } return ans ; } }; 1015. Smallest Integer Divisible by K $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int smallestRepunitDivByK ( int K ) { if ( K % 10 != 1 && K % 10 != 3 && K % 10 != 7 && K % 10 != 9 ) return - 1 ; unordered_set < int > set ; int mod = 0 ; for ( int N = 1 ; N <= K ; N ++ ) { mod = ( mod * 10 + 1 ) % K ; if ( mod == 0 ) return N ; if ( set . count ( mod )) return - 1 ; set . insert ( mod ); } return - 1 ; } }; 1016. Binary String With Substrings Representing 1 To N $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool queryString ( string S , int N ) { if ( N > 1511 ) return false ; for ( int i = N ; i > N / 2 ; i -- ) { string binary = bitset < 32 > ( i ). to_string (); binary = binary . substr ( binary . find ( \"1\" )); if ( S . find ( binary ) == string :: npos ) return false ; } return true ; } }; 1017. Convert to Base -2 $\\star\\star$ 1018. Binary Prefix Divisible By 5 $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < bool > prefixesDivBy5 ( vector < int >& A ) { vector < bool > ans ; int num = 0 ; for ( int a : A ) { num = ( num * 2 + a ) % 5 ; ans . push_back ( num % 5 == 0 ); } return ans ; } }; 1019. Next Greater Node In Linked List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < int > nextLargerNodes ( ListNode * head ) { vector < int > ans ; vector < int > stack ; for ( auto curr = head ; curr ; curr = curr -> next ) { while ( stack . size () && ans [ stack . back ()] < curr -> val ) { ans [ stack . back ()] = curr -> val ; stack . pop_back (); } stack . push_back ( ans . size ()); ans . push_back ( curr -> val ); } for ( int i : stack ) ans [ i ] = 0 ; return ans ; } }; 1020. Number of Enclaves $\\star\\star$","title":"1011-1020"},{"location":"cpp/1001-1100/1011-1020/#1011-capacity-to-ship-packages-within-d-days-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public : int shipWithinDays ( vector < int >& weights , int D ) { int l = * max_element ( weights . begin (), weights . end ()); int r = accumulate ( weights . begin (), weights . end (), 0 ); while ( l < r ) { int m = l + ( r - l ) / 2 ; int day = 1 ; int capacity = 0 ; for ( int weight : weights ) { if ( capacity + weight > m ) { day ++ ; capacity = weight ; } else capacity += weight ; } if ( day <= D ) r = m ; else l = m + 1 ; } return l ; } };","title":"1011. Capacity To Ship Packages Within D Days $\\star\\star$"},{"location":"cpp/1001-1100/1011-1020/#1012-numbers-with-repeated-digits-starstarstar","text":"","title":"1012. Numbers With Repeated Digits $\\star\\star\\star$"},{"location":"cpp/1001-1100/1011-1020/#1013-partition-array-into-three-parts-with-equal-sum-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : bool canThreePartsEqualSum ( vector < int >& A ) { int sum = accumulate ( A . begin (), A . end (), 0 ); int presum = 0 ; int parts = 1 ; for ( int a : A ) { presum += a ; if ( presum == sum * parts / 3 ) parts ++ ; } return sum % 3 == 0 && parts >= 3 ; } };","title":"1013. Partition Array Into Three Parts With Equal Sum $\\star$"},{"location":"cpp/1001-1100/1011-1020/#1014-best-sightseeing-pair-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : int maxScoreSightseeingPair ( vector < int >& A ) { int ans = 0 ; int bestPrev = 0 ; for ( int a : A ) { ans = max ( ans , a + bestPrev ); bestPrev = max ( bestPrev , a ) - 1 ; } return ans ; } };","title":"1014. Best Sightseeing Pair $\\star\\star$"},{"location":"cpp/1001-1100/1011-1020/#1015-smallest-integer-divisible-by-k-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public : int smallestRepunitDivByK ( int K ) { if ( K % 10 != 1 && K % 10 != 3 && K % 10 != 7 && K % 10 != 9 ) return - 1 ; unordered_set < int > set ; int mod = 0 ; for ( int N = 1 ; N <= K ; N ++ ) { mod = ( mod * 10 + 1 ) % K ; if ( mod == 0 ) return N ; if ( set . count ( mod )) return - 1 ; set . insert ( mod ); } return - 1 ; } };","title":"1015. Smallest Integer Divisible by K $\\star\\star$"},{"location":"cpp/1001-1100/1011-1020/#1016-binary-string-with-substrings-representing-1-to-n-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : bool queryString ( string S , int N ) { if ( N > 1511 ) return false ; for ( int i = N ; i > N / 2 ; i -- ) { string binary = bitset < 32 > ( i ). to_string (); binary = binary . substr ( binary . find ( \"1\" )); if ( S . find ( binary ) == string :: npos ) return false ; } return true ; } };","title":"1016. Binary String With Substrings Representing 1 To N $\\star\\star$"},{"location":"cpp/1001-1100/1011-1020/#1017-convert-to-base-2-starstar","text":"","title":"1017. Convert to Base -2 $\\star\\star$"},{"location":"cpp/1001-1100/1011-1020/#1018-binary-prefix-divisible-by-5-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < bool > prefixesDivBy5 ( vector < int >& A ) { vector < bool > ans ; int num = 0 ; for ( int a : A ) { num = ( num * 2 + a ) % 5 ; ans . push_back ( num % 5 == 0 ); } return ans ; } };","title":"1018. Binary Prefix Divisible By 5 $\\star$"},{"location":"cpp/1001-1100/1011-1020/#1019-next-greater-node-in-linked-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : vector < int > nextLargerNodes ( ListNode * head ) { vector < int > ans ; vector < int > stack ; for ( auto curr = head ; curr ; curr = curr -> next ) { while ( stack . size () && ans [ stack . back ()] < curr -> val ) { ans [ stack . back ()] = curr -> val ; stack . pop_back (); } stack . push_back ( ans . size ()); ans . push_back ( curr -> val ); } for ( int i : stack ) ans [ i ] = 0 ; return ans ; } };","title":"1019. Next Greater Node In Linked List $\\star\\star$"},{"location":"cpp/1001-1100/1011-1020/#1020-number-of-enclaves-starstar","text":"","title":"1020. Number of Enclaves $\\star\\star$"},{"location":"cpp/1001-1100/1021-1030/","text":"1021. Remove Outermost Parentheses $\\star$ 1022. Sum of Root To Leaf Binary Numbers $\\star$ 1023. Camelcase Matching $\\star\\star$ 1024. Video Stitching $\\star\\star$ 1025. Divisor Game $\\star$ 1026. Maximum Difference Between Node and Ancestor $\\star\\star$ 1027. Longest Arithmetic Sequence $\\star\\star$ 1028. Recover a Tree From Preorder Traversal $\\star\\star\\star$ 1029. Two City Scheduling $\\star$ 1030. Matrix Cells in Distance Order $\\star$","title":"1021-1030"},{"location":"cpp/1001-1100/1021-1030/#1021-remove-outermost-parentheses-star","text":"","title":"1021. Remove Outermost Parentheses $\\star$"},{"location":"cpp/1001-1100/1021-1030/#1022-sum-of-root-to-leaf-binary-numbers-star","text":"","title":"1022. Sum of Root To Leaf Binary Numbers $\\star$"},{"location":"cpp/1001-1100/1021-1030/#1023-camelcase-matching-starstar","text":"","title":"1023. Camelcase Matching $\\star\\star$"},{"location":"cpp/1001-1100/1021-1030/#1024-video-stitching-starstar","text":"","title":"1024. Video Stitching $\\star\\star$"},{"location":"cpp/1001-1100/1021-1030/#1025-divisor-game-star","text":"","title":"1025. Divisor Game $\\star$"},{"location":"cpp/1001-1100/1021-1030/#1026-maximum-difference-between-node-and-ancestor-starstar","text":"","title":"1026. Maximum Difference Between Node and Ancestor $\\star\\star$"},{"location":"cpp/1001-1100/1021-1030/#1027-longest-arithmetic-sequence-starstar","text":"","title":"1027. Longest Arithmetic Sequence $\\star\\star$"},{"location":"cpp/1001-1100/1021-1030/#1028-recover-a-tree-from-preorder-traversal-starstarstar","text":"","title":"1028. Recover a Tree From Preorder Traversal $\\star\\star\\star$"},{"location":"cpp/1001-1100/1021-1030/#1029-two-city-scheduling-star","text":"","title":"1029. Two City Scheduling $\\star$"},{"location":"cpp/1001-1100/1021-1030/#1030-matrix-cells-in-distance-order-star","text":"","title":"1030. Matrix Cells in Distance Order $\\star$"},{"location":"cpp/1001-1100/1031-1040/","text":"1031. Maximum Sum of Two Non-Overlapping Subarrays $\\star\\star$ 1032. Stream of Characters $\\star\\star\\star$ 1033. Moving Stones Until Consecutive $\\star$ 1034. Coloring A Border $\\star\\star$ 1035. Uncrossed Lines $\\star\\star$ 1036. Escape a Large Maze $\\star\\star\\star$ 1037. Valid Boomerang $\\star$ 1038. Binary Search Tree to Greater Sum Tree $\\star\\star$ 1039. Minimum Score Triangulation of Polygon $\\star\\star$ 1040. Moving Stones Until Consecutive II $\\star\\star$","title":"1031-1040"},{"location":"cpp/1001-1100/1031-1040/#1031-maximum-sum-of-two-non-overlapping-subarrays-starstar","text":"","title":"1031. Maximum Sum of Two Non-Overlapping Subarrays $\\star\\star$"},{"location":"cpp/1001-1100/1031-1040/#1032-stream-of-characters-starstarstar","text":"","title":"1032. Stream of Characters $\\star\\star\\star$"},{"location":"cpp/1001-1100/1031-1040/#1033-moving-stones-until-consecutive-star","text":"","title":"1033. Moving Stones Until Consecutive $\\star$"},{"location":"cpp/1001-1100/1031-1040/#1034-coloring-a-border-starstar","text":"","title":"1034. Coloring A Border $\\star\\star$"},{"location":"cpp/1001-1100/1031-1040/#1035-uncrossed-lines-starstar","text":"","title":"1035. Uncrossed Lines $\\star\\star$"},{"location":"cpp/1001-1100/1031-1040/#1036-escape-a-large-maze-starstarstar","text":"","title":"1036. Escape a Large Maze $\\star\\star\\star$"},{"location":"cpp/1001-1100/1031-1040/#1037-valid-boomerang-star","text":"","title":"1037. Valid Boomerang $\\star$"},{"location":"cpp/1001-1100/1031-1040/#1038-binary-search-tree-to-greater-sum-tree-starstar","text":"","title":"1038. Binary Search Tree to Greater Sum Tree $\\star\\star$"},{"location":"cpp/1001-1100/1031-1040/#1039-minimum-score-triangulation-of-polygon-starstar","text":"","title":"1039. Minimum Score Triangulation of Polygon $\\star\\star$"},{"location":"cpp/1001-1100/1031-1040/#1040-moving-stones-until-consecutive-ii-starstar","text":"","title":"1040. Moving Stones Until Consecutive II $\\star\\star$"},{"location":"cpp/1001-1100/1041-1050/","text":"1041. Robot Bounded In Circle $\\star\\star$ 1042. Flower Planting With No Adjacent $\\star$ 1043. Partition Array for Maximum Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxSumAfterPartitioning ( vector < int >& A , int K ) { const int n = A . size (); vector < int > dp ( n + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { int min = INT_MIN ; for ( int j = 1 ; j <= std :: min ( i , K ); j ++ ) { min = max ( min , A [ i - j ]); dp [ i ] = max ( dp [ i ], dp [ i - j ] + min * j ); } } return dp [ n ]; } }; 1044. Longest Duplicate Substring $\\star\\star\\star$ 1045. Customers Who Bought All Products $\\star\\star$ 1046. Last Stone Weight $\\star$ 1047. Remove All Adjacent Duplicates In String $\\star$ 1048. Longest String Chain $\\star\\star$ 1049. Last Stone Weight II $\\star\\star$ 1050. Actors and Directors Who Cooperated At Least Three Times $\\star$","title":"1041-1050"},{"location":"cpp/1001-1100/1041-1050/#1041-robot-bounded-in-circle-starstar","text":"","title":"1041. Robot Bounded In Circle $\\star\\star$"},{"location":"cpp/1001-1100/1041-1050/#1042-flower-planting-with-no-adjacent-star","text":"","title":"1042. Flower Planting With No Adjacent $\\star$"},{"location":"cpp/1001-1100/1041-1050/#1043-partition-array-for-maximum-sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public : int maxSumAfterPartitioning ( vector < int >& A , int K ) { const int n = A . size (); vector < int > dp ( n + 1 ); for ( int i = 1 ; i <= n ; i ++ ) { int min = INT_MIN ; for ( int j = 1 ; j <= std :: min ( i , K ); j ++ ) { min = max ( min , A [ i - j ]); dp [ i ] = max ( dp [ i ], dp [ i - j ] + min * j ); } } return dp [ n ]; } };","title":"1043. Partition Array for Maximum Sum $\\star\\star$"},{"location":"cpp/1001-1100/1041-1050/#1044-longest-duplicate-substring-starstarstar","text":"","title":"1044. Longest Duplicate Substring $\\star\\star\\star$"},{"location":"cpp/1001-1100/1041-1050/#1045-customers-who-bought-all-products-starstar","text":"","title":"1045. Customers Who Bought All Products $\\star\\star$"},{"location":"cpp/1001-1100/1041-1050/#1046-last-stone-weight-star","text":"","title":"1046. Last Stone Weight $\\star$"},{"location":"cpp/1001-1100/1041-1050/#1047-remove-all-adjacent-duplicates-in-string-star","text":"","title":"1047. Remove All Adjacent Duplicates In String $\\star$"},{"location":"cpp/1001-1100/1041-1050/#1048-longest-string-chain-starstar","text":"","title":"1048. Longest String Chain $\\star\\star$"},{"location":"cpp/1001-1100/1041-1050/#1049-last-stone-weight-ii-starstar","text":"","title":"1049. Last Stone Weight II $\\star\\star$"},{"location":"cpp/1001-1100/1041-1050/#1050-actors-and-directors-who-cooperated-at-least-three-times-star","text":"","title":"1050. Actors and Directors Who Cooperated At Least Three Times $\\star$"},{"location":"cpp/1001-1100/1051-1060/","text":"1051. Height Checker $\\star$ 1052. Grumpy Bookstore Owner $\\star\\star$ 1053. Previous Permutation With One Swap $\\star\\star$ 1054. Distant Barcodes $\\star\\star$ 1055. Shortest Way to Form String $\\star\\star$ 1056. Confusing Number $\\star$ 1057. Campus Bikes $\\star\\star$ 1058. Minimize Rounding Error to Meet Target $\\star\\star$ 1059. All Paths from Source Lead to Destination $\\star\\star$ 1060. Missing Element in Sorted Array $\\star\\star$","title":"1051-1060"},{"location":"cpp/1001-1100/1051-1060/#1051-height-checker-star","text":"","title":"1051. Height Checker $\\star$"},{"location":"cpp/1001-1100/1051-1060/#1052-grumpy-bookstore-owner-starstar","text":"","title":"1052. Grumpy Bookstore Owner $\\star\\star$"},{"location":"cpp/1001-1100/1051-1060/#1053-previous-permutation-with-one-swap-starstar","text":"","title":"1053. Previous Permutation With One Swap $\\star\\star$"},{"location":"cpp/1001-1100/1051-1060/#1054-distant-barcodes-starstar","text":"","title":"1054. Distant Barcodes $\\star\\star$"},{"location":"cpp/1001-1100/1051-1060/#1055-shortest-way-to-form-string-starstar","text":"","title":"1055. Shortest Way to Form String $\\star\\star$"},{"location":"cpp/1001-1100/1051-1060/#1056-confusing-number-star","text":"","title":"1056. Confusing Number $\\star$"},{"location":"cpp/1001-1100/1051-1060/#1057-campus-bikes-starstar","text":"","title":"1057. Campus Bikes $\\star\\star$"},{"location":"cpp/1001-1100/1051-1060/#1058-minimize-rounding-error-to-meet-target-starstar","text":"","title":"1058. Minimize Rounding Error to Meet Target $\\star\\star$"},{"location":"cpp/1001-1100/1051-1060/#1059-all-paths-from-source-lead-to-destination-starstar","text":"","title":"1059. All Paths from Source Lead to Destination $\\star\\star$"},{"location":"cpp/1001-1100/1051-1060/#1060-missing-element-in-sorted-array-starstar","text":"","title":"1060. Missing Element in Sorted Array $\\star\\star$"},{"location":"cpp/1001-1100/1061-1070/","text":"1061. Lexicographically Smallest Equivalent String $\\star\\star$ 1062. Longest Repeating Substring $\\star\\star$ 1063. Number of Valid Subarrays $\\star\\star\\star$ 1064. Fixed Point $\\star$ 1065. Index Pairs of a String $\\star$ 1066. Campus Bikes II $\\star\\star$ 1067. Digit Count in Range $\\star\\star\\star$ 1068. Product Sales Analysis I $\\star$ 1069. Product Sales Analysis II $\\star$ 1070. Product Sales Analysis III $\\star\\star$","title":"1061-1070"},{"location":"cpp/1001-1100/1061-1070/#1061-lexicographically-smallest-equivalent-string-starstar","text":"","title":"1061. Lexicographically Smallest Equivalent String $\\star\\star$"},{"location":"cpp/1001-1100/1061-1070/#1062-longest-repeating-substring-starstar","text":"","title":"1062. Longest Repeating Substring $\\star\\star$"},{"location":"cpp/1001-1100/1061-1070/#1063-number-of-valid-subarrays-starstarstar","text":"","title":"1063. Number of Valid Subarrays $\\star\\star\\star$"},{"location":"cpp/1001-1100/1061-1070/#1064-fixed-point-star","text":"","title":"1064. Fixed Point $\\star$"},{"location":"cpp/1001-1100/1061-1070/#1065-index-pairs-of-a-string-star","text":"","title":"1065. Index Pairs of a String $\\star$"},{"location":"cpp/1001-1100/1061-1070/#1066-campus-bikes-ii-starstar","text":"","title":"1066. Campus Bikes II $\\star\\star$"},{"location":"cpp/1001-1100/1061-1070/#1067-digit-count-in-range-starstarstar","text":"","title":"1067. Digit Count in Range $\\star\\star\\star$"},{"location":"cpp/1001-1100/1061-1070/#1068-product-sales-analysis-i-star","text":"","title":"1068. Product Sales Analysis I $\\star$"},{"location":"cpp/1001-1100/1061-1070/#1069-product-sales-analysis-ii-star","text":"","title":"1069. Product Sales Analysis II $\\star$"},{"location":"cpp/1001-1100/1061-1070/#1070-product-sales-analysis-iii-starstar","text":"","title":"1070. Product Sales Analysis III $\\star\\star$"},{"location":"cpp/1001-1100/1071-1080/","text":"1071. Greatest Common Divisor of Strings $\\star$ 1072. Flip Columns For Maximum Number of Equal Rows $\\star\\star$ 1073. Adding Two Negabinary Numbers $\\star\\star$ 1074. Number of Submatrices That Sum to Target $\\star\\star\\star$ 1075. Project Employees I $\\star$ 1076. Project Employees II $\\star$ 1077. Project Employees III $\\star\\star$ 1078. Occurrences After Bigram $\\star$ 1079. Letter Tile Possibilities $\\star\\star$ 1080. Insufficient Nodes in Root to Leaf Paths $\\star\\star$","title":"1071-1080"},{"location":"cpp/1001-1100/1071-1080/#1071-greatest-common-divisor-of-strings-star","text":"","title":"1071. Greatest Common Divisor of Strings $\\star$"},{"location":"cpp/1001-1100/1071-1080/#1072-flip-columns-for-maximum-number-of-equal-rows-starstar","text":"","title":"1072. Flip Columns For Maximum Number of Equal Rows $\\star\\star$"},{"location":"cpp/1001-1100/1071-1080/#1073-adding-two-negabinary-numbers-starstar","text":"","title":"1073. Adding Two Negabinary Numbers $\\star\\star$"},{"location":"cpp/1001-1100/1071-1080/#1074-number-of-submatrices-that-sum-to-target-starstarstar","text":"","title":"1074. Number of Submatrices That Sum to Target $\\star\\star\\star$"},{"location":"cpp/1001-1100/1071-1080/#1075-project-employees-i-star","text":"","title":"1075. Project Employees I $\\star$"},{"location":"cpp/1001-1100/1071-1080/#1076-project-employees-ii-star","text":"","title":"1076. Project Employees II $\\star$"},{"location":"cpp/1001-1100/1071-1080/#1077-project-employees-iii-starstar","text":"","title":"1077. Project Employees III $\\star\\star$"},{"location":"cpp/1001-1100/1071-1080/#1078-occurrences-after-bigram-star","text":"","title":"1078. Occurrences After Bigram $\\star$"},{"location":"cpp/1001-1100/1071-1080/#1079-letter-tile-possibilities-starstar","text":"","title":"1079. Letter Tile Possibilities $\\star\\star$"},{"location":"cpp/1001-1100/1071-1080/#1080-insufficient-nodes-in-root-to-leaf-paths-starstar","text":"","title":"1080. Insufficient Nodes in Root to Leaf Paths $\\star\\star$"},{"location":"cpp/1001-1100/1081-1090/","text":"1081. Smallest Subsequence of Distinct Characters $\\star\\star$ 1082. Sales Analysis I $\\star$ 1083. Sales Analysis II $\\star$ 1084. Sales Analysis III $\\star$ 1085. Sum of Digits in the Minimum Number $\\star$ 1086. High Five $\\star$ 1087. Brace Expansion $\\star\\star$ 1088. Confusing Number II $\\star\\star\\star$ 1089. Duplicate Zeros $\\star$ 1090. Largest Values From Labels $\\star\\star$","title":"1081-1090"},{"location":"cpp/1001-1100/1081-1090/#1081-smallest-subsequence-of-distinct-characters-starstar","text":"","title":"1081. Smallest Subsequence of Distinct Characters $\\star\\star$"},{"location":"cpp/1001-1100/1081-1090/#1082-sales-analysis-i-star","text":"","title":"1082. Sales Analysis I $\\star$"},{"location":"cpp/1001-1100/1081-1090/#1083-sales-analysis-ii-star","text":"","title":"1083. Sales Analysis II $\\star$"},{"location":"cpp/1001-1100/1081-1090/#1084-sales-analysis-iii-star","text":"","title":"1084. Sales Analysis III $\\star$"},{"location":"cpp/1001-1100/1081-1090/#1085-sum-of-digits-in-the-minimum-number-star","text":"","title":"1085. Sum of Digits in the Minimum Number $\\star$"},{"location":"cpp/1001-1100/1081-1090/#1086-high-five-star","text":"","title":"1086. High Five $\\star$"},{"location":"cpp/1001-1100/1081-1090/#1087-brace-expansion-starstar","text":"","title":"1087. Brace Expansion $\\star\\star$"},{"location":"cpp/1001-1100/1081-1090/#1088-confusing-number-ii-starstarstar","text":"","title":"1088. Confusing Number II $\\star\\star\\star$"},{"location":"cpp/1001-1100/1081-1090/#1089-duplicate-zeros-star","text":"","title":"1089. Duplicate Zeros $\\star$"},{"location":"cpp/1001-1100/1081-1090/#1090-largest-values-from-labels-starstar","text":"","title":"1090. Largest Values From Labels $\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/","text":"1091. Shortest Path in Binary Matrix $\\star\\star$ 1092. Shortest Common Supersequence $\\star\\star\\star$ 1093. Statistics from a Large Sample $\\star\\star$ 1094. Car Pooling $\\star\\star$ 1095. Find in Mountain Array $\\star\\star\\star$ 1096. Brace Expansion II $\\star\\star\\star$ 1097. Game Play Analysis V $\\star\\star\\star$ 1098. Unpopular Books $\\star\\star$ 1099. Two Sum Less Than K $\\star$ 1100. Find K-Length Substrings With No Repeated Characters $\\star\\star$","title":"1091-1100"},{"location":"cpp/1001-1100/1091-1100/#1091-shortest-path-in-binary-matrix-starstar","text":"","title":"1091. Shortest Path in Binary Matrix $\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/#1092-shortest-common-supersequence-starstarstar","text":"","title":"1092. Shortest Common Supersequence  $\\star\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/#1093-statistics-from-a-large-sample-starstar","text":"","title":"1093. Statistics from a Large Sample $\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/#1094-car-pooling-starstar","text":"","title":"1094. Car Pooling $\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/#1095-find-in-mountain-array-starstarstar","text":"","title":"1095. Find in Mountain Array $\\star\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/#1096-brace-expansion-ii-starstarstar","text":"","title":"1096. Brace Expansion II $\\star\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/#1097-game-play-analysis-v-starstarstar","text":"","title":"1097. Game Play Analysis V $\\star\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/#1098-unpopular-books-starstar","text":"","title":"1098. Unpopular Books $\\star\\star$"},{"location":"cpp/1001-1100/1091-1100/#1099-two-sum-less-than-k-star","text":"","title":"1099. Two Sum Less Than K $\\star$"},{"location":"cpp/1001-1100/1091-1100/#1100-find-k-length-substrings-with-no-repeated-characters-starstar","text":"","title":"1100. Find K-Length Substrings With No Repeated Characters $\\star\\star$"},{"location":"cpp/1101-1200/1101-1110/","text":"1101. The Earliest Moment When Everyone Become Friends $\\star\\star$ 1102. Path With Maximum Minimum Value $\\star\\star$ 1103. Distribute Candies to People $\\star$ 1104. Path In Zigzag Labelled Binary Tree $\\star\\star$ 1105. Filling Bookcase Shelves $\\star\\star$ 1106. Parsing A Boolean Expression $\\star\\star\\star$ 1107. New Users Daily Count $\\star\\star$ 1108. Defanging an IP Address $\\star$ 1109. Corporate Flight Bookings $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < int > corpFlightBookings ( vector < vector < int >>& bookings , int n ) { vector < int > ans ( n ); for ( vector < int >& booking : bookings ) { ans [ booking [ 0 ] - 1 ] += booking [ 2 ]; if ( booking [ 1 ] < n ) ans [ booking [ 1 ]] -= booking [ 2 ]; } for ( int i = 1 ; i < n ; i ++ ) ans [ i ] += ans [ i - 1 ]; return ans ; } }; 1110. Delete Nodes And Return Forest $\\star\\star$","title":"1101-1110"},{"location":"cpp/1101-1200/1101-1110/#1101-the-earliest-moment-when-everyone-become-friends-starstar","text":"","title":"1101. The Earliest Moment When Everyone Become Friends $\\star\\star$"},{"location":"cpp/1101-1200/1101-1110/#1102-path-with-maximum-minimum-value-starstar","text":"","title":"1102. Path With Maximum Minimum Value $\\star\\star$"},{"location":"cpp/1101-1200/1101-1110/#1103-distribute-candies-to-people-star","text":"","title":"1103. Distribute Candies to People $\\star$"},{"location":"cpp/1101-1200/1101-1110/#1104-path-in-zigzag-labelled-binary-tree-starstar","text":"","title":"1104. Path In Zigzag Labelled Binary Tree $\\star\\star$"},{"location":"cpp/1101-1200/1101-1110/#1105-filling-bookcase-shelves-starstar","text":"","title":"1105. Filling Bookcase Shelves $\\star\\star$"},{"location":"cpp/1101-1200/1101-1110/#1106-parsing-a-boolean-expression-starstarstar","text":"","title":"1106. Parsing A Boolean Expression $\\star\\star\\star$"},{"location":"cpp/1101-1200/1101-1110/#1107-new-users-daily-count-starstar","text":"","title":"1107. New Users Daily Count $\\star\\star$"},{"location":"cpp/1101-1200/1101-1110/#1108-defanging-an-ip-address-star","text":"","title":"1108. Defanging an IP Address $\\star$"},{"location":"cpp/1101-1200/1101-1110/#1109-corporate-flight-bookings-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public : vector < int > corpFlightBookings ( vector < vector < int >>& bookings , int n ) { vector < int > ans ( n ); for ( vector < int >& booking : bookings ) { ans [ booking [ 0 ] - 1 ] += booking [ 2 ]; if ( booking [ 1 ] < n ) ans [ booking [ 1 ]] -= booking [ 2 ]; } for ( int i = 1 ; i < n ; i ++ ) ans [ i ] += ans [ i - 1 ]; return ans ; } };","title":"1109. Corporate Flight Bookings $\\star\\star$"},{"location":"cpp/1101-1200/1101-1110/#1110-delete-nodes-and-return-forest-starstar","text":"","title":"1110. Delete Nodes And Return Forest $\\star\\star$"},{"location":"cpp/1101-1200/1111-1120/","text":"1111. Maximum Nesting Depth of Two Valid Parentheses Strings $\\star\\star$ 1112. Highest Grade For Each Student $\\star\\star$ 1113. Reported Posts $\\star$ 1114. Print in Order $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Foo { public : Foo () { mutex2 . lock (); mutex3 . lock (); } void first ( function < void () > printFirst ) { printFirst (); mutex2 . unlock (); } void second ( function < void () > printSecond ) { mutex2 . lock (); printSecond (); mutex3 . unlock (); } void third ( function < void () > printThird ) { mutex3 . lock (); printThird (); } private : mutex mutex2 ; mutex mutex3 ; }; 1115. Print FooBar Alternately $\\star\\star$ 1116. Print Zero Even Odd $\\star\\star$ 1117. Building H2O $\\star\\star$ 1118. Number of Days in a Month $\\star$ 1119. Remove Vowels from a String $\\star$ 1120. Maximum Average Subtree $\\star\\star$","title":"1111-1120"},{"location":"cpp/1101-1200/1111-1120/#1111-maximum-nesting-depth-of-two-valid-parentheses-strings-starstar","text":"","title":"1111. Maximum Nesting Depth of Two Valid Parentheses Strings $\\star\\star$"},{"location":"cpp/1101-1200/1111-1120/#1112-highest-grade-for-each-student-starstar","text":"","title":"1112. Highest Grade For Each Student $\\star\\star$"},{"location":"cpp/1101-1200/1111-1120/#1113-reported-posts-star","text":"","title":"1113. Reported Posts $\\star$"},{"location":"cpp/1101-1200/1111-1120/#1114-print-in-order-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Foo { public : Foo () { mutex2 . lock (); mutex3 . lock (); } void first ( function < void () > printFirst ) { printFirst (); mutex2 . unlock (); } void second ( function < void () > printSecond ) { mutex2 . lock (); printSecond (); mutex3 . unlock (); } void third ( function < void () > printThird ) { mutex3 . lock (); printThird (); } private : mutex mutex2 ; mutex mutex3 ; };","title":"1114. Print in Order $\\star$"},{"location":"cpp/1101-1200/1111-1120/#1115-print-foobar-alternately-starstar","text":"","title":"1115. Print FooBar Alternately $\\star\\star$"},{"location":"cpp/1101-1200/1111-1120/#1116-print-zero-even-odd-starstar","text":"","title":"1116. Print Zero Even Odd $\\star\\star$"},{"location":"cpp/1101-1200/1111-1120/#1117-building-h2o-starstar","text":"","title":"1117. Building H2O $\\star\\star$"},{"location":"cpp/1101-1200/1111-1120/#1118-number-of-days-in-a-month-star","text":"","title":"1118. Number of Days in a Month $\\star$"},{"location":"cpp/1101-1200/1111-1120/#1119-remove-vowels-from-a-string-star","text":"","title":"1119. Remove Vowels from a String $\\star$"},{"location":"cpp/1101-1200/1111-1120/#1120-maximum-average-subtree-starstar","text":"","title":"1120. Maximum Average Subtree $\\star\\star$"},{"location":"cpp/1101-1200/1121-1130/","text":"1121. Divide Array Into Increasing Sequences $\\star\\star\\star$ 1122. Relative Sort Array $\\star$ 1123. Lowest Common Ancestor of Deepest Leaves $\\star\\star$ 1124. Longest Well-Performing Interval $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int longestWPI ( vector < int >& hours ) { int ans = 0 ; int presum = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < hours . size (); i ++ ) { presum += hours [ i ] > 8 ? 1 : - 1 ; if ( presum > 0 ) { ans = i + 1 ; } else { if ( ! map . count ( presum )) map [ presum ] = i ; if ( map . count ( presum - 1 )) ans = max ( ans , i - map [ presum - 1 ]); } } return ans ; } }; 1125. Smallest Sufficient Team $\\star\\star\\star$ 1126. Active Businesses $\\star\\star$ 1127. User Purchase Platform $\\star\\star\\star$ 1128. Number of Equivalent Domino Pairs $\\star$ 1129. Shortest Path with Alternating Colors $\\star\\star$ 1130. Minimum Cost Tree From Leaf Values $\\star\\star$","title":"1121-1130"},{"location":"cpp/1101-1200/1121-1130/#1121-divide-array-into-increasing-sequences-starstarstar","text":"","title":"1121. Divide Array Into Increasing Sequences $\\star\\star\\star$"},{"location":"cpp/1101-1200/1121-1130/#1122-relative-sort-array-star","text":"","title":"1122. Relative Sort Array $\\star$"},{"location":"cpp/1101-1200/1121-1130/#1123-lowest-common-ancestor-of-deepest-leaves-starstar","text":"","title":"1123. Lowest Common Ancestor of Deepest Leaves $\\star\\star$"},{"location":"cpp/1101-1200/1121-1130/#1124-longest-well-performing-interval-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public : int longestWPI ( vector < int >& hours ) { int ans = 0 ; int presum = 0 ; unordered_map < int , int > map ; for ( int i = 0 ; i < hours . size (); i ++ ) { presum += hours [ i ] > 8 ? 1 : - 1 ; if ( presum > 0 ) { ans = i + 1 ; } else { if ( ! map . count ( presum )) map [ presum ] = i ; if ( map . count ( presum - 1 )) ans = max ( ans , i - map [ presum - 1 ]); } } return ans ; } };","title":"1124. Longest Well-Performing Interval $\\star\\star$"},{"location":"cpp/1101-1200/1121-1130/#1125-smallest-sufficient-team-starstarstar","text":"","title":"1125. Smallest Sufficient Team $\\star\\star\\star$"},{"location":"cpp/1101-1200/1121-1130/#1126-active-businesses-starstar","text":"","title":"1126. Active Businesses $\\star\\star$"},{"location":"cpp/1101-1200/1121-1130/#1127-user-purchase-platform-starstarstar","text":"","title":"1127. User Purchase Platform $\\star\\star\\star$"},{"location":"cpp/1101-1200/1121-1130/#1128-number-of-equivalent-domino-pairs-star","text":"","title":"1128. Number of Equivalent Domino Pairs $\\star$"},{"location":"cpp/1101-1200/1121-1130/#1129-shortest-path-with-alternating-colors-starstar","text":"","title":"1129. Shortest Path with Alternating Colors $\\star\\star$"},{"location":"cpp/1101-1200/1121-1130/#1130-minimum-cost-tree-from-leaf-values-starstar","text":"","title":"1130. Minimum Cost Tree From Leaf Values $\\star\\star$"},{"location":"cpp/1101-1200/1131-1140/","text":"1131. Maximum of Absolute Value Expression $\\star\\star$ 1132. Reported Posts II $\\star\\star$ 1133. Largest Unique Number $\\star$ 1134. Armstrong Number $\\star$ 1135. Connecting Cities With Minimum Cost $\\star\\star$ 1136. Parallel Courses $\\star\\star\\star$ 1137. N-th Tribonacci Number $\\star$ 1138. Alphabet Board Path $\\star\\star$ 1139. Largest 1-Bordered Square $\\star\\star$ 1140. Stone Game II $\\star\\star$","title":"1131-1140"},{"location":"cpp/1101-1200/1131-1140/#1131-maximum-of-absolute-value-expression-starstar","text":"","title":"1131. Maximum of Absolute Value Expression $\\star\\star$"},{"location":"cpp/1101-1200/1131-1140/#1132-reported-posts-ii-starstar","text":"","title":"1132. Reported Posts II $\\star\\star$"},{"location":"cpp/1101-1200/1131-1140/#1133-largest-unique-number-star","text":"","title":"1133. Largest Unique Number $\\star$"},{"location":"cpp/1101-1200/1131-1140/#1134-armstrong-number-star","text":"","title":"1134. Armstrong Number $\\star$"},{"location":"cpp/1101-1200/1131-1140/#1135-connecting-cities-with-minimum-cost-starstar","text":"","title":"1135. Connecting Cities With Minimum Cost $\\star\\star$"},{"location":"cpp/1101-1200/1131-1140/#1136-parallel-courses-starstarstar","text":"","title":"1136. Parallel Courses $\\star\\star\\star$"},{"location":"cpp/1101-1200/1131-1140/#1137-n-th-tribonacci-number-star","text":"","title":"1137. N-th Tribonacci Number $\\star$"},{"location":"cpp/1101-1200/1131-1140/#1138-alphabet-board-path-starstar","text":"","title":"1138. Alphabet Board Path $\\star\\star$"},{"location":"cpp/1101-1200/1131-1140/#1139-largest-1-bordered-square-starstar","text":"","title":"1139. Largest 1-Bordered Square $\\star\\star$"},{"location":"cpp/1101-1200/1131-1140/#1140-stone-game-ii-starstar","text":"","title":"1140. Stone Game II $\\star\\star$"},{"location":"cpp/1101-1200/1141-1150/","text":"1141. User Activity for the Past 30 Days I $\\star$ 1142. User Activity for the Past 30 Days II $\\star$ 1143. Longest Common Subsequence $\\star\\star$ 1144. Decrease Elements To Make Array Zigzag $\\star\\star$ 1145. Binary Tree Coloring Game $\\star\\star$ 1146. Snapshot Array $\\star\\star$ 1147. Longest Chunked Palindrome Decomposition $\\star\\star\\star$ 1148. Article Views I $\\star$ 1149. Article Views II $\\star\\star$ 1150. Check If a Number Is Majority Element in a Sorted Array $\\star$","title":"1141-1150"},{"location":"cpp/1101-1200/1141-1150/#1141-user-activity-for-the-past-30-days-i-star","text":"","title":"1141. User Activity for the Past 30 Days I $\\star$"},{"location":"cpp/1101-1200/1141-1150/#1142-user-activity-for-the-past-30-days-ii-star","text":"","title":"1142. User Activity for the Past 30 Days II $\\star$"},{"location":"cpp/1101-1200/1141-1150/#1143-longest-common-subsequence-starstar","text":"","title":"1143. Longest Common Subsequence $\\star\\star$"},{"location":"cpp/1101-1200/1141-1150/#1144-decrease-elements-to-make-array-zigzag-starstar","text":"","title":"1144. Decrease Elements To Make Array Zigzag $\\star\\star$"},{"location":"cpp/1101-1200/1141-1150/#1145-binary-tree-coloring-game-starstar","text":"","title":"1145. Binary Tree Coloring Game $\\star\\star$"},{"location":"cpp/1101-1200/1141-1150/#1146-snapshot-array-starstar","text":"","title":"1146. Snapshot Array $\\star\\star$"},{"location":"cpp/1101-1200/1141-1150/#1147-longest-chunked-palindrome-decomposition-starstarstar","text":"","title":"1147. Longest Chunked Palindrome Decomposition $\\star\\star\\star$"},{"location":"cpp/1101-1200/1141-1150/#1148-article-views-i-star","text":"","title":"1148. Article Views I $\\star$"},{"location":"cpp/1101-1200/1141-1150/#1149-article-views-ii-starstar","text":"","title":"1149. Article Views II $\\star\\star$"},{"location":"cpp/1101-1200/1141-1150/#1150-check-if-a-number-is-majority-element-in-a-sorted-array-star","text":"","title":"1150. Check If a Number Is Majority Element in a Sorted Array $\\star$"},{"location":"cpp/1101-1200/1151-1160/","text":"1151. Minimum Swaps to Group All 1's Together $\\star\\star$ 1152. Analyze User Website Visit Pattern $\\star\\star$ 1153. String Transforms Into Another String $\\star\\star\\star$ 1154. Day of the Year $\\star$ 1155. Number of Dice Rolls With Target Sum $\\star\\star$ 1156. Swap For Longest Repeated Character Substring $\\star\\star$ 1157. Online Majority Element In Subarray $\\star\\star\\star$ 1158. Market Analysis I $\\star\\star$ 1159. Market Analysis II $\\star\\star\\star$ 1160. Find Words That Can Be Formed by Characters $\\star$","title":"1151-1160"},{"location":"cpp/1101-1200/1151-1160/#1151-minimum-swaps-to-group-all-1s-together-starstar","text":"","title":"1151. Minimum Swaps to Group All 1's Together $\\star\\star$"},{"location":"cpp/1101-1200/1151-1160/#1152-analyze-user-website-visit-pattern-starstar","text":"","title":"1152. Analyze User Website Visit Pattern $\\star\\star$"},{"location":"cpp/1101-1200/1151-1160/#1153-string-transforms-into-another-string-starstarstar","text":"","title":"1153. String Transforms Into Another String $\\star\\star\\star$"},{"location":"cpp/1101-1200/1151-1160/#1154-day-of-the-year-star","text":"","title":"1154. Day of the Year $\\star$"},{"location":"cpp/1101-1200/1151-1160/#1155-number-of-dice-rolls-with-target-sum-starstar","text":"","title":"1155. Number of Dice Rolls With Target Sum $\\star\\star$"},{"location":"cpp/1101-1200/1151-1160/#1156-swap-for-longest-repeated-character-substring-starstar","text":"","title":"1156. Swap For Longest Repeated Character Substring $\\star\\star$"},{"location":"cpp/1101-1200/1151-1160/#1157-online-majority-element-in-subarray-starstarstar","text":"","title":"1157. Online Majority Element In Subarray $\\star\\star\\star$"},{"location":"cpp/1101-1200/1151-1160/#1158-market-analysis-i-starstar","text":"","title":"1158. Market Analysis I $\\star\\star$"},{"location":"cpp/1101-1200/1151-1160/#1159-market-analysis-ii-starstarstar","text":"","title":"1159. Market Analysis II $\\star\\star\\star$"},{"location":"cpp/1101-1200/1151-1160/#1160-find-words-that-can-be-formed-by-characters-star","text":"","title":"1160. Find Words That Can Be Formed by Characters $\\star$"},{"location":"cpp/1101-1200/1161-1170/","text":"1161. Maximum Level Sum of a Binary Tree $\\star\\star$ 1162. As Far from Land as Possible $\\star\\star$ 1163. Last Substring in Lexicographical Order $\\star\\star\\star$ 1164. Product Price at a Given Date $\\star\\star$ 1165. Single-Row Keyboard $\\star$ 1166. Design File System $\\star\\star$ 1167. Minimum Cost to Connect Sticks $\\star\\star$ 1168. Optimize Water Distribution in a Village $\\star\\star\\star$ 1169. Invalid Transactions $\\star\\star$ 1170. Compare Strings by Frequency of the Smallest Character $\\star$","title":"1161-1170"},{"location":"cpp/1101-1200/1161-1170/#1161-maximum-level-sum-of-a-binary-tree-starstar","text":"","title":"1161. Maximum Level Sum of a Binary Tree $\\star\\star$"},{"location":"cpp/1101-1200/1161-1170/#1162-as-far-from-land-as-possible-starstar","text":"","title":"1162. As Far from Land as Possible $\\star\\star$"},{"location":"cpp/1101-1200/1161-1170/#1163-last-substring-in-lexicographical-order-starstarstar","text":"","title":"1163. Last Substring in Lexicographical Order $\\star\\star\\star$"},{"location":"cpp/1101-1200/1161-1170/#1164-product-price-at-a-given-date-starstar","text":"","title":"1164. Product Price at a Given Date $\\star\\star$"},{"location":"cpp/1101-1200/1161-1170/#1165-single-row-keyboard-star","text":"","title":"1165. Single-Row Keyboard $\\star$"},{"location":"cpp/1101-1200/1161-1170/#1166-design-file-system-starstar","text":"","title":"1166. Design File System $\\star\\star$"},{"location":"cpp/1101-1200/1161-1170/#1167-minimum-cost-to-connect-sticks-starstar","text":"","title":"1167. Minimum Cost to Connect Sticks $\\star\\star$"},{"location":"cpp/1101-1200/1161-1170/#1168-optimize-water-distribution-in-a-village-starstarstar","text":"","title":"1168. Optimize Water Distribution in a Village $\\star\\star\\star$"},{"location":"cpp/1101-1200/1161-1170/#1169-invalid-transactions-starstar","text":"","title":"1169. Invalid Transactions $\\star\\star$"},{"location":"cpp/1101-1200/1161-1170/#1170-compare-strings-by-frequency-of-the-smallest-character-star","text":"","title":"1170. Compare Strings by Frequency of the Smallest Character $\\star$"},{"location":"cpp/1101-1200/1171-1180/","text":"1171. Remove Zero Sum Consecutive Nodes from Linked List $\\star\\star$ 1172. Dinner Plate Stacks $\\star\\star\\star$ 1173. Immediate Food Delivery I $\\star$ 1174. Immediate Food Delivery II $\\star\\star$ 1175. Prime Arrangements $\\star$ 1176. Diet Plan Performance $\\star$ 1177. Can Make Palindrome from Substring $\\star\\star$ 1178. Number of Valid Words for Each Puzzle $\\star\\star\\star$ 1179. Reformat Department Table $\\star$ 1180. Count Substrings with Only One Distinct Letter $\\star$","title":"1171-1180"},{"location":"cpp/1101-1200/1171-1180/#1171-remove-zero-sum-consecutive-nodes-from-linked-list-starstar","text":"","title":"1171. Remove Zero Sum Consecutive Nodes from Linked List $\\star\\star$"},{"location":"cpp/1101-1200/1171-1180/#1172-dinner-plate-stacks-starstarstar","text":"","title":"1172. Dinner Plate Stacks $\\star\\star\\star$"},{"location":"cpp/1101-1200/1171-1180/#1173-immediate-food-delivery-i-star","text":"","title":"1173. Immediate Food Delivery I $\\star$"},{"location":"cpp/1101-1200/1171-1180/#1174-immediate-food-delivery-ii-starstar","text":"","title":"1174. Immediate Food Delivery II $\\star\\star$"},{"location":"cpp/1101-1200/1171-1180/#1175-prime-arrangements-star","text":"","title":"1175. Prime Arrangements $\\star$"},{"location":"cpp/1101-1200/1171-1180/#1176-diet-plan-performance-star","text":"","title":"1176. Diet Plan Performance $\\star$"},{"location":"cpp/1101-1200/1171-1180/#1177-can-make-palindrome-from-substring-starstar","text":"","title":"1177. Can Make Palindrome from Substring $\\star\\star$"},{"location":"cpp/1101-1200/1171-1180/#1178-number-of-valid-words-for-each-puzzle-starstarstar","text":"","title":"1178. Number of Valid Words for Each Puzzle $\\star\\star\\star$"},{"location":"cpp/1101-1200/1171-1180/#1179-reformat-department-table-star","text":"","title":"1179. Reformat Department Table $\\star$"},{"location":"cpp/1101-1200/1171-1180/#1180-count-substrings-with-only-one-distinct-letter-star","text":"","title":"1180. Count Substrings with Only One Distinct Letter $\\star$"},{"location":"cpp/1101-1200/1181-1190/","text":"1181. Before and After Puzzle $\\star\\star$ 1182. Shortest Distance to Target Color $\\star\\star$ 1183. Maximum Number of Ones $\\star\\star\\star$ 1184. Distance Between Bus Stops $\\star$ 1185. Day of the Week $\\star$ 1186. Maximum Subarray Sum with One Deletion $\\star\\star$ 1187. Make Array Strictly Increasing $\\star\\star\\star$ 1188. Design Bounded Blocking Queue $\\star\\star$ 1189. Maximum Number of Balloons $\\star$ 1190. Reverse Substrings Between Each Pair of Parentheses $\\star\\star$","title":"1181-1190"},{"location":"cpp/1101-1200/1181-1190/#1181-before-and-after-puzzle-starstar","text":"","title":"1181. Before and After Puzzle $\\star\\star$"},{"location":"cpp/1101-1200/1181-1190/#1182-shortest-distance-to-target-color-starstar","text":"","title":"1182. Shortest Distance to Target Color $\\star\\star$"},{"location":"cpp/1101-1200/1181-1190/#1183-maximum-number-of-ones-starstarstar","text":"","title":"1183. Maximum Number of Ones $\\star\\star\\star$"},{"location":"cpp/1101-1200/1181-1190/#1184-distance-between-bus-stops-star","text":"","title":"1184. Distance Between Bus Stops $\\star$"},{"location":"cpp/1101-1200/1181-1190/#1185-day-of-the-week-star","text":"","title":"1185. Day of the Week $\\star$"},{"location":"cpp/1101-1200/1181-1190/#1186-maximum-subarray-sum-with-one-deletion-starstar","text":"","title":"1186. Maximum Subarray Sum with One Deletion $\\star\\star$"},{"location":"cpp/1101-1200/1181-1190/#1187-make-array-strictly-increasing-starstarstar","text":"","title":"1187. Make Array Strictly Increasing $\\star\\star\\star$"},{"location":"cpp/1101-1200/1181-1190/#1188-design-bounded-blocking-queue-starstar","text":"","title":"1188. Design Bounded Blocking Queue $\\star\\star$"},{"location":"cpp/1101-1200/1181-1190/#1189-maximum-number-of-balloons-star","text":"","title":"1189. Maximum Number of Balloons $\\star$"},{"location":"cpp/1101-1200/1181-1190/#1190-reverse-substrings-between-each-pair-of-parentheses-starstar","text":"","title":"1190. Reverse Substrings Between Each Pair of Parentheses $\\star\\star$"},{"location":"cpp/1101-1200/1191-1200/","text":"1191. K-Concatenation Maximum Sum $\\star\\star$ 1192. Critical Connections in a Network $\\star\\star\\star$ 1193. Monthly Transactions I $\\star\\star$ 1194. Tournament Winners $\\star\\star\\star$ 1195. Fizz Buzz Multithreaded $\\star\\star$ 1196. How Many Apples Can You Put into the Basket $\\star$ 1197. Minimum Knight Moves $\\star\\star$ 1198. Find Smallest Common Element in All Rows $\\star\\star$ 1199. Minimum Time to Build Blocks $\\star\\star\\star$ 1200. Minimum Absolute Difference $\\star$","title":"1191-1200"},{"location":"cpp/1101-1200/1191-1200/#1191-k-concatenation-maximum-sum-starstar","text":"","title":"1191. K-Concatenation Maximum Sum $\\star\\star$"},{"location":"cpp/1101-1200/1191-1200/#1192-critical-connections-in-a-network-starstarstar","text":"","title":"1192. Critical Connections in a Network $\\star\\star\\star$"},{"location":"cpp/1101-1200/1191-1200/#1193-monthly-transactions-i-starstar","text":"","title":"1193. Monthly Transactions I $\\star\\star$"},{"location":"cpp/1101-1200/1191-1200/#1194-tournament-winners-starstarstar","text":"","title":"1194. Tournament Winners $\\star\\star\\star$"},{"location":"cpp/1101-1200/1191-1200/#1195-fizz-buzz-multithreaded-starstar","text":"","title":"1195. Fizz Buzz Multithreaded $\\star\\star$"},{"location":"cpp/1101-1200/1191-1200/#1196-how-many-apples-can-you-put-into-the-basket-star","text":"","title":"1196. How Many Apples Can You Put into the Basket $\\star$"},{"location":"cpp/1101-1200/1191-1200/#1197-minimum-knight-moves-starstar","text":"","title":"1197. Minimum Knight Moves $\\star\\star$"},{"location":"cpp/1101-1200/1191-1200/#1198-find-smallest-common-element-in-all-rows-starstar","text":"","title":"1198. Find Smallest Common Element in All Rows $\\star\\star$"},{"location":"cpp/1101-1200/1191-1200/#1199-minimum-time-to-build-blocks-starstarstar","text":"","title":"1199. Minimum Time to Build Blocks $\\star\\star\\star$"},{"location":"cpp/1101-1200/1191-1200/#1200-minimum-absolute-difference-star","text":"","title":"1200. Minimum Absolute Difference $\\star$"},{"location":"cpp/1201-1300/1201-1210/","text":"1201. Ugly Number III $\\star\\star$ 1202. Smallest String With Swaps $\\star\\star$ 1203. Sort Items by Groups Respecting Dependencies $\\star\\star\\star$ 1204. Last Person to Fit in the Elevator $\\star\\star$ 1205. Monthly Transactions II $\\star\\star$ 1206. Design Skiplist $\\star\\star\\star$ 1207. Unique Number of Occurrences $\\star$ 1208. Get Equal Substrings Within Budget $\\star\\star$ 1209. Remove All Adjacent Duplicates in String II $\\star\\star$ 1210. Minimum Moves to Reach Target with Rotations $\\star\\star\\star$","title":"1201-1210"},{"location":"cpp/1201-1300/1201-1210/#1201-ugly-number-iii-starstar","text":"","title":"1201. Ugly Number III $\\star\\star$"},{"location":"cpp/1201-1300/1201-1210/#1202-smallest-string-with-swaps-starstar","text":"","title":"1202. Smallest String With Swaps $\\star\\star$"},{"location":"cpp/1201-1300/1201-1210/#1203-sort-items-by-groups-respecting-dependencies-starstarstar","text":"","title":"1203. Sort Items by Groups Respecting Dependencies $\\star\\star\\star$"},{"location":"cpp/1201-1300/1201-1210/#1204-last-person-to-fit-in-the-elevator-starstar","text":"","title":"1204. Last Person to Fit in the Elevator $\\star\\star$"},{"location":"cpp/1201-1300/1201-1210/#1205-monthly-transactions-ii-starstar","text":"","title":"1205. Monthly Transactions II $\\star\\star$"},{"location":"cpp/1201-1300/1201-1210/#1206-design-skiplist-starstarstar","text":"","title":"1206. Design Skiplist $\\star\\star\\star$"},{"location":"cpp/1201-1300/1201-1210/#1207-unique-number-of-occurrences-star","text":"","title":"1207. Unique Number of Occurrences $\\star$"},{"location":"cpp/1201-1300/1201-1210/#1208-get-equal-substrings-within-budget-starstar","text":"","title":"1208. Get Equal Substrings Within Budget $\\star\\star$"},{"location":"cpp/1201-1300/1201-1210/#1209-remove-all-adjacent-duplicates-in-string-ii-starstar","text":"","title":"1209. Remove All Adjacent Duplicates in String II $\\star\\star$"},{"location":"cpp/1201-1300/1201-1210/#1210-minimum-moves-to-reach-target-with-rotations-starstarstar","text":"","title":"1210. Minimum Moves to Reach Target with Rotations $\\star\\star\\star$"},{"location":"cpp/1201-1300/1211-1220/","text":"1211. Queries Quality and Percentage $\\star$ 1212. Team Scores in Football Tournament $\\star\\star$ 1213. Intersection of Three Sorted Arrays $\\star$ 1214. Two Sum BSTs $\\star\\star$ 1215. Stepping Numbers $\\star\\star$ 1216. Valid Palindrome III $\\star\\star\\star$ 1217. Play with Chips $\\star$ 1218. Longest Arithmetic Subsequence of Given Difference $\\star\\star$ 1219. Path with Maximum Gold $\\star\\star$ 1220. Count Vowels Permutation $\\star\\star\\star$","title":"1211-1220"},{"location":"cpp/1201-1300/1211-1220/#1211-queries-quality-and-percentage-star","text":"","title":"1211. Queries Quality and Percentage $\\star$"},{"location":"cpp/1201-1300/1211-1220/#1212-team-scores-in-football-tournament-starstar","text":"","title":"1212. Team Scores in Football Tournament $\\star\\star$"},{"location":"cpp/1201-1300/1211-1220/#1213-intersection-of-three-sorted-arrays-star","text":"","title":"1213. Intersection of Three Sorted Arrays $\\star$"},{"location":"cpp/1201-1300/1211-1220/#1214-two-sum-bsts-starstar","text":"","title":"1214. Two Sum BSTs $\\star\\star$"},{"location":"cpp/1201-1300/1211-1220/#1215-stepping-numbers-starstar","text":"","title":"1215. Stepping Numbers $\\star\\star$"},{"location":"cpp/1201-1300/1211-1220/#1216-valid-palindrome-iii-starstarstar","text":"","title":"1216. Valid Palindrome III $\\star\\star\\star$"},{"location":"cpp/1201-1300/1211-1220/#1217-play-with-chips-star","text":"","title":"1217. Play with Chips $\\star$"},{"location":"cpp/1201-1300/1211-1220/#1218-longest-arithmetic-subsequence-of-given-difference-starstar","text":"","title":"1218. Longest Arithmetic Subsequence of Given Difference $\\star\\star$"},{"location":"cpp/1201-1300/1211-1220/#1219-path-with-maximum-gold-starstar","text":"","title":"1219. Path with Maximum Gold $\\star\\star$"},{"location":"cpp/1201-1300/1211-1220/#1220-count-vowels-permutation-starstarstar","text":"","title":"1220. Count Vowels Permutation $\\star\\star\\star$"},{"location":"cpp/1201-1300/1221-1230/","text":"1221. Split a String in Balanced Strings $\\star$ 1222. Queens That Can Attack the King $\\star\\star$ 1223. Dice Roll Simulation $\\star\\star$ 1224. Maximum Equal Frequency $\\star\\star\\star$ 1225. Report Contiguous Dates $\\star\\star\\star$ 1226. The Dining Philosophers $\\star\\star$ 1227. Airplane Seat Assignment Probability $\\star\\star$ 1228. Missing Number In Arithmetic Progression $\\star$ 1229. Meeting Scheduler $\\star\\star$ 1230. Toss Strange Coins $\\star\\star$","title":"1221-1230"},{"location":"cpp/1201-1300/1221-1230/#1221-split-a-string-in-balanced-strings-star","text":"","title":"1221. Split a String in Balanced Strings $\\star$"},{"location":"cpp/1201-1300/1221-1230/#1222-queens-that-can-attack-the-king-starstar","text":"","title":"1222. Queens That Can Attack the King $\\star\\star$"},{"location":"cpp/1201-1300/1221-1230/#1223-dice-roll-simulation-starstar","text":"","title":"1223. Dice Roll Simulation $\\star\\star$"},{"location":"cpp/1201-1300/1221-1230/#1224-maximum-equal-frequency-starstarstar","text":"","title":"1224. Maximum Equal Frequency $\\star\\star\\star$"},{"location":"cpp/1201-1300/1221-1230/#1225-report-contiguous-dates-starstarstar","text":"","title":"1225. Report Contiguous Dates $\\star\\star\\star$"},{"location":"cpp/1201-1300/1221-1230/#1226-the-dining-philosophers-starstar","text":"","title":"1226. The Dining Philosophers $\\star\\star$"},{"location":"cpp/1201-1300/1221-1230/#1227-airplane-seat-assignment-probability-starstar","text":"","title":"1227. Airplane Seat Assignment Probability $\\star\\star$"},{"location":"cpp/1201-1300/1221-1230/#1228-missing-number-in-arithmetic-progression-star","text":"","title":"1228. Missing Number In Arithmetic Progression $\\star$"},{"location":"cpp/1201-1300/1221-1230/#1229-meeting-scheduler-starstar","text":"","title":"1229. Meeting Scheduler $\\star\\star$"},{"location":"cpp/1201-1300/1221-1230/#1230-toss-strange-coins-starstar","text":"","title":"1230. Toss Strange Coins $\\star\\star$"},{"location":"cpp/1201-1300/1231-1240/","text":"1231. Divide Chocolate $\\star\\star\\star$ 1232. Check If It Is a Straight Line $\\star$ 1233. Remove Sub-Folders from the Filesystem $\\star\\star$ 1234. Replace the Substring for Balanced String $\\star\\star$ 1235. Maximum Profit in Job Scheduling $\\star\\star\\star$ 1236. Web Crawler $\\star\\star$ 1237. Find Positive Integer Solution for a Given Equation $\\star$ 1238. Circular Permutation in Binary Representation $\\star\\star$ 1239. Maximum Length of a Concatenated String with Unique Characters $\\star\\star$ 1240. Tiling a Rectangle with the Fewest Squares $\\star\\star\\star$","title":"1231-1240"},{"location":"cpp/1201-1300/1231-1240/#1231-divide-chocolate-starstarstar","text":"","title":"1231. Divide Chocolate $\\star\\star\\star$"},{"location":"cpp/1201-1300/1231-1240/#1232-check-if-it-is-a-straight-line-star","text":"","title":"1232. Check If It Is a Straight Line $\\star$"},{"location":"cpp/1201-1300/1231-1240/#1233-remove-sub-folders-from-the-filesystem-starstar","text":"","title":"1233. Remove Sub-Folders from the Filesystem $\\star\\star$"},{"location":"cpp/1201-1300/1231-1240/#1234-replace-the-substring-for-balanced-string-starstar","text":"","title":"1234. Replace the Substring for Balanced String $\\star\\star$"},{"location":"cpp/1201-1300/1231-1240/#1235-maximum-profit-in-job-scheduling-starstarstar","text":"","title":"1235. Maximum Profit in Job Scheduling $\\star\\star\\star$"},{"location":"cpp/1201-1300/1231-1240/#1236-web-crawler-starstar","text":"","title":"1236. Web Crawler $\\star\\star$"},{"location":"cpp/1201-1300/1231-1240/#1237-find-positive-integer-solution-for-a-given-equation-star","text":"","title":"1237. Find Positive Integer Solution for a Given Equation $\\star$"},{"location":"cpp/1201-1300/1231-1240/#1238-circular-permutation-in-binary-representation-starstar","text":"","title":"1238. Circular Permutation in Binary Representation $\\star\\star$"},{"location":"cpp/1201-1300/1231-1240/#1239-maximum-length-of-a-concatenated-string-with-unique-characters-starstar","text":"","title":"1239. Maximum Length of a Concatenated String with Unique Characters $\\star\\star$"},{"location":"cpp/1201-1300/1231-1240/#1240-tiling-a-rectangle-with-the-fewest-squares-starstarstar","text":"","title":"1240. Tiling a Rectangle with the Fewest Squares $\\star\\star\\star$"},{"location":"cpp/1201-1300/1241-1250/","text":"1241. Number of Comments per Post $\\star$ 1242. Web Crawler Multithreaded $\\star\\star$ 1243. Array Transformation $\\star$ 1244. Design A Leaderboard $\\star\\star$ 1245. Tree Diameter $\\star\\star$ 1246. Palindrome Removal $\\star\\star\\star$ 1247. Minimum Swaps to Make Strings Equal $\\star\\star$ 1248. Count Number of Nice Subarrays $\\star\\star$ 1249. Minimum Remove to Make Valid Parentheses $\\star\\star$ 1250. Check If It Is a Good Array $\\star\\star\\star$","title":"1241-1250"},{"location":"cpp/1201-1300/1241-1250/#1241-number-of-comments-per-post-star","text":"","title":"1241. Number of Comments per Post $\\star$"},{"location":"cpp/1201-1300/1241-1250/#1242-web-crawler-multithreaded-starstar","text":"","title":"1242. Web Crawler Multithreaded $\\star\\star$"},{"location":"cpp/1201-1300/1241-1250/#1243-array-transformation-star","text":"","title":"1243. Array Transformation $\\star$"},{"location":"cpp/1201-1300/1241-1250/#1244-design-a-leaderboard-starstar","text":"","title":"1244. Design A Leaderboard $\\star\\star$"},{"location":"cpp/1201-1300/1241-1250/#1245-tree-diameter-starstar","text":"","title":"1245. Tree Diameter $\\star\\star$"},{"location":"cpp/1201-1300/1241-1250/#1246-palindrome-removal-starstarstar","text":"","title":"1246. Palindrome Removal $\\star\\star\\star$"},{"location":"cpp/1201-1300/1241-1250/#1247-minimum-swaps-to-make-strings-equal-starstar","text":"","title":"1247. Minimum Swaps to Make Strings Equal $\\star\\star$"},{"location":"cpp/1201-1300/1241-1250/#1248-count-number-of-nice-subarrays-starstar","text":"","title":"1248. Count Number of Nice Subarrays $\\star\\star$"},{"location":"cpp/1201-1300/1241-1250/#1249-minimum-remove-to-make-valid-parentheses-starstar","text":"","title":"1249. Minimum Remove to Make Valid Parentheses $\\star\\star$"},{"location":"cpp/1201-1300/1241-1250/#1250-check-if-it-is-a-good-array-starstarstar","text":"","title":"1250. Check If It Is a Good Array $\\star\\star\\star$"},{"location":"cpp/1201-1300/1251-1260/","text":"1251. Average Selling Price $\\star$ 1252. Cells with Odd Values in a Matrix $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int oddCells ( int n , int m , vector < vector < int >>& indices ) { int ans = 0 ; vector < int > rows ( n ); vector < int > cols ( m ); for ( vector < int >& indice : indices ) { rows [ indice [ 0 ]] ^= 1 ; cols [ indice [ 1 ]] ^= 1 ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) ans += rows [ i ] ^ cols [ j ]; return ans ; } }; 1253. Reconstruct a 2-Row Binary Matrix $\\star\\star$ 1254. Number of Closed Islands $\\star\\star$ 1255. Maximum Score Words Formed by Letters $\\star\\star\\star$ 1256. Encode Number $\\star\\star$ 1257. Smallest Common Region $\\star\\star$ 1258. Synonymous Sentences $\\star\\star$ 1259. Handshakes That Don't Cross $\\star\\star\\star$ 1260. Shift 2D Grid $\\star$","title":"1251-1260"},{"location":"cpp/1201-1300/1251-1260/#1251-average-selling-price-star","text":"","title":"1251. Average Selling Price $\\star$"},{"location":"cpp/1201-1300/1251-1260/#1252-cells-with-odd-values-in-a-matrix-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public : int oddCells ( int n , int m , vector < vector < int >>& indices ) { int ans = 0 ; vector < int > rows ( n ); vector < int > cols ( m ); for ( vector < int >& indice : indices ) { rows [ indice [ 0 ]] ^= 1 ; cols [ indice [ 1 ]] ^= 1 ; } for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < m ; j ++ ) ans += rows [ i ] ^ cols [ j ]; return ans ; } };","title":"1252. Cells with Odd Values in a Matrix $\\star$"},{"location":"cpp/1201-1300/1251-1260/#1253-reconstruct-a-2-row-binary-matrix-starstar","text":"","title":"1253. Reconstruct a 2-Row Binary Matrix $\\star\\star$"},{"location":"cpp/1201-1300/1251-1260/#1254-number-of-closed-islands-starstar","text":"","title":"1254. Number of Closed Islands $\\star\\star$"},{"location":"cpp/1201-1300/1251-1260/#1255-maximum-score-words-formed-by-letters-starstarstar","text":"","title":"1255. Maximum Score Words Formed by Letters $\\star\\star\\star$"},{"location":"cpp/1201-1300/1251-1260/#1256-encode-number-starstar","text":"","title":"1256. Encode Number $\\star\\star$"},{"location":"cpp/1201-1300/1251-1260/#1257-smallest-common-region-starstar","text":"","title":"1257. Smallest Common Region $\\star\\star$"},{"location":"cpp/1201-1300/1251-1260/#1258-synonymous-sentences-starstar","text":"","title":"1258. Synonymous Sentences $\\star\\star$"},{"location":"cpp/1201-1300/1251-1260/#1259-handshakes-that-dont-cross-starstarstar","text":"","title":"1259. Handshakes That Don't Cross $\\star\\star\\star$"},{"location":"cpp/1201-1300/1251-1260/#1260-shift-2d-grid-star","text":"","title":"1260. Shift 2D Grid $\\star$"},{"location":"cpp/1201-1300/1261-1270/","text":"1261. Find Elements in a Contaminated Binary Tree $\\star\\star$ 1262. Greatest Sum Divisible by Three $\\star\\star$ 1263. Minimum Moves to Move a Box to Their Target Location $\\star\\star\\star$ 1264. Page Recommendations $\\star\\star$ 1265. Print Immutable Linked List in Reverse $\\star\\star$ 1266. Minimum Time Visiting All Points $\\star$ 1267. Count Servers that Communicate $\\star\\star$ 1268. Search Suggestions System $\\star\\star$ 1269. Number of Ways to Stay in the Same Place After Some Steps $\\star\\star\\star$ 1270. All People Report to the Given Manager $\\star\\star$","title":"1261-1270"},{"location":"cpp/1201-1300/1261-1270/#1261-find-elements-in-a-contaminated-binary-tree-starstar","text":"","title":"1261. Find Elements in a Contaminated Binary Tree $\\star\\star$"},{"location":"cpp/1201-1300/1261-1270/#1262-greatest-sum-divisible-by-three-starstar","text":"","title":"1262. Greatest Sum Divisible by Three $\\star\\star$"},{"location":"cpp/1201-1300/1261-1270/#1263-minimum-moves-to-move-a-box-to-their-target-location-starstarstar","text":"","title":"1263. Minimum Moves to Move a Box to Their Target Location $\\star\\star\\star$"},{"location":"cpp/1201-1300/1261-1270/#1264-page-recommendations-starstar","text":"","title":"1264. Page Recommendations $\\star\\star$"},{"location":"cpp/1201-1300/1261-1270/#1265-print-immutable-linked-list-in-reverse-starstar","text":"","title":"1265. Print Immutable Linked List in Reverse $\\star\\star$"},{"location":"cpp/1201-1300/1261-1270/#1266-minimum-time-visiting-all-points-star","text":"","title":"1266. Minimum Time Visiting All Points $\\star$"},{"location":"cpp/1201-1300/1261-1270/#1267-count-servers-that-communicate-starstar","text":"","title":"1267. Count Servers that Communicate $\\star\\star$"},{"location":"cpp/1201-1300/1261-1270/#1268-search-suggestions-system-starstar","text":"","title":"1268. Search Suggestions System $\\star\\star$"},{"location":"cpp/1201-1300/1261-1270/#1269-number-of-ways-to-stay-in-the-same-place-after-some-steps-starstarstar","text":"","title":"1269. Number of Ways to Stay in the Same Place After Some Steps $\\star\\star\\star$"},{"location":"cpp/1201-1300/1261-1270/#1270-all-people-report-to-the-given-manager-starstar","text":"","title":"1270. All People Report to the Given Manager $\\star\\star$"},{"location":"cpp/1201-1300/1271-1280/","text":"1271. Hexspeak $\\star$ 1272. Remove Interval $\\star\\star$ 1273. Delete Tree Nodes $\\star\\star$ 1274. Number of Ships in a Rectangle $\\star\\star\\star$ 1275. Find Winner on a Tic Tac Toe Game $\\star$ 1276. Number of Burgers with No Waste of Ingredients $\\star\\star$ 1277. Count Square Submatrices with All Ones $\\star\\star$ 1278. Palindrome Partitioning III $\\star\\star\\star$ 1279. Traffic Light Controlled Intersection $\\star$ 1280. Students and Examinations $\\star$","title":"1271-1280"},{"location":"cpp/1201-1300/1271-1280/#1271-hexspeak-star","text":"","title":"1271. Hexspeak $\\star$"},{"location":"cpp/1201-1300/1271-1280/#1272-remove-interval-starstar","text":"","title":"1272. Remove Interval $\\star\\star$"},{"location":"cpp/1201-1300/1271-1280/#1273-delete-tree-nodes-starstar","text":"","title":"1273. Delete Tree Nodes $\\star\\star$"},{"location":"cpp/1201-1300/1271-1280/#1274-number-of-ships-in-a-rectangle-starstarstar","text":"","title":"1274. Number of Ships in a Rectangle $\\star\\star\\star$"},{"location":"cpp/1201-1300/1271-1280/#1275-find-winner-on-a-tic-tac-toe-game-star","text":"","title":"1275. Find Winner on a Tic Tac Toe Game $\\star$"},{"location":"cpp/1201-1300/1271-1280/#1276-number-of-burgers-with-no-waste-of-ingredients-starstar","text":"","title":"1276. Number of Burgers with No Waste of Ingredients $\\star\\star$"},{"location":"cpp/1201-1300/1271-1280/#1277-count-square-submatrices-with-all-ones-starstar","text":"","title":"1277. Count Square Submatrices with All Ones $\\star\\star$"},{"location":"cpp/1201-1300/1271-1280/#1278-palindrome-partitioning-iii-starstarstar","text":"","title":"1278. Palindrome Partitioning III $\\star\\star\\star$"},{"location":"cpp/1201-1300/1271-1280/#1279-traffic-light-controlled-intersection-star","text":"","title":"1279. Traffic Light Controlled Intersection $\\star$"},{"location":"cpp/1201-1300/1271-1280/#1280-students-and-examinations-star","text":"","title":"1280. Students and Examinations $\\star$"},{"location":"cpp/1201-1300/1281-1290/","text":"1281. Subtract the Product and Sum of Digits of an Integer $\\star$ 1282. Group the People Given the Group Size They Belong To $\\star\\star$ 1283. Find the Smallest Divisor Given a Threshold $\\star\\star$ 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix $\\star\\star\\star$ 1285. Find the Start and End Number of Continuous Ranges $\\star\\star$ 1286. Iterator for Combination $\\star\\star$ 1287. Element Appearing More Than 25% In Sorted Array $\\star$ 1288. Remove Covered Intervals $\\star\\star$ 1289. Minimum Falling Path Sum II $\\star\\star\\star$ 1290. Convert Binary Number in a Linked List to Integer $\\star$","title":"1281-1290"},{"location":"cpp/1201-1300/1281-1290/#1281-subtract-the-product-and-sum-of-digits-of-an-integer-star","text":"","title":"1281. Subtract the Product and Sum of Digits of an Integer $\\star$"},{"location":"cpp/1201-1300/1281-1290/#1282-group-the-people-given-the-group-size-they-belong-to-starstar","text":"","title":"1282. Group the People Given the Group Size They Belong To $\\star\\star$"},{"location":"cpp/1201-1300/1281-1290/#1283-find-the-smallest-divisor-given-a-threshold-starstar","text":"","title":"1283. Find the Smallest Divisor Given a Threshold $\\star\\star$"},{"location":"cpp/1201-1300/1281-1290/#1284-minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix-starstarstar","text":"","title":"1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix $\\star\\star\\star$"},{"location":"cpp/1201-1300/1281-1290/#1285-find-the-start-and-end-number-of-continuous-ranges-starstar","text":"","title":"1285. Find the Start and End Number of Continuous Ranges $\\star\\star$"},{"location":"cpp/1201-1300/1281-1290/#1286-iterator-for-combination-starstar","text":"","title":"1286. Iterator for Combination $\\star\\star$"},{"location":"cpp/1201-1300/1281-1290/#1287-element-appearing-more-than-25-in-sorted-array-star","text":"","title":"1287. Element Appearing More Than 25% In Sorted Array $\\star$"},{"location":"cpp/1201-1300/1281-1290/#1288-remove-covered-intervals-starstar","text":"","title":"1288. Remove Covered Intervals $\\star\\star$"},{"location":"cpp/1201-1300/1281-1290/#1289-minimum-falling-path-sum-ii-starstarstar","text":"","title":"1289. Minimum Falling Path Sum II $\\star\\star\\star$"},{"location":"cpp/1201-1300/1281-1290/#1290-convert-binary-number-in-a-linked-list-to-integer-star","text":"","title":"1290. Convert Binary Number in a Linked List to Integer $\\star$"},{"location":"cpp/1201-1300/1291-1300/","text":"1291. Sequential Digits $\\star\\star$ 1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold $\\star\\star$ 1293. Shortest Path in a Grid with Obstacles Elimination $\\star\\star\\star$ 1294. Weather Type in Each Country $\\star$ 1295. Find Numbers with Even Number of Digits $\\star$ 1296. Divide Array in Sets of K Consecutive Numbers $\\star\\star$ 1297. Maximum Number of Occurrences of a Substring $\\star\\star$ 1298. Maximum Candies You Can Get from Boxes $\\star\\star\\star$ 1299. Replace Elements with Greatest Element on Right Side $\\star$ 1300. Sum of Mutated Array Closest to Target $\\star\\star$","title":"1291-1300"},{"location":"cpp/1201-1300/1291-1300/#1291-sequential-digits-starstar","text":"","title":"1291. Sequential Digits $\\star\\star$"},{"location":"cpp/1201-1300/1291-1300/#1292-maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold-starstar","text":"","title":"1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold $\\star\\star$"},{"location":"cpp/1201-1300/1291-1300/#1293-shortest-path-in-a-grid-with-obstacles-elimination-starstarstar","text":"","title":"1293. Shortest Path in a Grid with Obstacles Elimination $\\star\\star\\star$"},{"location":"cpp/1201-1300/1291-1300/#1294-weather-type-in-each-country-star","text":"","title":"1294. Weather Type in Each Country $\\star$"},{"location":"cpp/1201-1300/1291-1300/#1295-find-numbers-with-even-number-of-digits-star","text":"","title":"1295. Find Numbers with Even Number of Digits $\\star$"},{"location":"cpp/1201-1300/1291-1300/#1296-divide-array-in-sets-of-k-consecutive-numbers-starstar","text":"","title":"1296. Divide Array in Sets of K Consecutive Numbers $\\star\\star$"},{"location":"cpp/1201-1300/1291-1300/#1297-maximum-number-of-occurrences-of-a-substring-starstar","text":"","title":"1297. Maximum Number of Occurrences of a Substring $\\star\\star$"},{"location":"cpp/1201-1300/1291-1300/#1298-maximum-candies-you-can-get-from-boxes-starstarstar","text":"","title":"1298. Maximum Candies You Can Get from Boxes $\\star\\star\\star$"},{"location":"cpp/1201-1300/1291-1300/#1299-replace-elements-with-greatest-element-on-right-side-star","text":"","title":"1299. Replace Elements with Greatest Element on Right Side $\\star$"},{"location":"cpp/1201-1300/1291-1300/#1300-sum-of-mutated-array-closest-to-target-starstar","text":"","title":"1300. Sum of Mutated Array Closest to Target $\\star\\star$"},{"location":"cpp/1301-1400/1301-1310/","text":"1301. Number of Paths with Max Score $\\star\\star\\star$ 1302. Deepest Leaves Sum $\\star\\star$ 1303. Find the Team Size $\\star$ 1304. Find N Unique Integers Sum up to Zero $\\star$ 1305. All Elements in Two Binary Search Trees $\\star\\star$ 1306. Jump Game III $\\star\\star$ 1307. Verbal Arithmetic Puzzle $\\star\\star\\star$ 1308. Running Total for Different Genders $\\star\\star$ 1309. Decrypt String from Alphabet to Integer Mapping $\\star$ 1310. XOR Queries of a Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > xorQueries ( vector < int >& arr , vector < vector < int >>& queries ) { vector < int > ans ; vector < int > xors ( arr . size () + 1 ); for ( int i = 0 ; i < arr . size (); i ++ ) xors [ i + 1 ] ^= xors [ i ] ^ arr [ i ]; for ( vector < int >& query : queries ) ans . push_back ( xors [ query [ 0 ]] ^ xors [ query [ 1 ] + 1 ]); return ans ; } };","title":"1301-1310"},{"location":"cpp/1301-1400/1301-1310/#1301-number-of-paths-with-max-score-starstarstar","text":"","title":"1301. Number of Paths with Max Score $\\star\\star\\star$"},{"location":"cpp/1301-1400/1301-1310/#1302-deepest-leaves-sum-starstar","text":"","title":"1302. Deepest Leaves Sum $\\star\\star$"},{"location":"cpp/1301-1400/1301-1310/#1303-find-the-team-size-star","text":"","title":"1303. Find the Team Size $\\star$"},{"location":"cpp/1301-1400/1301-1310/#1304-find-n-unique-integers-sum-up-to-zero-star","text":"","title":"1304. Find N Unique Integers Sum up to Zero $\\star$"},{"location":"cpp/1301-1400/1301-1310/#1305-all-elements-in-two-binary-search-trees-starstar","text":"","title":"1305. All Elements in Two Binary Search Trees $\\star\\star$"},{"location":"cpp/1301-1400/1301-1310/#1306-jump-game-iii-starstar","text":"","title":"1306. Jump Game III $\\star\\star$"},{"location":"cpp/1301-1400/1301-1310/#1307-verbal-arithmetic-puzzle-starstarstar","text":"","title":"1307. Verbal Arithmetic Puzzle $\\star\\star\\star$"},{"location":"cpp/1301-1400/1301-1310/#1308-running-total-for-different-genders-starstar","text":"","title":"1308. Running Total for Different Genders $\\star\\star$"},{"location":"cpp/1301-1400/1301-1310/#1309-decrypt-string-from-alphabet-to-integer-mapping-star","text":"","title":"1309. Decrypt String from Alphabet to Integer Mapping $\\star$"},{"location":"cpp/1301-1400/1301-1310/#1310-xor-queries-of-a-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public : vector < int > xorQueries ( vector < int >& arr , vector < vector < int >>& queries ) { vector < int > ans ; vector < int > xors ( arr . size () + 1 ); for ( int i = 0 ; i < arr . size (); i ++ ) xors [ i + 1 ] ^= xors [ i ] ^ arr [ i ]; for ( vector < int >& query : queries ) ans . push_back ( xors [ query [ 0 ]] ^ xors [ query [ 1 ] + 1 ]); return ans ; } };","title":"1310. XOR Queries of a Subarray $\\star\\star$"},{"location":"cpp/1301-1400/1311-1320/","text":"1311. Get Watched Videos by Your Friends $\\star\\star$ 1312. Minimum Insertion Steps to Make a String Palindrome $\\star\\star\\star$ 1313. Decompress Run-Length Encoded List $\\star$ 1314. Matrix Block Sum $\\star\\star$ 1315. Sum of Nodes with Even-Valued Grandparent $\\star\\star$ 1316. Distinct Echo Substrings $\\star\\star\\star$ 1317. Convert Integer to the Sum of Two No-Zero Integers $\\star$ 1318. Minimum Flips to Make a OR b Equal to c $\\star\\star$ 1319. Number of Operations to Make Network Connected $\\star\\star$ 1320. Minimum Distance to Type a Word Using Two Fingers $\\star\\star\\star$","title":"1311-1320"},{"location":"cpp/1301-1400/1311-1320/#1311-get-watched-videos-by-your-friends-starstar","text":"","title":"1311. Get Watched Videos by Your Friends $\\star\\star$"},{"location":"cpp/1301-1400/1311-1320/#1312-minimum-insertion-steps-to-make-a-string-palindrome-starstarstar","text":"","title":"1312. Minimum Insertion Steps to Make a String Palindrome $\\star\\star\\star$"},{"location":"cpp/1301-1400/1311-1320/#1313-decompress-run-length-encoded-list-star","text":"","title":"1313. Decompress Run-Length Encoded List $\\star$"},{"location":"cpp/1301-1400/1311-1320/#1314-matrix-block-sum-starstar","text":"","title":"1314. Matrix Block Sum $\\star\\star$"},{"location":"cpp/1301-1400/1311-1320/#1315-sum-of-nodes-with-even-valued-grandparent-starstar","text":"","title":"1315. Sum of Nodes with Even-Valued Grandparent $\\star\\star$"},{"location":"cpp/1301-1400/1311-1320/#1316-distinct-echo-substrings-starstarstar","text":"","title":"1316. Distinct Echo Substrings $\\star\\star\\star$"},{"location":"cpp/1301-1400/1311-1320/#1317-convert-integer-to-the-sum-of-two-no-zero-integers-star","text":"","title":"1317. Convert Integer to the Sum of Two No-Zero Integers $\\star$"},{"location":"cpp/1301-1400/1311-1320/#1318-minimum-flips-to-make-a-or-b-equal-to-c-starstar","text":"","title":"1318. Minimum Flips to Make a OR b Equal to c $\\star\\star$"},{"location":"cpp/1301-1400/1311-1320/#1319-number-of-operations-to-make-network-connected-starstar","text":"","title":"1319. Number of Operations to Make Network Connected $\\star\\star$"},{"location":"cpp/1301-1400/1311-1320/#1320-minimum-distance-to-type-a-word-using-two-fingers-starstarstar","text":"","title":"1320. Minimum Distance to Type a Word Using Two Fingers $\\star\\star\\star$"},{"location":"cpp/1301-1400/1321-1330/","text":"1321. Restaurant Growth $\\star\\star$ 1322. Ads Performance $\\star$","title":"1321-1321"},{"location":"cpp/1301-1400/1321-1330/#1321-restaurant-growth-starstar","text":"","title":"1321. Restaurant Growth $\\star\\star$"},{"location":"cpp/1301-1400/1321-1330/#1322-ads-performance-star","text":"","title":"1322. Ads Performance $\\star$"},{"location":"java/","text":"LeetCode in Java","title":"Preface"},{"location":"java/#leetcode-in-java","text":"","title":"LeetCode in Java"},{"location":"java/0001-0100/0001-0010/","text":"1. Two Sum $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int [] twoSum ( int [] nums , int target ) { Map < Integer , Integer > map = new HashMap <>(); for ( int i = 0 ; i < nums . length ; i ++) { if ( map . containsKey ( nums [ i ])) return new int [] { map . get ( nums [ i ]), i }; map . put ( target - nums [ i ], i ); } throw new IllegalArgumentException (); } } 2. Add Two Numbers $\\star\\star$ 3. Longest Substring Without Repeating Characters $\\star\\star$ 4. Median of Two Sorted Arrays $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public double findMedianSortedArrays ( int [] nums1 , int [] nums2 ) { final int n1 = nums1 . length ; final int n2 = nums2 . length ; if ( n1 > n2 ) return findMedianSortedArrays ( nums2 , nums1 ); int l = 0 ; int r = n1 ; while ( l <= r ) { int partition1 = l + ( r - l ) / 2 ; int partition2 = ( n1 + n2 + 1 ) / 2 - partition1 ; int maxLeft1 = partition1 == 0 ? Integer . MIN_VALUE : nums1 [ partition1 - 1 ]; int maxLeft2 = partition2 == 0 ? Integer . MIN_VALUE : nums2 [ partition2 - 1 ]; int minRight1 = partition1 == n1 ? Integer . MAX_VALUE : nums1 [ partition1 ]; int minRight2 = partition2 == n2 ? Integer . MAX_VALUE : nums2 [ partition2 ]; if ( maxLeft1 <= minRight2 && maxLeft2 <= minRight1 ) return ( n1 + n2 ) % 2 == 0 ? ( Math . max ( maxLeft1 , maxLeft2 ) + Math . min ( minRight1 , minRight2 )) * 0.5 : Math . max ( maxLeft1 , maxLeft2 ); else if ( maxLeft1 > minRight2 ) r = partition1 - 1 ; else l = partition1 + 1 ; } throw new IllegalArgumentException (); } } 5. Longest Palindromic Substring $\\star\\star$ 6. ZigZag Conversion $\\star\\star$ 7. Reverse Integer $\\star$ 8. String to Integer (atoi) $\\star\\star$ 9. Palindrome Number $\\star$ 10. Regular Expression Matching $\\star\\star\\star$","title":"0001-0010"},{"location":"java/0001-0100/0001-0010/#1-two-sum-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int [] twoSum ( int [] nums , int target ) { Map < Integer , Integer > map = new HashMap <>(); for ( int i = 0 ; i < nums . length ; i ++) { if ( map . containsKey ( nums [ i ])) return new int [] { map . get ( nums [ i ]), i }; map . put ( target - nums [ i ], i ); } throw new IllegalArgumentException (); } }","title":"1. Two Sum $\\star$"},{"location":"java/0001-0100/0001-0010/#2-add-two-numbers-starstar","text":"","title":"2. Add Two Numbers $\\star\\star$"},{"location":"java/0001-0100/0001-0010/#3-longest-substring-without-repeating-characters-starstar","text":"","title":"3. Longest Substring Without Repeating Characters $\\star\\star$"},{"location":"java/0001-0100/0001-0010/#4-median-of-two-sorted-arrays-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution { public double findMedianSortedArrays ( int [] nums1 , int [] nums2 ) { final int n1 = nums1 . length ; final int n2 = nums2 . length ; if ( n1 > n2 ) return findMedianSortedArrays ( nums2 , nums1 ); int l = 0 ; int r = n1 ; while ( l <= r ) { int partition1 = l + ( r - l ) / 2 ; int partition2 = ( n1 + n2 + 1 ) / 2 - partition1 ; int maxLeft1 = partition1 == 0 ? Integer . MIN_VALUE : nums1 [ partition1 - 1 ]; int maxLeft2 = partition2 == 0 ? Integer . MIN_VALUE : nums2 [ partition2 - 1 ]; int minRight1 = partition1 == n1 ? Integer . MAX_VALUE : nums1 [ partition1 ]; int minRight2 = partition2 == n2 ? Integer . MAX_VALUE : nums2 [ partition2 ]; if ( maxLeft1 <= minRight2 && maxLeft2 <= minRight1 ) return ( n1 + n2 ) % 2 == 0 ? ( Math . max ( maxLeft1 , maxLeft2 ) + Math . min ( minRight1 , minRight2 )) * 0.5 : Math . max ( maxLeft1 , maxLeft2 ); else if ( maxLeft1 > minRight2 ) r = partition1 - 1 ; else l = partition1 + 1 ; } throw new IllegalArgumentException (); } }","title":"4. Median of Two Sorted Arrays $\\star\\star\\star$"},{"location":"java/0001-0100/0001-0010/#5-longest-palindromic-substring-starstar","text":"","title":"5. Longest Palindromic Substring $\\star\\star$"},{"location":"java/0001-0100/0001-0010/#6-zigzag-conversion-starstar","text":"","title":"6. ZigZag Conversion $\\star\\star$"},{"location":"java/0001-0100/0001-0010/#7-reverse-integer-star","text":"","title":"7. Reverse Integer $\\star$"},{"location":"java/0001-0100/0001-0010/#8-string-to-integer-atoi-starstar","text":"","title":"8. String to Integer (atoi) $\\star\\star$"},{"location":"java/0001-0100/0001-0010/#9-palindrome-number-star","text":"","title":"9. Palindrome Number $\\star$"},{"location":"java/0001-0100/0001-0010/#10-regular-expression-matching-starstarstar","text":"","title":"10. Regular Expression Matching $\\star\\star\\star$"},{"location":"java/0001-0100/0011-0020/","text":"11. Container With Most Water $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int maxArea ( int [] height ) { int ans = 0 ; int l = 0 ; int r = height . length - 1 ; while ( l < r ) { int h = Math . min ( height [ l ], height [ r ]); ans = Math . max ( ans , ( r - l ) * h ); while ( height [ l ] <= h && l < r ) l ++; while ( height [ r ] <= h && l < r ) r --; } return ans ; } } 12. Integer to Roman $\\star\\star$ 13. Roman to Integer $\\star$ 14. Longest Common Prefix $\\star$ 15. 3Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public List < List < Integer >> threeSum ( int [] nums ) { List < List < Integer >> ans = new ArrayList <>(); Arrays . sort ( nums ); for ( int i = 0 ; i + 2 < nums . length ; i ++) { if ( i > 0 && nums [ i ] == nums [ i - 1 ]) continue ; int l = i + 1 ; int r = nums . length - 1 ; while ( l < r ) { int sum = nums [ i ] + nums [ l ] + nums [ r ]; if ( sum == 0 ) { ans . add ( Arrays . asList ( nums [ i ], nums [ l ], nums [ r ])); l ++; r --; while ( nums [ l ] == nums [ l - 1 ] && l < r ) l ++; while ( nums [ r ] == nums [ r + 1 ] && l < r ) r --; } else if ( sum < 0 ) { l ++; } else { r --; } } } return ans ; } } 16. 3Sum Closest $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int threeSumClosest ( int [] nums , int target ) { int ans = nums [ 0 ] + nums [ 1 ] + nums [ 2 ]; Arrays . sort ( nums ); for ( int i = 0 ; i + 2 < nums . length ; i ++) { int l = i + 1 ; int r = nums . length - 1 ; while ( l < r ) { int sum = nums [ i ] + nums [ l ] + nums [ r ]; if ( sum == target ) return sum ; if ( Math . abs ( sum - target ) < Math . abs ( ans - target )) ans = sum ; if ( sum < target ) l ++; else r --; } } return ans ; } } 17. Letter Combinations of a Phone Number $\\star\\star$ 18. 4Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public List < List < Integer >> fourSum ( int [] nums , int target ) { List < List < Integer >> ans = new ArrayList <>(); List < Integer > path = new ArrayList <>(); Arrays . sort ( nums ); nSum ( nums , target , 0 , nums . length - 1 , 4 , path , ans ); return ans ; } private void nSum ( int [] nums , int target , int l , int r , int n , List < Integer > path , List < List < Integer >> ans ) { if ( r - l + 1 < n || n < 2 || target < nums [ l ] * n || target > nums [ r ] * n ) return ; if ( n == 2 ) { while ( l < r ) { int sum = nums [ l ] + nums [ r ]; if ( sum == target ) { path . add ( nums [ l ]); path . add ( nums [ r ]); ans . add ( new ArrayList <>( path )); path . remove ( path . size () - 1 ); path . remove ( path . size () - 1 ); l ++; while ( nums [ l ] == nums [ l - 1 ] && l < r ) l ++; } else if ( sum < target ) { l ++; } else { r --; } } return ; } for ( int i = l ; i <= r ; i ++) { if ( i > l && nums [ i ] == nums [ i - 1 ]) continue ; path . add ( nums [ i ]); nSum ( nums , target - nums [ i ], i + 1 , r , n - 1 , path , ans ); path . remove ( path . size () - 1 ); } } } 19. Remove Nth Node From End of List $\\star\\star$ 20. Valid Parentheses $\\star$","title":"0011-0020"},{"location":"java/0001-0100/0011-0020/#11-container-with-most-water-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int maxArea ( int [] height ) { int ans = 0 ; int l = 0 ; int r = height . length - 1 ; while ( l < r ) { int h = Math . min ( height [ l ], height [ r ]); ans = Math . max ( ans , ( r - l ) * h ); while ( height [ l ] <= h && l < r ) l ++; while ( height [ r ] <= h && l < r ) r --; } return ans ; } }","title":"11. Container With Most Water $\\star\\star$"},{"location":"java/0001-0100/0011-0020/#12-integer-to-roman-starstar","text":"","title":"12. Integer to Roman $\\star\\star$"},{"location":"java/0001-0100/0011-0020/#13-roman-to-integer-star","text":"","title":"13. Roman to Integer $\\star$"},{"location":"java/0001-0100/0011-0020/#14-longest-common-prefix-star","text":"","title":"14. Longest Common Prefix $\\star$"},{"location":"java/0001-0100/0011-0020/#15-3sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public List < List < Integer >> threeSum ( int [] nums ) { List < List < Integer >> ans = new ArrayList <>(); Arrays . sort ( nums ); for ( int i = 0 ; i + 2 < nums . length ; i ++) { if ( i > 0 && nums [ i ] == nums [ i - 1 ]) continue ; int l = i + 1 ; int r = nums . length - 1 ; while ( l < r ) { int sum = nums [ i ] + nums [ l ] + nums [ r ]; if ( sum == 0 ) { ans . add ( Arrays . asList ( nums [ i ], nums [ l ], nums [ r ])); l ++; r --; while ( nums [ l ] == nums [ l - 1 ] && l < r ) l ++; while ( nums [ r ] == nums [ r + 1 ] && l < r ) r --; } else if ( sum < 0 ) { l ++; } else { r --; } } } return ans ; } }","title":"15. 3Sum $\\star\\star$"},{"location":"java/0001-0100/0011-0020/#16-3sum-closest-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int threeSumClosest ( int [] nums , int target ) { int ans = nums [ 0 ] + nums [ 1 ] + nums [ 2 ]; Arrays . sort ( nums ); for ( int i = 0 ; i + 2 < nums . length ; i ++) { int l = i + 1 ; int r = nums . length - 1 ; while ( l < r ) { int sum = nums [ i ] + nums [ l ] + nums [ r ]; if ( sum == target ) return sum ; if ( Math . abs ( sum - target ) < Math . abs ( ans - target )) ans = sum ; if ( sum < target ) l ++; else r --; } } return ans ; } }","title":"16. 3Sum Closest $\\star\\star$"},{"location":"java/0001-0100/0011-0020/#17-letter-combinations-of-a-phone-number-starstar","text":"","title":"17. Letter Combinations of a Phone Number $\\star\\star$"},{"location":"java/0001-0100/0011-0020/#18-4sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class Solution { public List < List < Integer >> fourSum ( int [] nums , int target ) { List < List < Integer >> ans = new ArrayList <>(); List < Integer > path = new ArrayList <>(); Arrays . sort ( nums ); nSum ( nums , target , 0 , nums . length - 1 , 4 , path , ans ); return ans ; } private void nSum ( int [] nums , int target , int l , int r , int n , List < Integer > path , List < List < Integer >> ans ) { if ( r - l + 1 < n || n < 2 || target < nums [ l ] * n || target > nums [ r ] * n ) return ; if ( n == 2 ) { while ( l < r ) { int sum = nums [ l ] + nums [ r ]; if ( sum == target ) { path . add ( nums [ l ]); path . add ( nums [ r ]); ans . add ( new ArrayList <>( path )); path . remove ( path . size () - 1 ); path . remove ( path . size () - 1 ); l ++; while ( nums [ l ] == nums [ l - 1 ] && l < r ) l ++; } else if ( sum < target ) { l ++; } else { r --; } } return ; } for ( int i = l ; i <= r ; i ++) { if ( i > l && nums [ i ] == nums [ i - 1 ]) continue ; path . add ( nums [ i ]); nSum ( nums , target - nums [ i ], i + 1 , r , n - 1 , path , ans ); path . remove ( path . size () - 1 ); } } }","title":"18. 4Sum $\\star\\star$"},{"location":"java/0001-0100/0011-0020/#19-remove-nth-node-from-end-of-list-starstar","text":"","title":"19. Remove Nth Node From End of List $\\star\\star$"},{"location":"java/0001-0100/0011-0020/#20-valid-parentheses-star","text":"","title":"20. Valid Parentheses $\\star$"},{"location":"java/0001-0100/0021-0030/","text":"21. Merge Two Sorted Lists $\\star$ 22. Generate Parentheses $\\star\\star$ 23. Merge k Sorted Lists $\\star\\star\\star$ 24. Swap Nodes in Pairs $\\star\\star$ 25. Reverse Nodes in k-Group $\\star\\star\\star$ 26. Remove Duplicates from Sorted Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int removeDuplicates ( int [] nums ) { int j = 0 ; for ( int i = 1 ; i < nums . length ; i ++) if ( nums [ i ] != nums [ j ]) nums [++ j ] = nums [ i ]; return j + 1 ; } } 27. Remove Element $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int removeElement ( int [] nums , int val ) { int i = 0 ; for ( int num : nums ) if ( num != val ) nums [ i ++] = num ; return i ; } } 28. Implement strStr() $\\star$ 29. Divide Two Integers $\\star\\star$ 30. Substring with Concatenation of All Words $\\star\\star\\star$","title":"0021-0030"},{"location":"java/0001-0100/0021-0030/#21-merge-two-sorted-lists-star","text":"","title":"21. Merge Two Sorted Lists $\\star$"},{"location":"java/0001-0100/0021-0030/#22-generate-parentheses-starstar","text":"","title":"22. Generate Parentheses $\\star\\star$"},{"location":"java/0001-0100/0021-0030/#23-merge-k-sorted-lists-starstarstar","text":"","title":"23. Merge k Sorted Lists $\\star\\star\\star$"},{"location":"java/0001-0100/0021-0030/#24-swap-nodes-in-pairs-starstar","text":"","title":"24. Swap Nodes in Pairs $\\star\\star$"},{"location":"java/0001-0100/0021-0030/#25-reverse-nodes-in-k-group-starstarstar","text":"","title":"25. Reverse Nodes in k-Group $\\star\\star\\star$"},{"location":"java/0001-0100/0021-0030/#26-remove-duplicates-from-sorted-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public int removeDuplicates ( int [] nums ) { int j = 0 ; for ( int i = 1 ; i < nums . length ; i ++) if ( nums [ i ] != nums [ j ]) nums [++ j ] = nums [ i ]; return j + 1 ; } }","title":"26. Remove Duplicates from Sorted Array $\\star$"},{"location":"java/0001-0100/0021-0030/#27-remove-element-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public int removeElement ( int [] nums , int val ) { int i = 0 ; for ( int num : nums ) if ( num != val ) nums [ i ++] = num ; return i ; } }","title":"27. Remove Element $\\star$"},{"location":"java/0001-0100/0021-0030/#28-implement-strstr-star","text":"","title":"28. Implement strStr() $\\star$"},{"location":"java/0001-0100/0021-0030/#29-divide-two-integers-starstar","text":"","title":"29. Divide Two Integers $\\star\\star$"},{"location":"java/0001-0100/0021-0030/#30-substring-with-concatenation-of-all-words-starstarstar","text":"","title":"30. Substring with Concatenation of All Words $\\star\\star\\star$"},{"location":"java/0001-0100/0031-0040/","text":"31. Next Permutation $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public void nextPermutation ( int [] nums ) { int i ; for ( i = nums . length - 2 ; i >= 0 ; i --) if ( nums [ i ] < nums [ i + 1 ]) break ; if ( i >= 0 ) { int j ; for ( j = nums . length - 1 ; j >= 0 ; j --) if ( nums [ j ] > nums [ i ]) break ; swap ( nums , i , j ); } reverse ( nums , i + 1 , nums . length - 1 ); } private void reverse ( int [] nums , int l , int r ) { while ( l < r ) swap ( nums , l ++, r --); } private void swap ( int [] nums , int i , int j ) { int temp = nums [ i ]; nums [ i ] = nums [ j ]; nums [ j ] = temp ; } } 32. Longest Valid Parentheses $\\star\\star\\star$ 33. Search in Rotated Sorted Array $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int search ( int [] nums , int target ) { int l = 0 ; int r = nums . length - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ l ] <= nums [ m ]) { if ( nums [ l ] <= target && target < nums [ m ]) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ]) l = m + 1 ; else r = m - 1 ; } } return - 1 ; } } 34. Find First and Last Position of Element in Sorted Array $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int [] searchRange ( int [] nums , int target ) { int leftIndex = find ( nums , target , true ); if ( leftIndex == nums . length || nums [ leftIndex ] != target ) return new int [] { - 1 , - 1 }; return new int [] { leftIndex , find ( nums , target , false ) - 1 }; } private int find ( int [] nums , int target , boolean isLeft ) { int l = 0 ; int r = nums . length ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] > target || ( isLeft && nums [ m ] == target )) r = m ; else l = m + 1 ; } return l ; } } 35. Search Insert Position $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int searchInsert ( int [] nums , int target ) { int l = 0 ; int r = nums . length ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ m ] < target ) l = m + 1 ; else r = m ; } return l ; } } 36. Valid Sudoku $\\star\\star$ 37. Sudoku Solver $\\star\\star\\star$ 38. Count and Say $\\star$ 39. Combination Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public List < List < Integer >> combinationSum ( int [] candidates , int target ) { List < List < Integer >> ans = new ArrayList <>(); List < Integer > path = new ArrayList <>(); Arrays . sort ( candidates ); dfs ( candidates , target , 0 , path , ans ); return ans ; } private void dfs ( int [] candidates , int target , int s , List < Integer > path , List < List < Integer >> ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . add ( new ArrayList <>( path )); return ; } for ( int i = s ; i < candidates . length ; i ++) { path . add ( candidates [ i ]); dfs ( candidates , target - candidates [ i ], i , path , ans ); path . remove ( path . size () - 1 ); } } } 40. Combination Sum II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public List < List < Integer >> combinationSum2 ( int [] candidates , int target ) { List < List < Integer >> ans = new ArrayList <>(); List < Integer > path = new ArrayList <>(); Arrays . sort ( candidates ); dfs ( candidates , target , 0 , path , ans ); return ans ; } private void dfs ( int [] candidates , int target , int s , List < Integer > path , List < List < Integer >> ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . add ( new ArrayList <>( path )); return ; } for ( int i = s ; i < candidates . length ; i ++) { if ( i > s && candidates [ i ] == candidates [ i - 1 ]) continue ; path . add ( candidates [ i ]); dfs ( candidates , target - candidates [ i ], i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } }","title":"0031-0040"},{"location":"java/0001-0100/0031-0040/#31-next-permutation-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public void nextPermutation ( int [] nums ) { int i ; for ( i = nums . length - 2 ; i >= 0 ; i --) if ( nums [ i ] < nums [ i + 1 ]) break ; if ( i >= 0 ) { int j ; for ( j = nums . length - 1 ; j >= 0 ; j --) if ( nums [ j ] > nums [ i ]) break ; swap ( nums , i , j ); } reverse ( nums , i + 1 , nums . length - 1 ); } private void reverse ( int [] nums , int l , int r ) { while ( l < r ) swap ( nums , l ++, r --); } private void swap ( int [] nums , int i , int j ) { int temp = nums [ i ]; nums [ i ] = nums [ j ]; nums [ j ] = temp ; } }","title":"31. Next Permutation $\\star\\star$"},{"location":"java/0001-0100/0031-0040/#32-longest-valid-parentheses-starstarstar","text":"","title":"32. Longest Valid Parentheses $\\star\\star\\star$"},{"location":"java/0001-0100/0031-0040/#33-search-in-rotated-sorted-array-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int search ( int [] nums , int target ) { int l = 0 ; int r = nums . length - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ l ] <= nums [ m ]) { if ( nums [ l ] <= target && target < nums [ m ]) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ]) l = m + 1 ; else r = m - 1 ; } } return - 1 ; } }","title":"33. Search in Rotated Sorted Array $\\star\\star$"},{"location":"java/0001-0100/0031-0040/#34-find-first-and-last-position-of-element-in-sorted-array-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int [] searchRange ( int [] nums , int target ) { int leftIndex = find ( nums , target , true ); if ( leftIndex == nums . length || nums [ leftIndex ] != target ) return new int [] { - 1 , - 1 }; return new int [] { leftIndex , find ( nums , target , false ) - 1 }; } private int find ( int [] nums , int target , boolean isLeft ) { int l = 0 ; int r = nums . length ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] > target || ( isLeft && nums [ m ] == target )) r = m ; else l = m + 1 ; } return l ; } }","title":"34. Find First and Last Position of Element in Sorted Array $\\star\\star$"},{"location":"java/0001-0100/0031-0040/#35-search-insert-position-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int searchInsert ( int [] nums , int target ) { int l = 0 ; int r = nums . length ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return m ; if ( nums [ m ] < target ) l = m + 1 ; else r = m ; } return l ; } }","title":"35. Search Insert Position $\\star$"},{"location":"java/0001-0100/0031-0040/#36-valid-sudoku-starstar","text":"","title":"36. Valid Sudoku $\\star\\star$"},{"location":"java/0001-0100/0031-0040/#37-sudoku-solver-starstarstar","text":"","title":"37. Sudoku Solver $\\star\\star\\star$"},{"location":"java/0001-0100/0031-0040/#38-count-and-say-star","text":"","title":"38. Count and Say $\\star$"},{"location":"java/0001-0100/0031-0040/#39-combination-sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public List < List < Integer >> combinationSum ( int [] candidates , int target ) { List < List < Integer >> ans = new ArrayList <>(); List < Integer > path = new ArrayList <>(); Arrays . sort ( candidates ); dfs ( candidates , target , 0 , path , ans ); return ans ; } private void dfs ( int [] candidates , int target , int s , List < Integer > path , List < List < Integer >> ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . add ( new ArrayList <>( path )); return ; } for ( int i = s ; i < candidates . length ; i ++) { path . add ( candidates [ i ]); dfs ( candidates , target - candidates [ i ], i , path , ans ); path . remove ( path . size () - 1 ); } } }","title":"39. Combination Sum $\\star\\star$"},{"location":"java/0001-0100/0031-0040/#40-combination-sum-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public List < List < Integer >> combinationSum2 ( int [] candidates , int target ) { List < List < Integer >> ans = new ArrayList <>(); List < Integer > path = new ArrayList <>(); Arrays . sort ( candidates ); dfs ( candidates , target , 0 , path , ans ); return ans ; } private void dfs ( int [] candidates , int target , int s , List < Integer > path , List < List < Integer >> ans ) { if ( target < 0 ) return ; if ( target == 0 ) { ans . add ( new ArrayList <>( path )); return ; } for ( int i = s ; i < candidates . length ; i ++) { if ( i > s && candidates [ i ] == candidates [ i - 1 ]) continue ; path . add ( candidates [ i ]); dfs ( candidates , target - candidates [ i ], i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } }","title":"40. Combination Sum II $\\star\\star$"},{"location":"java/0001-0100/0041-0050/","text":"41. First Missing Positive $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int firstMissingPositive ( int [] nums ) { if ( nums . length == 0 ) return 1 ; final int n = nums . length ; for ( int i = 0 ; i < n ; i ++) while ( nums [ i ] > 0 && nums [ i ] <= n && nums [ i ] != nums [ nums [ i ] - 1 ]) swap ( nums , i , nums [ i ] - 1 ); for ( int i = 0 ; i < n ; i ++) if ( nums [ i ] != i + 1 ) return i + 1 ; return n + 1 ; } private void swap ( int [] nums , int i , int j ) { int temp = nums [ i ]; nums [ i ] = nums [ j ]; nums [ j ] = temp ; } } 42. Trapping Rain Water $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int trap ( int [] height ) { int ans = 0 ; int l = 0 ; int r = height . length - 1 ; int maxLeft = 0 ; int maxRight = 0 ; while ( l < r ) { if ( height [ l ] < height [ r ]) { maxLeft = Math . max ( maxLeft , height [ l ]); ans += maxLeft - height [ l ]; l ++; } else { maxRight = Math . max ( maxRight , height [ r ]); ans += maxRight - height [ r ]; r --; } } return ans ; } } 43. Multiply Strings $\\star\\star$ 44. Wildcard Matching $\\star\\star\\star$ 45. Jump Game II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int jump ( int [] nums ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i + 1 < nums . length ; i ++) { farthest = Math . max ( farthest , i + nums [ i ]); if ( i == end ) { ans ++; end = farthest ; } } return ans ; } } 46. Permutations $\\star\\star$ 47. Permutations II $\\star\\star$ 48. Rotate Image $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public void rotate ( int [][] matrix ) { for ( int min = 0 ; min < matrix . length / 2 ; min ++) { int max = matrix . length - min - 1 ; for ( int i = min ; i < max ; i ++) { int offset = i - min ; int top = matrix [ min ][ i ]; matrix [ min ][ i ] = matrix [ max - offset ][ min ]; matrix [ max - offset ][ min ] = matrix [ max ][ max - offset ]; matrix [ max ][ max - offset ] = matrix [ i ][ max ]; matrix [ i ][ max ] = top ; } } } } 49. Group Anagrams $\\star\\star$ 50. Pow(x, n) $\\star\\star$","title":"0041-0050"},{"location":"java/0001-0100/0041-0050/#41-first-missing-positive-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int firstMissingPositive ( int [] nums ) { if ( nums . length == 0 ) return 1 ; final int n = nums . length ; for ( int i = 0 ; i < n ; i ++) while ( nums [ i ] > 0 && nums [ i ] <= n && nums [ i ] != nums [ nums [ i ] - 1 ]) swap ( nums , i , nums [ i ] - 1 ); for ( int i = 0 ; i < n ; i ++) if ( nums [ i ] != i + 1 ) return i + 1 ; return n + 1 ; } private void swap ( int [] nums , int i , int j ) { int temp = nums [ i ]; nums [ i ] = nums [ j ]; nums [ j ] = temp ; } }","title":"41. First Missing Positive $\\star\\star\\star$"},{"location":"java/0001-0100/0041-0050/#42-trapping-rain-water-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int trap ( int [] height ) { int ans = 0 ; int l = 0 ; int r = height . length - 1 ; int maxLeft = 0 ; int maxRight = 0 ; while ( l < r ) { if ( height [ l ] < height [ r ]) { maxLeft = Math . max ( maxLeft , height [ l ]); ans += maxLeft - height [ l ]; l ++; } else { maxRight = Math . max ( maxRight , height [ r ]); ans += maxRight - height [ r ]; r --; } } return ans ; } }","title":"42. Trapping Rain Water $\\star\\star\\star$"},{"location":"java/0001-0100/0041-0050/#43-multiply-strings-starstar","text":"","title":"43. Multiply Strings $\\star\\star$"},{"location":"java/0001-0100/0041-0050/#44-wildcard-matching-starstarstar","text":"","title":"44. Wildcard Matching $\\star\\star\\star$"},{"location":"java/0001-0100/0041-0050/#45-jump-game-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int jump ( int [] nums ) { int ans = 0 ; int end = 0 ; int farthest = 0 ; for ( int i = 0 ; i + 1 < nums . length ; i ++) { farthest = Math . max ( farthest , i + nums [ i ]); if ( i == end ) { ans ++; end = farthest ; } } return ans ; } }","title":"45. Jump Game II $\\star\\star\\star$"},{"location":"java/0001-0100/0041-0050/#46-permutations-starstar","text":"","title":"46. Permutations $\\star\\star$"},{"location":"java/0001-0100/0041-0050/#47-permutations-ii-starstar","text":"","title":"47. Permutations II $\\star\\star$"},{"location":"java/0001-0100/0041-0050/#48-rotate-image-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public void rotate ( int [][] matrix ) { for ( int min = 0 ; min < matrix . length / 2 ; min ++) { int max = matrix . length - min - 1 ; for ( int i = min ; i < max ; i ++) { int offset = i - min ; int top = matrix [ min ][ i ]; matrix [ min ][ i ] = matrix [ max - offset ][ min ]; matrix [ max - offset ][ min ] = matrix [ max ][ max - offset ]; matrix [ max ][ max - offset ] = matrix [ i ][ max ]; matrix [ i ][ max ] = top ; } } } }","title":"48. Rotate Image $\\star\\star$"},{"location":"java/0001-0100/0041-0050/#49-group-anagrams-starstar","text":"","title":"49. Group Anagrams $\\star\\star$"},{"location":"java/0001-0100/0041-0050/#50-powx-n-starstar","text":"","title":"50. Pow(x, n) $\\star\\star$"},{"location":"java/0001-0100/0051-0060/","text":"51. N-Queens $\\star\\star\\star$ 52. N-Queens II $\\star\\star\\star$ 53. Maximum Subarray $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int maxSubArray ( int [] nums ) { int ans = Integer . MIN_VALUE ; int sum = 0 ; for ( int num : nums ) { sum += num ; ans = Math . max ( ans , sum ); sum = Math . max ( sum , 0 ); } return ans ; } } 54. Spiral Matrix $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public List < Integer > spiralOrder ( int [][] matrix ) { if ( matrix . length == 0 ) return new ArrayList <>(); List < Integer > ans = new ArrayList <>(); int r1 = 0 ; int c1 = 0 ; int r2 = matrix . length - 1 ; int c2 = matrix [ 0 ]. length - 1 ; while ( r1 <= r2 && c1 <= c2 ) { for ( int c = c1 ; c <= c2 ; c ++) ans . add ( matrix [ r1 ][ c ]); for ( int r = r1 + 1 ; r <= r2 ; r ++) ans . add ( matrix [ r ][ c2 ]); if ( r1 < r2 && c1 < c2 ) { for ( int c = c2 - 1 ; c > c1 ; c --) ans . add ( matrix [ r2 ][ c ]); for ( int r = r2 ; r > r1 ; r --) ans . add ( matrix [ r ][ c1 ]); } r1 ++; c1 ++; r2 --; c2 --; } return ans ; } } 55. Jump Game $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public boolean canJump ( int [] nums ) { int goal = nums . length - 1 ; for ( int i = goal ; i >= 0 ; i --) if ( i + nums [ i ] >= goal ) goal = i ; return goal == 0 ; } } 56. Merge Intervals $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int [][] merge ( int [][] intervals ) { List < int []> ans = new ArrayList <>(); Arrays . sort ( intervals , ( a , b ) -> ( a [ 0 ] - b [ 0 ])); for ( int [] interval : intervals ) { if ( ans . isEmpty () || ans . get ( ans . size () - 1 )[ 1 ] < interval [ 0 ]) ans . add ( interval ); else ans . get ( ans . size () - 1 )[ 1 ] = Math . max ( ans . get ( ans . size () - 1 )[ 1 ], interval [ 1 ]); } return ans . toArray ( new int [ ans . size ()][]); } } 57. Insert Interval $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int [][] insert ( int [][] intervals , int [] newInterval ) { List < int []> ans = new ArrayList <>(); List < int []> intervalsList = new ArrayList <>( Arrays . asList ( intervals )); int i = 0 ; for (; i < intervals . length ; i ++) if ( intervals [ i ][ 0 ] >= newInterval [ 0 ]) break ; intervalsList . add ( i , newInterval ); for ( int [] interval : intervalsList ) { if ( ans . isEmpty () || ans . get ( ans . size () - 1 )[ 1 ] < interval [ 0 ]) ans . add ( interval ); else ans . get ( ans . size () - 1 )[ 1 ] = Math . max ( ans . get ( ans . size () - 1 )[ 1 ], interval [ 1 ]); } return ans . toArray ( new int [ ans . size ()][]); } } 58. Length of Last Word $\\star$ 59. Spiral Matrix II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int [][] generateMatrix ( int n ) { int [][] ans = new int [ n ][ n ]; int count = 1 ; for ( int min = 0 ; min < n / 2 ; min ++) { int max = n - min - 1 ; for ( int i = min ; i < max ; i ++) ans [ min ][ i ] = count ++; for ( int i = min ; i < max ; i ++) ans [ i ][ max ] = count ++; for ( int i = max ; i > min ; i --) ans [ max ][ i ] = count ++; for ( int i = max ; i > min ; i --) ans [ i ][ min ] = count ++; } if ( n % 2 == 1 ) ans [ n / 2 ][ n / 2 ] = count ; return ans ; } } 60. Permutation Sequence $\\star\\star$","title":"0051-0060"},{"location":"java/0001-0100/0051-0060/#51-n-queens-starstarstar","text":"","title":"51. N-Queens $\\star\\star\\star$"},{"location":"java/0001-0100/0051-0060/#52-n-queens-ii-starstarstar","text":"","title":"52. N-Queens II $\\star\\star\\star$"},{"location":"java/0001-0100/0051-0060/#53-maximum-subarray-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int maxSubArray ( int [] nums ) { int ans = Integer . MIN_VALUE ; int sum = 0 ; for ( int num : nums ) { sum += num ; ans = Math . max ( ans , sum ); sum = Math . max ( sum , 0 ); } return ans ; } }","title":"53. Maximum Subarray $\\star$"},{"location":"java/0001-0100/0051-0060/#54-spiral-matrix-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public List < Integer > spiralOrder ( int [][] matrix ) { if ( matrix . length == 0 ) return new ArrayList <>(); List < Integer > ans = new ArrayList <>(); int r1 = 0 ; int c1 = 0 ; int r2 = matrix . length - 1 ; int c2 = matrix [ 0 ]. length - 1 ; while ( r1 <= r2 && c1 <= c2 ) { for ( int c = c1 ; c <= c2 ; c ++) ans . add ( matrix [ r1 ][ c ]); for ( int r = r1 + 1 ; r <= r2 ; r ++) ans . add ( matrix [ r ][ c2 ]); if ( r1 < r2 && c1 < c2 ) { for ( int c = c2 - 1 ; c > c1 ; c --) ans . add ( matrix [ r2 ][ c ]); for ( int r = r2 ; r > r1 ; r --) ans . add ( matrix [ r ][ c1 ]); } r1 ++; c1 ++; r2 --; c2 --; } return ans ; } }","title":"54. Spiral Matrix $\\star\\star$"},{"location":"java/0001-0100/0051-0060/#55-jump-game-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public boolean canJump ( int [] nums ) { int goal = nums . length - 1 ; for ( int i = goal ; i >= 0 ; i --) if ( i + nums [ i ] >= goal ) goal = i ; return goal == 0 ; } }","title":"55. Jump Game $\\star\\star$"},{"location":"java/0001-0100/0051-0060/#56-merge-intervals-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int [][] merge ( int [][] intervals ) { List < int []> ans = new ArrayList <>(); Arrays . sort ( intervals , ( a , b ) -> ( a [ 0 ] - b [ 0 ])); for ( int [] interval : intervals ) { if ( ans . isEmpty () || ans . get ( ans . size () - 1 )[ 1 ] < interval [ 0 ]) ans . add ( interval ); else ans . get ( ans . size () - 1 )[ 1 ] = Math . max ( ans . get ( ans . size () - 1 )[ 1 ], interval [ 1 ]); } return ans . toArray ( new int [ ans . size ()][]); } }","title":"56. Merge Intervals $\\star\\star$"},{"location":"java/0001-0100/0051-0060/#57-insert-interval-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int [][] insert ( int [][] intervals , int [] newInterval ) { List < int []> ans = new ArrayList <>(); List < int []> intervalsList = new ArrayList <>( Arrays . asList ( intervals )); int i = 0 ; for (; i < intervals . length ; i ++) if ( intervals [ i ][ 0 ] >= newInterval [ 0 ]) break ; intervalsList . add ( i , newInterval ); for ( int [] interval : intervalsList ) { if ( ans . isEmpty () || ans . get ( ans . size () - 1 )[ 1 ] < interval [ 0 ]) ans . add ( interval ); else ans . get ( ans . size () - 1 )[ 1 ] = Math . max ( ans . get ( ans . size () - 1 )[ 1 ], interval [ 1 ]); } return ans . toArray ( new int [ ans . size ()][]); } }","title":"57. Insert Interval $\\star\\star\\star$"},{"location":"java/0001-0100/0051-0060/#58-length-of-last-word-star","text":"","title":"58. Length of Last Word $\\star$"},{"location":"java/0001-0100/0051-0060/#59-spiral-matrix-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int [][] generateMatrix ( int n ) { int [][] ans = new int [ n ][ n ]; int count = 1 ; for ( int min = 0 ; min < n / 2 ; min ++) { int max = n - min - 1 ; for ( int i = min ; i < max ; i ++) ans [ min ][ i ] = count ++; for ( int i = min ; i < max ; i ++) ans [ i ][ max ] = count ++; for ( int i = max ; i > min ; i --) ans [ max ][ i ] = count ++; for ( int i = max ; i > min ; i --) ans [ i ][ min ] = count ++; } if ( n % 2 == 1 ) ans [ n / 2 ][ n / 2 ] = count ; return ans ; } }","title":"59. Spiral Matrix II $\\star\\star$"},{"location":"java/0001-0100/0051-0060/#60-permutation-sequence-starstar","text":"","title":"60. Permutation Sequence $\\star\\star$"},{"location":"java/0001-0100/0061-0070/","text":"61. Rotate List $\\star\\star$ 62. Unique Paths $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int uniquePaths ( int m , int n ) { int [] dp = new int [ n ]; Arrays . fill ( dp , 1 ); for ( int i = 1 ; i < m ; i ++) for ( int j = 1 ; j < n ; j ++) dp [ j ] += dp [ j - 1 ]; return dp [ n - 1 ]; } } 63. Unique Paths II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int uniquePathsWithObstacles ( int [][] obstacleGrid ) { final int m = obstacleGrid . length ; final int n = obstacleGrid [ 0 ]. length ; int [] dp = new int [ n ]; dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++) for ( int j = 0 ; j < n ; j ++) { if ( obstacleGrid [ i ][ j ] == 1 ) dp [ j ] = 0 ; else if ( j > 0 ) dp [ j ] += dp [ j - 1 ]; } return dp [ n - 1 ]; } } 64. Minimum Path Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int minPathSum ( int [][] grid ) { final int m = grid . length ; final int n = grid [ 0 ]. length ; for ( int i = 1 ; i < m ; i ++) grid [ i ][ 0 ] += grid [ i - 1 ][ 0 ]; for ( int j = 1 ; j < n ; j ++) grid [ 0 ][ j ] += grid [ 0 ][ j - 1 ]; for ( int i = 1 ; i < m ; i ++) for ( int j = 1 ; j < n ; j ++) grid [ i ][ j ] += Math . min ( grid [ i - 1 ][ j ], grid [ i ][ j - 1 ]); return grid [ m - 1 ][ n - 1 ]; } } 65. Valid Number $\\star\\star\\star$ 66. Plus One $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int [] plusOne ( int [] digits ) { final int n = digits . length ; for ( int i = n - 1 ; i >= 0 ; i --) { if ( digits [ i ] < 9 ) { digits [ i ]++; return digits ; } digits [ i ] = 0 ; } int [] ans = new int [ n + 1 ]; ans [ 0 ] = 1 ; return ans ; } } 67. Add Binary $\\star$ 68. Text Justification $\\star\\star\\star$ 69. Sqrt(x) $\\star$ 70. Climbing Stairs $\\star$","title":"0061-0070"},{"location":"java/0001-0100/0061-0070/#61-rotate-list-starstar","text":"","title":"61. Rotate List $\\star\\star$"},{"location":"java/0001-0100/0061-0070/#62-unique-paths-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public int uniquePaths ( int m , int n ) { int [] dp = new int [ n ]; Arrays . fill ( dp , 1 ); for ( int i = 1 ; i < m ; i ++) for ( int j = 1 ; j < n ; j ++) dp [ j ] += dp [ j - 1 ]; return dp [ n - 1 ]; } }","title":"62. Unique Paths $\\star\\star$"},{"location":"java/0001-0100/0061-0070/#63-unique-paths-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int uniquePathsWithObstacles ( int [][] obstacleGrid ) { final int m = obstacleGrid . length ; final int n = obstacleGrid [ 0 ]. length ; int [] dp = new int [ n ]; dp [ 0 ] = 1 ; for ( int i = 0 ; i < m ; i ++) for ( int j = 0 ; j < n ; j ++) { if ( obstacleGrid [ i ][ j ] == 1 ) dp [ j ] = 0 ; else if ( j > 0 ) dp [ j ] += dp [ j - 1 ]; } return dp [ n - 1 ]; } }","title":"63. Unique Paths II $\\star\\star$"},{"location":"java/0001-0100/0061-0070/#64-minimum-path-sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int minPathSum ( int [][] grid ) { final int m = grid . length ; final int n = grid [ 0 ]. length ; for ( int i = 1 ; i < m ; i ++) grid [ i ][ 0 ] += grid [ i - 1 ][ 0 ]; for ( int j = 1 ; j < n ; j ++) grid [ 0 ][ j ] += grid [ 0 ][ j - 1 ]; for ( int i = 1 ; i < m ; i ++) for ( int j = 1 ; j < n ; j ++) grid [ i ][ j ] += Math . min ( grid [ i - 1 ][ j ], grid [ i ][ j - 1 ]); return grid [ m - 1 ][ n - 1 ]; } }","title":"64. Minimum Path Sum $\\star\\star$"},{"location":"java/0001-0100/0061-0070/#65-valid-number-starstarstar","text":"","title":"65. Valid Number $\\star\\star\\star$"},{"location":"java/0001-0100/0061-0070/#66-plus-one-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int [] plusOne ( int [] digits ) { final int n = digits . length ; for ( int i = n - 1 ; i >= 0 ; i --) { if ( digits [ i ] < 9 ) { digits [ i ]++; return digits ; } digits [ i ] = 0 ; } int [] ans = new int [ n + 1 ]; ans [ 0 ] = 1 ; return ans ; } }","title":"66. Plus One $\\star$"},{"location":"java/0001-0100/0061-0070/#67-add-binary-star","text":"","title":"67. Add Binary $\\star$"},{"location":"java/0001-0100/0061-0070/#68-text-justification-starstarstar","text":"","title":"68. Text Justification $\\star\\star\\star$"},{"location":"java/0001-0100/0061-0070/#69-sqrtx-star","text":"","title":"69. Sqrt(x) $\\star$"},{"location":"java/0001-0100/0061-0070/#70-climbing-stairs-star","text":"","title":"70. Climbing Stairs $\\star$"},{"location":"java/0001-0100/0071-0080/","text":"71. Simplify Path $\\star\\star$ 72. Edit Distance $\\star\\star\\star$ 73. Set Matrix Zeroes $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public void setZeroes ( int [][] matrix ) { final int m = matrix . length ; final int n = matrix [ 0 ]. length ; boolean isFirstRow = false ; boolean isFirstCol = false ; for ( int j = 0 ; j < n ; j ++) if ( matrix [ 0 ][ j ] == 0 ) isFirstRow = true ; for ( int i = 0 ; i < m ; i ++) if ( matrix [ i ][ 0 ] == 0 ) isFirstCol = true ; for ( int i = 1 ; i < m ; i ++) for ( int j = 1 ; j < n ; j ++) if ( matrix [ i ][ j ] == 0 ) { matrix [ i ][ 0 ] = 0 ; matrix [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i < m ; i ++) for ( int j = 1 ; j < n ; j ++) if ( matrix [ i ][ 0 ] == 0 || matrix [ 0 ][ j ] == 0 ) matrix [ i ][ j ] = 0 ; if ( isFirstRow ) for ( int j = 0 ; j < n ; j ++) matrix [ 0 ][ j ] = 0 ; if ( isFirstCol ) for ( int i = 0 ; i < m ; i ++) matrix [ i ][ 0 ] = 0 ; } } 74. Search a 2D Matrix $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public boolean searchMatrix ( int [][] matrix , int target ) { if ( matrix . length == 0 ) return false ; final int m = matrix . length ; final int n = matrix [ 0 ]. length ; int l = 0 ; int r = m * n ; while ( l < r ) { int mid = l + ( r - l ) / 2 ; int i = mid / n ; int j = mid % n ; if ( matrix [ i ][ j ] == target ) return true ; if ( matrix [ i ][ j ] < target ) l = mid + 1 ; else r = mid ; } return false ; } } 75. Sort Colors $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public void sortColors ( int [] nums ) { int zero = - 1 ; int one = - 1 ; int two = - 1 ; for ( int num : nums ) { if ( num == 0 ) { nums [++ two ] = 2 ; nums [++ one ] = 1 ; nums [++ zero ] = 0 ; } else if ( num == 1 ) { nums [++ two ] = 2 ; nums [++ one ] = 1 ; } else { nums [++ two ] = 2 ; } } } } 76. Minimum Window Substring $\\star\\star\\star$ 77. Combinations $\\star\\star$ 78. Subsets $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List < List < Integer >> subsets ( int [] nums ) { List < List < Integer >> ans = new ArrayList <>(); List < Integer > path = new ArrayList <>(); dfs ( nums , 0 , path , ans ); return ans ; } private void dfs ( int [] nums , int s , List < Integer > path , List < List < Integer >> ans ) { ans . add ( new ArrayList <>( path )); if ( s == nums . length ) return ; for ( int i = s ; i < nums . length ; i ++) { path . add ( nums [ i ]); dfs ( nums , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } } 79. Word Search $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public boolean exist ( char [][] board , String word ) { if ( board . length == 0 ) return false ; for ( int i = 0 ; i < board . length ; i ++) for ( int j = 0 ; j < board [ 0 ]. length ; j ++) if ( dfs ( board , word , i , j , 0 )) return true ; return false ; } private boolean dfs ( char [][] board , String word , int i , int j , int pos ) { if ( i < 0 || i >= board . length || j < 0 || j >= board [ 0 ]. length || board [ i ][ j ] != word . charAt ( pos ) || board [ i ][ j ] == '*' ) return false ; if ( pos == word . length () - 1 ) return true ; char c = board [ i ][ j ]; board [ i ][ j ] = '*' ; boolean flag = dfs ( board , word , i + 1 , j , pos + 1 ) || dfs ( board , word , i - 1 , j , pos + 1 ) || dfs ( board , word , i , j + 1 , pos + 1 ) || dfs ( board , word , i , j - 1 , pos + 1 ); board [ i ][ j ] = c ; return flag ; } } 80. Remove Duplicates from Sorted Array II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public int removeDuplicates ( int [] nums ) { int i = 0 ; for ( int num : nums ) if ( i < 2 || num != nums [ i - 2 ]) nums [ i ++] = num ; return i ; } }","title":"0071-0080"},{"location":"java/0001-0100/0071-0080/#71-simplify-path-starstar","text":"","title":"71. Simplify Path $\\star\\star$"},{"location":"java/0001-0100/0071-0080/#72-edit-distance-starstarstar","text":"","title":"72. Edit Distance $\\star\\star\\star$"},{"location":"java/0001-0100/0071-0080/#73-set-matrix-zeroes-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution { public void setZeroes ( int [][] matrix ) { final int m = matrix . length ; final int n = matrix [ 0 ]. length ; boolean isFirstRow = false ; boolean isFirstCol = false ; for ( int j = 0 ; j < n ; j ++) if ( matrix [ 0 ][ j ] == 0 ) isFirstRow = true ; for ( int i = 0 ; i < m ; i ++) if ( matrix [ i ][ 0 ] == 0 ) isFirstCol = true ; for ( int i = 1 ; i < m ; i ++) for ( int j = 1 ; j < n ; j ++) if ( matrix [ i ][ j ] == 0 ) { matrix [ i ][ 0 ] = 0 ; matrix [ 0 ][ j ] = 0 ; } for ( int i = 1 ; i < m ; i ++) for ( int j = 1 ; j < n ; j ++) if ( matrix [ i ][ 0 ] == 0 || matrix [ 0 ][ j ] == 0 ) matrix [ i ][ j ] = 0 ; if ( isFirstRow ) for ( int j = 0 ; j < n ; j ++) matrix [ 0 ][ j ] = 0 ; if ( isFirstCol ) for ( int i = 0 ; i < m ; i ++) matrix [ i ][ 0 ] = 0 ; } }","title":"73. Set Matrix Zeroes $\\star\\star$"},{"location":"java/0001-0100/0071-0080/#74-search-a-2d-matrix-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution { public boolean searchMatrix ( int [][] matrix , int target ) { if ( matrix . length == 0 ) return false ; final int m = matrix . length ; final int n = matrix [ 0 ]. length ; int l = 0 ; int r = m * n ; while ( l < r ) { int mid = l + ( r - l ) / 2 ; int i = mid / n ; int j = mid % n ; if ( matrix [ i ][ j ] == target ) return true ; if ( matrix [ i ][ j ] < target ) l = mid + 1 ; else r = mid ; } return false ; } }","title":"74. Search a 2D Matrix $\\star\\star$"},{"location":"java/0001-0100/0071-0080/#75-sort-colors-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public void sortColors ( int [] nums ) { int zero = - 1 ; int one = - 1 ; int two = - 1 ; for ( int num : nums ) { if ( num == 0 ) { nums [++ two ] = 2 ; nums [++ one ] = 1 ; nums [++ zero ] = 0 ; } else if ( num == 1 ) { nums [++ two ] = 2 ; nums [++ one ] = 1 ; } else { nums [++ two ] = 2 ; } } } }","title":"75. Sort Colors $\\star\\star$"},{"location":"java/0001-0100/0071-0080/#76-minimum-window-substring-starstarstar","text":"","title":"76. Minimum Window Substring $\\star\\star\\star$"},{"location":"java/0001-0100/0071-0080/#77-combinations-starstar","text":"","title":"77. Combinations $\\star\\star$"},{"location":"java/0001-0100/0071-0080/#78-subsets-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public List < List < Integer >> subsets ( int [] nums ) { List < List < Integer >> ans = new ArrayList <>(); List < Integer > path = new ArrayList <>(); dfs ( nums , 0 , path , ans ); return ans ; } private void dfs ( int [] nums , int s , List < Integer > path , List < List < Integer >> ans ) { ans . add ( new ArrayList <>( path )); if ( s == nums . length ) return ; for ( int i = s ; i < nums . length ; i ++) { path . add ( nums [ i ]); dfs ( nums , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } }","title":"78. Subsets $\\star\\star$"},{"location":"java/0001-0100/0071-0080/#79-word-search-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public boolean exist ( char [][] board , String word ) { if ( board . length == 0 ) return false ; for ( int i = 0 ; i < board . length ; i ++) for ( int j = 0 ; j < board [ 0 ]. length ; j ++) if ( dfs ( board , word , i , j , 0 )) return true ; return false ; } private boolean dfs ( char [][] board , String word , int i , int j , int pos ) { if ( i < 0 || i >= board . length || j < 0 || j >= board [ 0 ]. length || board [ i ][ j ] != word . charAt ( pos ) || board [ i ][ j ] == '*' ) return false ; if ( pos == word . length () - 1 ) return true ; char c = board [ i ][ j ]; board [ i ][ j ] = '*' ; boolean flag = dfs ( board , word , i + 1 , j , pos + 1 ) || dfs ( board , word , i - 1 , j , pos + 1 ) || dfs ( board , word , i , j + 1 , pos + 1 ) || dfs ( board , word , i , j - 1 , pos + 1 ); board [ i ][ j ] = c ; return flag ; } }","title":"79. Word Search $\\star\\star$"},{"location":"java/0001-0100/0071-0080/#80-remove-duplicates-from-sorted-array-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public int removeDuplicates ( int [] nums ) { int i = 0 ; for ( int num : nums ) if ( i < 2 || num != nums [ i - 2 ]) nums [ i ++] = num ; return i ; } }","title":"80. Remove Duplicates from Sorted Array II $\\star\\star$"},{"location":"java/0001-0100/0081-0090/","text":"81. Search in Rotated Sorted Array II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public boolean search ( int [] nums , int target ) { int l = 0 ; int r = nums . length - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return true ; if ( nums [ l ] == nums [ m ] && nums [ m ] == nums [ r ]) { l ++; r --; } else if ( nums [ l ] <= nums [ m ]) { if ( nums [ l ] <= target && target < nums [ m ]) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ]) l = m + 1 ; else r = m - 1 ; } } return false ; } } 82. Remove Duplicates from Sorted List II $\\star\\star$ 83. Remove Duplicates from Sorted List $\\star$ 84. Largest Rectangle in Histogram $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int largestRectangleArea ( int [] heights ) { int ans = 0 ; Stack < Integer > stack = new Stack <>(); for ( int i = 0 ; i <= heights . length ; i ++) { while (! stack . isEmpty () && ( i == heights . length || heights [ i ] < heights [ stack . peek ()])) { int h = heights [ stack . pop ()]; int w = stack . isEmpty () ? i : i - stack . peek () - 1 ; ans = Math . max ( ans , h * w ); } stack . push ( i ); } return ans ; } } 85. Maximal Rectangle $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public int maximalRectangle ( char [][] matrix ) { if ( matrix . length == 0 ) return 0 ; int ans = 0 ; int [] temp = new int [ matrix [ 0 ]. length ]; for ( int i = 0 ; i < matrix . length ; i ++) { for ( int j = 0 ; j < matrix [ 0 ]. length ; j ++) temp [ j ] = matrix [ i ][ j ] == '0' ? 0 : temp [ j ] + 1 ; ans = Math . max ( ans , largestRectangleArea ( temp )); } return ans ; } private int largestRectangleArea ( int [] heights ) { int ans = 0 ; Stack < Integer > stack = new Stack <>(); for ( int i = 0 ; i <= heights . length ; i ++) { while (! stack . isEmpty () && ( i == heights . length || heights [ i ] < heights [ stack . peek ()])) { int h = heights [ stack . pop ()]; int w = stack . isEmpty () ? i : i - stack . peek () - 1 ; ans = Math . max ( ans , h * w ); } stack . push ( i ); } return ans ; } } 86. Partition List $\\star\\star$ 87. Scramble String $\\star\\star\\star$ 88. Merge Sorted Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public void merge ( int [] nums1 , int m , int [] nums2 , int n ) { int k = m + n ; while ( n > 0 ) { if ( m > 0 && nums1 [ m - 1 ] > nums2 [ n - 1 ]) nums1 [-- k ] = nums1 [-- m ]; else nums1 [-- k ] = nums2 [-- n ]; } } } 89. Gray Code $\\star\\star$ 90. Subsets II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public List < List < Integer >> subsetsWithDup ( int [] nums ) { List < List < Integer >> ans = new ArrayList <>(); List < Integer > path = new ArrayList <>(); Arrays . sort ( nums ); dfs ( nums , 0 , path , ans ); return ans ; } private void dfs ( int [] nums , int s , List < Integer > path , List < List < Integer >> ans ) { ans . add ( new ArrayList <>( path )); if ( s == nums . length ) return ; for ( int i = s ; i < nums . length ; i ++) { if ( i > s && nums [ i ] == nums [ i - 1 ]) continue ; path . add ( nums [ i ]); dfs ( nums , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } }","title":"0081-0090"},{"location":"java/0001-0100/0081-0090/#81-search-in-rotated-sorted-array-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution { public boolean search ( int [] nums , int target ) { int l = 0 ; int r = nums . length - 1 ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == target ) return true ; if ( nums [ l ] == nums [ m ] && nums [ m ] == nums [ r ]) { l ++; r --; } else if ( nums [ l ] <= nums [ m ]) { if ( nums [ l ] <= target && target < nums [ m ]) r = m - 1 ; else l = m + 1 ; } else { if ( nums [ m ] < target && target <= nums [ r ]) l = m + 1 ; else r = m - 1 ; } } return false ; } }","title":"81. Search in Rotated Sorted Array II $\\star\\star$"},{"location":"java/0001-0100/0081-0090/#82-remove-duplicates-from-sorted-list-ii-starstar","text":"","title":"82. Remove Duplicates from Sorted List II $\\star\\star$"},{"location":"java/0001-0100/0081-0090/#83-remove-duplicates-from-sorted-list-star","text":"","title":"83. Remove Duplicates from Sorted List $\\star$"},{"location":"java/0001-0100/0081-0090/#84-largest-rectangle-in-histogram-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int largestRectangleArea ( int [] heights ) { int ans = 0 ; Stack < Integer > stack = new Stack <>(); for ( int i = 0 ; i <= heights . length ; i ++) { while (! stack . isEmpty () && ( i == heights . length || heights [ i ] < heights [ stack . peek ()])) { int h = heights [ stack . pop ()]; int w = stack . isEmpty () ? i : i - stack . peek () - 1 ; ans = Math . max ( ans , h * w ); } stack . push ( i ); } return ans ; } }","title":"84. Largest Rectangle in Histogram $\\star\\star\\star$"},{"location":"java/0001-0100/0081-0090/#85-maximal-rectangle-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public int maximalRectangle ( char [][] matrix ) { if ( matrix . length == 0 ) return 0 ; int ans = 0 ; int [] temp = new int [ matrix [ 0 ]. length ]; for ( int i = 0 ; i < matrix . length ; i ++) { for ( int j = 0 ; j < matrix [ 0 ]. length ; j ++) temp [ j ] = matrix [ i ][ j ] == '0' ? 0 : temp [ j ] + 1 ; ans = Math . max ( ans , largestRectangleArea ( temp )); } return ans ; } private int largestRectangleArea ( int [] heights ) { int ans = 0 ; Stack < Integer > stack = new Stack <>(); for ( int i = 0 ; i <= heights . length ; i ++) { while (! stack . isEmpty () && ( i == heights . length || heights [ i ] < heights [ stack . peek ()])) { int h = heights [ stack . pop ()]; int w = stack . isEmpty () ? i : i - stack . peek () - 1 ; ans = Math . max ( ans , h * w ); } stack . push ( i ); } return ans ; } }","title":"85. Maximal Rectangle $\\star\\star\\star$"},{"location":"java/0001-0100/0081-0090/#86-partition-list-starstar","text":"","title":"86. Partition List $\\star\\star$"},{"location":"java/0001-0100/0081-0090/#87-scramble-string-starstarstar","text":"","title":"87. Scramble String $\\star\\star\\star$"},{"location":"java/0001-0100/0081-0090/#88-merge-sorted-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public void merge ( int [] nums1 , int m , int [] nums2 , int n ) { int k = m + n ; while ( n > 0 ) { if ( m > 0 && nums1 [ m - 1 ] > nums2 [ n - 1 ]) nums1 [-- k ] = nums1 [-- m ]; else nums1 [-- k ] = nums2 [-- n ]; } } }","title":"88. Merge Sorted Array $\\star$"},{"location":"java/0001-0100/0081-0090/#89-gray-code-starstar","text":"","title":"89. Gray Code $\\star\\star$"},{"location":"java/0001-0100/0081-0090/#90-subsets-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public List < List < Integer >> subsetsWithDup ( int [] nums ) { List < List < Integer >> ans = new ArrayList <>(); List < Integer > path = new ArrayList <>(); Arrays . sort ( nums ); dfs ( nums , 0 , path , ans ); return ans ; } private void dfs ( int [] nums , int s , List < Integer > path , List < List < Integer >> ans ) { ans . add ( new ArrayList <>( path )); if ( s == nums . length ) return ; for ( int i = s ; i < nums . length ; i ++) { if ( i > s && nums [ i ] == nums [ i - 1 ]) continue ; path . add ( nums [ i ]); dfs ( nums , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } }","title":"90. Subsets II $\\star\\star$"},{"location":"java/0001-0100/0091-0100/","text":"91. Decode Ways $\\star\\star$ 92. Reverse Linked List II $\\star\\star$ 93. Restore IP Addresses $\\star\\star$ 94. Binary Tree Inorder Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public List < Integer > inorderTraversal ( TreeNode root ) { List < Integer > ans = new ArrayList <>(); Stack < TreeNode > stack = new Stack <>(); TreeNode curr = root ; while ( curr != null || ! stack . empty ()) { while ( curr != null ) { stack . push ( curr ); curr = curr . left ; } curr = stack . pop (); ans . add ( curr . val ); curr = curr . right ; } return ans ; } } 95. Unique Binary Search Trees II $\\star\\star$ 96. Unique Binary Search Trees $\\star\\star$ 97. Interleaving String $\\star\\star\\star$ 98. Validate Binary Search Tree $\\star\\star$ 99. Recover Binary Search Tree $\\star\\star\\star$ 100. Same Tree $\\star$","title":"0091-0100"},{"location":"java/0001-0100/0091-0100/#91-decode-ways-starstar","text":"","title":"91. Decode Ways $\\star\\star$"},{"location":"java/0001-0100/0091-0100/#92-reverse-linked-list-ii-starstar","text":"","title":"92. Reverse Linked List II $\\star\\star$"},{"location":"java/0001-0100/0091-0100/#93-restore-ip-addresses-starstar","text":"","title":"93. Restore IP Addresses $\\star\\star$"},{"location":"java/0001-0100/0091-0100/#94-binary-tree-inorder-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public List < Integer > inorderTraversal ( TreeNode root ) { List < Integer > ans = new ArrayList <>(); Stack < TreeNode > stack = new Stack <>(); TreeNode curr = root ; while ( curr != null || ! stack . empty ()) { while ( curr != null ) { stack . push ( curr ); curr = curr . left ; } curr = stack . pop (); ans . add ( curr . val ); curr = curr . right ; } return ans ; } }","title":"94. Binary Tree Inorder Traversal $\\star\\star$"},{"location":"java/0001-0100/0091-0100/#95-unique-binary-search-trees-ii-starstar","text":"","title":"95. Unique Binary Search Trees II $\\star\\star$"},{"location":"java/0001-0100/0091-0100/#96-unique-binary-search-trees-starstar","text":"","title":"96. Unique Binary Search Trees $\\star\\star$"},{"location":"java/0001-0100/0091-0100/#97-interleaving-string-starstarstar","text":"","title":"97. Interleaving String $\\star\\star\\star$"},{"location":"java/0001-0100/0091-0100/#98-validate-binary-search-tree-starstar","text":"","title":"98. Validate Binary Search Tree $\\star\\star$"},{"location":"java/0001-0100/0091-0100/#99-recover-binary-search-tree-starstarstar","text":"","title":"99. Recover Binary Search Tree $\\star\\star\\star$"},{"location":"java/0001-0100/0091-0100/#100-same-tree-star","text":"","title":"100. Same Tree $\\star$"},{"location":"java/0101-0200/0101-0110/","text":"101. Symmetric Tree $\\star$ 102. Binary Tree Level Order Traversal $\\star\\star$ 103. Binary Tree Zigzag Level Order Traversal $\\star\\star$ 104. Maximum Depth of Binary Tree $\\star$ 105. Construct Binary Tree from Preorder and Inorder Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public TreeNode buildTree ( int [] preorder , int [] inorder ) { Map < Integer , Integer > map = new HashMap <>(); for ( int i = 0 ; i < inorder . length ; i ++) map . put ( inorder [ i ], i ); return helper ( preorder , 0 , preorder . length - 1 , inorder , 0 , inorder . length - 1 , map ); } private TreeNode helper ( int [] preorder , int pLeft , int pRight , int [] inorder , int iLeft , int iRight , Map < Integer , Integer > map ) { if ( pLeft > pRight || iLeft > iRight ) return null ; int i = map . get ( preorder [ pLeft ]); TreeNode curr = new TreeNode ( preorder [ pLeft ]); curr . left = helper ( preorder , pLeft + 1 , pLeft + i - iLeft , inorder , iLeft , i - 1 , map ); curr . right = helper ( preorder , pLeft + i - iLeft + 1 , pRight , inorder , i + 1 , iRight , map ); return curr ; } } 106. Construct Binary Tree from Inorder and Postorder Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public TreeNode buildTree ( int [] inorder , int [] postorder ) { Map < Integer , Integer > map = new HashMap <>(); for ( int i = 0 ; i < inorder . length ; i ++) map . put ( inorder [ i ], i ); return helper ( inorder , 0 , inorder . length - 1 , postorder , 0 , postorder . length - 1 , map ); } private TreeNode helper ( int [] inorder , int iLeft , int iRight , int [] postorder , int pLeft , int pRight , Map < Integer , Integer > map ) { if ( iLeft > iRight || pLeft > pRight ) return null ; int i = map . get ( postorder [ pRight ]); TreeNode curr = new TreeNode ( postorder [ pRight ]); curr . left = helper ( inorder , iLeft , i - 1 , postorder , pLeft , pLeft + i - iLeft - 1 , map ); curr . right = helper ( inorder , i + 1 , iRight , postorder , pLeft + i - iLeft , pRight - 1 , map ); return curr ; } } 107. Binary Tree Level Order Traversal II $\\star$ 108. Convert Sorted Array to Binary Search Tree $\\star$ 109. Convert Sorted List to Binary Search Tree $\\star\\star$ 110. Balanced Binary Tree $\\star$","title":"0101-0110"},{"location":"java/0101-0200/0101-0110/#101-symmetric-tree-star","text":"","title":"101. Symmetric Tree $\\star$"},{"location":"java/0101-0200/0101-0110/#102-binary-tree-level-order-traversal-starstar","text":"","title":"102. Binary Tree Level Order Traversal $\\star\\star$"},{"location":"java/0101-0200/0101-0110/#103-binary-tree-zigzag-level-order-traversal-starstar","text":"","title":"103. Binary Tree Zigzag Level Order Traversal $\\star\\star$"},{"location":"java/0101-0200/0101-0110/#104-maximum-depth-of-binary-tree-star","text":"","title":"104. Maximum Depth of Binary Tree $\\star$"},{"location":"java/0101-0200/0101-0110/#105-construct-binary-tree-from-preorder-and-inorder-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public TreeNode buildTree ( int [] preorder , int [] inorder ) { Map < Integer , Integer > map = new HashMap <>(); for ( int i = 0 ; i < inorder . length ; i ++) map . put ( inorder [ i ], i ); return helper ( preorder , 0 , preorder . length - 1 , inorder , 0 , inorder . length - 1 , map ); } private TreeNode helper ( int [] preorder , int pLeft , int pRight , int [] inorder , int iLeft , int iRight , Map < Integer , Integer > map ) { if ( pLeft > pRight || iLeft > iRight ) return null ; int i = map . get ( preorder [ pLeft ]); TreeNode curr = new TreeNode ( preorder [ pLeft ]); curr . left = helper ( preorder , pLeft + 1 , pLeft + i - iLeft , inorder , iLeft , i - 1 , map ); curr . right = helper ( preorder , pLeft + i - iLeft + 1 , pRight , inorder , i + 1 , iRight , map ); return curr ; } }","title":"105. Construct Binary Tree from Preorder and Inorder Traversal $\\star\\star$"},{"location":"java/0101-0200/0101-0110/#106-construct-binary-tree-from-inorder-and-postorder-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public TreeNode buildTree ( int [] inorder , int [] postorder ) { Map < Integer , Integer > map = new HashMap <>(); for ( int i = 0 ; i < inorder . length ; i ++) map . put ( inorder [ i ], i ); return helper ( inorder , 0 , inorder . length - 1 , postorder , 0 , postorder . length - 1 , map ); } private TreeNode helper ( int [] inorder , int iLeft , int iRight , int [] postorder , int pLeft , int pRight , Map < Integer , Integer > map ) { if ( iLeft > iRight || pLeft > pRight ) return null ; int i = map . get ( postorder [ pRight ]); TreeNode curr = new TreeNode ( postorder [ pRight ]); curr . left = helper ( inorder , iLeft , i - 1 , postorder , pLeft , pLeft + i - iLeft - 1 , map ); curr . right = helper ( inorder , i + 1 , iRight , postorder , pLeft + i - iLeft , pRight - 1 , map ); return curr ; } }","title":"106. Construct Binary Tree from Inorder and Postorder Traversal $\\star\\star$"},{"location":"java/0101-0200/0101-0110/#107-binary-tree-level-order-traversal-ii-star","text":"","title":"107. Binary Tree Level Order Traversal II $\\star$"},{"location":"java/0101-0200/0101-0110/#108-convert-sorted-array-to-binary-search-tree-star","text":"","title":"108. Convert Sorted Array to Binary Search Tree $\\star$"},{"location":"java/0101-0200/0101-0110/#109-convert-sorted-list-to-binary-search-tree-starstar","text":"","title":"109. Convert Sorted List to Binary Search Tree $\\star\\star$"},{"location":"java/0101-0200/0101-0110/#110-balanced-binary-tree-star","text":"","title":"110. Balanced Binary Tree $\\star$"},{"location":"java/0101-0200/0111-0120/","text":"111. Minimum Depth of Binary Tree $\\star$ 112. Path Sum $\\star$ 113. Path Sum II $\\star\\star$ 114. Flatten Binary Tree to Linked List $\\star\\star$ 115. Distinct Subsequences $\\star\\star\\star$ 116. Populating Next Right Pointers in Each Node $\\star\\star$ 117. Populating Next Right Pointers in Each Node II $\\star\\star$ 118. Pascal's Triangle $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public List < List < Integer >> generate ( int numRows ) { List < List < Integer >> ans = new ArrayList <>(); for ( int i = 0 ; i < numRows ; i ++) { Integer [] temp = new Integer [ i + 1 ]; Arrays . fill ( temp , 1 ); ans . add ( Arrays . asList ( temp )); } for ( int i = 2 ; i < numRows ; i ++) for ( int j = 1 ; j < ans . get ( i ). size () - 1 ; j ++) ans . get ( i ). set ( j , ans . get ( i - 1 ). get ( j - 1 ) + ans . get ( i - 1 ). get ( j )); return ans ; } } 119. Pascal's Triangle II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public List < Integer > getRow ( int rowIndex ) { Integer [] ans = new Integer [ rowIndex + 1 ]; Arrays . fill ( ans , 1 ); for ( int i = 2 ; i < rowIndex + 1 ; i ++) for ( int j = 1 ; j < i ; j ++) ans [ i - j ] += ans [ i - j - 1 ]; return Arrays . asList ( ans ); } } 120. Triangle $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public int minimumTotal ( List < List < Integer >> triangle ) { for ( int i = triangle . size () - 2 ; i >= 0 ; i --) for ( int j = 0 ; j <= i ; j ++) triangle . get ( i ). set ( j , triangle . get ( i ). get ( j ) + Math . min ( triangle . get ( i + 1 ). get ( j ), triangle . get ( i + 1 ). get ( j + 1 ))); return triangle . get ( 0 ). get ( 0 ); } }","title":"0111-0120"},{"location":"java/0101-0200/0111-0120/#111-minimum-depth-of-binary-tree-star","text":"","title":"111. Minimum Depth of Binary Tree $\\star$"},{"location":"java/0101-0200/0111-0120/#112-path-sum-star","text":"","title":"112. Path Sum $\\star$"},{"location":"java/0101-0200/0111-0120/#113-path-sum-ii-starstar","text":"","title":"113. Path Sum II $\\star\\star$"},{"location":"java/0101-0200/0111-0120/#114-flatten-binary-tree-to-linked-list-starstar","text":"","title":"114. Flatten Binary Tree to Linked List $\\star\\star$"},{"location":"java/0101-0200/0111-0120/#115-distinct-subsequences-starstarstar","text":"","title":"115. Distinct Subsequences $\\star\\star\\star$"},{"location":"java/0101-0200/0111-0120/#116-populating-next-right-pointers-in-each-node-starstar","text":"","title":"116. Populating Next Right Pointers in Each Node $\\star\\star$"},{"location":"java/0101-0200/0111-0120/#117-populating-next-right-pointers-in-each-node-ii-starstar","text":"","title":"117. Populating Next Right Pointers in Each Node II $\\star\\star$"},{"location":"java/0101-0200/0111-0120/#118-pascals-triangle-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public List < List < Integer >> generate ( int numRows ) { List < List < Integer >> ans = new ArrayList <>(); for ( int i = 0 ; i < numRows ; i ++) { Integer [] temp = new Integer [ i + 1 ]; Arrays . fill ( temp , 1 ); ans . add ( Arrays . asList ( temp )); } for ( int i = 2 ; i < numRows ; i ++) for ( int j = 1 ; j < ans . get ( i ). size () - 1 ; j ++) ans . get ( i ). set ( j , ans . get ( i - 1 ). get ( j - 1 ) + ans . get ( i - 1 ). get ( j )); return ans ; } }","title":"118. Pascal's Triangle $\\star$"},{"location":"java/0101-0200/0111-0120/#119-pascals-triangle-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public List < Integer > getRow ( int rowIndex ) { Integer [] ans = new Integer [ rowIndex + 1 ]; Arrays . fill ( ans , 1 ); for ( int i = 2 ; i < rowIndex + 1 ; i ++) for ( int j = 1 ; j < i ; j ++) ans [ i - j ] += ans [ i - j - 1 ]; return Arrays . asList ( ans ); } }","title":"119. Pascal's Triangle II $\\star$"},{"location":"java/0101-0200/0111-0120/#120-triangle-starstar","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public int minimumTotal ( List < List < Integer >> triangle ) { for ( int i = triangle . size () - 2 ; i >= 0 ; i --) for ( int j = 0 ; j <= i ; j ++) triangle . get ( i ). set ( j , triangle . get ( i ). get ( j ) + Math . min ( triangle . get ( i + 1 ). get ( j ), triangle . get ( i + 1 ). get ( j + 1 ))); return triangle . get ( 0 ). get ( 0 ); } }","title":"120. Triangle $\\star\\star$"},{"location":"java/0101-0200/0121-0130/","text":"121. Best Time to Buy and Sell Stock $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int maxProfit ( int [] prices ) { int sellOne = 0 ; int holdOne = Integer . MIN_VALUE ; for ( int price : prices ) { sellOne = Math . max ( sellOne , holdOne + price ); holdOne = Math . max ( holdOne , - price ); } return sellOne ; } } 122. Best Time to Buy and Sell Stock II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int maxProfit ( int [] prices ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; for ( int price : prices ) { sell = Math . max ( sell , hold + price ); hold = Math . max ( hold , sell - price ); } return sell ; } } 123. Best Time to Buy and Sell Stock III $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int maxProfit ( int [] prices ) { int sellTwo = 0 ; int holdTwo = Integer . MIN_VALUE ; int sellOne = 0 ; int holdOne = Integer . MIN_VALUE ; for ( int price : prices ) { sellTwo = Math . max ( sellTwo , holdTwo + price ); holdTwo = Math . max ( holdTwo , sellOne - price ); sellOne = Math . max ( sellOne , holdOne + price ); holdOne = Math . max ( holdOne , - price ); } return sellTwo ; } } 124. Binary Tree Maximum Path Sum $\\star\\star\\star$ 125. Valid Palindrome $\\star$ 126. Word Ladder II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class Solution { public List < List < String >> findLadders ( String beginWord , String endWord , List < String > wordList ) { List < List < String >> ans = new ArrayList <>(); Set < String > set = new HashSet <>( wordList ); if (! set . contains ( endWord )) return ans ; Set < String > set1 = new HashSet <>( Arrays . asList ( beginWord )); Map < String , List < String >> map = new HashMap <>(); boolean isFound = false ; while (! set1 . isEmpty () && ! isFound ) { for ( String word : set1 ) set . remove ( word ); Set < String > tempSet = new HashSet <>(); for ( String parent : set1 ) { char [] word = parent . toCharArray (); for ( int i = 0 ; i < word . length ; i ++) { char c = word [ i ]; for ( char j = 'a' ; j <= 'z' ; j ++) { word [ i ] = j ; String newWord = String . valueOf ( word ); if ( newWord . equals ( endWord )) { if (! map . containsKey ( parent )) map . put ( parent , new ArrayList <>()); map . get ( parent ). add ( newWord ); isFound = true ; } else if ( set . contains ( newWord ) && ! isFound ) { tempSet . add ( newWord ); if (! map . containsKey ( parent )) map . put ( parent , new ArrayList <>()); map . get ( parent ). add ( newWord ); } } word [ i ] = c ; } } set1 = tempSet ; } if ( isFound ) { List < String > path = new ArrayList <>( Arrays . asList ( beginWord )); dfs ( map , beginWord , endWord , path , ans ); } return ans ; } private void dfs ( Map < String , List < String >> map , String word , String endWord , List < String > path , List < List < String >> ans ) { if ( word . equals ( endWord )) { ans . add ( new ArrayList <>( path )); return ; } if (! map . containsKey ( word )) return ; for ( String child : map . get ( word )) { path . add ( child ); dfs ( map , child , endWord , path , ans ); path . remove ( path . size () - 1 ); } } } 127. Word Ladder $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { public int ladderLength ( String beginWord , String endWord , List < String > wordList ) { Set < String > set = new HashSet <>( wordList ); if (! set . contains ( endWord )) return 0 ; int ans = 0 ; Set < String > set1 = new HashSet <>( Arrays . asList ( beginWord )); Set < String > set2 = new HashSet <>( Arrays . asList ( endWord )); while (! set1 . isEmpty () && ! set2 . isEmpty ()) { ans ++; if ( set1 . size () > set2 . size ()) swap ( set1 , set2 ); Set < String > tempSet = new HashSet <>(); for ( String word : set1 ) { char [] charArray = word . toCharArray (); for ( int i = 0 ; i < word . length (); i ++) { char c = charArray [ i ]; for ( char j = 'a' ; j <= 'z' ; j ++) { charArray [ i ] = j ; String newWord = String . valueOf ( charArray ); if ( set2 . contains ( newWord )) return ans + 1 ; if (! set . contains ( newWord )) continue ; set . remove ( newWord ); tempSet . add ( newWord ); } charArray [ i ] = c ; } } set1 = tempSet ; } return 0 ; } public void swap ( Set s1 , Set s2 ) { Set temp = s1 ; s1 = s2 ; s2 = temp ; } } 128. Longest Consecutive Sequence $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int longestConsecutive ( int [] nums ) { int ans = 0 ; Set < Integer > set = new HashSet <>(); for ( int num : nums ) set . add ( num ); for ( int num : nums ) if (! set . contains ( num - 1 )) { int length = 0 ; while ( set . contains ( num ++)) length ++; ans = Math . max ( ans , length ); } return ans ; } } 129. Sum Root to Leaf Numbers $\\star\\star$ 130. Surrounded Regions $\\star\\star$","title":"0121-0130"},{"location":"java/0101-0200/0121-0130/#121-best-time-to-buy-and-sell-stock-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int maxProfit ( int [] prices ) { int sellOne = 0 ; int holdOne = Integer . MIN_VALUE ; for ( int price : prices ) { sellOne = Math . max ( sellOne , holdOne + price ); holdOne = Math . max ( holdOne , - price ); } return sellOne ; } }","title":"121. Best Time to Buy and Sell Stock $\\star$"},{"location":"java/0101-0200/0121-0130/#122-best-time-to-buy-and-sell-stock-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int maxProfit ( int [] prices ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; for ( int price : prices ) { sell = Math . max ( sell , hold + price ); hold = Math . max ( hold , sell - price ); } return sell ; } }","title":"122. Best Time to Buy and Sell Stock II $\\star$"},{"location":"java/0101-0200/0121-0130/#123-best-time-to-buy-and-sell-stock-iii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int maxProfit ( int [] prices ) { int sellTwo = 0 ; int holdTwo = Integer . MIN_VALUE ; int sellOne = 0 ; int holdOne = Integer . MIN_VALUE ; for ( int price : prices ) { sellTwo = Math . max ( sellTwo , holdTwo + price ); holdTwo = Math . max ( holdTwo , sellOne - price ); sellOne = Math . max ( sellOne , holdOne + price ); holdOne = Math . max ( holdOne , - price ); } return sellTwo ; } }","title":"123. Best Time to Buy and Sell Stock III $\\star\\star\\star$"},{"location":"java/0101-0200/0121-0130/#124-binary-tree-maximum-path-sum-starstarstar","text":"","title":"124. Binary Tree Maximum Path Sum $\\star\\star\\star$"},{"location":"java/0101-0200/0121-0130/#125-valid-palindrome-star","text":"","title":"125. Valid Palindrome $\\star$"},{"location":"java/0101-0200/0121-0130/#126-word-ladder-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class Solution { public List < List < String >> findLadders ( String beginWord , String endWord , List < String > wordList ) { List < List < String >> ans = new ArrayList <>(); Set < String > set = new HashSet <>( wordList ); if (! set . contains ( endWord )) return ans ; Set < String > set1 = new HashSet <>( Arrays . asList ( beginWord )); Map < String , List < String >> map = new HashMap <>(); boolean isFound = false ; while (! set1 . isEmpty () && ! isFound ) { for ( String word : set1 ) set . remove ( word ); Set < String > tempSet = new HashSet <>(); for ( String parent : set1 ) { char [] word = parent . toCharArray (); for ( int i = 0 ; i < word . length ; i ++) { char c = word [ i ]; for ( char j = 'a' ; j <= 'z' ; j ++) { word [ i ] = j ; String newWord = String . valueOf ( word ); if ( newWord . equals ( endWord )) { if (! map . containsKey ( parent )) map . put ( parent , new ArrayList <>()); map . get ( parent ). add ( newWord ); isFound = true ; } else if ( set . contains ( newWord ) && ! isFound ) { tempSet . add ( newWord ); if (! map . containsKey ( parent )) map . put ( parent , new ArrayList <>()); map . get ( parent ). add ( newWord ); } } word [ i ] = c ; } } set1 = tempSet ; } if ( isFound ) { List < String > path = new ArrayList <>( Arrays . asList ( beginWord )); dfs ( map , beginWord , endWord , path , ans ); } return ans ; } private void dfs ( Map < String , List < String >> map , String word , String endWord , List < String > path , List < List < String >> ans ) { if ( word . equals ( endWord )) { ans . add ( new ArrayList <>( path )); return ; } if (! map . containsKey ( word )) return ; for ( String child : map . get ( word )) { path . add ( child ); dfs ( map , child , endWord , path , ans ); path . remove ( path . size () - 1 ); } } }","title":"126. Word Ladder II $\\star\\star\\star$"},{"location":"java/0101-0200/0121-0130/#127-word-ladder-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class Solution { public int ladderLength ( String beginWord , String endWord , List < String > wordList ) { Set < String > set = new HashSet <>( wordList ); if (! set . contains ( endWord )) return 0 ; int ans = 0 ; Set < String > set1 = new HashSet <>( Arrays . asList ( beginWord )); Set < String > set2 = new HashSet <>( Arrays . asList ( endWord )); while (! set1 . isEmpty () && ! set2 . isEmpty ()) { ans ++; if ( set1 . size () > set2 . size ()) swap ( set1 , set2 ); Set < String > tempSet = new HashSet <>(); for ( String word : set1 ) { char [] charArray = word . toCharArray (); for ( int i = 0 ; i < word . length (); i ++) { char c = charArray [ i ]; for ( char j = 'a' ; j <= 'z' ; j ++) { charArray [ i ] = j ; String newWord = String . valueOf ( charArray ); if ( set2 . contains ( newWord )) return ans + 1 ; if (! set . contains ( newWord )) continue ; set . remove ( newWord ); tempSet . add ( newWord ); } charArray [ i ] = c ; } } set1 = tempSet ; } return 0 ; } public void swap ( Set s1 , Set s2 ) { Set temp = s1 ; s1 = s2 ; s2 = temp ; } }","title":"127. Word Ladder $\\star\\star$"},{"location":"java/0101-0200/0121-0130/#128-longest-consecutive-sequence-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int longestConsecutive ( int [] nums ) { int ans = 0 ; Set < Integer > set = new HashSet <>(); for ( int num : nums ) set . add ( num ); for ( int num : nums ) if (! set . contains ( num - 1 )) { int length = 0 ; while ( set . contains ( num ++)) length ++; ans = Math . max ( ans , length ); } return ans ; } }","title":"128. Longest Consecutive Sequence $\\star\\star\\star$"},{"location":"java/0101-0200/0121-0130/#129-sum-root-to-leaf-numbers-starstar","text":"","title":"129. Sum Root to Leaf Numbers $\\star\\star$"},{"location":"java/0101-0200/0121-0130/#130-surrounded-regions-starstar","text":"","title":"130. Surrounded Regions $\\star\\star$"},{"location":"java/0101-0200/0131-0140/","text":"131. Palindrome Partitioning $\\star\\star$ 132. Palindrome Partitioning II $\\star\\star\\star$ 133. Clone Graph $\\star\\star$ 134. Gas Station $\\star\\star$ 135. Candy $\\star\\star\\star$ 136. Single Number $\\star$ 137. Single Number II $\\star\\star$ 138. Copy List with Random Pointer $\\star\\star$ 139. Word Break $\\star\\star$ 140. Word Break II $\\star\\star\\star$","title":"0131-0140"},{"location":"java/0101-0200/0131-0140/#131-palindrome-partitioning-starstar","text":"","title":"131. Palindrome Partitioning $\\star\\star$"},{"location":"java/0101-0200/0131-0140/#132-palindrome-partitioning-ii-starstarstar","text":"","title":"132. Palindrome Partitioning II $\\star\\star\\star$"},{"location":"java/0101-0200/0131-0140/#133-clone-graph-starstar","text":"","title":"133. Clone Graph $\\star\\star$"},{"location":"java/0101-0200/0131-0140/#134-gas-station-starstar","text":"","title":"134. Gas Station $\\star\\star$"},{"location":"java/0101-0200/0131-0140/#135-candy-starstarstar","text":"","title":"135. Candy $\\star\\star\\star$"},{"location":"java/0101-0200/0131-0140/#136-single-number-star","text":"","title":"136. Single Number $\\star$"},{"location":"java/0101-0200/0131-0140/#137-single-number-ii-starstar","text":"","title":"137. Single Number II $\\star\\star$"},{"location":"java/0101-0200/0131-0140/#138-copy-list-with-random-pointer-starstar","text":"","title":"138. Copy List with Random Pointer $\\star\\star$"},{"location":"java/0101-0200/0131-0140/#139-word-break-starstar","text":"","title":"139. Word Break $\\star\\star$"},{"location":"java/0101-0200/0131-0140/#140-word-break-ii-starstarstar","text":"","title":"140. Word Break II $\\star\\star\\star$"},{"location":"java/0101-0200/0141-0150/","text":"141. Linked List Cycle $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Solution { public boolean hasCycle ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; if ( slow == fast ) return true ; } return false ; } } 142. Linked List Cycle II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Solution { public ListNode detectCycle ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow . next ; fast = fast . next ; } return slow ; } } return null ; } } 143. Reorder List $\\star\\star$ 144. Binary Tree Preorder Traversal $\\star\\star$ 145. Binary Tree Postorder Traversal $\\star\\star\\star$ 146. LRU Cache $\\star\\star$ 147. Insertion Sort List $\\star\\star$ 148. Sort List $\\star\\star$ 149. Max Points on a Line $\\star\\star\\star$ 150. Evaluate Reverse Polish Notation $\\star\\star$","title":"0141-0150"},{"location":"java/0101-0200/0141-0150/#141-linked-list-cycle-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class Solution { public boolean hasCycle ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; if ( slow == fast ) return true ; } return false ; } }","title":"141. Linked List Cycle $\\star$"},{"location":"java/0101-0200/0141-0150/#142-linked-list-cycle-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 public class Solution { public ListNode detectCycle ( ListNode head ) { ListNode slow = head ; ListNode fast = head ; while ( fast != null && fast . next != null ) { slow = slow . next ; fast = fast . next . next ; if ( slow == fast ) { slow = head ; while ( slow != fast ) { slow = slow . next ; fast = fast . next ; } return slow ; } } return null ; } }","title":"142. Linked List Cycle II $\\star\\star$"},{"location":"java/0101-0200/0141-0150/#143-reorder-list-starstar","text":"","title":"143. Reorder List $\\star\\star$"},{"location":"java/0101-0200/0141-0150/#144-binary-tree-preorder-traversal-starstar","text":"","title":"144. Binary Tree Preorder Traversal $\\star\\star$"},{"location":"java/0101-0200/0141-0150/#145-binary-tree-postorder-traversal-starstarstar","text":"","title":"145. Binary Tree Postorder Traversal $\\star\\star\\star$"},{"location":"java/0101-0200/0141-0150/#146-lru-cache-starstar","text":"","title":"146. LRU Cache $\\star\\star$"},{"location":"java/0101-0200/0141-0150/#147-insertion-sort-list-starstar","text":"","title":"147. Insertion Sort List $\\star\\star$"},{"location":"java/0101-0200/0141-0150/#148-sort-list-starstar","text":"","title":"148. Sort List $\\star\\star$"},{"location":"java/0101-0200/0141-0150/#149-max-points-on-a-line-starstarstar","text":"","title":"149. Max Points on a Line $\\star\\star\\star$"},{"location":"java/0101-0200/0141-0150/#150-evaluate-reverse-polish-notation-starstar","text":"","title":"150. Evaluate Reverse Polish Notation $\\star\\star$"},{"location":"java/0101-0200/0151-0160/","text":"151. Reverse Words in a String $\\star\\star$ 152. Maximum Product Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int maxProduct ( int [] nums ) { int ans = nums [ 0 ]; int prevMin = nums [ 0 ]; int prevMax = nums [ 0 ]; for ( int i = 1 ; i < nums . length ; i ++) { int min = prevMin * nums [ i ]; int max = prevMax * nums [ i ]; prevMin = Math . min ( nums [ i ], Math . min ( min , max )); prevMax = Math . max ( nums [ i ], Math . max ( min , max )); ans = Math . max ( ans , prevMax ); } return ans ; } } 153. Find Minimum in Rotated Sorted Array $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int findMin ( int [] nums ) { int l = 0 ; int r = nums . length - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] < nums [ r ]) r = m ; else l = m + 1 ; } return nums [ l ]; } } 154. Find Minimum in Rotated Sorted Array II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int findMin ( int [] nums ) { int l = 0 ; int r = nums . length - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == nums [ r ]) r --; else if ( nums [ m ] < nums [ r ]) r = m ; else l = m + 1 ; } return nums [ l ]; } } 155. Min Stack $\\star$ 156. Binary Tree Upside Down $\\star\\star$ 157. Read N Characters Given Read4 $\\star$ 158. Read N Characters Given Read4 II - Call multiple times $\\star\\star\\star$ 159. Longest Substring with At Most Two Distinct Characters $\\star\\star$ 160. Intersection of Two Linked Lists $\\star$","title":"0151-0160"},{"location":"java/0101-0200/0151-0160/#151-reverse-words-in-a-string-starstar","text":"","title":"151. Reverse Words in a String $\\star\\star$"},{"location":"java/0101-0200/0151-0160/#152-maximum-product-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int maxProduct ( int [] nums ) { int ans = nums [ 0 ]; int prevMin = nums [ 0 ]; int prevMax = nums [ 0 ]; for ( int i = 1 ; i < nums . length ; i ++) { int min = prevMin * nums [ i ]; int max = prevMax * nums [ i ]; prevMin = Math . min ( nums [ i ], Math . min ( min , max )); prevMax = Math . max ( nums [ i ], Math . max ( min , max )); ans = Math . max ( ans , prevMax ); } return ans ; } }","title":"152. Maximum Product Subarray $\\star\\star$"},{"location":"java/0101-0200/0151-0160/#153-find-minimum-in-rotated-sorted-array-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int findMin ( int [] nums ) { int l = 0 ; int r = nums . length - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] < nums [ r ]) r = m ; else l = m + 1 ; } return nums [ l ]; } }","title":"153. Find Minimum in Rotated Sorted Array $\\star\\star$"},{"location":"java/0101-0200/0151-0160/#154-find-minimum-in-rotated-sorted-array-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int findMin ( int [] nums ) { int l = 0 ; int r = nums . length - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] == nums [ r ]) r --; else if ( nums [ m ] < nums [ r ]) r = m ; else l = m + 1 ; } return nums [ l ]; } }","title":"154. Find Minimum in Rotated Sorted Array II $\\star\\star\\star$"},{"location":"java/0101-0200/0151-0160/#155-min-stack-star","text":"","title":"155. Min Stack $\\star$"},{"location":"java/0101-0200/0151-0160/#156-binary-tree-upside-down-starstar","text":"","title":"156. Binary Tree Upside Down $\\star\\star$"},{"location":"java/0101-0200/0151-0160/#157-read-n-characters-given-read4-star","text":"","title":"157. Read N Characters Given Read4 $\\star$"},{"location":"java/0101-0200/0151-0160/#158-read-n-characters-given-read4-ii-call-multiple-times-starstarstar","text":"","title":"158. Read N Characters Given Read4 II - Call multiple times $\\star\\star\\star$"},{"location":"java/0101-0200/0151-0160/#159-longest-substring-with-at-most-two-distinct-characters-starstar","text":"","title":"159. Longest Substring with At Most Two Distinct Characters $\\star\\star$"},{"location":"java/0101-0200/0151-0160/#160-intersection-of-two-linked-lists-star","text":"","title":"160. Intersection of Two Linked Lists $\\star$"},{"location":"java/0101-0200/0161-0170/","text":"161. One Edit Distance $\\star\\star$ 162. Find Peak Element $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int findPeakElement ( int [] nums ) { int l = 0 ; int r = nums . length - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] > nums [ m + 1 ]) r = m ; else l = m + 1 ; } return l ; } } 163. Missing Ranges $\\star\\star$ 164. Maximum Gap $\\star\\star\\star$ 165. Compare Version Numbers $\\star\\star$ 166. Fraction to Recurring Decimal $\\star\\star$ 167. Two Sum II - Input array is sorted $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int [] twoSum ( int [] numbers , int target ) { int l = 0 ; int r = numbers . length - 1 ; while ( l < r ) { int sum = numbers [ l ] + numbers [ r ]; if ( sum == target ) return new int [] { l + 1 , r + 1 }; if ( sum < target ) l ++; else r --; } throw new IllegalArgumentException (); } } 168. Excel Sheet Column Title $\\star$ 169. Majority Element $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int majorityElement ( int [] nums ) { Integer ans = null ; int count = 0 ; for ( int num : nums ) { if ( count == 0 ) ans = num ; count += num == ans ? 1 : - 1 ; } return ans ; } } 170. Two Sum III - Data structure design $\\star$","title":"0161-0170"},{"location":"java/0101-0200/0161-0170/#161-one-edit-distance-starstar","text":"","title":"161. One Edit Distance $\\star\\star$"},{"location":"java/0101-0200/0161-0170/#162-find-peak-element-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int findPeakElement ( int [] nums ) { int l = 0 ; int r = nums . length - 1 ; while ( l < r ) { int m = l + ( r - l ) / 2 ; if ( nums [ m ] > nums [ m + 1 ]) r = m ; else l = m + 1 ; } return l ; } }","title":"162. Find Peak Element $\\star\\star$"},{"location":"java/0101-0200/0161-0170/#163-missing-ranges-starstar","text":"","title":"163. Missing Ranges $\\star\\star$"},{"location":"java/0101-0200/0161-0170/#164-maximum-gap-starstarstar","text":"","title":"164. Maximum Gap $\\star\\star\\star$"},{"location":"java/0101-0200/0161-0170/#165-compare-version-numbers-starstar","text":"","title":"165. Compare Version Numbers $\\star\\star$"},{"location":"java/0101-0200/0161-0170/#166-fraction-to-recurring-decimal-starstar","text":"","title":"166. Fraction to Recurring Decimal $\\star\\star$"},{"location":"java/0101-0200/0161-0170/#167-two-sum-ii-input-array-is-sorted-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int [] twoSum ( int [] numbers , int target ) { int l = 0 ; int r = numbers . length - 1 ; while ( l < r ) { int sum = numbers [ l ] + numbers [ r ]; if ( sum == target ) return new int [] { l + 1 , r + 1 }; if ( sum < target ) l ++; else r --; } throw new IllegalArgumentException (); } }","title":"167. Two Sum II - Input array is sorted $\\star$"},{"location":"java/0101-0200/0161-0170/#168-excel-sheet-column-title-star","text":"","title":"168. Excel Sheet Column Title $\\star$"},{"location":"java/0101-0200/0161-0170/#169-majority-element-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int majorityElement ( int [] nums ) { Integer ans = null ; int count = 0 ; for ( int num : nums ) { if ( count == 0 ) ans = num ; count += num == ans ? 1 : - 1 ; } return ans ; } }","title":"169. Majority Element $\\star$"},{"location":"java/0101-0200/0161-0170/#170-two-sum-iii-data-structure-design-star","text":"","title":"170. Two Sum III - Data structure design $\\star$"},{"location":"java/0101-0200/0171-0180/","text":"171. Excel Sheet Column Number $\\star$ 172. Factorial Trailing Zeroes $\\star$ 173. Binary Search Tree Iterator $\\star\\star$ 174. Dungeon Game $\\star\\star\\star$ 175. Combine Two Tables $\\star$ 176. Second Highest Salary $\\star$ 177. Nth Highest Salary $\\star\\star$ 178. Rank Scores $\\star\\star$ 179. Largest Number $\\star\\star$ 180. Consecutive Numbers $\\star\\star$","title":"0171-0180"},{"location":"java/0101-0200/0171-0180/#171-excel-sheet-column-number-star","text":"","title":"171. Excel Sheet Column Number $\\star$"},{"location":"java/0101-0200/0171-0180/#172-factorial-trailing-zeroes-star","text":"","title":"172. Factorial Trailing Zeroes $\\star$"},{"location":"java/0101-0200/0171-0180/#173-binary-search-tree-iterator-starstar","text":"","title":"173. Binary Search Tree Iterator $\\star\\star$"},{"location":"java/0101-0200/0171-0180/#174-dungeon-game-starstarstar","text":"","title":"174. Dungeon Game $\\star\\star\\star$"},{"location":"java/0101-0200/0171-0180/#175-combine-two-tables-star","text":"","title":"175. Combine Two Tables $\\star$"},{"location":"java/0101-0200/0171-0180/#176-second-highest-salary-star","text":"","title":"176. Second Highest Salary $\\star$"},{"location":"java/0101-0200/0171-0180/#177-nth-highest-salary-starstar","text":"","title":"177. Nth Highest Salary $\\star\\star$"},{"location":"java/0101-0200/0171-0180/#178-rank-scores-starstar","text":"","title":"178. Rank Scores $\\star\\star$"},{"location":"java/0101-0200/0171-0180/#179-largest-number-starstar","text":"","title":"179. Largest Number $\\star\\star$"},{"location":"java/0101-0200/0171-0180/#180-consecutive-numbers-starstar","text":"","title":"180. Consecutive Numbers $\\star\\star$"},{"location":"java/0101-0200/0181-0190/","text":"181. Employees Earning More Than Their Managers $\\star$ 182. Duplicate Emails $\\star$ 183. Customers Who Never Order $\\star$ 184. Department Highest Salary $\\star\\star$ 185. Department Top Three Salaries $\\star\\star\\star$ 186. Reverse Words in a String II $\\star\\star$ 187. Repeated DNA Sequences $\\star\\star$ 188. Best Time to Buy and Sell Stock IV $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int maxProfit ( int k , int [] prices ) { if ( k >= prices . length / 2 ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; for ( int price : prices ) { sell = Math . max ( sell , hold + price ); hold = Math . max ( hold , sell - price ); } return sell ; } int [] sell = new int [ k + 1 ]; int [] hold = new int [ k + 1 ]; Arrays . fill ( hold , Integer . MIN_VALUE ); for ( int price : prices ) for ( int i = k ; i > 0 ; i --) { sell [ i ] = Math . max ( sell [ i ], hold [ i ] + price ); hold [ i ] = Math . max ( hold [ i ], sell [ i - 1 ] - price ); } return sell [ k ]; } } 189. Rotate Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public void rotate ( int [] nums , int k ) { k %= nums . length ; reverse ( nums , 0 , nums . length - 1 ); reverse ( nums , 0 , k - 1 ); reverse ( nums , k , nums . length - 1 ); } private void reverse ( int [] nums , int l , int r ) { while ( l < r ) swap ( nums , l ++, r --); } private void swap ( int [] nums , int l , int r ) { int temp = nums [ l ]; nums [ l ] = nums [ r ]; nums [ r ] = temp ; } } 190. Reverse Bits $\\star$","title":"0181-0190"},{"location":"java/0101-0200/0181-0190/#181-employees-earning-more-than-their-managers-star","text":"","title":"181. Employees Earning More Than Their Managers $\\star$"},{"location":"java/0101-0200/0181-0190/#182-duplicate-emails-star","text":"","title":"182. Duplicate Emails $\\star$"},{"location":"java/0101-0200/0181-0190/#183-customers-who-never-order-star","text":"","title":"183. Customers Who Never Order $\\star$"},{"location":"java/0101-0200/0181-0190/#184-department-highest-salary-starstar","text":"","title":"184. Department Highest Salary $\\star\\star$"},{"location":"java/0101-0200/0181-0190/#185-department-top-three-salaries-starstarstar","text":"","title":"185. Department Top Three Salaries $\\star\\star\\star$"},{"location":"java/0101-0200/0181-0190/#186-reverse-words-in-a-string-ii-starstar","text":"","title":"186. Reverse Words in a String II $\\star\\star$"},{"location":"java/0101-0200/0181-0190/#187-repeated-dna-sequences-starstar","text":"","title":"187. Repeated DNA Sequences $\\star\\star$"},{"location":"java/0101-0200/0181-0190/#188-best-time-to-buy-and-sell-stock-iv-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution { public int maxProfit ( int k , int [] prices ) { if ( k >= prices . length / 2 ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; for ( int price : prices ) { sell = Math . max ( sell , hold + price ); hold = Math . max ( hold , sell - price ); } return sell ; } int [] sell = new int [ k + 1 ]; int [] hold = new int [ k + 1 ]; Arrays . fill ( hold , Integer . MIN_VALUE ); for ( int price : prices ) for ( int i = k ; i > 0 ; i --) { sell [ i ] = Math . max ( sell [ i ], hold [ i ] + price ); hold [ i ] = Math . max ( hold [ i ], sell [ i - 1 ] - price ); } return sell [ k ]; } }","title":"188. Best Time to Buy and Sell Stock IV $\\star\\star\\star$"},{"location":"java/0101-0200/0181-0190/#189-rotate-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public void rotate ( int [] nums , int k ) { k %= nums . length ; reverse ( nums , 0 , nums . length - 1 ); reverse ( nums , 0 , k - 1 ); reverse ( nums , k , nums . length - 1 ); } private void reverse ( int [] nums , int l , int r ) { while ( l < r ) swap ( nums , l ++, r --); } private void swap ( int [] nums , int l , int r ) { int temp = nums [ l ]; nums [ l ] = nums [ r ]; nums [ r ] = temp ; } }","title":"189. Rotate Array $\\star$"},{"location":"java/0101-0200/0181-0190/#190-reverse-bits-star","text":"","title":"190. Reverse Bits $\\star$"},{"location":"java/0101-0200/0191-0200/","text":"191. Number of 1 Bits $\\star$ 192. Word Frequency $\\star\\star$ 193. Valid Phone Numbers $\\star$ 194. Transpose File $\\star\\star$ 195. Tenth Line $\\star$ 196. Delete Duplicate Emails $\\star$ 197. Rising Temperature $\\star$ 198. House Robber $\\star$ 199. Binary Tree Right Side View $\\star\\star$ 200. Number of Islands $\\star\\star$","title":"0191-0200"},{"location":"java/0101-0200/0191-0200/#191-number-of-1-bits-star","text":"","title":"191. Number of 1 Bits $\\star$"},{"location":"java/0101-0200/0191-0200/#192-word-frequency-starstar","text":"","title":"192. Word Frequency $\\star\\star$"},{"location":"java/0101-0200/0191-0200/#193-valid-phone-numbers-star","text":"","title":"193. Valid Phone Numbers $\\star$"},{"location":"java/0101-0200/0191-0200/#194-transpose-file-starstar","text":"","title":"194. Transpose File $\\star\\star$"},{"location":"java/0101-0200/0191-0200/#195-tenth-line-star","text":"","title":"195. Tenth Line $\\star$"},{"location":"java/0101-0200/0191-0200/#196-delete-duplicate-emails-star","text":"","title":"196. Delete Duplicate Emails $\\star$"},{"location":"java/0101-0200/0191-0200/#197-rising-temperature-star","text":"","title":"197. Rising Temperature $\\star$"},{"location":"java/0101-0200/0191-0200/#198-house-robber-star","text":"","title":"198. House Robber $\\star$"},{"location":"java/0101-0200/0191-0200/#199-binary-tree-right-side-view-starstar","text":"","title":"199. Binary Tree Right Side View $\\star\\star$"},{"location":"java/0101-0200/0191-0200/#200-number-of-islands-starstar","text":"","title":"200. Number of Islands $\\star\\star$"},{"location":"java/0201-0300/0201-0210/","text":"201. Bitwise AND of Numbers Range $\\star\\star$ 202. Happy Number $\\star$ 203. Remove Linked List Elements $\\star$ 204. Count Primes $\\star$ 205. Isomorphic Strings $\\star$ 206. Reverse Linked List $\\star$ 207. Course Schedule $\\star\\star$ 208. Implement Trie (Prefix Tree) $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Trie { public void insert ( String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ]; } node . isWord = true ; } public boolean search ( String word ) { TrieNode node = find ( word ); return node != null && node . isWord ; } public boolean startsWith ( String prefix ) { return find ( prefix ) != null ; } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ]; private boolean isWord = false ; } private TrieNode root = new TrieNode (); private TrieNode find ( String prefix ) { TrieNode node = root ; for ( int i = 0 ; i < prefix . length (); i ++) { int index = ( int ) ( prefix . charAt ( i ) - 'a' ); if ( node . children [ index ] == null ) return null ; node = node . children [ index ]; } return node ; } } 209. Minimum Size Subarray Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int minSubArrayLen ( int s , int [] nums ) { int ans = Integer . MAX_VALUE ; int sum = 0 ; int j = 0 ; for ( int i = 0 ; i < nums . length ; i ++) { sum += nums [ i ]; while ( sum >= s ) { ans = Math . min ( ans , i - j + 1 ); sum -= nums [ j ++]; } } return ans != Integer . MAX_VALUE ? ans : 0 ; } } 210. Course Schedule II $\\star\\star$","title":"0201-0210"},{"location":"java/0201-0300/0201-0210/#201-bitwise-and-of-numbers-range-starstar","text":"","title":"201. Bitwise AND of Numbers Range $\\star\\star$"},{"location":"java/0201-0300/0201-0210/#202-happy-number-star","text":"","title":"202. Happy Number $\\star$"},{"location":"java/0201-0300/0201-0210/#203-remove-linked-list-elements-star","text":"","title":"203. Remove Linked List Elements $\\star$"},{"location":"java/0201-0300/0201-0210/#204-count-primes-star","text":"","title":"204. Count Primes $\\star$"},{"location":"java/0201-0300/0201-0210/#205-isomorphic-strings-star","text":"","title":"205. Isomorphic Strings $\\star$"},{"location":"java/0201-0300/0201-0210/#206-reverse-linked-list-star","text":"","title":"206. Reverse Linked List $\\star$"},{"location":"java/0201-0300/0201-0210/#207-course-schedule-starstar","text":"","title":"207. Course Schedule $\\star\\star$"},{"location":"java/0201-0300/0201-0210/#208-implement-trie-prefix-tree-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Trie { public void insert ( String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ]; } node . isWord = true ; } public boolean search ( String word ) { TrieNode node = find ( word ); return node != null && node . isWord ; } public boolean startsWith ( String prefix ) { return find ( prefix ) != null ; } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ]; private boolean isWord = false ; } private TrieNode root = new TrieNode (); private TrieNode find ( String prefix ) { TrieNode node = root ; for ( int i = 0 ; i < prefix . length (); i ++) { int index = ( int ) ( prefix . charAt ( i ) - 'a' ); if ( node . children [ index ] == null ) return null ; node = node . children [ index ]; } return node ; } }","title":"208. Implement Trie (Prefix Tree) $\\star\\star$"},{"location":"java/0201-0300/0201-0210/#209-minimum-size-subarray-sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int minSubArrayLen ( int s , int [] nums ) { int ans = Integer . MAX_VALUE ; int sum = 0 ; int j = 0 ; for ( int i = 0 ; i < nums . length ; i ++) { sum += nums [ i ]; while ( sum >= s ) { ans = Math . min ( ans , i - j + 1 ); sum -= nums [ j ++]; } } return ans != Integer . MAX_VALUE ? ans : 0 ; } }","title":"209. Minimum Size Subarray Sum $\\star\\star$"},{"location":"java/0201-0300/0201-0210/#210-course-schedule-ii-starstar","text":"","title":"210. Course Schedule II $\\star\\star$"},{"location":"java/0201-0300/0211-0220/","text":"211. Add and Search Word - Data structure design $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class WordDictionary { public void addWord ( String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ]; } node . isWord = true ; } public boolean search ( String word ) { return dfs ( word , 0 , root ); } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ]; private boolean isWord = false ; } private TrieNode root = new TrieNode (); private boolean dfs ( String word , int depth , TrieNode node ) { if ( depth == word . length ()) return node . isWord ; if ( word . charAt ( depth ) != '.' ) { TrieNode next = node . children [ word . charAt ( depth ) - 'a' ]; return next != null ? dfs ( word , depth + 1 , next ) : false ; } for ( int i = 0 ; i < 26 ; i ++) if ( node . children [ i ] != null && dfs ( word , depth + 1 , node . children [ i ])) return true ; return false ; } } 212. Word Search II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Solution { public List < String > findWords ( char [][] board , String [] words ) { for ( String word : words ) insert ( word ); List < String > ans = new ArrayList <>(); for ( int i = 0 ; i < board . length ; i ++) for ( int j = 0 ; j < board [ 0 ]. length ; j ++) dfs ( board , i , j , root , ans ); return ans ; } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ]; private String word ; } private TrieNode root = new TrieNode (); private void insert ( String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ]; } node . word = word ; } private void dfs ( char [][] board , int i , int j , TrieNode node , List < String > ans ) { if ( i < 0 || i >= board . length || j < 0 || j >= board [ 0 ]. length || board [ i ][ j ] == '*' ) return ; char c = board [ i ][ j ]; int index = ( int ) ( c - 'a' ); TrieNode next = node . children [ index ]; if ( next == null ) return ; if ( next . word != null ) { ans . add ( next . word ); next . word = null ; } board [ i ][ j ] = '*' ; dfs ( board , i + 1 , j , next , ans ); dfs ( board , i - 1 , j , next , ans ); dfs ( board , i , j + 1 , next , ans ); dfs ( board , i , j - 1 , next , ans ); board [ i ][ j ] = c ; } } 213. House Robber II $\\star\\star$ 214. Shortest Palindrome $\\star\\star\\star$ 215. Kth Largest Element in an Array $\\star\\star$ 216. Combination Sum III $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public List < List < Integer >> combinationSum3 ( int k , int n ) { List < List < Integer >> ans = new ArrayList <>(); List < Integer > path = new ArrayList <>(); dfs ( k , n , 1 , path , ans ); return ans ; } private void dfs ( int k , int n , int s , List < Integer > path , List < List < Integer >> ans ) { if ( k == 0 && n == 0 ) { ans . add ( new ArrayList <>( path )); return ; } if ( k == 0 || n < 0 ) return ; for ( int i = s ; i <= 9 ; i ++) { path . add ( i ); dfs ( k - 1 , n - i , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } } 217. Contains Duplicate $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public boolean containsDuplicate ( int [] nums ) { Set < Integer > set = new HashSet <>(); for ( int num : nums ) { if ( set . contains ( num )) return true ; set . add ( num ); } return false ; } } 218. The Skyline Problem $\\star\\star\\star$ 219. Contains Duplicate II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public boolean containsNearbyDuplicate ( int [] nums , int k ) { Set < Integer > set = new HashSet <>(); for ( int i = 0 ; i < nums . length ; i ++) { if ( i > k ) set . remove ( nums [ i - k - 1 ]); if ( set . contains ( nums [ i ])) return true ; set . add ( nums [ i ]); } return false ; } } 220. Contains Duplicate III $\\star\\star$","title":"0211-0220"},{"location":"java/0201-0300/0211-0220/#211-add-and-search-word-data-structure-design-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class WordDictionary { public void addWord ( String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ]; } node . isWord = true ; } public boolean search ( String word ) { return dfs ( word , 0 , root ); } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ]; private boolean isWord = false ; } private TrieNode root = new TrieNode (); private boolean dfs ( String word , int depth , TrieNode node ) { if ( depth == word . length ()) return node . isWord ; if ( word . charAt ( depth ) != '.' ) { TrieNode next = node . children [ word . charAt ( depth ) - 'a' ]; return next != null ? dfs ( word , depth + 1 , next ) : false ; } for ( int i = 0 ; i < 26 ; i ++) if ( node . children [ i ] != null && dfs ( word , depth + 1 , node . children [ i ])) return true ; return false ; } }","title":"211. Add and Search Word - Data structure design $\\star\\star$"},{"location":"java/0201-0300/0211-0220/#212-word-search-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 class Solution { public List < String > findWords ( char [][] board , String [] words ) { for ( String word : words ) insert ( word ); List < String > ans = new ArrayList <>(); for ( int i = 0 ; i < board . length ; i ++) for ( int j = 0 ; j < board [ 0 ]. length ; j ++) dfs ( board , i , j , root , ans ); return ans ; } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ]; private String word ; } private TrieNode root = new TrieNode (); private void insert ( String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ]; } node . word = word ; } private void dfs ( char [][] board , int i , int j , TrieNode node , List < String > ans ) { if ( i < 0 || i >= board . length || j < 0 || j >= board [ 0 ]. length || board [ i ][ j ] == '*' ) return ; char c = board [ i ][ j ]; int index = ( int ) ( c - 'a' ); TrieNode next = node . children [ index ]; if ( next == null ) return ; if ( next . word != null ) { ans . add ( next . word ); next . word = null ; } board [ i ][ j ] = '*' ; dfs ( board , i + 1 , j , next , ans ); dfs ( board , i - 1 , j , next , ans ); dfs ( board , i , j + 1 , next , ans ); dfs ( board , i , j - 1 , next , ans ); board [ i ][ j ] = c ; } }","title":"212. Word Search II $\\star\\star\\star$"},{"location":"java/0201-0300/0211-0220/#213-house-robber-ii-starstar","text":"","title":"213. House Robber II $\\star\\star$"},{"location":"java/0201-0300/0211-0220/#214-shortest-palindrome-starstarstar","text":"","title":"214. Shortest Palindrome $\\star\\star\\star$"},{"location":"java/0201-0300/0211-0220/#215-kth-largest-element-in-an-array-starstar","text":"","title":"215. Kth Largest Element in an Array $\\star\\star$"},{"location":"java/0201-0300/0211-0220/#216-combination-sum-iii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public List < List < Integer >> combinationSum3 ( int k , int n ) { List < List < Integer >> ans = new ArrayList <>(); List < Integer > path = new ArrayList <>(); dfs ( k , n , 1 , path , ans ); return ans ; } private void dfs ( int k , int n , int s , List < Integer > path , List < List < Integer >> ans ) { if ( k == 0 && n == 0 ) { ans . add ( new ArrayList <>( path )); return ; } if ( k == 0 || n < 0 ) return ; for ( int i = s ; i <= 9 ; i ++) { path . add ( i ); dfs ( k - 1 , n - i , i + 1 , path , ans ); path . remove ( path . size () - 1 ); } } }","title":"216. Combination Sum III $\\star\\star$"},{"location":"java/0201-0300/0211-0220/#217-contains-duplicate-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public boolean containsDuplicate ( int [] nums ) { Set < Integer > set = new HashSet <>(); for ( int num : nums ) { if ( set . contains ( num )) return true ; set . add ( num ); } return false ; } }","title":"217. Contains Duplicate $\\star$"},{"location":"java/0201-0300/0211-0220/#218-the-skyline-problem-starstarstar","text":"","title":"218. The Skyline Problem $\\star\\star\\star$"},{"location":"java/0201-0300/0211-0220/#219-contains-duplicate-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public boolean containsNearbyDuplicate ( int [] nums , int k ) { Set < Integer > set = new HashSet <>(); for ( int i = 0 ; i < nums . length ; i ++) { if ( i > k ) set . remove ( nums [ i - k - 1 ]); if ( set . contains ( nums [ i ])) return true ; set . add ( nums [ i ]); } return false ; } }","title":"219. Contains Duplicate II $\\star$"},{"location":"java/0201-0300/0211-0220/#220-contains-duplicate-iii-starstar","text":"","title":"220. Contains Duplicate III $\\star\\star$"},{"location":"java/0201-0300/0221-0230/","text":"221. Maximal Square $\\star\\star$ 222. Count Complete Tree Nodes $\\star\\star$ 223. Rectangle Area $\\star\\star$ 224. Basic Calculator $\\star\\star\\star$ 225. Implement Stack using Queues $\\star$ 226. Invert Binary Tree $\\star$ 227. Basic Calculator II $\\star\\star$ 228. Summary Ranges $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public List < String > summaryRanges ( int [] nums ) { List < String > ans = new ArrayList <>(); for ( int i = 0 ; i < nums . length ; i ++) { int begin = nums [ i ]; while ( i < nums . length - 1 && nums [ i ] == nums [ i + 1 ] - 1 ) i ++; int end = nums [ i ]; if ( begin == end ) ans . add ( \"\" + begin ); else ans . add ( \"\" + begin + \"->\" + end ); } return ans ; } } 229. Majority Element II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public List < Integer > majorityElement ( int [] nums ) { List < Integer > ans = new ArrayList <>(); int ans1 = 0 ; int ans2 = 1 ; int count1 = 0 ; int count2 = 0 ; for ( int num : nums ) { if ( num == ans1 ) count1 ++; else if ( num == ans2 ) count2 ++; else if ( count1 == 0 ) { ans1 = num ; count1 ++; } else if ( count2 == 0 ) { ans2 = num ; count2 ++; } else { count1 --; count2 --; } } count1 = 0 ; count2 = 0 ; for ( int num : nums ) { if ( num == ans1 ) count1 ++; else if ( num == ans2 ) count2 ++; } if ( count1 > nums . length / 3 ) ans . add ( ans1 ); if ( count2 > nums . length / 3 ) ans . add ( ans2 ); return ans ; } } 230. Kth Smallest Element in a BST $\\star\\star$","title":"0221-0230"},{"location":"java/0201-0300/0221-0230/#221-maximal-square-starstar","text":"","title":"221. Maximal Square $\\star\\star$"},{"location":"java/0201-0300/0221-0230/#222-count-complete-tree-nodes-starstar","text":"","title":"222. Count Complete Tree Nodes $\\star\\star$"},{"location":"java/0201-0300/0221-0230/#223-rectangle-area-starstar","text":"","title":"223. Rectangle Area $\\star\\star$"},{"location":"java/0201-0300/0221-0230/#224-basic-calculator-starstarstar","text":"","title":"224. Basic Calculator $\\star\\star\\star$"},{"location":"java/0201-0300/0221-0230/#225-implement-stack-using-queues-star","text":"","title":"225. Implement Stack using Queues $\\star$"},{"location":"java/0201-0300/0221-0230/#226-invert-binary-tree-star","text":"","title":"226. Invert Binary Tree $\\star$"},{"location":"java/0201-0300/0221-0230/#227-basic-calculator-ii-starstar","text":"","title":"227. Basic Calculator II $\\star\\star$"},{"location":"java/0201-0300/0221-0230/#228-summary-ranges-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public List < String > summaryRanges ( int [] nums ) { List < String > ans = new ArrayList <>(); for ( int i = 0 ; i < nums . length ; i ++) { int begin = nums [ i ]; while ( i < nums . length - 1 && nums [ i ] == nums [ i + 1 ] - 1 ) i ++; int end = nums [ i ]; if ( begin == end ) ans . add ( \"\" + begin ); else ans . add ( \"\" + begin + \"->\" + end ); } return ans ; } }","title":"228. Summary Ranges $\\star\\star$"},{"location":"java/0201-0300/0221-0230/#229-majority-element-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public List < Integer > majorityElement ( int [] nums ) { List < Integer > ans = new ArrayList <>(); int ans1 = 0 ; int ans2 = 1 ; int count1 = 0 ; int count2 = 0 ; for ( int num : nums ) { if ( num == ans1 ) count1 ++; else if ( num == ans2 ) count2 ++; else if ( count1 == 0 ) { ans1 = num ; count1 ++; } else if ( count2 == 0 ) { ans2 = num ; count2 ++; } else { count1 --; count2 --; } } count1 = 0 ; count2 = 0 ; for ( int num : nums ) { if ( num == ans1 ) count1 ++; else if ( num == ans2 ) count2 ++; } if ( count1 > nums . length / 3 ) ans . add ( ans1 ); if ( count2 > nums . length / 3 ) ans . add ( ans2 ); return ans ; } }","title":"229. Majority Element II $\\star\\star$"},{"location":"java/0201-0300/0221-0230/#230-kth-smallest-element-in-a-bst-starstar","text":"","title":"230. Kth Smallest Element in a BST $\\star\\star$"},{"location":"java/0201-0300/0231-0240/","text":"231. Power of Two $\\star$ 232. Implement Queue using Stacks $\\star$ 233. Number of Digit One $\\star\\star\\star$ 234. Palindrome Linked List $\\star$ 235. Lowest Common Ancestor of a Binary Search Tree $\\star$ 236. Lowest Common Ancestor of a Binary Tree $\\star\\star$ 237. Delete Node in a Linked List $\\star$ 238. Product of Array Except Self $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int [] productExceptSelf ( int [] nums ) { int [] ans = new int [ nums . length ]; ans [ 0 ] = 1 ; int r = 1 ; for ( int i = 1 ; i < nums . length ; i ++) ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ]; for ( int i = nums . length - 1 ; i >= 0 ; i --) { ans [ i ] *= r ; r *= nums [ i ]; } return ans ; } } 239. Sliding Window Maximum $\\star\\star\\star$ 240. Search a 2D Matrix II $\\star\\star$","title":"0231-0240"},{"location":"java/0201-0300/0231-0240/#231-power-of-two-star","text":"","title":"231. Power of Two $\\star$"},{"location":"java/0201-0300/0231-0240/#232-implement-queue-using-stacks-star","text":"","title":"232. Implement Queue using Stacks $\\star$"},{"location":"java/0201-0300/0231-0240/#233-number-of-digit-one-starstarstar","text":"","title":"233. Number of Digit One $\\star\\star\\star$"},{"location":"java/0201-0300/0231-0240/#234-palindrome-linked-list-star","text":"","title":"234. Palindrome Linked List $\\star$"},{"location":"java/0201-0300/0231-0240/#235-lowest-common-ancestor-of-a-binary-search-tree-star","text":"","title":"235. Lowest Common Ancestor of a Binary Search Tree $\\star$"},{"location":"java/0201-0300/0231-0240/#236-lowest-common-ancestor-of-a-binary-tree-starstar","text":"","title":"236. Lowest Common Ancestor of a Binary Tree $\\star\\star$"},{"location":"java/0201-0300/0231-0240/#237-delete-node-in-a-linked-list-star","text":"","title":"237. Delete Node in a Linked List $\\star$"},{"location":"java/0201-0300/0231-0240/#238-product-of-array-except-self-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int [] productExceptSelf ( int [] nums ) { int [] ans = new int [ nums . length ]; ans [ 0 ] = 1 ; int r = 1 ; for ( int i = 1 ; i < nums . length ; i ++) ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ]; for ( int i = nums . length - 1 ; i >= 0 ; i --) { ans [ i ] *= r ; r *= nums [ i ]; } return ans ; } }","title":"238. Product of Array Except Self $\\star\\star$"},{"location":"java/0201-0300/0231-0240/#239-sliding-window-maximum-starstarstar","text":"","title":"239. Sliding Window Maximum $\\star\\star\\star$"},{"location":"java/0201-0300/0231-0240/#240-search-a-2d-matrix-ii-starstar","text":"","title":"240. Search a 2D Matrix II $\\star\\star$"},{"location":"java/0201-0300/0241-0250/","text":"241. Different Ways to Add Parentheses $\\star\\star$ 242. Valid Anagram $\\star$ 243. Shortest Word Distance $\\star$ 244. Shortest Word Distance II $\\star\\star$ 245. Shortest Word Distance III $\\star\\star$ 246. Strobogrammatic Number $\\star$ 247. Strobogrammatic Number II $\\star\\star$ 248. Strobogrammatic Number III $\\star\\star\\star$ 249. Group Shifted Strings $\\star\\star$ 250. Count Univalue Subtrees $\\star\\star$","title":"0241-0250"},{"location":"java/0201-0300/0241-0250/#241-different-ways-to-add-parentheses-starstar","text":"","title":"241. Different Ways to Add Parentheses $\\star\\star$"},{"location":"java/0201-0300/0241-0250/#242-valid-anagram-star","text":"","title":"242. Valid Anagram $\\star$"},{"location":"java/0201-0300/0241-0250/#243-shortest-word-distance-star","text":"","title":"243. Shortest Word Distance $\\star$"},{"location":"java/0201-0300/0241-0250/#244-shortest-word-distance-ii-starstar","text":"","title":"244. Shortest Word Distance II $\\star\\star$"},{"location":"java/0201-0300/0241-0250/#245-shortest-word-distance-iii-starstar","text":"","title":"245. Shortest Word Distance III $\\star\\star$"},{"location":"java/0201-0300/0241-0250/#246-strobogrammatic-number-star","text":"","title":"246. Strobogrammatic Number $\\star$"},{"location":"java/0201-0300/0241-0250/#247-strobogrammatic-number-ii-starstar","text":"","title":"247. Strobogrammatic Number II $\\star\\star$"},{"location":"java/0201-0300/0241-0250/#248-strobogrammatic-number-iii-starstarstar","text":"","title":"248. Strobogrammatic Number III $\\star\\star\\star$"},{"location":"java/0201-0300/0241-0250/#249-group-shifted-strings-starstar","text":"","title":"249. Group Shifted Strings $\\star\\star$"},{"location":"java/0201-0300/0241-0250/#250-count-univalue-subtrees-starstar","text":"","title":"250. Count Univalue Subtrees $\\star\\star$"},{"location":"java/0201-0300/0251-0260/","text":"251. Flatten 2D Vector $\\star\\star$ 252. Meeting Rooms $\\star$ 253. Meeting Rooms II $\\star\\star$ 254. Factor Combinations $\\star\\star$ 255. Verify Preorder Sequence in Binary Search Tree $\\star\\star$ 256. Paint House $\\star$ 257. Binary Tree Paths $\\star$ 258. Add Digits $\\star$ 259. 3Sum Smaller $\\star\\star$ 260. Single Number III $\\star\\star$","title":"0251-0260"},{"location":"java/0201-0300/0251-0260/#251-flatten-2d-vector-starstar","text":"","title":"251. Flatten 2D Vector $\\star\\star$"},{"location":"java/0201-0300/0251-0260/#252-meeting-rooms-star","text":"","title":"252. Meeting Rooms $\\star$"},{"location":"java/0201-0300/0251-0260/#253-meeting-rooms-ii-starstar","text":"","title":"253. Meeting Rooms II $\\star\\star$"},{"location":"java/0201-0300/0251-0260/#254-factor-combinations-starstar","text":"","title":"254. Factor Combinations $\\star\\star$"},{"location":"java/0201-0300/0251-0260/#255-verify-preorder-sequence-in-binary-search-tree-starstar","text":"","title":"255. Verify Preorder Sequence in Binary Search Tree $\\star\\star$"},{"location":"java/0201-0300/0251-0260/#256-paint-house-star","text":"","title":"256. Paint House $\\star$"},{"location":"java/0201-0300/0251-0260/#257-binary-tree-paths-star","text":"","title":"257. Binary Tree Paths $\\star$"},{"location":"java/0201-0300/0251-0260/#258-add-digits-star","text":"","title":"258. Add Digits $\\star$"},{"location":"java/0201-0300/0251-0260/#259-3sum-smaller-starstar","text":"","title":"259. 3Sum Smaller $\\star\\star$"},{"location":"java/0201-0300/0251-0260/#260-single-number-iii-starstar","text":"","title":"260. Single Number III $\\star\\star$"},{"location":"java/0201-0300/0261-0270/","text":"261. Graph Valid Tree $\\star\\star$ 262. Trips and Users $\\star\\star\\star$ 263. Ugly Number $\\star$ 264. Ugly Number II $\\star\\star$ 265. Paint House II $\\star\\star\\star$ 266. Palindrome Permutation $\\star$ 267. Palindrome Permutation II $\\star\\star$ 268. Missing Number $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public int missingNumber ( int [] nums ) { int ans = nums . length ; for ( int i = 0 ; i < nums . length ; i ++) ans ^= i ^ nums [ i ]; return ans ; } } 269. Alien Dictionary $\\star\\star\\star$ 270. Closest Binary Search Tree Value $\\star$","title":"0261-0270"},{"location":"java/0201-0300/0261-0270/#261-graph-valid-tree-starstar","text":"","title":"261. Graph Valid Tree $\\star\\star$"},{"location":"java/0201-0300/0261-0270/#262-trips-and-users-starstarstar","text":"","title":"262. Trips and Users $\\star\\star\\star$"},{"location":"java/0201-0300/0261-0270/#263-ugly-number-star","text":"","title":"263. Ugly Number $\\star$"},{"location":"java/0201-0300/0261-0270/#264-ugly-number-ii-starstar","text":"","title":"264. Ugly Number II $\\star\\star$"},{"location":"java/0201-0300/0261-0270/#265-paint-house-ii-starstarstar","text":"","title":"265. Paint House II $\\star\\star\\star$"},{"location":"java/0201-0300/0261-0270/#266-palindrome-permutation-star","text":"","title":"266. Palindrome Permutation $\\star$"},{"location":"java/0201-0300/0261-0270/#267-palindrome-permutation-ii-starstar","text":"","title":"267. Palindrome Permutation II $\\star\\star$"},{"location":"java/0201-0300/0261-0270/#268-missing-number-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public int missingNumber ( int [] nums ) { int ans = nums . length ; for ( int i = 0 ; i < nums . length ; i ++) ans ^= i ^ nums [ i ]; return ans ; } }","title":"268. Missing Number $\\star$"},{"location":"java/0201-0300/0261-0270/#269-alien-dictionary-starstarstar","text":"","title":"269. Alien Dictionary $\\star\\star\\star$"},{"location":"java/0201-0300/0261-0270/#270-closest-binary-search-tree-value-star","text":"","title":"270. Closest Binary Search Tree Value $\\star$"},{"location":"java/0201-0300/0271-0280/","text":"271. Encode and Decode Strings $\\star\\star$ 272. Closest Binary Search Tree Value II $\\star\\star\\star$ 273. Integer to English Words $\\star\\star\\star$ 274. H-Index $\\star\\star$ 275. H-Index II $\\star\\star$ 276. Paint Fence $\\star$ 277. Find the Celebrity $\\star\\star$ 278. First Bad Version $\\star$ 279. Perfect Squares $\\star\\star$ 280. Wiggle Sort $\\star\\star$","title":"0271-0280"},{"location":"java/0201-0300/0271-0280/#271-encode-and-decode-strings-starstar","text":"","title":"271. Encode and Decode Strings $\\star\\star$"},{"location":"java/0201-0300/0271-0280/#272-closest-binary-search-tree-value-ii-starstarstar","text":"","title":"272. Closest Binary Search Tree Value II $\\star\\star\\star$"},{"location":"java/0201-0300/0271-0280/#273-integer-to-english-words-starstarstar","text":"","title":"273. Integer to English Words $\\star\\star\\star$"},{"location":"java/0201-0300/0271-0280/#274-h-index-starstar","text":"","title":"274. H-Index $\\star\\star$"},{"location":"java/0201-0300/0271-0280/#275-h-index-ii-starstar","text":"","title":"275. H-Index II $\\star\\star$"},{"location":"java/0201-0300/0271-0280/#276-paint-fence-star","text":"","title":"276. Paint Fence $\\star$"},{"location":"java/0201-0300/0271-0280/#277-find-the-celebrity-starstar","text":"","title":"277. Find the Celebrity $\\star\\star$"},{"location":"java/0201-0300/0271-0280/#278-first-bad-version-star","text":"","title":"278. First Bad Version $\\star$"},{"location":"java/0201-0300/0271-0280/#279-perfect-squares-starstar","text":"","title":"279. Perfect Squares $\\star\\star$"},{"location":"java/0201-0300/0271-0280/#280-wiggle-sort-starstar","text":"","title":"280. Wiggle Sort $\\star\\star$"},{"location":"java/0201-0300/0281-0290/","text":"281. Zigzag Iterator $\\star\\star$ 282. Expression Add Operators $\\star\\star\\star$ 283. Move Zeroes $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public void moveZeroes ( int [] nums ) { int j = 0 ; for ( int num : nums ) if ( num != 0 ) nums [ j ++] = num ; for ( int i = j ; i < nums . length ; i ++) nums [ i ] = 0 ; } } 284. Peeking Iterator $\\star\\star$ 285. Inorder Successor in BST $\\star\\star$ 286. Walls and Gates $\\star\\star$ 287. Find the Duplicate Number $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int findDuplicate ( int [] nums ) { int slow = nums [ nums [ 0 ]]; int fast = nums [ nums [ nums [ 0 ]]]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ nums [ fast ]]; } slow = nums [ 0 ]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ fast ]; } return slow ; } } 288. Unique Word Abbreviation $\\star\\star$ 289. Game of Life $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public void gameOfLife ( int [][] board ) { final int m = board . length ; final int n = board [ 0 ]. length ; for ( int i = 0 ; i < m ; i ++) for ( int j = 0 ; j < n ; j ++) { int ones = 0 ; for ( int y = Math . max ( 0 , i - 1 ); y < Math . min ( m , i + 2 ); y ++) for ( int x = Math . max ( 0 , j - 1 ); x < Math . min ( n , j + 2 ); x ++) ones += board [ y ][ x ] & 1 ; if (( board [ i ][ j ] == 1 && ( ones == 3 || ones == 4 )) || ( board [ i ][ j ] == 0 && ones == 3 )) board [ i ][ j ] |= 0b10 ; } for ( int i = 0 ; i < m ; i ++) for ( int j = 0 ; j < n ; j ++) board [ i ][ j ] >>= 1 ; } } 290. Word Pattern $\\star$","title":"0281-0290"},{"location":"java/0201-0300/0281-0290/#281-zigzag-iterator-starstar","text":"","title":"281. Zigzag Iterator $\\star\\star$"},{"location":"java/0201-0300/0281-0290/#282-expression-add-operators-starstarstar","text":"","title":"282. Expression Add Operators $\\star\\star\\star$"},{"location":"java/0201-0300/0281-0290/#283-move-zeroes-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public void moveZeroes ( int [] nums ) { int j = 0 ; for ( int num : nums ) if ( num != 0 ) nums [ j ++] = num ; for ( int i = j ; i < nums . length ; i ++) nums [ i ] = 0 ; } }","title":"283. Move Zeroes $\\star$"},{"location":"java/0201-0300/0281-0290/#284-peeking-iterator-starstar","text":"","title":"284. Peeking Iterator $\\star\\star$"},{"location":"java/0201-0300/0281-0290/#285-inorder-successor-in-bst-starstar","text":"","title":"285. Inorder Successor in BST $\\star\\star$"},{"location":"java/0201-0300/0281-0290/#286-walls-and-gates-starstar","text":"","title":"286. Walls and Gates $\\star\\star$"},{"location":"java/0201-0300/0281-0290/#287-find-the-duplicate-number-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int findDuplicate ( int [] nums ) { int slow = nums [ nums [ 0 ]]; int fast = nums [ nums [ nums [ 0 ]]]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ nums [ fast ]]; } slow = nums [ 0 ]; while ( slow != fast ) { slow = nums [ slow ]; fast = nums [ fast ]; } return slow ; } }","title":"287. Find the Duplicate Number $\\star\\star$"},{"location":"java/0201-0300/0281-0290/#288-unique-word-abbreviation-starstar","text":"","title":"288. Unique Word Abbreviation $\\star\\star$"},{"location":"java/0201-0300/0281-0290/#289-game-of-life-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public void gameOfLife ( int [][] board ) { final int m = board . length ; final int n = board [ 0 ]. length ; for ( int i = 0 ; i < m ; i ++) for ( int j = 0 ; j < n ; j ++) { int ones = 0 ; for ( int y = Math . max ( 0 , i - 1 ); y < Math . min ( m , i + 2 ); y ++) for ( int x = Math . max ( 0 , j - 1 ); x < Math . min ( n , j + 2 ); x ++) ones += board [ y ][ x ] & 1 ; if (( board [ i ][ j ] == 1 && ( ones == 3 || ones == 4 )) || ( board [ i ][ j ] == 0 && ones == 3 )) board [ i ][ j ] |= 0b10 ; } for ( int i = 0 ; i < m ; i ++) for ( int j = 0 ; j < n ; j ++) board [ i ][ j ] >>= 1 ; } }","title":"289. Game of Life $\\star\\star$"},{"location":"java/0201-0300/0281-0290/#290-word-pattern-star","text":"","title":"290. Word Pattern $\\star$"},{"location":"java/0201-0300/0291-0300/","text":"291. Word Pattern II $\\star\\star\\star$ 292. Nim Game $\\star$ 293. Flip Game $\\star$ 294. Flip Game II $\\star\\star$ 295. Find Median from Data Stream $\\star\\star\\star$ 296. Best Meeting Point $\\star\\star\\star$ 297. Serialize and Deserialize Binary Tree $\\star\\star\\star$ 298. Binary Tree Longest Consecutive Sequence $\\star\\star$ 299. Bulls and Cows $\\star$ 300. Longest Increasing Subsequence $\\star\\star$","title":"0291-0300"},{"location":"java/0201-0300/0291-0300/#291-word-pattern-ii-starstarstar","text":"","title":"291. Word Pattern II $\\star\\star\\star$"},{"location":"java/0201-0300/0291-0300/#292-nim-game-star","text":"","title":"292. Nim Game $\\star$"},{"location":"java/0201-0300/0291-0300/#293-flip-game-star","text":"","title":"293. Flip Game $\\star$"},{"location":"java/0201-0300/0291-0300/#294-flip-game-ii-starstar","text":"","title":"294. Flip Game II $\\star\\star$"},{"location":"java/0201-0300/0291-0300/#295-find-median-from-data-stream-starstarstar","text":"","title":"295. Find Median from Data Stream $\\star\\star\\star$"},{"location":"java/0201-0300/0291-0300/#296-best-meeting-point-starstarstar","text":"","title":"296. Best Meeting Point $\\star\\star\\star$"},{"location":"java/0201-0300/0291-0300/#297-serialize-and-deserialize-binary-tree-starstarstar","text":"","title":"297. Serialize and Deserialize Binary Tree $\\star\\star\\star$"},{"location":"java/0201-0300/0291-0300/#298-binary-tree-longest-consecutive-sequence-starstar","text":"","title":"298. Binary Tree Longest Consecutive Sequence $\\star\\star$"},{"location":"java/0201-0300/0291-0300/#299-bulls-and-cows-star","text":"","title":"299. Bulls and Cows $\\star$"},{"location":"java/0201-0300/0291-0300/#300-longest-increasing-subsequence-starstar","text":"","title":"300. Longest Increasing Subsequence $\\star\\star$"},{"location":"java/0301-0400/0301-0310/","text":"301. Remove Invalid Parentheses $\\star\\star\\star$ 302. Smallest Rectangle Enclosing Black Pixels $\\star\\star\\star$ 303. Range Sum Query - Immutable $\\star$ 304. Range Sum Query 2D - Immutable $\\star\\star$ 305. Number of Islands II $\\star\\star\\star$ 306. Additive Number $\\star\\star$ 307. Range Sum Query - Mutable $\\star\\star$ 308. Range Sum Query 2D - Mutable $\\star\\star\\star$ 309. Best Time to Buy and Sell Stock with Cooldown $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int maxProfit ( int [] prices ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; int prev = 0 ; for ( int price : prices ) { int cache = sell ; sell = Math . max ( sell , hold + price ); hold = Math . max ( hold , prev - price ); prev = cache ; } return sell ; } } 310. Minimum Height Trees $\\star\\star$","title":"0301-0310"},{"location":"java/0301-0400/0301-0310/#301-remove-invalid-parentheses-starstarstar","text":"","title":"301. Remove Invalid Parentheses $\\star\\star\\star$"},{"location":"java/0301-0400/0301-0310/#302-smallest-rectangle-enclosing-black-pixels-starstarstar","text":"","title":"302. Smallest Rectangle Enclosing Black Pixels $\\star\\star\\star$"},{"location":"java/0301-0400/0301-0310/#303-range-sum-query-immutable-star","text":"","title":"303. Range Sum Query - Immutable $\\star$"},{"location":"java/0301-0400/0301-0310/#304-range-sum-query-2d-immutable-starstar","text":"","title":"304. Range Sum Query 2D - Immutable $\\star\\star$"},{"location":"java/0301-0400/0301-0310/#305-number-of-islands-ii-starstarstar","text":"","title":"305. Number of Islands II $\\star\\star\\star$"},{"location":"java/0301-0400/0301-0310/#306-additive-number-starstar","text":"","title":"306. Additive Number $\\star\\star$"},{"location":"java/0301-0400/0301-0310/#307-range-sum-query-mutable-starstar","text":"","title":"307. Range Sum Query - Mutable $\\star\\star$"},{"location":"java/0301-0400/0301-0310/#308-range-sum-query-2d-mutable-starstarstar","text":"","title":"308. Range Sum Query 2D - Mutable $\\star\\star\\star$"},{"location":"java/0301-0400/0301-0310/#309-best-time-to-buy-and-sell-stock-with-cooldown-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int maxProfit ( int [] prices ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; int prev = 0 ; for ( int price : prices ) { int cache = sell ; sell = Math . max ( sell , hold + price ); hold = Math . max ( hold , prev - price ); prev = cache ; } return sell ; } }","title":"309. Best Time to Buy and Sell Stock with Cooldown $\\star\\star$"},{"location":"java/0301-0400/0301-0310/#310-minimum-height-trees-starstar","text":"","title":"310. Minimum Height Trees $\\star\\star$"},{"location":"java/0301-0400/0311-0320/","text":"311. Sparse Matrix Multiplication $\\star\\star$ 312. Burst Balloons $\\star\\star\\star$ 313. Super Ugly Number $\\star\\star$ 314. Binary Tree Vertical Order Traversal $\\star\\star$ 315. Count of Smaller Numbers After Self $\\star\\star\\star$ 316. Remove Duplicate Letters $\\star\\star\\star$ 317. Shortest Distance from All Buildings $\\star\\star\\star$ 318. Maximum Product of Word Lengths $\\star\\star$ 319. Bulb Switcher $\\star\\star$ 320. Generalized Abbreviation $\\star\\star$","title":"0311-0320"},{"location":"java/0301-0400/0311-0320/#311-sparse-matrix-multiplication-starstar","text":"","title":"311. Sparse Matrix Multiplication $\\star\\star$"},{"location":"java/0301-0400/0311-0320/#312-burst-balloons-starstarstar","text":"","title":"312. Burst Balloons $\\star\\star\\star$"},{"location":"java/0301-0400/0311-0320/#313-super-ugly-number-starstar","text":"","title":"313. Super Ugly Number $\\star\\star$"},{"location":"java/0301-0400/0311-0320/#314-binary-tree-vertical-order-traversal-starstar","text":"","title":"314. Binary Tree Vertical Order Traversal $\\star\\star$"},{"location":"java/0301-0400/0311-0320/#315-count-of-smaller-numbers-after-self-starstarstar","text":"","title":"315. Count of Smaller Numbers After Self $\\star\\star\\star$"},{"location":"java/0301-0400/0311-0320/#316-remove-duplicate-letters-starstarstar","text":"","title":"316. Remove Duplicate Letters $\\star\\star\\star$"},{"location":"java/0301-0400/0311-0320/#317-shortest-distance-from-all-buildings-starstarstar","text":"","title":"317. Shortest Distance from All Buildings $\\star\\star\\star$"},{"location":"java/0301-0400/0311-0320/#318-maximum-product-of-word-lengths-starstar","text":"","title":"318. Maximum Product of Word Lengths $\\star\\star$"},{"location":"java/0301-0400/0311-0320/#319-bulb-switcher-starstar","text":"","title":"319. Bulb Switcher $\\star\\star$"},{"location":"java/0301-0400/0311-0320/#320-generalized-abbreviation-starstar","text":"","title":"320. Generalized Abbreviation $\\star\\star$"},{"location":"java/0301-0400/0321-0330/","text":"321. Create Maximum Number $\\star\\star\\star$ 322. Coin Change $\\star\\star$ 323. Number of Connected Components in an Undirected Graph $\\star\\star$ 324. Wiggle Sort II $\\star\\star$ 325. Maximum Size Subarray Sum Equals k $\\star\\star$ 326. Power of Three $\\star$ 327. Count of Range Sum $\\star\\star\\star$ 328. Odd Even Linked List $\\star\\star$ 329. Longest Increasing Path in a Matrix $\\star\\star\\star$ 330. Patching Array $\\star\\star\\star$","title":"0321-0330"},{"location":"java/0301-0400/0321-0330/#321-create-maximum-number-starstarstar","text":"","title":"321. Create Maximum Number $\\star\\star\\star$"},{"location":"java/0301-0400/0321-0330/#322-coin-change-starstar","text":"","title":"322. Coin Change $\\star\\star$"},{"location":"java/0301-0400/0321-0330/#323-number-of-connected-components-in-an-undirected-graph-starstar","text":"","title":"323. Number of Connected Components in an Undirected Graph $\\star\\star$"},{"location":"java/0301-0400/0321-0330/#324-wiggle-sort-ii-starstar","text":"","title":"324. Wiggle Sort II $\\star\\star$"},{"location":"java/0301-0400/0321-0330/#325-maximum-size-subarray-sum-equals-k-starstar","text":"","title":"325. Maximum Size Subarray Sum Equals k $\\star\\star$"},{"location":"java/0301-0400/0321-0330/#326-power-of-three-star","text":"","title":"326. Power of Three $\\star$"},{"location":"java/0301-0400/0321-0330/#327-count-of-range-sum-starstarstar","text":"","title":"327. Count of Range Sum $\\star\\star\\star$"},{"location":"java/0301-0400/0321-0330/#328-odd-even-linked-list-starstar","text":"","title":"328. Odd Even Linked List $\\star\\star$"},{"location":"java/0301-0400/0321-0330/#329-longest-increasing-path-in-a-matrix-starstarstar","text":"","title":"329. Longest Increasing Path in a Matrix $\\star\\star\\star$"},{"location":"java/0301-0400/0321-0330/#330-patching-array-starstarstar","text":"","title":"330. Patching Array $\\star\\star\\star$"},{"location":"java/0301-0400/0331-0340/","text":"331. Verify Preorder Serialization of a Binary Tree $\\star\\star$ 332. Reconstruct Itinerary $\\star\\star$ 333. Largest BST Subtree $\\star\\star$ 334. Increasing Triplet Subsequence $\\star\\star$ 335. Self Crossing $\\star\\star\\star$ 336. Palindrome Pairs $\\star\\star\\star$ 337. House Robber III $\\star\\star$ 338. Counting Bits $\\star\\star$ 339. Nested List Weight Sum $\\star$ 340. Longest Substring with At Most K Distinct Characters $\\star\\star\\star$","title":"0331-0340"},{"location":"java/0301-0400/0331-0340/#331-verify-preorder-serialization-of-a-binary-tree-starstar","text":"","title":"331. Verify Preorder Serialization of a Binary Tree $\\star\\star$"},{"location":"java/0301-0400/0331-0340/#332-reconstruct-itinerary-starstar","text":"","title":"332. Reconstruct Itinerary $\\star\\star$"},{"location":"java/0301-0400/0331-0340/#333-largest-bst-subtree-starstar","text":"","title":"333. Largest BST Subtree $\\star\\star$"},{"location":"java/0301-0400/0331-0340/#334-increasing-triplet-subsequence-starstar","text":"","title":"334. Increasing Triplet Subsequence $\\star\\star$"},{"location":"java/0301-0400/0331-0340/#335-self-crossing-starstarstar","text":"","title":"335. Self Crossing $\\star\\star\\star$"},{"location":"java/0301-0400/0331-0340/#336-palindrome-pairs-starstarstar","text":"","title":"336. Palindrome Pairs $\\star\\star\\star$"},{"location":"java/0301-0400/0331-0340/#337-house-robber-iii-starstar","text":"","title":"337. House Robber III $\\star\\star$"},{"location":"java/0301-0400/0331-0340/#338-counting-bits-starstar","text":"","title":"338. Counting Bits $\\star\\star$"},{"location":"java/0301-0400/0331-0340/#339-nested-list-weight-sum-star","text":"","title":"339. Nested List Weight Sum $\\star$"},{"location":"java/0301-0400/0331-0340/#340-longest-substring-with-at-most-k-distinct-characters-starstarstar","text":"","title":"340. Longest Substring with At Most K Distinct Characters $\\star\\star\\star$"},{"location":"java/0301-0400/0341-0350/","text":"341. Flatten Nested List Iterator $\\star\\star$ 342. Power of Four $\\star$ 343. Integer Break $\\star\\star$ 344. Reverse String $\\star$ 345. Reverse Vowels of a String $\\star$ 346. Moving Average from Data Stream $\\star$ 347. Top K Frequent Elements $\\star\\star$ 348. Design Tic-Tac-Toe $\\star\\star$ 349. Intersection of Two Arrays $\\star$ 350. Intersection of Two Arrays II $\\star$","title":"0341-0350"},{"location":"java/0301-0400/0341-0350/#341-flatten-nested-list-iterator-starstar","text":"","title":"341. Flatten Nested List Iterator $\\star\\star$"},{"location":"java/0301-0400/0341-0350/#342-power-of-four-star","text":"","title":"342. Power of Four $\\star$"},{"location":"java/0301-0400/0341-0350/#343-integer-break-starstar","text":"","title":"343. Integer Break $\\star\\star$"},{"location":"java/0301-0400/0341-0350/#344-reverse-string-star","text":"","title":"344. Reverse String $\\star$"},{"location":"java/0301-0400/0341-0350/#345-reverse-vowels-of-a-string-star","text":"","title":"345. Reverse Vowels of a String $\\star$"},{"location":"java/0301-0400/0341-0350/#346-moving-average-from-data-stream-star","text":"","title":"346. Moving Average from Data Stream $\\star$"},{"location":"java/0301-0400/0341-0350/#347-top-k-frequent-elements-starstar","text":"","title":"347. Top K Frequent Elements $\\star\\star$"},{"location":"java/0301-0400/0341-0350/#348-design-tic-tac-toe-starstar","text":"","title":"348. Design Tic-Tac-Toe $\\star\\star$"},{"location":"java/0301-0400/0341-0350/#349-intersection-of-two-arrays-star","text":"","title":"349. Intersection of Two Arrays $\\star$"},{"location":"java/0301-0400/0341-0350/#350-intersection-of-two-arrays-ii-star","text":"","title":"350. Intersection of Two Arrays II $\\star$"},{"location":"java/0301-0400/0351-0360/","text":"351. Android Unlock Patterns $\\star\\star$ 352. Data Stream as Disjoint Intervals $\\star\\star\\star$ 353. Design Snake Game $\\star\\star$ 354. Russian Doll Envelopes $\\star\\star\\star$ 355. Design Twitter $\\star\\star$ 356. Line Reflection $\\star\\star$ 357. Count Numbers with Unique Digits $\\star\\star$ 358. Rearrange String k Distance Apart $\\star\\star\\star$ 359. Logger Rate Limiter $\\star$ 360. Sort Transformed Array $\\star\\star$","title":"0351-0360"},{"location":"java/0301-0400/0351-0360/#351-android-unlock-patterns-starstar","text":"","title":"351. Android Unlock Patterns $\\star\\star$"},{"location":"java/0301-0400/0351-0360/#352-data-stream-as-disjoint-intervals-starstarstar","text":"","title":"352. Data Stream as Disjoint Intervals $\\star\\star\\star$"},{"location":"java/0301-0400/0351-0360/#353-design-snake-game-starstar","text":"","title":"353. Design Snake Game $\\star\\star$"},{"location":"java/0301-0400/0351-0360/#354-russian-doll-envelopes-starstarstar","text":"","title":"354. Russian Doll Envelopes $\\star\\star\\star$"},{"location":"java/0301-0400/0351-0360/#355-design-twitter-starstar","text":"","title":"355. Design Twitter $\\star\\star$"},{"location":"java/0301-0400/0351-0360/#356-line-reflection-starstar","text":"","title":"356. Line Reflection $\\star\\star$"},{"location":"java/0301-0400/0351-0360/#357-count-numbers-with-unique-digits-starstar","text":"","title":"357. Count Numbers with Unique Digits $\\star\\star$"},{"location":"java/0301-0400/0351-0360/#358-rearrange-string-k-distance-apart-starstarstar","text":"","title":"358. Rearrange String k Distance Apart $\\star\\star\\star$"},{"location":"java/0301-0400/0351-0360/#359-logger-rate-limiter-star","text":"","title":"359. Logger Rate Limiter $\\star$"},{"location":"java/0301-0400/0351-0360/#360-sort-transformed-array-starstar","text":"","title":"360. Sort Transformed Array $\\star\\star$"},{"location":"java/0301-0400/0361-0370/","text":"361. Bomb Enemy $\\star\\star$ 362. Design Hit Counter $\\star\\star$ 363. Max Sum of Rectangle No Larger Than K $\\star\\star\\star$ 364. Nested List Weight Sum II $\\star\\star$ 365. Water and Jug Problem $\\star\\star$ 366. Find Leaves of Binary Tree $\\star\\star$ 367. Valid Perfect Square $\\star$ 368. Largest Divisible Subset $\\star\\star$ 369. Plus One Linked List $\\star\\star$ 370. Range Addition $\\star\\star$","title":"0361-0370"},{"location":"java/0301-0400/0361-0370/#361-bomb-enemy-starstar","text":"","title":"361. Bomb Enemy $\\star\\star$"},{"location":"java/0301-0400/0361-0370/#362-design-hit-counter-starstar","text":"","title":"362. Design Hit Counter $\\star\\star$"},{"location":"java/0301-0400/0361-0370/#363-max-sum-of-rectangle-no-larger-than-k-starstarstar","text":"","title":"363. Max Sum of Rectangle No Larger Than K $\\star\\star\\star$"},{"location":"java/0301-0400/0361-0370/#364-nested-list-weight-sum-ii-starstar","text":"","title":"364. Nested List Weight Sum II $\\star\\star$"},{"location":"java/0301-0400/0361-0370/#365-water-and-jug-problem-starstar","text":"","title":"365. Water and Jug Problem $\\star\\star$"},{"location":"java/0301-0400/0361-0370/#366-find-leaves-of-binary-tree-starstar","text":"","title":"366. Find Leaves of Binary Tree $\\star\\star$"},{"location":"java/0301-0400/0361-0370/#367-valid-perfect-square-star","text":"","title":"367. Valid Perfect Square $\\star$"},{"location":"java/0301-0400/0361-0370/#368-largest-divisible-subset-starstar","text":"","title":"368. Largest Divisible Subset $\\star\\star$"},{"location":"java/0301-0400/0361-0370/#369-plus-one-linked-list-starstar","text":"","title":"369. Plus One Linked List $\\star\\star$"},{"location":"java/0301-0400/0361-0370/#370-range-addition-starstar","text":"","title":"370. Range Addition $\\star\\star$"},{"location":"java/0301-0400/0371-0380/","text":"371. Sum of Two Integers $\\star$ 372. Super Pow $\\star\\star$ 373. Find K Pairs with Smallest Sums $\\star\\star$ 374. Guess Number Higher or Lower $\\star$ 375. Guess Number Higher or Lower II $\\star\\star$ 376. Wiggle Subsequence $\\star\\star$ 377. Combination Sum IV $\\star\\star$ 378. Kth Smallest Element in a Sorted Matrix $\\star\\star$ 379. Design Phone Directory $\\star\\star$ 380. Insert Delete GetRandom O(1) $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class RandomizedSet { public boolean insert ( int val ) { if ( map . containsKey ( val )) return false ; map . put ( val , vals . size ()); vals . add ( val ); return true ; } public boolean remove ( int val ) { if (! map . containsKey ( val )) return false ; int index = map . get ( val ); map . put ( vals . get ( vals . size () - 1 ), index ); map . remove ( val ); vals . set ( index , vals . get ( vals . size () - 1 )); vals . remove ( vals . size () - 1 ); return true ; } public int getRandom () { int index = rand . nextInt ( vals . size ()); return vals . get ( index ); } private List < Integer > vals = new ArrayList <>(); private Map < Integer , Integer > map = new HashMap <>(); private Random rand = new Random (); }","title":"0371-0380"},{"location":"java/0301-0400/0371-0380/#371-sum-of-two-integers-star","text":"","title":"371. Sum of Two Integers $\\star$"},{"location":"java/0301-0400/0371-0380/#372-super-pow-starstar","text":"","title":"372. Super Pow $\\star\\star$"},{"location":"java/0301-0400/0371-0380/#373-find-k-pairs-with-smallest-sums-starstar","text":"","title":"373. Find K Pairs with Smallest Sums $\\star\\star$"},{"location":"java/0301-0400/0371-0380/#374-guess-number-higher-or-lower-star","text":"","title":"374. Guess Number Higher or Lower $\\star$"},{"location":"java/0301-0400/0371-0380/#375-guess-number-higher-or-lower-ii-starstar","text":"","title":"375. Guess Number Higher or Lower II $\\star\\star$"},{"location":"java/0301-0400/0371-0380/#376-wiggle-subsequence-starstar","text":"","title":"376. Wiggle Subsequence $\\star\\star$"},{"location":"java/0301-0400/0371-0380/#377-combination-sum-iv-starstar","text":"","title":"377. Combination Sum IV $\\star\\star$"},{"location":"java/0301-0400/0371-0380/#378-kth-smallest-element-in-a-sorted-matrix-starstar","text":"","title":"378. Kth Smallest Element in a Sorted Matrix $\\star\\star$"},{"location":"java/0301-0400/0371-0380/#379-design-phone-directory-starstar","text":"","title":"379. Design Phone Directory $\\star\\star$"},{"location":"java/0301-0400/0371-0380/#380-insert-delete-getrandom-o1-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class RandomizedSet { public boolean insert ( int val ) { if ( map . containsKey ( val )) return false ; map . put ( val , vals . size ()); vals . add ( val ); return true ; } public boolean remove ( int val ) { if (! map . containsKey ( val )) return false ; int index = map . get ( val ); map . put ( vals . get ( vals . size () - 1 ), index ); map . remove ( val ); vals . set ( index , vals . get ( vals . size () - 1 )); vals . remove ( vals . size () - 1 ); return true ; } public int getRandom () { int index = rand . nextInt ( vals . size ()); return vals . get ( index ); } private List < Integer > vals = new ArrayList <>(); private Map < Integer , Integer > map = new HashMap <>(); private Random rand = new Random (); }","title":"380. Insert Delete GetRandom O(1) $\\star\\star$"},{"location":"java/0301-0400/0381-0390/","text":"381. Insert Delete GetRandom O(1) - Duplicates allowed $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class RandomizedCollection { public boolean insert ( int val ) { if (! map . containsKey ( val )) map . put ( val , new LinkedHashSet <>()); map . get ( val ). add ( vals . size ()); vals . add ( val ); return map . get ( val ). size () == 1 ; } public boolean remove ( int val ) { if (! map . containsKey ( val ) || map . get ( val ). isEmpty ()) return false ; int index = map . get ( val ). iterator (). next (); int lastVal = vals . get ( vals . size () - 1 ); vals . set ( index , lastVal ); vals . remove ( vals . size () - 1 ); map . get ( val ). remove ( index ); map . get ( lastVal ). add ( index ); map . get ( lastVal ). remove ( vals . size ()); return true ; } public int getRandom () { int index = rand . nextInt ( vals . size ()); return vals . get ( index ); } private List < Integer > vals = new ArrayList <>(); private Map < Integer , LinkedHashSet < Integer >> map = new HashMap <>(); private Random rand = new Random (); } 382. Linked List Random Node $\\star\\star$ 383. Ransom Note $\\star$ 384. Shuffle an Array $\\star\\star$ 385. Mini Parser $\\star\\star$ 386. Lexicographical Numbers $\\star\\star$ 387. First Unique Character in a String $\\star$ 388. Longest Absolute File Path $\\star\\star$ 389. Find the Difference $\\star$ 390. Elimination Game $\\star\\star$","title":"0381-0390"},{"location":"java/0301-0400/0381-0390/#381-insert-delete-getrandom-o1-duplicates-allowed-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class RandomizedCollection { public boolean insert ( int val ) { if (! map . containsKey ( val )) map . put ( val , new LinkedHashSet <>()); map . get ( val ). add ( vals . size ()); vals . add ( val ); return map . get ( val ). size () == 1 ; } public boolean remove ( int val ) { if (! map . containsKey ( val ) || map . get ( val ). isEmpty ()) return false ; int index = map . get ( val ). iterator (). next (); int lastVal = vals . get ( vals . size () - 1 ); vals . set ( index , lastVal ); vals . remove ( vals . size () - 1 ); map . get ( val ). remove ( index ); map . get ( lastVal ). add ( index ); map . get ( lastVal ). remove ( vals . size ()); return true ; } public int getRandom () { int index = rand . nextInt ( vals . size ()); return vals . get ( index ); } private List < Integer > vals = new ArrayList <>(); private Map < Integer , LinkedHashSet < Integer >> map = new HashMap <>(); private Random rand = new Random (); }","title":"381. Insert Delete GetRandom O(1) - Duplicates allowed $\\star\\star\\star$"},{"location":"java/0301-0400/0381-0390/#382-linked-list-random-node-starstar","text":"","title":"382. Linked List Random Node $\\star\\star$"},{"location":"java/0301-0400/0381-0390/#383-ransom-note-star","text":"","title":"383. Ransom Note $\\star$"},{"location":"java/0301-0400/0381-0390/#384-shuffle-an-array-starstar","text":"","title":"384. Shuffle an Array $\\star\\star$"},{"location":"java/0301-0400/0381-0390/#385-mini-parser-starstar","text":"","title":"385. Mini Parser $\\star\\star$"},{"location":"java/0301-0400/0381-0390/#386-lexicographical-numbers-starstar","text":"","title":"386. Lexicographical Numbers $\\star\\star$"},{"location":"java/0301-0400/0381-0390/#387-first-unique-character-in-a-string-star","text":"","title":"387. First Unique Character in a String $\\star$"},{"location":"java/0301-0400/0381-0390/#388-longest-absolute-file-path-starstar","text":"","title":"388. Longest Absolute File Path $\\star\\star$"},{"location":"java/0301-0400/0381-0390/#389-find-the-difference-star","text":"","title":"389. Find the Difference $\\star$"},{"location":"java/0301-0400/0381-0390/#390-elimination-game-starstar","text":"","title":"390. Elimination Game $\\star\\star$"},{"location":"java/0301-0400/0391-0400/","text":"391. Perfect Rectangle $\\star\\star\\star$ 392. Is Subsequence $\\star$ 393. UTF-8 Validation $\\star\\star$ 394. Decode String $\\star\\star$ 395. Longest Substring with At Least K Repeating Characters $\\star\\star$ 396. Rotate Function $\\star\\star$ 397. Integer Replacement $\\star\\star$ 398. Random Pick Index $\\star\\star$ 399. Evaluate Division $\\star\\star$ 400. Nth Digit $\\star\\star$","title":"0391-0300"},{"location":"java/0301-0400/0391-0400/#391-perfect-rectangle-starstarstar","text":"","title":"391. Perfect Rectangle $\\star\\star\\star$"},{"location":"java/0301-0400/0391-0400/#392-is-subsequence-star","text":"","title":"392. Is Subsequence $\\star$"},{"location":"java/0301-0400/0391-0400/#393-utf-8-validation-starstar","text":"","title":"393. UTF-8 Validation $\\star\\star$"},{"location":"java/0301-0400/0391-0400/#394-decode-string-starstar","text":"","title":"394. Decode String $\\star\\star$"},{"location":"java/0301-0400/0391-0400/#395-longest-substring-with-at-least-k-repeating-characters-starstar","text":"","title":"395. Longest Substring with At Least K Repeating Characters $\\star\\star$"},{"location":"java/0301-0400/0391-0400/#396-rotate-function-starstar","text":"","title":"396. Rotate Function $\\star\\star$"},{"location":"java/0301-0400/0391-0400/#397-integer-replacement-starstar","text":"","title":"397. Integer Replacement $\\star\\star$"},{"location":"java/0301-0400/0391-0400/#398-random-pick-index-starstar","text":"","title":"398. Random Pick Index $\\star\\star$"},{"location":"java/0301-0400/0391-0400/#399-evaluate-division-starstar","text":"","title":"399. Evaluate Division $\\star\\star$"},{"location":"java/0301-0400/0391-0400/#400-nth-digit-starstar","text":"","title":"400. Nth Digit $\\star\\star$"},{"location":"java/0401-0500/0401-0410/","text":"401. Binary Watch $\\star$ 402. Remove K Digits $\\star\\star$ 403. Frog Jump $\\star\\star\\star$ 404. Sum of Left Leaves $\\star$ 405. Convert a Number to Hexadecimal $\\star$ 406. Queue Reconstruction by Height $\\star\\star$ 407. Trapping Rain Water II $\\star\\star\\star$ 408. Valid Word Abbreviation $\\star$ 409. Longest Palindrome $\\star$ 410. Split Array Largest Sum $\\star\\star\\star$","title":"0401-0410"},{"location":"java/0401-0500/0401-0410/#401-binary-watch-star","text":"","title":"401. Binary Watch $\\star$"},{"location":"java/0401-0500/0401-0410/#402-remove-k-digits-starstar","text":"","title":"402. Remove K Digits $\\star\\star$"},{"location":"java/0401-0500/0401-0410/#403-frog-jump-starstarstar","text":"","title":"403. Frog Jump $\\star\\star\\star$"},{"location":"java/0401-0500/0401-0410/#404-sum-of-left-leaves-star","text":"","title":"404. Sum of Left Leaves $\\star$"},{"location":"java/0401-0500/0401-0410/#405-convert-a-number-to-hexadecimal-star","text":"","title":"405. Convert a Number to Hexadecimal $\\star$"},{"location":"java/0401-0500/0401-0410/#406-queue-reconstruction-by-height-starstar","text":"","title":"406. Queue Reconstruction by Height $\\star\\star$"},{"location":"java/0401-0500/0401-0410/#407-trapping-rain-water-ii-starstarstar","text":"","title":"407. Trapping Rain Water II $\\star\\star\\star$"},{"location":"java/0401-0500/0401-0410/#408-valid-word-abbreviation-star","text":"","title":"408. Valid Word Abbreviation $\\star$"},{"location":"java/0401-0500/0401-0410/#409-longest-palindrome-star","text":"","title":"409. Longest Palindrome $\\star$"},{"location":"java/0401-0500/0401-0410/#410-split-array-largest-sum-starstarstar","text":"","title":"410. Split Array Largest Sum $\\star\\star\\star$"},{"location":"java/0401-0500/0411-0420/","text":"411. Minimum Unique Word Abbreviation $\\star\\star\\star$ 412. Fizz Buzz $\\star$ 413. Arithmetic Slices $\\star\\star$ 414. Third Maximum Number $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Solution { public int thirdMax ( int [] nums ) { Queue < Integer > pq = new PriorityQueue <>(); Set < Integer > set = new HashSet <>(); for ( int num : nums ) if ( set . add ( num )) { pq . add ( num ); if ( pq . size () > 3 ) pq . poll (); } if ( pq . size () == 2 ) pq . poll (); return pq . peek (); } } 415. Add Strings $\\star$ 416. Partition Equal Subset Sum $\\star\\star$ 417. Pacific Atlantic Water Flow $\\star\\star$ 418. Sentence Screen Fitting $\\star\\star$ 419. Battleships in a Board $\\star\\star$ 420. Strong Password Checker $\\star\\star\\star$","title":"0411-0420"},{"location":"java/0401-0500/0411-0420/#411-minimum-unique-word-abbreviation-starstarstar","text":"","title":"411. Minimum Unique Word Abbreviation $\\star\\star\\star$"},{"location":"java/0401-0500/0411-0420/#412-fizz-buzz-star","text":"","title":"412. Fizz Buzz $\\star$"},{"location":"java/0401-0500/0411-0420/#413-arithmetic-slices-starstar","text":"","title":"413. Arithmetic Slices $\\star\\star$"},{"location":"java/0401-0500/0411-0420/#414-third-maximum-number-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class Solution { public int thirdMax ( int [] nums ) { Queue < Integer > pq = new PriorityQueue <>(); Set < Integer > set = new HashSet <>(); for ( int num : nums ) if ( set . add ( num )) { pq . add ( num ); if ( pq . size () > 3 ) pq . poll (); } if ( pq . size () == 2 ) pq . poll (); return pq . peek (); } }","title":"414. Third Maximum Number $\\star$"},{"location":"java/0401-0500/0411-0420/#415-add-strings-star","text":"","title":"415. Add Strings $\\star$"},{"location":"java/0401-0500/0411-0420/#416-partition-equal-subset-sum-starstar","text":"","title":"416. Partition Equal Subset Sum $\\star\\star$"},{"location":"java/0401-0500/0411-0420/#417-pacific-atlantic-water-flow-starstar","text":"","title":"417. Pacific Atlantic Water Flow $\\star\\star$"},{"location":"java/0401-0500/0411-0420/#418-sentence-screen-fitting-starstar","text":"","title":"418. Sentence Screen Fitting $\\star\\star$"},{"location":"java/0401-0500/0411-0420/#419-battleships-in-a-board-starstar","text":"","title":"419. Battleships in a Board $\\star\\star$"},{"location":"java/0401-0500/0411-0420/#420-strong-password-checker-starstarstar","text":"","title":"420. Strong Password Checker $\\star\\star\\star$"},{"location":"java/0401-0500/0421-0430/","text":"421. Maximum XOR of Two Numbers in an Array $\\star\\star$ 422. Valid Word Square $\\star$ 423. Reconstruct Original Digits from English $\\star\\star$ 424. Longest Repeating Character Replacement $\\star\\star$ 425. Word Squares $\\star\\star\\star$ 426. Convert Binary Search Tree to Sorted Doubly Linked List $\\star\\star$ 427. Construct Quad Tree $\\star\\star$ 428. Serialize and Deserialize N-ary Tree $\\star\\star\\star$ 429. N-ary Tree Level Order Traversal $\\star\\star$ 430. Flatten a Multilevel Doubly Linked List $\\star\\star$","title":"0421-0430"},{"location":"java/0401-0500/0421-0430/#421-maximum-xor-of-two-numbers-in-an-array-starstar","text":"","title":"421. Maximum XOR of Two Numbers in an Array $\\star\\star$"},{"location":"java/0401-0500/0421-0430/#422-valid-word-square-star","text":"","title":"422. Valid Word Square $\\star$"},{"location":"java/0401-0500/0421-0430/#423-reconstruct-original-digits-from-english-starstar","text":"","title":"423. Reconstruct Original Digits from English $\\star\\star$"},{"location":"java/0401-0500/0421-0430/#424-longest-repeating-character-replacement-starstar","text":"","title":"424. Longest Repeating Character Replacement $\\star\\star$"},{"location":"java/0401-0500/0421-0430/#425-word-squares-starstarstar","text":"","title":"425. Word Squares $\\star\\star\\star$"},{"location":"java/0401-0500/0421-0430/#426-convert-binary-search-tree-to-sorted-doubly-linked-list-starstar","text":"","title":"426. Convert Binary Search Tree to Sorted Doubly Linked List $\\star\\star$"},{"location":"java/0401-0500/0421-0430/#427-construct-quad-tree-starstar","text":"","title":"427. Construct Quad Tree $\\star\\star$"},{"location":"java/0401-0500/0421-0430/#428-serialize-and-deserialize-n-ary-tree-starstarstar","text":"","title":"428. Serialize and Deserialize N-ary Tree $\\star\\star\\star$"},{"location":"java/0401-0500/0421-0430/#429-n-ary-tree-level-order-traversal-starstar","text":"","title":"429. N-ary Tree Level Order Traversal $\\star\\star$"},{"location":"java/0401-0500/0421-0430/#430-flatten-a-multilevel-doubly-linked-list-starstar","text":"","title":"430. Flatten a Multilevel Doubly Linked List $\\star\\star$"},{"location":"java/0401-0500/0431-0440/","text":"431. Encode N-ary Tree to Binary Tree $\\star\\star\\star$ 432. All O`one Data Structure $\\star\\star\\star$ 433. Minimum Genetic Mutation $\\star\\star$ 434. Number of Segments in a String $\\star$ 435. Non-overlapping Intervals $\\star\\star$ 436. Find Right Interval $\\star\\star$ 437. Path Sum III $\\star$ 438. Find All Anagrams in a String $\\star\\star$ 439. Ternary Expression Parser $\\star\\star$ 440. K-th Smallest in Lexicographical Order $\\star\\star\\star$","title":"0431-0440"},{"location":"java/0401-0500/0431-0440/#431-encode-n-ary-tree-to-binary-tree-starstarstar","text":"","title":"431. Encode N-ary Tree to Binary Tree $\\star\\star\\star$"},{"location":"java/0401-0500/0431-0440/#432-all-oone-data-structure-starstarstar","text":"","title":"432. All O`one Data Structure $\\star\\star\\star$"},{"location":"java/0401-0500/0431-0440/#433-minimum-genetic-mutation-starstar","text":"","title":"433. Minimum Genetic Mutation $\\star\\star$"},{"location":"java/0401-0500/0431-0440/#434-number-of-segments-in-a-string-star","text":"","title":"434. Number of Segments in a String $\\star$"},{"location":"java/0401-0500/0431-0440/#435-non-overlapping-intervals-starstar","text":"","title":"435. Non-overlapping Intervals $\\star\\star$"},{"location":"java/0401-0500/0431-0440/#436-find-right-interval-starstar","text":"","title":"436. Find Right Interval $\\star\\star$"},{"location":"java/0401-0500/0431-0440/#437-path-sum-iii-star","text":"","title":"437. Path Sum III $\\star$"},{"location":"java/0401-0500/0431-0440/#438-find-all-anagrams-in-a-string-starstar","text":"","title":"438. Find All Anagrams in a String $\\star\\star$"},{"location":"java/0401-0500/0431-0440/#439-ternary-expression-parser-starstar","text":"","title":"439. Ternary Expression Parser $\\star\\star$"},{"location":"java/0401-0500/0431-0440/#440-k-th-smallest-in-lexicographical-order-starstarstar","text":"","title":"440. K-th Smallest in Lexicographical Order $\\star\\star\\star$"},{"location":"java/0401-0500/0441-0450/","text":"441. Arranging Coins $\\star$ 442. Find All Duplicates in an Array $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public List < Integer > findDuplicates ( int [] nums ) { List < Integer > ans = new ArrayList <>(); for ( int num : nums ) { nums [ Math . abs ( num ) - 1 ] *= - 1 ; if ( nums [ Math . abs ( num ) - 1 ] > 0 ) ans . add ( Math . abs ( num )); } return ans ; } } 443. String Compression $\\star$ 444. Sequence Reconstruction $\\star\\star$ 445. Add Two Numbers II $\\star\\star$ 446. Arithmetic Slices II - Subsequence $\\star\\star\\star$ 447. Number of Boomerangs $\\star$ 448. Find All Numbers Disappeared in an Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public List < Integer > findDisappearedNumbers ( int [] nums ) { List < Integer > ans = new ArrayList <>(); for ( int num : nums ) { int index = Math . abs ( num ) - 1 ; nums [ index ] = - Math . abs ( nums [ index ]); } for ( int i = 0 ; i < nums . length ; i ++) if ( nums [ i ] > 0 ) ans . add ( i + 1 ); return ans ; } } 449. Serialize and Deserialize BST $\\star\\star$ 450. Delete Node in a BST $\\star\\star$","title":"0441-0450"},{"location":"java/0401-0500/0441-0450/#441-arranging-coins-star","text":"","title":"441. Arranging Coins $\\star$"},{"location":"java/0401-0500/0441-0450/#442-find-all-duplicates-in-an-array-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public List < Integer > findDuplicates ( int [] nums ) { List < Integer > ans = new ArrayList <>(); for ( int num : nums ) { nums [ Math . abs ( num ) - 1 ] *= - 1 ; if ( nums [ Math . abs ( num ) - 1 ] > 0 ) ans . add ( Math . abs ( num )); } return ans ; } }","title":"442. Find All Duplicates in an Array $\\star\\star$"},{"location":"java/0401-0500/0441-0450/#443-string-compression-star","text":"","title":"443. String Compression $\\star$"},{"location":"java/0401-0500/0441-0450/#444-sequence-reconstruction-starstar","text":"","title":"444. Sequence Reconstruction $\\star\\star$"},{"location":"java/0401-0500/0441-0450/#445-add-two-numbers-ii-starstar","text":"","title":"445. Add Two Numbers II $\\star\\star$"},{"location":"java/0401-0500/0441-0450/#446-arithmetic-slices-ii-subsequence-starstarstar","text":"","title":"446. Arithmetic Slices II - Subsequence $\\star\\star\\star$"},{"location":"java/0401-0500/0441-0450/#447-number-of-boomerangs-star","text":"","title":"447. Number of Boomerangs $\\star$"},{"location":"java/0401-0500/0441-0450/#448-find-all-numbers-disappeared-in-an-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public List < Integer > findDisappearedNumbers ( int [] nums ) { List < Integer > ans = new ArrayList <>(); for ( int num : nums ) { int index = Math . abs ( num ) - 1 ; nums [ index ] = - Math . abs ( nums [ index ]); } for ( int i = 0 ; i < nums . length ; i ++) if ( nums [ i ] > 0 ) ans . add ( i + 1 ); return ans ; } }","title":"448. Find All Numbers Disappeared in an Array $\\star$"},{"location":"java/0401-0500/0441-0450/#449-serialize-and-deserialize-bst-starstar","text":"","title":"449. Serialize and Deserialize BST $\\star\\star$"},{"location":"java/0401-0500/0441-0450/#450-delete-node-in-a-bst-starstar","text":"","title":"450. Delete Node in a BST $\\star\\star$"},{"location":"java/0401-0500/0451-0460/","text":"451. Sort Characters By Frequency $\\star\\star$ 452. Minimum Number of Arrows to Burst Balloons $\\star\\star$ 453. Minimum Moves to Equal Array Elements $\\star$ 454. 4Sum II $\\star\\star$ 455. Assign Cookies $\\star$ 456. 132 Pattern $\\star\\star$ 457. Circular Array Loop $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public boolean circularArrayLoop ( int [] nums ) { if ( nums . length < 2 ) return false ; for ( int i = 0 ; i < nums . length ; i ++) { if ( nums [ i ] == 0 ) continue ; int slow = i ; int fast = advance ( nums , slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( nums , fast )] > 0 ) { if ( slow == fast ) { if ( slow == advance ( nums , slow )) break ; return true ; } slow = advance ( nums , slow ); fast = advance ( nums , advance ( nums , fast )); } slow = i ; int sign = nums [ i ]; while ( sign * nums [ slow ] > 0 ) { int next = advance ( nums , slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; } private int advance ( int [] nums , int i ) { final int n = nums . length ; int val = ( i + nums [ i ]) % n ; return i + nums [ i ] >= 0 ? val : n + val ; } } 458. Poor Pigs $\\star\\star\\star$ 459. Repeated Substring Pattern $\\star$ 460. LFU Cache $\\star\\star\\star$","title":"0451-0460"},{"location":"java/0401-0500/0451-0460/#451-sort-characters-by-frequency-starstar","text":"","title":"451. Sort Characters By Frequency $\\star\\star$"},{"location":"java/0401-0500/0451-0460/#452-minimum-number-of-arrows-to-burst-balloons-starstar","text":"","title":"452. Minimum Number of Arrows to Burst Balloons $\\star\\star$"},{"location":"java/0401-0500/0451-0460/#453-minimum-moves-to-equal-array-elements-star","text":"","title":"453. Minimum Moves to Equal Array Elements $\\star$"},{"location":"java/0401-0500/0451-0460/#454-4sum-ii-starstar","text":"","title":"454. 4Sum II $\\star\\star$"},{"location":"java/0401-0500/0451-0460/#455-assign-cookies-star","text":"","title":"455. Assign Cookies $\\star$"},{"location":"java/0401-0500/0451-0460/#456-132-pattern-starstar","text":"","title":"456. 132 Pattern $\\star\\star$"},{"location":"java/0401-0500/0451-0460/#457-circular-array-loop-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class Solution { public boolean circularArrayLoop ( int [] nums ) { if ( nums . length < 2 ) return false ; for ( int i = 0 ; i < nums . length ; i ++) { if ( nums [ i ] == 0 ) continue ; int slow = i ; int fast = advance ( nums , slow ); while ( nums [ i ] * nums [ fast ] > 0 && nums [ i ] * nums [ advance ( nums , fast )] > 0 ) { if ( slow == fast ) { if ( slow == advance ( nums , slow )) break ; return true ; } slow = advance ( nums , slow ); fast = advance ( nums , advance ( nums , fast )); } slow = i ; int sign = nums [ i ]; while ( sign * nums [ slow ] > 0 ) { int next = advance ( nums , slow ); nums [ slow ] = 0 ; slow = next ; } } return false ; } private int advance ( int [] nums , int i ) { final int n = nums . length ; int val = ( i + nums [ i ]) % n ; return i + nums [ i ] >= 0 ? val : n + val ; } }","title":"457. Circular Array Loop $\\star\\star$"},{"location":"java/0401-0500/0451-0460/#458-poor-pigs-starstarstar","text":"","title":"458. Poor Pigs $\\star\\star\\star$"},{"location":"java/0401-0500/0451-0460/#459-repeated-substring-pattern-star","text":"","title":"459. Repeated Substring Pattern $\\star$"},{"location":"java/0401-0500/0451-0460/#460-lfu-cache-starstarstar","text":"","title":"460. LFU Cache $\\star\\star\\star$"},{"location":"java/0401-0500/0461-0470/","text":"461. Hamming Distance $\\star$ 462. Minimum Moves to Equal Array Elements II $\\star\\star$ 463. Island Perimeter $\\star$ 464. Can I Win $\\star\\star$ 465. Optimal Account Balancing $\\star\\star\\star$ 466. Count The Repetitions $\\star\\star\\star$ 467. Unique Substrings in Wraparound String $\\star\\star$ 468. Validate IP Address $\\star\\star$ 469. Convex Polygon $\\star\\star$ 470. Implement Rand10() Using Rand7() $\\star\\star$","title":"0461-0470"},{"location":"java/0401-0500/0461-0470/#461-hamming-distance-star","text":"","title":"461. Hamming Distance $\\star$"},{"location":"java/0401-0500/0461-0470/#462-minimum-moves-to-equal-array-elements-ii-starstar","text":"","title":"462. Minimum Moves to Equal Array Elements II $\\star\\star$"},{"location":"java/0401-0500/0461-0470/#463-island-perimeter-star","text":"","title":"463. Island Perimeter $\\star$"},{"location":"java/0401-0500/0461-0470/#464-can-i-win-starstar","text":"","title":"464. Can I Win $\\star\\star$"},{"location":"java/0401-0500/0461-0470/#465-optimal-account-balancing-starstarstar","text":"","title":"465. Optimal Account Balancing $\\star\\star\\star$"},{"location":"java/0401-0500/0461-0470/#466-count-the-repetitions-starstarstar","text":"","title":"466. Count The Repetitions $\\star\\star\\star$"},{"location":"java/0401-0500/0461-0470/#467-unique-substrings-in-wraparound-string-starstar","text":"","title":"467. Unique Substrings in Wraparound String $\\star\\star$"},{"location":"java/0401-0500/0461-0470/#468-validate-ip-address-starstar","text":"","title":"468. Validate IP Address $\\star\\star$"},{"location":"java/0401-0500/0461-0470/#469-convex-polygon-starstar","text":"","title":"469. Convex Polygon $\\star\\star$"},{"location":"java/0401-0500/0461-0470/#470-implement-rand10-using-rand7-starstar","text":"","title":"470. Implement Rand10() Using Rand7() $\\star\\star$"},{"location":"java/0401-0500/0471-0480/","text":"471. Encode String with Shortest Length $\\star\\star\\star$ 472. Concatenated Words $\\star\\star\\star$ 473. Matchsticks to Square $\\star\\star$ 474. Ones and Zeroes $\\star\\star$ 475. Heaters $\\star$ 476. Number Complement $\\star$ 477. Total Hamming Distance $\\star\\star$ 478. Generate Random Point in a Circle $\\star\\star$ 479. Largest Palindrome Product $\\star\\star\\star$ 480. Sliding Window Median $\\star\\star\\star$","title":"0471-0480"},{"location":"java/0401-0500/0471-0480/#471-encode-string-with-shortest-length-starstarstar","text":"","title":"471. Encode String with Shortest Length $\\star\\star\\star$"},{"location":"java/0401-0500/0471-0480/#472-concatenated-words-starstarstar","text":"","title":"472. Concatenated Words $\\star\\star\\star$"},{"location":"java/0401-0500/0471-0480/#473-matchsticks-to-square-starstar","text":"","title":"473. Matchsticks to Square $\\star\\star$"},{"location":"java/0401-0500/0471-0480/#474-ones-and-zeroes-starstar","text":"","title":"474. Ones and Zeroes $\\star\\star$"},{"location":"java/0401-0500/0471-0480/#475-heaters-star","text":"","title":"475. Heaters $\\star$"},{"location":"java/0401-0500/0471-0480/#476-number-complement-star","text":"","title":"476. Number Complement $\\star$"},{"location":"java/0401-0500/0471-0480/#477-total-hamming-distance-starstar","text":"","title":"477. Total Hamming Distance $\\star\\star$"},{"location":"java/0401-0500/0471-0480/#478-generate-random-point-in-a-circle-starstar","text":"","title":"478. Generate Random Point in a Circle $\\star\\star$"},{"location":"java/0401-0500/0471-0480/#479-largest-palindrome-product-starstarstar","text":"","title":"479. Largest Palindrome Product $\\star\\star\\star$"},{"location":"java/0401-0500/0471-0480/#480-sliding-window-median-starstarstar","text":"","title":"480. Sliding Window Median $\\star\\star\\star$"},{"location":"java/0401-0500/0481-0490/","text":"481. Magical String $\\star\\star$ 482. License Key Formatting $\\star$ 483. Smallest Good Base $\\star\\star\\star$ 484. Find Permutation $\\star\\star$ 485. Max Consecutive Ones $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int findMaxConsecutiveOnes ( int [] nums ) { int ans = 0 ; int sum = 0 ; for ( int num : nums ) { if ( num == 0 ) sum = 0 ; else { sum += num ; ans = Math . max ( ans , sum ); } } return ans ; } } 486. Predict the Winner $\\star\\star$ 487. Max Consecutive Ones II $\\star\\star$ 488. Zuma Game $\\star\\star\\star$ 489. Robot Room Cleaner $\\star\\star\\star$ 490. The Maze $\\star\\star$","title":"0481-0490"},{"location":"java/0401-0500/0481-0490/#481-magical-string-starstar","text":"","title":"481. Magical String $\\star\\star$"},{"location":"java/0401-0500/0481-0490/#482-license-key-formatting-star","text":"","title":"482. License Key Formatting $\\star$"},{"location":"java/0401-0500/0481-0490/#483-smallest-good-base-starstarstar","text":"","title":"483. Smallest Good Base $\\star\\star\\star$"},{"location":"java/0401-0500/0481-0490/#484-find-permutation-starstar","text":"","title":"484. Find Permutation $\\star\\star$"},{"location":"java/0401-0500/0481-0490/#485-max-consecutive-ones-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int findMaxConsecutiveOnes ( int [] nums ) { int ans = 0 ; int sum = 0 ; for ( int num : nums ) { if ( num == 0 ) sum = 0 ; else { sum += num ; ans = Math . max ( ans , sum ); } } return ans ; } }","title":"485. Max Consecutive Ones $\\star$"},{"location":"java/0401-0500/0481-0490/#486-predict-the-winner-starstar","text":"","title":"486. Predict the Winner $\\star\\star$"},{"location":"java/0401-0500/0481-0490/#487-max-consecutive-ones-ii-starstar","text":"","title":"487. Max Consecutive Ones II $\\star\\star$"},{"location":"java/0401-0500/0481-0490/#488-zuma-game-starstarstar","text":"","title":"488. Zuma Game $\\star\\star\\star$"},{"location":"java/0401-0500/0481-0490/#489-robot-room-cleaner-starstarstar","text":"","title":"489. Robot Room Cleaner $\\star\\star\\star$"},{"location":"java/0401-0500/0481-0490/#490-the-maze-starstar","text":"","title":"490. The Maze $\\star\\star$"},{"location":"java/0401-0500/0491-0500/","text":"491. Increasing Subsequences $\\star\\star$ 492. Construct the Rectangle $\\star$ 493. Reverse Pairs $\\star\\star\\star$ 494. Target Sum $\\star\\star$ 495. Teemo Attacking $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int findPoisonedDuration ( int [] timeSeries , int duration ) { if ( timeSeries . length == 0 || duration == 0 ) return 0 ; int ans = 0 ; for ( int i = 0 ; i + 1 < timeSeries . length ; i ++) ans += Math . min ( timeSeries [ i + 1 ] - timeSeries [ i ], duration ); return ans + duration ; } } 496. Next Greater Element I $\\star$ 497. Random Point in Non-overlapping Rectangles $\\star\\star$ 498. Diagonal Traverse $\\star\\star$ 499. The Maze III $\\star\\star\\star$ 500. Keyboard Row $\\star$","title":"0491-0500"},{"location":"java/0401-0500/0491-0500/#491-increasing-subsequences-starstar","text":"","title":"491. Increasing Subsequences $\\star\\star$"},{"location":"java/0401-0500/0491-0500/#492-construct-the-rectangle-star","text":"","title":"492. Construct the Rectangle $\\star$"},{"location":"java/0401-0500/0491-0500/#493-reverse-pairs-starstarstar","text":"","title":"493. Reverse Pairs $\\star\\star\\star$"},{"location":"java/0401-0500/0491-0500/#494-target-sum-starstar","text":"","title":"494. Target Sum $\\star\\star$"},{"location":"java/0401-0500/0491-0500/#495-teemo-attacking-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int findPoisonedDuration ( int [] timeSeries , int duration ) { if ( timeSeries . length == 0 || duration == 0 ) return 0 ; int ans = 0 ; for ( int i = 0 ; i + 1 < timeSeries . length ; i ++) ans += Math . min ( timeSeries [ i + 1 ] - timeSeries [ i ], duration ); return ans + duration ; } }","title":"495. Teemo Attacking $\\star\\star$"},{"location":"java/0401-0500/0491-0500/#496-next-greater-element-i-star","text":"","title":"496. Next Greater Element I $\\star$"},{"location":"java/0401-0500/0491-0500/#497-random-point-in-non-overlapping-rectangles-starstar","text":"","title":"497. Random Point in Non-overlapping Rectangles $\\star\\star$"},{"location":"java/0401-0500/0491-0500/#498-diagonal-traverse-starstar","text":"","title":"498. Diagonal Traverse $\\star\\star$"},{"location":"java/0401-0500/0491-0500/#499-the-maze-iii-starstarstar","text":"","title":"499. The Maze III $\\star\\star\\star$"},{"location":"java/0401-0500/0491-0500/#500-keyboard-row-star","text":"","title":"500. Keyboard Row $\\star$"},{"location":"java/0501-0600/0501-0510/","text":"501. Find Mode in Binary Search Tree $\\star$ 502. IPO $\\star\\star\\star$ 503. Next Greater Element II $\\star\\star$ 504. Base 7 $\\star$ 505. The Maze II $\\star\\star$ 506. Relative Ranks $\\star$ 507. Perfect Number $\\star$ 508. Most Frequent Subtree Sum $\\star\\star$ 509. Fibonacci Number $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int fib ( int N ) { if ( N < 2 ) return N ; int [] dp = { 0 , 0 , 1 }; for ( int i = 2 ; i <= N ; i ++) { dp [ 0 ] = dp [ 1 ]; dp [ 1 ] = dp [ 2 ]; dp [ 2 ] = dp [ 0 ] + dp [ 1 ]; } return dp [ 2 ]; } } 510. Inorder Successor in BST II $\\star\\star$","title":"0501-0510"},{"location":"java/0501-0600/0501-0510/#501-find-mode-in-binary-search-tree-star","text":"","title":"501. Find Mode in Binary Search Tree $\\star$"},{"location":"java/0501-0600/0501-0510/#502-ipo-starstarstar","text":"","title":"502. IPO $\\star\\star\\star$"},{"location":"java/0501-0600/0501-0510/#503-next-greater-element-ii-starstar","text":"","title":"503. Next Greater Element II $\\star\\star$"},{"location":"java/0501-0600/0501-0510/#504-base-7-star","text":"","title":"504. Base 7 $\\star$"},{"location":"java/0501-0600/0501-0510/#505-the-maze-ii-starstar","text":"","title":"505. The Maze II $\\star\\star$"},{"location":"java/0501-0600/0501-0510/#506-relative-ranks-star","text":"","title":"506. Relative Ranks $\\star$"},{"location":"java/0501-0600/0501-0510/#507-perfect-number-star","text":"","title":"507. Perfect Number $\\star$"},{"location":"java/0501-0600/0501-0510/#508-most-frequent-subtree-sum-starstar","text":"","title":"508. Most Frequent Subtree Sum $\\star\\star$"},{"location":"java/0501-0600/0501-0510/#509-fibonacci-number-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int fib ( int N ) { if ( N < 2 ) return N ; int [] dp = { 0 , 0 , 1 }; for ( int i = 2 ; i <= N ; i ++) { dp [ 0 ] = dp [ 1 ]; dp [ 1 ] = dp [ 2 ]; dp [ 2 ] = dp [ 0 ] + dp [ 1 ]; } return dp [ 2 ]; } }","title":"509. Fibonacci Number $\\star$"},{"location":"java/0501-0600/0501-0510/#510-inorder-successor-in-bst-ii-starstar","text":"","title":"510. Inorder Successor in BST II $\\star\\star$"},{"location":"java/0501-0600/0511-0520/","text":"511. Game Play Analysis I $\\star$ 512. Game Play Analysis II $\\star$ 513. Find Bottom Left Tree Value $\\star\\star$ 514. Freedom Trail $\\star\\star\\star$ 515. Find Largest Value in Each Tree Row $\\star\\star$ 516. Longest Palindromic Subsequence $\\star\\star$ 517. Super Washing Machines $\\star\\star\\star$ 518. Coin Change 2 $\\star\\star$ 519. Random Flip Matrix $\\star\\star$ 520. Detect Capital $\\star$","title":"0511-0520"},{"location":"java/0501-0600/0511-0520/#511-game-play-analysis-i-star","text":"","title":"511. Game Play Analysis I $\\star$"},{"location":"java/0501-0600/0511-0520/#512-game-play-analysis-ii-star","text":"","title":"512. Game Play Analysis II $\\star$"},{"location":"java/0501-0600/0511-0520/#513-find-bottom-left-tree-value-starstar","text":"","title":"513. Find Bottom Left Tree Value $\\star\\star$"},{"location":"java/0501-0600/0511-0520/#514-freedom-trail-starstarstar","text":"","title":"514. Freedom Trail $\\star\\star\\star$"},{"location":"java/0501-0600/0511-0520/#515-find-largest-value-in-each-tree-row-starstar","text":"","title":"515. Find Largest Value in Each Tree Row $\\star\\star$"},{"location":"java/0501-0600/0511-0520/#516-longest-palindromic-subsequence-starstar","text":"","title":"516. Longest Palindromic Subsequence $\\star\\star$"},{"location":"java/0501-0600/0511-0520/#517-super-washing-machines-starstarstar","text":"","title":"517. Super Washing Machines $\\star\\star\\star$"},{"location":"java/0501-0600/0511-0520/#518-coin-change-2-starstar","text":"","title":"518. Coin Change 2 $\\star\\star$"},{"location":"java/0501-0600/0511-0520/#519-random-flip-matrix-starstar","text":"","title":"519. Random Flip Matrix $\\star\\star$"},{"location":"java/0501-0600/0511-0520/#520-detect-capital-star","text":"","title":"520. Detect Capital $\\star$"},{"location":"java/0501-0600/0521-0530/","text":"521. Longest Uncommon Subsequence I $\\star$ 522. Longest Uncommon Subsequence II $\\star\\star$ 523. Continuous Subarray Sum $\\star\\star$ 524. Longest Word in Dictionary through Deleting $\\star\\star$ 525. Contiguous Array $\\star\\star$ 526. Beautiful Arrangement $\\star\\star$ 527. Word Abbreviation $\\star\\star\\star$ 528. Random Pick with Weight $\\star\\star$ 529. Minesweeper $\\star\\star$ 530. Minimum Absolute Difference in BST $\\star$","title":"0521-0530"},{"location":"java/0501-0600/0521-0530/#521-longest-uncommon-subsequence-i-star","text":"","title":"521. Longest Uncommon Subsequence I  $\\star$"},{"location":"java/0501-0600/0521-0530/#522-longest-uncommon-subsequence-ii-starstar","text":"","title":"522. Longest Uncommon Subsequence II $\\star\\star$"},{"location":"java/0501-0600/0521-0530/#523-continuous-subarray-sum-starstar","text":"","title":"523. Continuous Subarray Sum $\\star\\star$"},{"location":"java/0501-0600/0521-0530/#524-longest-word-in-dictionary-through-deleting-starstar","text":"","title":"524. Longest Word in Dictionary through Deleting $\\star\\star$"},{"location":"java/0501-0600/0521-0530/#525-contiguous-array-starstar","text":"","title":"525. Contiguous Array $\\star\\star$"},{"location":"java/0501-0600/0521-0530/#526-beautiful-arrangement-starstar","text":"","title":"526. Beautiful Arrangement $\\star\\star$"},{"location":"java/0501-0600/0521-0530/#527-word-abbreviation-starstarstar","text":"","title":"527. Word Abbreviation $\\star\\star\\star$"},{"location":"java/0501-0600/0521-0530/#528-random-pick-with-weight-starstar","text":"","title":"528. Random Pick with Weight $\\star\\star$"},{"location":"java/0501-0600/0521-0530/#529-minesweeper-starstar","text":"","title":"529. Minesweeper $\\star\\star$"},{"location":"java/0501-0600/0521-0530/#530-minimum-absolute-difference-in-bst-star","text":"","title":"530. Minimum Absolute Difference in BST $\\star$"},{"location":"java/0501-0600/0531-0540/","text":"531. Lonely Pixel I $\\star\\star$ 532. K-diff Pairs in an Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int findPairs ( int [] nums , int k ) { if ( k < 0 ) return 0 ; int ans = 0 ; Map < Integer , Integer > map = new HashMap <>(); for ( int i = 0 ; i < nums . length ; i ++) map . put ( nums [ i ], i ); for ( int i = 0 ; i < nums . length ; i ++) { int target = nums [ i ] + k ; if ( map . containsKey ( target ) && map . get ( target ) != i ) { ans ++; map . remove ( target ); } } return ans ; } } 533. Lonely Pixel II $\\star\\star$ 534. Game Play Analysis III $\\star\\star$ 535. Encode and Decode TinyURL $\\star\\star$ 536. Construct Binary Tree from String $\\star\\star$ 537. Complex Number Multiplication $\\star\\star$ 538. Convert BST to Greater Tree $\\star$ 539. Minimum Time Difference $\\star\\star$ 540. Single Element in a Sorted Array $\\star\\star$","title":"0531-0540"},{"location":"java/0501-0600/0531-0540/#531-lonely-pixel-i-starstar","text":"","title":"531. Lonely Pixel I $\\star\\star$"},{"location":"java/0501-0600/0531-0540/#532-k-diff-pairs-in-an-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int findPairs ( int [] nums , int k ) { if ( k < 0 ) return 0 ; int ans = 0 ; Map < Integer , Integer > map = new HashMap <>(); for ( int i = 0 ; i < nums . length ; i ++) map . put ( nums [ i ], i ); for ( int i = 0 ; i < nums . length ; i ++) { int target = nums [ i ] + k ; if ( map . containsKey ( target ) && map . get ( target ) != i ) { ans ++; map . remove ( target ); } } return ans ; } }","title":"532. K-diff Pairs in an Array $\\star$"},{"location":"java/0501-0600/0531-0540/#533-lonely-pixel-ii-starstar","text":"","title":"533. Lonely Pixel II $\\star\\star$"},{"location":"java/0501-0600/0531-0540/#534-game-play-analysis-iii-starstar","text":"","title":"534. Game Play Analysis III $\\star\\star$"},{"location":"java/0501-0600/0531-0540/#535-encode-and-decode-tinyurl-starstar","text":"","title":"535. Encode and Decode TinyURL $\\star\\star$"},{"location":"java/0501-0600/0531-0540/#536-construct-binary-tree-from-string-starstar","text":"","title":"536. Construct Binary Tree from String $\\star\\star$"},{"location":"java/0501-0600/0531-0540/#537-complex-number-multiplication-starstar","text":"","title":"537. Complex Number Multiplication $\\star\\star$"},{"location":"java/0501-0600/0531-0540/#538-convert-bst-to-greater-tree-star","text":"","title":"538. Convert BST to Greater Tree $\\star$"},{"location":"java/0501-0600/0531-0540/#539-minimum-time-difference-starstar","text":"","title":"539. Minimum Time Difference $\\star\\star$"},{"location":"java/0501-0600/0531-0540/#540-single-element-in-a-sorted-array-starstar","text":"","title":"540. Single Element in a Sorted Array $\\star\\star$"},{"location":"java/0501-0600/0541-0550/","text":"541. Reverse String II $\\star$ 542. 01 Matrix $\\star\\star$ 543. Diameter of Binary Tree $\\star$ 544. Output Contest Matches $\\star\\star$ 545. Boundary of Binary Tree $\\star\\star$ 546. Remove Boxes $\\star\\star\\star$ 547. Friend Circles $\\star\\star$ 548. Split Array with Equal Sum $\\star\\star$ 549. Binary Tree Longest Consecutive Sequence II $\\star\\star$ 550. Game Play Analysis IV $\\star\\star$","title":"0541-0550"},{"location":"java/0501-0600/0541-0550/#541-reverse-string-ii-star","text":"","title":"541. Reverse String II $\\star$"},{"location":"java/0501-0600/0541-0550/#542-01-matrix-starstar","text":"","title":"542. 01 Matrix $\\star\\star$"},{"location":"java/0501-0600/0541-0550/#543-diameter-of-binary-tree-star","text":"","title":"543. Diameter of Binary Tree $\\star$"},{"location":"java/0501-0600/0541-0550/#544-output-contest-matches-starstar","text":"","title":"544. Output Contest Matches $\\star\\star$"},{"location":"java/0501-0600/0541-0550/#545-boundary-of-binary-tree-starstar","text":"","title":"545. Boundary of Binary Tree $\\star\\star$"},{"location":"java/0501-0600/0541-0550/#546-remove-boxes-starstarstar","text":"","title":"546. Remove Boxes $\\star\\star\\star$"},{"location":"java/0501-0600/0541-0550/#547-friend-circles-starstar","text":"","title":"547. Friend Circles $\\star\\star$"},{"location":"java/0501-0600/0541-0550/#548-split-array-with-equal-sum-starstar","text":"","title":"548. Split Array with Equal Sum $\\star\\star$"},{"location":"java/0501-0600/0541-0550/#549-binary-tree-longest-consecutive-sequence-ii-starstar","text":"","title":"549. Binary Tree Longest Consecutive Sequence II $\\star\\star$"},{"location":"java/0501-0600/0541-0550/#550-game-play-analysis-iv-starstar","text":"","title":"550. Game Play Analysis IV $\\star\\star$"},{"location":"java/0501-0600/0551-0560/","text":"551. Student Attendance Record I $\\star$ 552. Student Attendance Record II $\\star\\star\\star$ 553. Optimal Division $\\star\\star$ 554. Brick Wall $\\star\\star$ 555. Split Concatenated Strings $\\star\\star$ 556. Next Greater Element III $\\star\\star$ 557. Reverse Words in a String III $\\star$ 558. Quad Tree Intersection $\\star$ 559. Maximum Depth of N-ary Tree $\\star$ 560. Subarray Sum Equals K $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int subarraySum ( int [] nums , int k ) { int ans = 0 ; int sum = 0 ; Map < Integer , Integer > map = new HashMap <>(); map . put ( 0 , 1 ); for ( int num : nums ) { sum += num ; ans += map . getOrDefault ( sum - k , 0 ); map . put ( sum , map . getOrDefault ( sum , 0 ) + 1 ); } return ans ; } }","title":"0551-0560"},{"location":"java/0501-0600/0551-0560/#551-student-attendance-record-i-star","text":"","title":"551. Student Attendance Record I $\\star$"},{"location":"java/0501-0600/0551-0560/#552-student-attendance-record-ii-starstarstar","text":"","title":"552. Student Attendance Record II $\\star\\star\\star$"},{"location":"java/0501-0600/0551-0560/#553-optimal-division-starstar","text":"","title":"553. Optimal Division $\\star\\star$"},{"location":"java/0501-0600/0551-0560/#554-brick-wall-starstar","text":"","title":"554. Brick Wall $\\star\\star$"},{"location":"java/0501-0600/0551-0560/#555-split-concatenated-strings-starstar","text":"","title":"555. Split Concatenated Strings $\\star\\star$"},{"location":"java/0501-0600/0551-0560/#556-next-greater-element-iii-starstar","text":"","title":"556. Next Greater Element III $\\star\\star$"},{"location":"java/0501-0600/0551-0560/#557-reverse-words-in-a-string-iii-star","text":"","title":"557. Reverse Words in a String III $\\star$"},{"location":"java/0501-0600/0551-0560/#558-quad-tree-intersection-star","text":"","title":"558. Quad Tree Intersection $\\star$"},{"location":"java/0501-0600/0551-0560/#559-maximum-depth-of-n-ary-tree-star","text":"","title":"559. Maximum Depth of N-ary Tree $\\star$"},{"location":"java/0501-0600/0551-0560/#560-subarray-sum-equals-k-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int subarraySum ( int [] nums , int k ) { int ans = 0 ; int sum = 0 ; Map < Integer , Integer > map = new HashMap <>(); map . put ( 0 , 1 ); for ( int num : nums ) { sum += num ; ans += map . getOrDefault ( sum - k , 0 ); map . put ( sum , map . getOrDefault ( sum , 0 ) + 1 ); } return ans ; } }","title":"560. Subarray Sum Equals K $\\star\\star$"},{"location":"java/0501-0600/0561-0570/","text":"561. Array Partition I $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int arrayPairSum ( int [] nums ) { int ans = 0 ; Arrays . sort ( nums ); for ( int i = 0 ; i < nums . length ; i += 2 ) ans += nums [ i ]; return ans ; } } 562. Longest Line of Consecutive One in Matrix $\\star\\star$ 563. Binary Tree Tilt $\\star$ 564. Find the Closest Palindrome $\\star\\star\\star$ 565. Array Nesting $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int arrayNesting ( int [] nums ) { int ans = 0 ; for ( int num : nums ) { if ( num == - 1 ) continue ; int index = num ; int count = 0 ; while ( nums [ index ] != - 1 ) { int temp = index ; index = nums [ index ]; nums [ temp ] = - 1 ; count ++; } ans = Math . max ( ans , count ); } return ans ; } } 566. Reshape the Matrix $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int [][] matrixReshape ( int [][] nums , int r , int c ) { if ( nums . length == 0 || r * c != nums . length * nums [ 0 ]. length ) return nums ; int [][] ans = new int [ r ][ c ]; int k = 0 ; for ( int [] row : nums ) for ( int num : row ) { ans [ k / c ][ k % c ] = num ; k ++; } return ans ; } } 567. Permutation in String $\\star\\star$ 568. Maximum Vacation Days $\\star\\star\\star$ 569. Median Employee Salary $\\star\\star\\star$ 570. Managers with at Least 5 Direct Reports $\\star\\star$","title":"0561-0570"},{"location":"java/0501-0600/0561-0570/#561-array-partition-i-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public int arrayPairSum ( int [] nums ) { int ans = 0 ; Arrays . sort ( nums ); for ( int i = 0 ; i < nums . length ; i += 2 ) ans += nums [ i ]; return ans ; } }","title":"561. Array Partition I $\\star$"},{"location":"java/0501-0600/0561-0570/#562-longest-line-of-consecutive-one-in-matrix-starstar","text":"","title":"562. Longest Line of Consecutive One in Matrix $\\star\\star$"},{"location":"java/0501-0600/0561-0570/#563-binary-tree-tilt-star","text":"","title":"563. Binary Tree Tilt $\\star$"},{"location":"java/0501-0600/0561-0570/#564-find-the-closest-palindrome-starstarstar","text":"","title":"564. Find the Closest Palindrome $\\star\\star\\star$"},{"location":"java/0501-0600/0561-0570/#565-array-nesting-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int arrayNesting ( int [] nums ) { int ans = 0 ; for ( int num : nums ) { if ( num == - 1 ) continue ; int index = num ; int count = 0 ; while ( nums [ index ] != - 1 ) { int temp = index ; index = nums [ index ]; nums [ temp ] = - 1 ; count ++; } ans = Math . max ( ans , count ); } return ans ; } }","title":"565. Array Nesting $\\star\\star$"},{"location":"java/0501-0600/0561-0570/#566-reshape-the-matrix-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int [][] matrixReshape ( int [][] nums , int r , int c ) { if ( nums . length == 0 || r * c != nums . length * nums [ 0 ]. length ) return nums ; int [][] ans = new int [ r ][ c ]; int k = 0 ; for ( int [] row : nums ) for ( int num : row ) { ans [ k / c ][ k % c ] = num ; k ++; } return ans ; } }","title":"566. Reshape the Matrix $\\star$"},{"location":"java/0501-0600/0561-0570/#567-permutation-in-string-starstar","text":"","title":"567. Permutation in String $\\star\\star$"},{"location":"java/0501-0600/0561-0570/#568-maximum-vacation-days-starstarstar","text":"","title":"568. Maximum Vacation Days $\\star\\star\\star$"},{"location":"java/0501-0600/0561-0570/#569-median-employee-salary-starstarstar","text":"","title":"569. Median Employee Salary $\\star\\star\\star$"},{"location":"java/0501-0600/0561-0570/#570-managers-with-at-least-5-direct-reports-starstar","text":"","title":"570. Managers with at Least 5 Direct Reports $\\star\\star$"},{"location":"java/0501-0600/0571-0580/","text":"571. Find Median Given Frequency of Numbers $\\star\\star\\star$ 572. Subtree of Another Tree $\\star$ 573. Squirrel Simulation $\\star\\star$ 574. Winning Candidate $\\star\\star$ 575. Distribute Candies $\\star$ 576. Out of Boundary Paths $\\star\\star$ 577. Employee Bonus $\\star$ 578. Get Highest Answer Rate Question $\\star\\star$ 579. Find Cumulative Salary of an Employee $\\star\\star\\star$ 580. Count Student Number in Departments $\\star\\star$","title":"0571-0580"},{"location":"java/0501-0600/0571-0580/#571-find-median-given-frequency-of-numbers-starstarstar","text":"","title":"571. Find Median Given Frequency of Numbers $\\star\\star\\star$"},{"location":"java/0501-0600/0571-0580/#572-subtree-of-another-tree-star","text":"","title":"572. Subtree of Another Tree $\\star$"},{"location":"java/0501-0600/0571-0580/#573-squirrel-simulation-starstar","text":"","title":"573. Squirrel Simulation $\\star\\star$"},{"location":"java/0501-0600/0571-0580/#574-winning-candidate-starstar","text":"","title":"574. Winning Candidate $\\star\\star$"},{"location":"java/0501-0600/0571-0580/#575-distribute-candies-star","text":"","title":"575. Distribute Candies $\\star$"},{"location":"java/0501-0600/0571-0580/#576-out-of-boundary-paths-starstar","text":"","title":"576. Out of Boundary Paths $\\star\\star$"},{"location":"java/0501-0600/0571-0580/#577-employee-bonus-star","text":"","title":"577. Employee Bonus $\\star$"},{"location":"java/0501-0600/0571-0580/#578-get-highest-answer-rate-question-starstar","text":"","title":"578. Get Highest Answer Rate Question $\\star\\star$"},{"location":"java/0501-0600/0571-0580/#579-find-cumulative-salary-of-an-employee-starstarstar","text":"","title":"579. Find Cumulative Salary of an Employee $\\star\\star\\star$"},{"location":"java/0501-0600/0571-0580/#580-count-student-number-in-departments-starstar","text":"","title":"580. Count Student Number in Departments $\\star\\star$"},{"location":"java/0501-0600/0581-0590/","text":"581. Shortest Unsorted Continuous Subarray $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public int findUnsortedSubarray ( int [] nums ) { int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; boolean flag = false ; for ( int i = 1 ; i < nums . length ; i ++) { if ( nums [ i ] < nums [ i - 1 ]) flag = true ; if ( flag ) min = Math . min ( min , nums [ i ]); } flag = false ; for ( int i = nums . length - 2 ; i >= 0 ; i --) { if ( nums [ i ] > nums [ i + 1 ]) flag = true ; if ( flag ) max = Math . max ( max , nums [ i ]); } int l = 0 ; for ( l = 0 ; l < nums . length ; l ++) if ( nums [ l ] > min ) break ; int r = 0 ; for ( r = nums . length - 1 ; r >= 0 ; r --) if ( nums [ r ] < max ) break ; return l > r ? 0 : r - l + 1 ; } } 582. Kill Process $\\star\\star$ 583. Delete Operation for Two Strings $\\star\\star$ 584. Find Customer Referee $\\star$ 585. Investments in 2016 $\\star\\star$ 586. Customer Placing the Largest Number of Orders $\\star$ 587. Erect the Fence $\\star\\star\\star$ 588. Design In-Memory File System $\\star\\star\\star$ 589. N-ary Tree Preorder Traversal $\\star$ 590. N-ary Tree Postorder Traversal $\\star$","title":"0581-0590"},{"location":"java/0501-0600/0581-0590/#581-shortest-unsorted-continuous-subarray-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution { public int findUnsortedSubarray ( int [] nums ) { int min = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; boolean flag = false ; for ( int i = 1 ; i < nums . length ; i ++) { if ( nums [ i ] < nums [ i - 1 ]) flag = true ; if ( flag ) min = Math . min ( min , nums [ i ]); } flag = false ; for ( int i = nums . length - 2 ; i >= 0 ; i --) { if ( nums [ i ] > nums [ i + 1 ]) flag = true ; if ( flag ) max = Math . max ( max , nums [ i ]); } int l = 0 ; for ( l = 0 ; l < nums . length ; l ++) if ( nums [ l ] > min ) break ; int r = 0 ; for ( r = nums . length - 1 ; r >= 0 ; r --) if ( nums [ r ] < max ) break ; return l > r ? 0 : r - l + 1 ; } }","title":"581. Shortest Unsorted Continuous Subarray $\\star$"},{"location":"java/0501-0600/0581-0590/#582-kill-process-starstar","text":"","title":"582. Kill Process $\\star\\star$"},{"location":"java/0501-0600/0581-0590/#583-delete-operation-for-two-strings-starstar","text":"","title":"583. Delete Operation for Two Strings $\\star\\star$"},{"location":"java/0501-0600/0581-0590/#584-find-customer-referee-star","text":"","title":"584. Find Customer Referee $\\star$"},{"location":"java/0501-0600/0581-0590/#585-investments-in-2016-starstar","text":"","title":"585. Investments in 2016 $\\star\\star$"},{"location":"java/0501-0600/0581-0590/#586-customer-placing-the-largest-number-of-orders-star","text":"","title":"586. Customer Placing the Largest Number of Orders $\\star$"},{"location":"java/0501-0600/0581-0590/#587-erect-the-fence-starstarstar","text":"","title":"587. Erect the Fence $\\star\\star\\star$"},{"location":"java/0501-0600/0581-0590/#588-design-in-memory-file-system-starstarstar","text":"","title":"588. Design In-Memory File System $\\star\\star\\star$"},{"location":"java/0501-0600/0581-0590/#589-n-ary-tree-preorder-traversal-star","text":"","title":"589. N-ary Tree Preorder Traversal $\\star$"},{"location":"java/0501-0600/0581-0590/#590-n-ary-tree-postorder-traversal-star","text":"","title":"590. N-ary Tree Postorder Traversal $\\star$"},{"location":"java/0501-0600/0591-0600/","text":"591. Tag Validator $\\star\\star\\star$ 592. Fraction Addition and Subtraction $\\star\\star$ 593. Valid Square $\\star\\star$ 594. Longest Harmonious Subsequence $\\star$ 595. Big Countries $\\star$ 596. Classes More Than 5 Students $\\star$ 597. Friend Requests I: Overall Acceptance Rate $\\star$ 598. Range Addition II $\\star$ 599. Minimum Index Sum of Two Lists $\\star$ 600. Non-negative Integers without Consecutive Ones $\\star\\star\\star$","title":"0591-0600"},{"location":"java/0501-0600/0591-0600/#591-tag-validator-starstarstar","text":"","title":"591. Tag Validator $\\star\\star\\star$"},{"location":"java/0501-0600/0591-0600/#592-fraction-addition-and-subtraction-starstar","text":"","title":"592. Fraction Addition and Subtraction $\\star\\star$"},{"location":"java/0501-0600/0591-0600/#593-valid-square-starstar","text":"","title":"593. Valid Square $\\star\\star$"},{"location":"java/0501-0600/0591-0600/#594-longest-harmonious-subsequence-star","text":"","title":"594. Longest Harmonious Subsequence $\\star$"},{"location":"java/0501-0600/0591-0600/#595-big-countries-star","text":"","title":"595. Big Countries $\\star$"},{"location":"java/0501-0600/0591-0600/#596-classes-more-than-5-students-star","text":"","title":"596. Classes More Than 5 Students $\\star$"},{"location":"java/0501-0600/0591-0600/#597-friend-requests-i-overall-acceptance-rate-star","text":"","title":"597. Friend Requests I: Overall Acceptance Rate $\\star$"},{"location":"java/0501-0600/0591-0600/#598-range-addition-ii-star","text":"","title":"598. Range Addition II $\\star$"},{"location":"java/0501-0600/0591-0600/#599-minimum-index-sum-of-two-lists-star","text":"","title":"599. Minimum Index Sum of Two Lists $\\star$"},{"location":"java/0501-0600/0591-0600/#600-non-negative-integers-without-consecutive-ones-starstarstar","text":"","title":"600. Non-negative Integers without Consecutive Ones $\\star\\star\\star$"},{"location":"java/0601-0700/0601-0610/","text":"601. Human Traffic of Stadium $\\star\\star\\star$ 602. Friend Requests II: Who Has the Most Friends $\\star\\star$ 603. Consecutive Available Seats $\\star$ 604. Design Compressed String Iterator $\\star$ 605. Can Place Flowers $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public boolean canPlaceFlowers ( int [] flowerbed , int n ) { for ( int i = 0 ; i < flowerbed . length ; i ++) { if ( flowerbed [ i ] == 0 && ( i == 0 || flowerbed [ i - 1 ] == 0 ) && ( i == flowerbed . length - 1 || flowerbed [ i + 1 ] == 0 )) { flowerbed [ i ] = 1 ; n --; } if ( n <= 0 ) return true ; } return false ; } } 606. Construct String from Binary Tree $\\star$ 607. Sales Person $\\star$ 608. Tree Node $\\star\\star$ 609. Find Duplicate File in System $\\star\\star$ 610. Triangle Judgement $\\star$","title":"0601-0610"},{"location":"java/0601-0700/0601-0610/#601-human-traffic-of-stadium-starstarstar","text":"","title":"601. Human Traffic of Stadium $\\star\\star\\star$"},{"location":"java/0601-0700/0601-0610/#602-friend-requests-ii-who-has-the-most-friends-starstar","text":"","title":"602. Friend Requests II: Who Has the Most Friends $\\star\\star$"},{"location":"java/0601-0700/0601-0610/#603-consecutive-available-seats-star","text":"","title":"603. Consecutive Available Seats $\\star$"},{"location":"java/0601-0700/0601-0610/#604-design-compressed-string-iterator-star","text":"","title":"604. Design Compressed String Iterator $\\star$"},{"location":"java/0601-0700/0601-0610/#605-can-place-flowers-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public boolean canPlaceFlowers ( int [] flowerbed , int n ) { for ( int i = 0 ; i < flowerbed . length ; i ++) { if ( flowerbed [ i ] == 0 && ( i == 0 || flowerbed [ i - 1 ] == 0 ) && ( i == flowerbed . length - 1 || flowerbed [ i + 1 ] == 0 )) { flowerbed [ i ] = 1 ; n --; } if ( n <= 0 ) return true ; } return false ; } }","title":"605. Can Place Flowers $\\star$"},{"location":"java/0601-0700/0601-0610/#606-construct-string-from-binary-tree-star","text":"","title":"606. Construct String from Binary Tree $\\star$"},{"location":"java/0601-0700/0601-0610/#607-sales-person-star","text":"","title":"607. Sales Person $\\star$"},{"location":"java/0601-0700/0601-0610/#608-tree-node-starstar","text":"","title":"608. Tree Node $\\star\\star$"},{"location":"java/0601-0700/0601-0610/#609-find-duplicate-file-in-system-starstar","text":"","title":"609. Find Duplicate File in System $\\star\\star$"},{"location":"java/0601-0700/0601-0610/#610-triangle-judgement-star","text":"","title":"610. Triangle Judgement $\\star$"},{"location":"java/0601-0700/0611-0620/","text":"611. Valid Triangle Number $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int triangleNumber ( int [] nums ) { int ans = 0 ; Arrays . sort ( nums ); for ( int k = nums . length - 1 ; k > 1 ; k --) for ( int i = 0 , j = k - 1 ; i < j ;) { if ( nums [ i ] + nums [ j ] > nums [ k ]) { ans += j - i ; j --; } else i ++; } return ans ; } } 612. Shortest Distance in a Plane $\\star\\star$ 613. Shortest Distance in a Line $\\star$ 614. Second Degree Follower $\\star\\star$ 615. Average Salary: Departments VS Company $\\star\\star\\star$ 616. Add Bold Tag in String $\\star\\star$ 617. Merge Two Binary Trees $\\star$ 618. Students Report By Geography $\\star\\star\\star$ 619. Biggest Single Number $\\star$ 620. Not Boring Movies $\\star$","title":"0611-0620"},{"location":"java/0601-0700/0611-0620/#611-valid-triangle-number-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int triangleNumber ( int [] nums ) { int ans = 0 ; Arrays . sort ( nums ); for ( int k = nums . length - 1 ; k > 1 ; k --) for ( int i = 0 , j = k - 1 ; i < j ;) { if ( nums [ i ] + nums [ j ] > nums [ k ]) { ans += j - i ; j --; } else i ++; } return ans ; } }","title":"611. Valid Triangle Number $\\star\\star$"},{"location":"java/0601-0700/0611-0620/#612-shortest-distance-in-a-plane-starstar","text":"","title":"612. Shortest Distance in a Plane $\\star\\star$"},{"location":"java/0601-0700/0611-0620/#613-shortest-distance-in-a-line-star","text":"","title":"613. Shortest Distance in a Line $\\star$"},{"location":"java/0601-0700/0611-0620/#614-second-degree-follower-starstar","text":"","title":"614. Second Degree Follower $\\star\\star$"},{"location":"java/0601-0700/0611-0620/#615-average-salary-departments-vs-company-starstarstar","text":"","title":"615. Average Salary: Departments VS Company $\\star\\star\\star$"},{"location":"java/0601-0700/0611-0620/#616-add-bold-tag-in-string-starstar","text":"","title":"616. Add Bold Tag in String $\\star\\star$"},{"location":"java/0601-0700/0611-0620/#617-merge-two-binary-trees-star","text":"","title":"617. Merge Two Binary Trees $\\star$"},{"location":"java/0601-0700/0611-0620/#618-students-report-by-geography-starstarstar","text":"","title":"618. Students Report By Geography $\\star\\star\\star$"},{"location":"java/0601-0700/0611-0620/#619-biggest-single-number-star","text":"","title":"619. Biggest Single Number $\\star$"},{"location":"java/0601-0700/0611-0620/#620-not-boring-movies-star","text":"","title":"620. Not Boring Movies $\\star$"},{"location":"java/0601-0700/0621-0630/","text":"621. Task Scheduler $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int leastInterval ( char [] tasks , int n ) { int [] count = new int [ 26 ]; for ( char task : tasks ) count [ task - 'A' ]++; int maxCount = Integer . MIN_VALUE ; for ( int c : count ) maxCount = Math . max ( maxCount , c ); int ans = ( maxCount - 1 ) * ( n + 1 ); for ( int c : count ) if ( c == maxCount ) ans ++; return Math . max ( ans , tasks . length ); } } 622. Design Circular Queue $\\star\\star$ 623. Add One Row to Tree $\\star\\star$ 624. Maximum Distance in Arrays $\\star$ 625. Minimum Factorization $\\star\\star$ 626. Exchange Seats $\\star\\star$ 627. Swap Salary $\\star$ 628. Maximum Product of Three Numbers $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public int maximumProduct ( int [] nums ) { int min = Integer . MAX_VALUE ; int secondMin = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; int secondMax = Integer . MIN_VALUE ; int thirdMax = Integer . MIN_VALUE ; for ( int num : nums ) { if ( num <= min ) { secondMin = min ; min = num ; } else if ( num <= secondMin ) secondMin = num ; if ( num >= max ) { thirdMax = secondMax ; secondMax = max ; max = num ; } else if ( num >= secondMax ) { thirdMax = secondMax ; secondMax = num ; } else if ( num >= thirdMax ) thirdMax = num ; } return Math . max ( min * secondMin * max , max * secondMax * thirdMax ); } } 629. K Inverse Pairs Array $\\star\\star\\star$ 630. Course Schedule III $\\star\\star\\star$","title":"0621-0630"},{"location":"java/0601-0700/0621-0630/#621-task-scheduler-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int leastInterval ( char [] tasks , int n ) { int [] count = new int [ 26 ]; for ( char task : tasks ) count [ task - 'A' ]++; int maxCount = Integer . MIN_VALUE ; for ( int c : count ) maxCount = Math . max ( maxCount , c ); int ans = ( maxCount - 1 ) * ( n + 1 ); for ( int c : count ) if ( c == maxCount ) ans ++; return Math . max ( ans , tasks . length ); } }","title":"621. Task Scheduler $\\star\\star$"},{"location":"java/0601-0700/0621-0630/#622-design-circular-queue-starstar","text":"","title":"622. Design Circular Queue $\\star\\star$"},{"location":"java/0601-0700/0621-0630/#623-add-one-row-to-tree-starstar","text":"","title":"623. Add One Row to Tree $\\star\\star$"},{"location":"java/0601-0700/0621-0630/#624-maximum-distance-in-arrays-star","text":"","title":"624. Maximum Distance in Arrays $\\star$"},{"location":"java/0601-0700/0621-0630/#625-minimum-factorization-starstar","text":"","title":"625. Minimum Factorization $\\star\\star$"},{"location":"java/0601-0700/0621-0630/#626-exchange-seats-starstar","text":"","title":"626. Exchange Seats $\\star\\star$"},{"location":"java/0601-0700/0621-0630/#627-swap-salary-star","text":"","title":"627. Swap Salary $\\star$"},{"location":"java/0601-0700/0621-0630/#628-maximum-product-of-three-numbers-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution { public int maximumProduct ( int [] nums ) { int min = Integer . MAX_VALUE ; int secondMin = Integer . MAX_VALUE ; int max = Integer . MIN_VALUE ; int secondMax = Integer . MIN_VALUE ; int thirdMax = Integer . MIN_VALUE ; for ( int num : nums ) { if ( num <= min ) { secondMin = min ; min = num ; } else if ( num <= secondMin ) secondMin = num ; if ( num >= max ) { thirdMax = secondMax ; secondMax = max ; max = num ; } else if ( num >= secondMax ) { thirdMax = secondMax ; secondMax = num ; } else if ( num >= thirdMax ) thirdMax = num ; } return Math . max ( min * secondMin * max , max * secondMax * thirdMax ); } }","title":"628. Maximum Product of Three Numbers $\\star$"},{"location":"java/0601-0700/0621-0630/#629-k-inverse-pairs-array-starstarstar","text":"","title":"629. K Inverse Pairs Array $\\star\\star\\star$"},{"location":"java/0601-0700/0621-0630/#630-course-schedule-iii-starstarstar","text":"","title":"630. Course Schedule III $\\star\\star\\star$"},{"location":"java/0601-0700/0631-0640/","text":"631. Design Excel Sum Formula $\\star\\star\\star$ 632. Smallest Range Covering Elements from K Lists $\\star\\star\\star$ 633. Sum of Square Numbers $\\star$ 634. Find the Derangement of An Array $\\star\\star$ 635. Design Log Storage System $\\star\\star$ 636. Exclusive Time of Functions $\\star\\star$ 637. Average of Levels in Binary Tree $\\star$ 638. Shopping Offers $\\star\\star$ 639. Decode Ways II $\\star\\star\\star$ 640. Solve the Equation $\\star\\star$","title":"0631-0640"},{"location":"java/0601-0700/0631-0640/#631-design-excel-sum-formula-starstarstar","text":"","title":"631. Design Excel Sum Formula $\\star\\star\\star$"},{"location":"java/0601-0700/0631-0640/#632-smallest-range-covering-elements-from-k-lists-starstarstar","text":"","title":"632. Smallest Range Covering Elements from K Lists $\\star\\star\\star$"},{"location":"java/0601-0700/0631-0640/#633-sum-of-square-numbers-star","text":"","title":"633. Sum of Square Numbers $\\star$"},{"location":"java/0601-0700/0631-0640/#634-find-the-derangement-of-an-array-starstar","text":"","title":"634. Find the Derangement of An Array $\\star\\star$"},{"location":"java/0601-0700/0631-0640/#635-design-log-storage-system-starstar","text":"","title":"635. Design Log Storage System $\\star\\star$"},{"location":"java/0601-0700/0631-0640/#636-exclusive-time-of-functions-starstar","text":"","title":"636. Exclusive Time of Functions $\\star\\star$"},{"location":"java/0601-0700/0631-0640/#637-average-of-levels-in-binary-tree-star","text":"","title":"637. Average of Levels in Binary Tree $\\star$"},{"location":"java/0601-0700/0631-0640/#638-shopping-offers-starstar","text":"","title":"638. Shopping Offers $\\star\\star$"},{"location":"java/0601-0700/0631-0640/#639-decode-ways-ii-starstarstar","text":"","title":"639. Decode Ways II $\\star\\star\\star$"},{"location":"java/0601-0700/0631-0640/#640-solve-the-equation-starstar","text":"","title":"640. Solve the Equation $\\star\\star$"},{"location":"java/0601-0700/0641-0650/","text":"641. Design Circular Deque $\\star\\star$ 642. Design Search Autocomplete System $\\star\\star\\star$ 643. Maximum Average Subarray I $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public double findMaxAverage ( int [] nums , int k ) { double sum = 0 ; for ( int i = 0 ; i < k ; i ++) sum += nums [ i ]; double ans = sum ; for ( int i = k ; i < nums . length ; i ++) { sum += nums [ i ] - nums [ i - k ]; ans = Math . max ( ans , sum ); } return ans / k ; } } 644. Maximum Average Subarray II $\\star\\star\\star$ 645. Set Mismatch $\\star$ 646. Maximum Length of Pair Chain $\\star\\star$ 647. Palindromic Substrings $\\star\\star$ 648. Replace Words $\\star\\star$ 649. Dota2 Senate $\\star\\star$ 650. 2 Keys Keyboard $\\star\\star$","title":"0641-0650"},{"location":"java/0601-0700/0641-0650/#641-design-circular-deque-starstar","text":"","title":"641. Design Circular Deque $\\star\\star$"},{"location":"java/0601-0700/0641-0650/#642-design-search-autocomplete-system-starstarstar","text":"","title":"642. Design Search Autocomplete System $\\star\\star\\star$"},{"location":"java/0601-0700/0641-0650/#643-maximum-average-subarray-i-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public double findMaxAverage ( int [] nums , int k ) { double sum = 0 ; for ( int i = 0 ; i < k ; i ++) sum += nums [ i ]; double ans = sum ; for ( int i = k ; i < nums . length ; i ++) { sum += nums [ i ] - nums [ i - k ]; ans = Math . max ( ans , sum ); } return ans / k ; } }","title":"643. Maximum Average Subarray I $\\star$"},{"location":"java/0601-0700/0641-0650/#644-maximum-average-subarray-ii-starstarstar","text":"","title":"644. Maximum Average Subarray II $\\star\\star\\star$"},{"location":"java/0601-0700/0641-0650/#645-set-mismatch-star","text":"","title":"645. Set Mismatch $\\star$"},{"location":"java/0601-0700/0641-0650/#646-maximum-length-of-pair-chain-starstar","text":"","title":"646. Maximum Length of Pair Chain $\\star\\star$"},{"location":"java/0601-0700/0641-0650/#647-palindromic-substrings-starstar","text":"","title":"647. Palindromic Substrings $\\star\\star$"},{"location":"java/0601-0700/0641-0650/#648-replace-words-starstar","text":"","title":"648. Replace Words $\\star\\star$"},{"location":"java/0601-0700/0641-0650/#649-dota2-senate-starstar","text":"","title":"649. Dota2 Senate $\\star\\star$"},{"location":"java/0601-0700/0641-0650/#650-2-keys-keyboard-starstar","text":"","title":"650. 2 Keys Keyboard $\\star\\star$"},{"location":"java/0601-0700/0651-0660/","text":"651. 4 Keys Keyboard $\\star\\star$ 652. Find Duplicate Subtrees $\\star\\star$ 653. Two Sum IV - Input is a BST $\\star$ 654. Maximum Binary Tree $\\star\\star$ 655. Print Binary Tree $\\star\\star$ 656. Coin Path $\\star\\star\\star$ 657. Robot Return to Origin $\\star$ 658. Find K Closest Elements $\\star\\star$ 659. Split Array into Consecutive Subsequences $\\star\\star$ 660. Remove 9 $\\star\\star\\star$","title":"0651-0660"},{"location":"java/0601-0700/0651-0660/#651-4-keys-keyboard-starstar","text":"","title":"651. 4 Keys Keyboard $\\star\\star$"},{"location":"java/0601-0700/0651-0660/#652-find-duplicate-subtrees-starstar","text":"","title":"652. Find Duplicate Subtrees $\\star\\star$"},{"location":"java/0601-0700/0651-0660/#653-two-sum-iv-input-is-a-bst-star","text":"","title":"653. Two Sum IV - Input is a BST $\\star$"},{"location":"java/0601-0700/0651-0660/#654-maximum-binary-tree-starstar","text":"","title":"654. Maximum Binary Tree $\\star\\star$"},{"location":"java/0601-0700/0651-0660/#655-print-binary-tree-starstar","text":"","title":"655. Print Binary Tree $\\star\\star$"},{"location":"java/0601-0700/0651-0660/#656-coin-path-starstarstar","text":"","title":"656. Coin Path $\\star\\star\\star$"},{"location":"java/0601-0700/0651-0660/#657-robot-return-to-origin-star","text":"","title":"657. Robot Return to Origin $\\star$"},{"location":"java/0601-0700/0651-0660/#658-find-k-closest-elements-starstar","text":"","title":"658. Find K Closest Elements $\\star\\star$"},{"location":"java/0601-0700/0651-0660/#659-split-array-into-consecutive-subsequences-starstar","text":"","title":"659. Split Array into Consecutive Subsequences $\\star\\star$"},{"location":"java/0601-0700/0651-0660/#660-remove-9-starstarstar","text":"","title":"660. Remove 9 $\\star\\star\\star$"},{"location":"java/0601-0700/0661-0670/","text":"661. Image Smoother $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int [][] imageSmoother ( int [][] M ) { final int m = M . length ; final int n = M [ 0 ]. length ; int ans [][] = new int [ m ][ n ]; for ( int i = 0 ; i < m ; i ++) for ( int j = 0 ; j < n ; j ++) { int ones = 0 ; int count = 0 ; for ( int y = Math . max ( 0 , i - 1 ); y < Math . min ( m , i + 2 ); y ++) for ( int x = Math . max ( 0 , j - 1 ); x < Math . min ( n , j + 2 ); x ++) { ones += M [ y ][ x ]; count ++; } ans [ i ][ j ] = ones / count ; } return ans ; } } 662. Maximum Width of Binary Tree $\\star\\star$ 663. Equal Tree Partition $\\star\\star$ 664. Strange Printer $\\star\\star\\star$ 665. Non-decreasing Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public boolean checkPossibility ( int [] nums ) { int j = - 1 ; for ( int i = 0 ; i + 1 < nums . length ; i ++) if ( nums [ i ] > nums [ i + 1 ]) { if ( j != - 1 ) return false ; j = i ; } return j == - 1 || j == 0 || j == nums . length - 2 || nums [ j - 1 ] <= nums [ j + 1 ] || nums [ j ] <= nums [ j + 2 ]; } } 666. Path Sum IV $\\star\\star$ 667. Beautiful Arrangement II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int [] constructArray ( int n , int k ) { int [] ans = new int [ n ]; for ( int i = 0 ; i < n - k ; i ++) ans [ i ] = i + 1 ; for ( int i = 0 ; i < k ; i ++) { if ( i % 2 == 0 ) ans [ n - k + i ] = n - i / 2 ; else ans [ n - k + i ] = n - k + ( i + 1 ) / 2 ; } return ans ; } } 668. Kth Smallest Number in Multiplication Table $\\star\\star\\star$ 669. Trim a Binary Search Tree $\\star$ 670. Maximum Swap $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int maximumSwap ( int num ) { char [] s = Integer . toString ( num ). toCharArray (); int [] map = new int [ 10 ]; for ( int i = 0 ; i < s . length ; i ++) map [ s [ i ] - '0' ] = i ; for ( int i = 0 ; i < s . length ; i ++) for ( int j = 9 ; j > s [ i ] - '0' ; j --) if ( map [ j ] > i ) { s [ map [ j ]] = s [ i ]; s [ i ] = ( char ) ( '0' + j ); return Integer . valueOf ( new String ( s )); } return num ; } }","title":"0661-0670"},{"location":"java/0601-0700/0661-0670/#661-image-smoother-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution { public int [][] imageSmoother ( int [][] M ) { final int m = M . length ; final int n = M [ 0 ]. length ; int ans [][] = new int [ m ][ n ]; for ( int i = 0 ; i < m ; i ++) for ( int j = 0 ; j < n ; j ++) { int ones = 0 ; int count = 0 ; for ( int y = Math . max ( 0 , i - 1 ); y < Math . min ( m , i + 2 ); y ++) for ( int x = Math . max ( 0 , j - 1 ); x < Math . min ( n , j + 2 ); x ++) { ones += M [ y ][ x ]; count ++; } ans [ i ][ j ] = ones / count ; } return ans ; } }","title":"661. Image Smoother $\\star$"},{"location":"java/0601-0700/0661-0670/#662-maximum-width-of-binary-tree-starstar","text":"","title":"662. Maximum Width of Binary Tree $\\star\\star$"},{"location":"java/0601-0700/0661-0670/#663-equal-tree-partition-starstar","text":"","title":"663. Equal Tree Partition $\\star\\star$"},{"location":"java/0601-0700/0661-0670/#664-strange-printer-starstarstar","text":"","title":"664. Strange Printer $\\star\\star\\star$"},{"location":"java/0601-0700/0661-0670/#665-non-decreasing-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public boolean checkPossibility ( int [] nums ) { int j = - 1 ; for ( int i = 0 ; i + 1 < nums . length ; i ++) if ( nums [ i ] > nums [ i + 1 ]) { if ( j != - 1 ) return false ; j = i ; } return j == - 1 || j == 0 || j == nums . length - 2 || nums [ j - 1 ] <= nums [ j + 1 ] || nums [ j ] <= nums [ j + 2 ]; } }","title":"665. Non-decreasing Array $\\star$"},{"location":"java/0601-0700/0661-0670/#666-path-sum-iv-starstar","text":"","title":"666. Path Sum IV $\\star\\star$"},{"location":"java/0601-0700/0661-0670/#667-beautiful-arrangement-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int [] constructArray ( int n , int k ) { int [] ans = new int [ n ]; for ( int i = 0 ; i < n - k ; i ++) ans [ i ] = i + 1 ; for ( int i = 0 ; i < k ; i ++) { if ( i % 2 == 0 ) ans [ n - k + i ] = n - i / 2 ; else ans [ n - k + i ] = n - k + ( i + 1 ) / 2 ; } return ans ; } }","title":"667. Beautiful Arrangement II $\\star\\star$"},{"location":"java/0601-0700/0661-0670/#668-kth-smallest-number-in-multiplication-table-starstarstar","text":"","title":"668. Kth Smallest Number in Multiplication Table $\\star\\star\\star$"},{"location":"java/0601-0700/0661-0670/#669-trim-a-binary-search-tree-star","text":"","title":"669. Trim a Binary Search Tree $\\star$"},{"location":"java/0601-0700/0661-0670/#670-maximum-swap-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int maximumSwap ( int num ) { char [] s = Integer . toString ( num ). toCharArray (); int [] map = new int [ 10 ]; for ( int i = 0 ; i < s . length ; i ++) map [ s [ i ] - '0' ] = i ; for ( int i = 0 ; i < s . length ; i ++) for ( int j = 9 ; j > s [ i ] - '0' ; j --) if ( map [ j ] > i ) { s [ map [ j ]] = s [ i ]; s [ i ] = ( char ) ( '0' + j ); return Integer . valueOf ( new String ( s )); } return num ; } }","title":"670. Maximum Swap $\\star\\star$"},{"location":"java/0601-0700/0671-0680/","text":"671. Second Minimum Node In a Binary Tree $\\star$ 672. Bulb Switcher II $\\star\\star$ 673. Number of Longest Increasing Subsequence $\\star\\star$ 674. Longest Continuous Increasing Subsequence $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int findLengthOfLCIS ( int [] nums ) { int ans = 0 ; int j = 0 ; for ( int i = 0 ; i < nums . length ; i ++) { if ( i > 0 && nums [ i ] <= nums [ i - 1 ]) j = i ; ans = Math . max ( ans , i - j + 1 ); } return ans ; } } 675. Cut Off Trees for Golf Event $\\star\\star\\star$ 676. Implement Magic Dictionary $\\star\\star$ 677. Map Sum Pairs $\\star\\star$ 678. Valid Parenthesis String $\\star\\star$ 679. 24 Game $\\star\\star\\star$ 680. Valid Palindrome II $\\star$","title":"0671-0680"},{"location":"java/0601-0700/0671-0680/#671-second-minimum-node-in-a-binary-tree-star","text":"","title":"671. Second Minimum Node In a Binary Tree $\\star$"},{"location":"java/0601-0700/0671-0680/#672-bulb-switcher-ii-starstar","text":"","title":"672. Bulb Switcher II $\\star\\star$"},{"location":"java/0601-0700/0671-0680/#673-number-of-longest-increasing-subsequence-starstar","text":"","title":"673. Number of Longest Increasing Subsequence $\\star\\star$"},{"location":"java/0601-0700/0671-0680/#674-longest-continuous-increasing-subsequence-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int findLengthOfLCIS ( int [] nums ) { int ans = 0 ; int j = 0 ; for ( int i = 0 ; i < nums . length ; i ++) { if ( i > 0 && nums [ i ] <= nums [ i - 1 ]) j = i ; ans = Math . max ( ans , i - j + 1 ); } return ans ; } }","title":"674. Longest Continuous Increasing Subsequence $\\star$"},{"location":"java/0601-0700/0671-0680/#675-cut-off-trees-for-golf-event-starstarstar","text":"","title":"675. Cut Off Trees for Golf Event $\\star\\star\\star$"},{"location":"java/0601-0700/0671-0680/#676-implement-magic-dictionary-starstar","text":"","title":"676. Implement Magic Dictionary $\\star\\star$"},{"location":"java/0601-0700/0671-0680/#677-map-sum-pairs-starstar","text":"","title":"677. Map Sum Pairs $\\star\\star$"},{"location":"java/0601-0700/0671-0680/#678-valid-parenthesis-string-starstar","text":"","title":"678. Valid Parenthesis String $\\star\\star$"},{"location":"java/0601-0700/0671-0680/#679-24-game-starstarstar","text":"","title":"679. 24 Game $\\star\\star\\star$"},{"location":"java/0601-0700/0671-0680/#680-valid-palindrome-ii-star","text":"","title":"680. Valid Palindrome II $\\star$"},{"location":"java/0601-0700/0681-0690/","text":"681. Next Closest Time $\\star\\star$ 682. Baseball Game $\\star$ 683. K Empty Slots $\\star\\star\\star$ 684. Redundant Connection $\\star\\star$ 685. Redundant Connection II $\\star\\star\\star$ 686. Repeated String Match $\\star$ 687. Longest Univalue Path $\\star$ 688. Knight Probability in Chessboard $\\star\\star$ 689. Maximum Sum of 3 Non-Overlapping Subarrays $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public int [] maxSumOfThreeSubarrays ( int [] nums , int k ) { int [] ans = new int [] { - 1 , - 1 , - 1 }; int subarrayCount = nums . length - k + 1 ; int [] dp = new int [ subarrayCount ]; int sum = 0 ; for ( int i = 0 ; i < nums . length ; i ++) { sum += nums [ i ]; if ( i >= k ) sum -= nums [ i - k ]; if ( i >= k - 1 ) dp [ i - k + 1 ] = sum ; } int [] left = new int [ subarrayCount ]; int maxIndex = 0 ; for ( int i = 0 ; i < subarrayCount ; i ++) { if ( dp [ i ] > dp [ maxIndex ]) maxIndex = i ; left [ i ] = maxIndex ; } int [] right = new int [ subarrayCount ]; maxIndex = subarrayCount - 1 ; for ( int i = subarrayCount - 1 ; i >= 0 ; i --) { if ( dp [ i ] >= dp [ maxIndex ]) maxIndex = i ; right [ i ] = maxIndex ; } for ( int i = k ; i < subarrayCount - k ; i ++) if ( ans [ 0 ] == - 1 || dp [ left [ i - k ]] + dp [ i ] + dp [ right [ i + k ]] > dp [ ans [ 0 ]] + dp [ ans [ 1 ]] + dp [ ans [ 2 ]]) { ans [ 0 ] = left [ i - k ]; ans [ 1 ] = i ; ans [ 2 ] = right [ i + k ]; } return ans ; } } 690. Employee Importance $\\star$","title":"0681-0690"},{"location":"java/0601-0700/0681-0690/#681-next-closest-time-starstar","text":"","title":"681. Next Closest Time $\\star\\star$"},{"location":"java/0601-0700/0681-0690/#682-baseball-game-star","text":"","title":"682. Baseball Game $\\star$"},{"location":"java/0601-0700/0681-0690/#683-k-empty-slots-starstarstar","text":"","title":"683. K Empty Slots $\\star\\star\\star$"},{"location":"java/0601-0700/0681-0690/#684-redundant-connection-starstar","text":"","title":"684. Redundant Connection $\\star\\star$"},{"location":"java/0601-0700/0681-0690/#685-redundant-connection-ii-starstarstar","text":"","title":"685. Redundant Connection II $\\star\\star\\star$"},{"location":"java/0601-0700/0681-0690/#686-repeated-string-match-star","text":"","title":"686. Repeated String Match $\\star$"},{"location":"java/0601-0700/0681-0690/#687-longest-univalue-path-star","text":"","title":"687. Longest Univalue Path $\\star$"},{"location":"java/0601-0700/0681-0690/#688-knight-probability-in-chessboard-starstar","text":"","title":"688. Knight Probability in Chessboard $\\star\\star$"},{"location":"java/0601-0700/0681-0690/#689-maximum-sum-of-3-non-overlapping-subarrays-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 class Solution { public int [] maxSumOfThreeSubarrays ( int [] nums , int k ) { int [] ans = new int [] { - 1 , - 1 , - 1 }; int subarrayCount = nums . length - k + 1 ; int [] dp = new int [ subarrayCount ]; int sum = 0 ; for ( int i = 0 ; i < nums . length ; i ++) { sum += nums [ i ]; if ( i >= k ) sum -= nums [ i - k ]; if ( i >= k - 1 ) dp [ i - k + 1 ] = sum ; } int [] left = new int [ subarrayCount ]; int maxIndex = 0 ; for ( int i = 0 ; i < subarrayCount ; i ++) { if ( dp [ i ] > dp [ maxIndex ]) maxIndex = i ; left [ i ] = maxIndex ; } int [] right = new int [ subarrayCount ]; maxIndex = subarrayCount - 1 ; for ( int i = subarrayCount - 1 ; i >= 0 ; i --) { if ( dp [ i ] >= dp [ maxIndex ]) maxIndex = i ; right [ i ] = maxIndex ; } for ( int i = k ; i < subarrayCount - k ; i ++) if ( ans [ 0 ] == - 1 || dp [ left [ i - k ]] + dp [ i ] + dp [ right [ i + k ]] > dp [ ans [ 0 ]] + dp [ ans [ 1 ]] + dp [ ans [ 2 ]]) { ans [ 0 ] = left [ i - k ]; ans [ 1 ] = i ; ans [ 2 ] = right [ i + k ]; } return ans ; } }","title":"689. Maximum Sum of 3 Non-Overlapping Subarrays $\\star\\star\\star$"},{"location":"java/0601-0700/0681-0690/#690-employee-importance-star","text":"","title":"690. Employee Importance $\\star$"},{"location":"java/0601-0700/0691-0700/","text":"691. Stickers to Spell Word $\\star\\star\\star$ 692. Top K Frequent Words $\\star\\star$ 693. Binary Number with Alternating Bits $\\star$ 694. Number of Distinct Islands $\\star\\star$ 695. Max Area of Island $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int maxAreaOfIsland ( int [][] grid ) { final int m = grid . length ; final int n = grid [ 0 ]. length ; int ans = 0 ; boolean [][] visited = new boolean [ m ][ n ]; for ( int i = 0 ; i < m ; i ++) for ( int j = 0 ; j < n ; j ++) ans = Math . max ( ans , dfs ( grid , i , j , visited )); return ans ; } private int dfs ( int [][] grid , int i , int j , boolean [][] visited ) { if ( i < 0 || i >= grid . length || j < 0 || j >= grid [ 0 ]. length || visited [ i ][ j ] == true || grid [ i ][ j ] == 0 ) return 0 ; visited [ i ][ j ] = true ; return 1 + dfs ( grid , i + 1 , j , visited ) + dfs ( grid , i - 1 , j , visited ) + dfs ( grid , i , j + 1 , visited ) + dfs ( grid , i , j - 1 , visited ); } } 696. Count Binary Substrings $\\star$ 697. Degree of an Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int findShortestSubArray ( int [] nums ) { int ans = 0 ; int degree = 0 ; Map < Integer , Integer > firstSeen = new HashMap <>(); Map < Integer , Integer > numCounts = new HashMap <>(); for ( int i = 0 ; i < nums . length ; i ++) { firstSeen . putIfAbsent ( nums [ i ], i ); numCounts . put ( nums [ i ], numCounts . getOrDefault ( nums [ i ], 0 ) + 1 ); if ( numCounts . get ( nums [ i ]) > degree ) { degree = numCounts . get ( nums [ i ]); ans = i - firstSeen . get ( nums [ i ]) + 1 ; } else if ( numCounts . get ( nums [ i ]) == degree ) ans = Math . min ( ans , i - firstSeen . get ( nums [ i ]) + 1 ); } return ans ; } } 698. Partition to K Equal Sum Subsets $\\star\\star$ 699. Falling Squares $\\star\\star\\star$ 700. Search in a Binary Search Tree $\\star$","title":"0691-0700"},{"location":"java/0601-0700/0691-0700/#691-stickers-to-spell-word-starstarstar","text":"","title":"691. Stickers to Spell Word $\\star\\star\\star$"},{"location":"java/0601-0700/0691-0700/#692-top-k-frequent-words-starstar","text":"","title":"692. Top K Frequent Words $\\star\\star$"},{"location":"java/0601-0700/0691-0700/#693-binary-number-with-alternating-bits-star","text":"","title":"693. Binary Number with Alternating Bits $\\star$"},{"location":"java/0601-0700/0691-0700/#694-number-of-distinct-islands-starstar","text":"","title":"694. Number of Distinct Islands $\\star\\star$"},{"location":"java/0601-0700/0691-0700/#695-max-area-of-island-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int maxAreaOfIsland ( int [][] grid ) { final int m = grid . length ; final int n = grid [ 0 ]. length ; int ans = 0 ; boolean [][] visited = new boolean [ m ][ n ]; for ( int i = 0 ; i < m ; i ++) for ( int j = 0 ; j < n ; j ++) ans = Math . max ( ans , dfs ( grid , i , j , visited )); return ans ; } private int dfs ( int [][] grid , int i , int j , boolean [][] visited ) { if ( i < 0 || i >= grid . length || j < 0 || j >= grid [ 0 ]. length || visited [ i ][ j ] == true || grid [ i ][ j ] == 0 ) return 0 ; visited [ i ][ j ] = true ; return 1 + dfs ( grid , i + 1 , j , visited ) + dfs ( grid , i - 1 , j , visited ) + dfs ( grid , i , j + 1 , visited ) + dfs ( grid , i , j - 1 , visited ); } }","title":"695. Max Area of Island $\\star\\star$"},{"location":"java/0601-0700/0691-0700/#696-count-binary-substrings-star","text":"","title":"696. Count Binary Substrings $\\star$"},{"location":"java/0601-0700/0691-0700/#697-degree-of-an-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int findShortestSubArray ( int [] nums ) { int ans = 0 ; int degree = 0 ; Map < Integer , Integer > firstSeen = new HashMap <>(); Map < Integer , Integer > numCounts = new HashMap <>(); for ( int i = 0 ; i < nums . length ; i ++) { firstSeen . putIfAbsent ( nums [ i ], i ); numCounts . put ( nums [ i ], numCounts . getOrDefault ( nums [ i ], 0 ) + 1 ); if ( numCounts . get ( nums [ i ]) > degree ) { degree = numCounts . get ( nums [ i ]); ans = i - firstSeen . get ( nums [ i ]) + 1 ; } else if ( numCounts . get ( nums [ i ]) == degree ) ans = Math . min ( ans , i - firstSeen . get ( nums [ i ]) + 1 ); } return ans ; } }","title":"697. Degree of an Array $\\star$"},{"location":"java/0601-0700/0691-0700/#698-partition-to-k-equal-sum-subsets-starstar","text":"","title":"698. Partition to K Equal Sum Subsets $\\star\\star$"},{"location":"java/0601-0700/0691-0700/#699-falling-squares-starstarstar","text":"","title":"699. Falling Squares $\\star\\star\\star$"},{"location":"java/0601-0700/0691-0700/#700-search-in-a-binary-search-tree-star","text":"","title":"700. Search in a Binary Search Tree $\\star$"},{"location":"java/0701-0800/0701-0710/","text":"701. Insert into a Binary Search Tree $\\star\\star$ 702. Search in a Sorted Array of Unknown Size $\\star\\star$ 703. Kth Largest Element in a Stream $\\star$ 704. Binary Search $\\star$ 705. Design HashSet $\\star$ 706. Design HashMap $\\star$ 707. Design Linked List $\\star\\star$ 708. Insert into a Sorted Circular Linked List $\\star\\star$ 709. To Lower Case $\\star$ 710. Random Pick with Blacklist $\\star\\star\\star$","title":"0701-0710"},{"location":"java/0701-0800/0701-0710/#701-insert-into-a-binary-search-tree-starstar","text":"","title":"701. Insert into a Binary Search Tree $\\star\\star$"},{"location":"java/0701-0800/0701-0710/#702-search-in-a-sorted-array-of-unknown-size-starstar","text":"","title":"702. Search in a Sorted Array of Unknown Size $\\star\\star$"},{"location":"java/0701-0800/0701-0710/#703-kth-largest-element-in-a-stream-star","text":"","title":"703. Kth Largest Element in a Stream $\\star$"},{"location":"java/0701-0800/0701-0710/#704-binary-search-star","text":"","title":"704. Binary Search $\\star$"},{"location":"java/0701-0800/0701-0710/#705-design-hashset-star","text":"","title":"705. Design HashSet $\\star$"},{"location":"java/0701-0800/0701-0710/#706-design-hashmap-star","text":"","title":"706. Design HashMap $\\star$"},{"location":"java/0701-0800/0701-0710/#707-design-linked-list-starstar","text":"","title":"707. Design Linked List $\\star\\star$"},{"location":"java/0701-0800/0701-0710/#708-insert-into-a-sorted-circular-linked-list-starstar","text":"","title":"708. Insert into a Sorted Circular Linked List $\\star\\star$"},{"location":"java/0701-0800/0701-0710/#709-to-lower-case-star","text":"","title":"709. To Lower Case $\\star$"},{"location":"java/0701-0800/0701-0710/#710-random-pick-with-blacklist-starstarstar","text":"","title":"710. Random Pick with Blacklist $\\star\\star\\star$"},{"location":"java/0701-0800/0711-0720/","text":"711. Number of Distinct Islands II $\\star\\star\\star$ 712. Minimum ASCII Delete Sum for Two Strings $\\star\\star$ 713. Subarray Product Less Than K $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int numSubarrayProductLessThanK ( int [] nums , int k ) { if ( k <= 1 ) return 0 ; int ans = 0 ; int prod = 1 ; int j = 0 ; for ( int i = 0 ; i < nums . length ; i ++) { prod *= nums [ i ]; while ( prod >= k ) prod /= nums [ j ++]; ans += i - j + 1 ; } return ans ; } } 714. Best Time to Buy and Sell Stock with Transaction Fee $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int maxProfit ( int [] prices , int fee ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; for ( int price : prices ) { sell = Math . max ( sell , hold + price ); hold = Math . max ( hold , sell - price - fee ); } return sell ; } } 715. Range Module $\\star\\star\\star$ 716. Max Stack $\\star$ 717. 1-bit and 2-bit Characters $\\star$ 1 2 3 4 5 6 7 8 9 class Solution { public boolean isOneBitCharacter ( int [] bits ) { int i = 0 ; while ( i < bits . length - 1 ) i += bits [ i ] + 1 ; return i == bits . length - 1 ; } } 718. Maximum Length of Repeated Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int findLength ( int [] A , int [] B ) { final int m = A . length ; final int n = B . length ; int ans = 0 ; int [][] dp = new int [ m + 1 ][ n + 1 ]; for ( int i = m - 1 ; i >= 0 ; i --) for ( int j = n - 1 ; j >= 0 ; j --) if ( A [ i ] == B [ j ]) dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 ; for ( int [] row : dp ) for ( int c : row ) ans = Math . max ( ans , c ); return ans ; } } 719. Find K-th Smallest Pair Distance $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int smallestDistancePair ( int [] nums , int k ) { Arrays . sort ( nums ); int l = 0 ; int r = nums [ nums . length - 1 ] - nums [ 0 ]; while ( l < r ) { int m = l + ( r - l ) / 2 ; int count = 0 ; for ( int i = 0 , j = 0 ; i < nums . length ; i ++) { while ( j < nums . length && nums [ j ] <= nums [ i ] + m ) j ++; count += j - i - 1 ; } if ( count < k ) l = m + 1 ; else r = m ; } return l ; } } 720. Longest Word in Dictionary $\\star$","title":"0711-0720"},{"location":"java/0701-0800/0711-0720/#711-number-of-distinct-islands-ii-starstarstar","text":"","title":"711. Number of Distinct Islands II $\\star\\star\\star$"},{"location":"java/0701-0800/0711-0720/#712-minimum-ascii-delete-sum-for-two-strings-starstar","text":"","title":"712. Minimum ASCII Delete Sum for Two Strings $\\star\\star$"},{"location":"java/0701-0800/0711-0720/#713-subarray-product-less-than-k-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int numSubarrayProductLessThanK ( int [] nums , int k ) { if ( k <= 1 ) return 0 ; int ans = 0 ; int prod = 1 ; int j = 0 ; for ( int i = 0 ; i < nums . length ; i ++) { prod *= nums [ i ]; while ( prod >= k ) prod /= nums [ j ++]; ans += i - j + 1 ; } return ans ; } }","title":"713. Subarray Product Less Than K $\\star\\star$"},{"location":"java/0701-0800/0711-0720/#714-best-time-to-buy-and-sell-stock-with-transaction-fee-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int maxProfit ( int [] prices , int fee ) { int sell = 0 ; int hold = Integer . MIN_VALUE ; for ( int price : prices ) { sell = Math . max ( sell , hold + price ); hold = Math . max ( hold , sell - price - fee ); } return sell ; } }","title":"714. Best Time to Buy and Sell Stock with Transaction Fee $\\star\\star$"},{"location":"java/0701-0800/0711-0720/#715-range-module-starstarstar","text":"","title":"715. Range Module $\\star\\star\\star$"},{"location":"java/0701-0800/0711-0720/#716-max-stack-star","text":"","title":"716. Max Stack $\\star$"},{"location":"java/0701-0800/0711-0720/#717-1-bit-and-2-bit-characters-star","text":"1 2 3 4 5 6 7 8 9 class Solution { public boolean isOneBitCharacter ( int [] bits ) { int i = 0 ; while ( i < bits . length - 1 ) i += bits [ i ] + 1 ; return i == bits . length - 1 ; } }","title":"717. 1-bit and 2-bit Characters $\\star$"},{"location":"java/0701-0800/0711-0720/#718-maximum-length-of-repeated-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int findLength ( int [] A , int [] B ) { final int m = A . length ; final int n = B . length ; int ans = 0 ; int [][] dp = new int [ m + 1 ][ n + 1 ]; for ( int i = m - 1 ; i >= 0 ; i --) for ( int j = n - 1 ; j >= 0 ; j --) if ( A [ i ] == B [ j ]) dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 ; for ( int [] row : dp ) for ( int c : row ) ans = Math . max ( ans , c ); return ans ; } }","title":"718. Maximum Length of Repeated Subarray $\\star\\star$"},{"location":"java/0701-0800/0711-0720/#719-find-k-th-smallest-pair-distance-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int smallestDistancePair ( int [] nums , int k ) { Arrays . sort ( nums ); int l = 0 ; int r = nums [ nums . length - 1 ] - nums [ 0 ]; while ( l < r ) { int m = l + ( r - l ) / 2 ; int count = 0 ; for ( int i = 0 , j = 0 ; i < nums . length ; i ++) { while ( j < nums . length && nums [ j ] <= nums [ i ] + m ) j ++; count += j - i - 1 ; } if ( count < k ) l = m + 1 ; else r = m ; } return l ; } }","title":"719. Find K-th Smallest Pair Distance $\\star\\star\\star$"},{"location":"java/0701-0800/0711-0720/#720-longest-word-in-dictionary-star","text":"","title":"720. Longest Word in Dictionary $\\star$"},{"location":"java/0701-0800/0721-0730/","text":"721. Accounts Merge $\\star\\star$ 722. Remove Comments $\\star\\star$ 723. Candy Crush $\\star\\star$ 724. Find Pivot Index $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int pivotIndex ( int [] nums ) { int sum = 0 ; int presum = 0 ; for ( int num : nums ) sum += num ; for ( int i = 0 ; i < nums . length ; i ++) { if ( presum == sum - presum - nums [ i ]) return i ; presum += nums [ i ]; } return - 1 ; } } 725. Split Linked List in Parts $\\star\\star$ 726. Number of Atoms $\\star\\star\\star$ 727. Minimum Window Subsequence $\\star\\star\\star$ 728. Self Dividing Numbers $\\star$ 729. My Calendar I $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class MyCalendar { public boolean book ( int start , int end ) { for ( int [] book : books ) if ( Math . max ( book [ 0 ], start ) < Math . min ( book [ 1 ], end )) return false ; books . add ( new int [] { start , end }); return true ; } private List < int []> books = new ArrayList <>(); } 730. Count Different Palindromic Subsequences $\\star\\star\\star$","title":"0721-0730"},{"location":"java/0701-0800/0721-0730/#721-accounts-merge-starstar","text":"","title":"721. Accounts Merge $\\star\\star$"},{"location":"java/0701-0800/0721-0730/#722-remove-comments-starstar","text":"","title":"722. Remove Comments $\\star\\star$"},{"location":"java/0701-0800/0721-0730/#723-candy-crush-starstar","text":"","title":"723. Candy Crush $\\star\\star$"},{"location":"java/0701-0800/0721-0730/#724-find-pivot-index-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int pivotIndex ( int [] nums ) { int sum = 0 ; int presum = 0 ; for ( int num : nums ) sum += num ; for ( int i = 0 ; i < nums . length ; i ++) { if ( presum == sum - presum - nums [ i ]) return i ; presum += nums [ i ]; } return - 1 ; } }","title":"724. Find Pivot Index $\\star$"},{"location":"java/0701-0800/0721-0730/#725-split-linked-list-in-parts-starstar","text":"","title":"725. Split Linked List in Parts $\\star\\star$"},{"location":"java/0701-0800/0721-0730/#726-number-of-atoms-starstarstar","text":"","title":"726. Number of Atoms $\\star\\star\\star$"},{"location":"java/0701-0800/0721-0730/#727-minimum-window-subsequence-starstarstar","text":"","title":"727. Minimum Window Subsequence $\\star\\star\\star$"},{"location":"java/0701-0800/0721-0730/#728-self-dividing-numbers-star","text":"","title":"728. Self Dividing Numbers $\\star$"},{"location":"java/0701-0800/0721-0730/#729-my-calendar-i-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 class MyCalendar { public boolean book ( int start , int end ) { for ( int [] book : books ) if ( Math . max ( book [ 0 ], start ) < Math . min ( book [ 1 ], end )) return false ; books . add ( new int [] { start , end }); return true ; } private List < int []> books = new ArrayList <>(); }","title":"729. My Calendar I $\\star\\star$"},{"location":"java/0701-0800/0721-0730/#730-count-different-palindromic-subsequences-starstarstar","text":"","title":"730. Count Different Palindromic Subsequences $\\star\\star\\star$"},{"location":"java/0701-0800/0731-0740/","text":"731. My Calendar II $\\star\\star$ 732. My Calendar III $\\star\\star\\star$ 733. Flood Fill $\\star$ 734. Sentence Similarity $\\star$ 735. Asteroid Collision $\\star\\star$ 736. Parse Lisp Expression $\\star\\star\\star$ 737. Sentence Similarity II $\\star\\star$ 738. Monotone Increasing Digits $\\star\\star$ 739. Daily Temperatures $\\star\\star$ 740. Delete and Earn $\\star\\star$","title":"0731-0740"},{"location":"java/0701-0800/0731-0740/#731-my-calendar-ii-starstar","text":"","title":"731. My Calendar II $\\star\\star$"},{"location":"java/0701-0800/0731-0740/#732-my-calendar-iii-starstarstar","text":"","title":"732. My Calendar III $\\star\\star\\star$"},{"location":"java/0701-0800/0731-0740/#733-flood-fill-star","text":"","title":"733. Flood Fill $\\star$"},{"location":"java/0701-0800/0731-0740/#734-sentence-similarity-star","text":"","title":"734. Sentence Similarity $\\star$"},{"location":"java/0701-0800/0731-0740/#735-asteroid-collision-starstar","text":"","title":"735. Asteroid Collision $\\star\\star$"},{"location":"java/0701-0800/0731-0740/#736-parse-lisp-expression-starstarstar","text":"","title":"736. Parse Lisp Expression $\\star\\star\\star$"},{"location":"java/0701-0800/0731-0740/#737-sentence-similarity-ii-starstar","text":"","title":"737. Sentence Similarity II $\\star\\star$"},{"location":"java/0701-0800/0731-0740/#738-monotone-increasing-digits-starstar","text":"","title":"738. Monotone Increasing Digits $\\star\\star$"},{"location":"java/0701-0800/0731-0740/#739-daily-temperatures-starstar","text":"","title":"739. Daily Temperatures $\\star\\star$"},{"location":"java/0701-0800/0731-0740/#740-delete-and-earn-starstar","text":"","title":"740. Delete and Earn $\\star\\star$"},{"location":"java/0701-0800/0741-0750/","text":"741. Cherry Pickup $\\star\\star\\star$ 742. Closest Leaf in a Binary Tree $\\star\\star$ 743. Network Delay Time $\\star\\star$ 744. Find Smallest Letter Greater Than Target $\\star$ 745. Prefix and Suffix Search $\\star\\star\\star$ 746. Min Cost Climbing Stairs $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public int minCostClimbingStairs ( int [] cost ) { final int n = cost . length ; for ( int i = 2 ; i < n ; i ++) cost [ i ] += Math . min ( cost [ i - 1 ], cost [ i - 2 ]); return Math . min ( cost [ n - 1 ], cost [ n - 2 ]); } } 747. Largest Number At Least Twice of Others $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int dominantIndex ( int [] nums ) { int ans = 0 ; int max = 0 ; int secondMax = 0 ; for ( int i = 0 ; i < nums . length ; i ++) { if ( nums [ i ] > max ) { secondMax = max ; max = nums [ i ]; ans = i ; } else if ( nums [ i ] > secondMax ) secondMax = nums [ i ]; } return max >= 2 * secondMax ? ans : - 1 ; } } 748. Shortest Completing Word $\\star$ 749. Contain Virus $\\star\\star\\star$ 750. Number Of Corner Rectangles $\\star\\star$","title":"0741-0750"},{"location":"java/0701-0800/0741-0750/#741-cherry-pickup-starstarstar","text":"","title":"741. Cherry Pickup $\\star\\star\\star$"},{"location":"java/0701-0800/0741-0750/#742-closest-leaf-in-a-binary-tree-starstar","text":"","title":"742. Closest Leaf in a Binary Tree $\\star\\star$"},{"location":"java/0701-0800/0741-0750/#743-network-delay-time-starstar","text":"","title":"743. Network Delay Time $\\star\\star$"},{"location":"java/0701-0800/0741-0750/#744-find-smallest-letter-greater-than-target-star","text":"","title":"744. Find Smallest Letter Greater Than Target $\\star$"},{"location":"java/0701-0800/0741-0750/#745-prefix-and-suffix-search-starstarstar","text":"","title":"745. Prefix and Suffix Search $\\star\\star\\star$"},{"location":"java/0701-0800/0741-0750/#746-min-cost-climbing-stairs-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public int minCostClimbingStairs ( int [] cost ) { final int n = cost . length ; for ( int i = 2 ; i < n ; i ++) cost [ i ] += Math . min ( cost [ i - 1 ], cost [ i - 2 ]); return Math . min ( cost [ n - 1 ], cost [ n - 2 ]); } }","title":"746. Min Cost Climbing Stairs $\\star$"},{"location":"java/0701-0800/0741-0750/#747-largest-number-at-least-twice-of-others-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int dominantIndex ( int [] nums ) { int ans = 0 ; int max = 0 ; int secondMax = 0 ; for ( int i = 0 ; i < nums . length ; i ++) { if ( nums [ i ] > max ) { secondMax = max ; max = nums [ i ]; ans = i ; } else if ( nums [ i ] > secondMax ) secondMax = nums [ i ]; } return max >= 2 * secondMax ? ans : - 1 ; } }","title":"747. Largest Number At Least Twice of Others $\\star$"},{"location":"java/0701-0800/0741-0750/#748-shortest-completing-word-star","text":"","title":"748. Shortest Completing Word $\\star$"},{"location":"java/0701-0800/0741-0750/#749-contain-virus-starstarstar","text":"","title":"749. Contain Virus $\\star\\star\\star$"},{"location":"java/0701-0800/0741-0750/#750-number-of-corner-rectangles-starstar","text":"","title":"750. Number Of Corner Rectangles $\\star\\star$"},{"location":"java/0701-0800/0751-0760/","text":"751. IP to CIDR $\\star$ 752. Open the Lock $\\star\\star$ 753. Cracking the Safe $\\star\\star\\star$ 754. Reach a Number $\\star\\star$ 755. Pour Water $\\star\\star$ 756. Pyramid Transition Matrix $\\star\\star$ 757. Set Intersection Size At Least Two $\\star\\star\\star$ 758. Bold Words in String $\\star$ 759. Employee Free Time $\\star\\star\\star$ 760. Find Anagram Mappings $\\star$","title":"0751-0760"},{"location":"java/0701-0800/0751-0760/#751-ip-to-cidr-star","text":"","title":"751. IP to CIDR $\\star$"},{"location":"java/0701-0800/0751-0760/#752-open-the-lock-starstar","text":"","title":"752. Open the Lock $\\star\\star$"},{"location":"java/0701-0800/0751-0760/#753-cracking-the-safe-starstarstar","text":"","title":"753. Cracking the Safe $\\star\\star\\star$"},{"location":"java/0701-0800/0751-0760/#754-reach-a-number-starstar","text":"","title":"754. Reach a Number $\\star\\star$"},{"location":"java/0701-0800/0751-0760/#755-pour-water-starstar","text":"","title":"755. Pour Water $\\star\\star$"},{"location":"java/0701-0800/0751-0760/#756-pyramid-transition-matrix-starstar","text":"","title":"756. Pyramid Transition Matrix $\\star\\star$"},{"location":"java/0701-0800/0751-0760/#757-set-intersection-size-at-least-two-starstarstar","text":"","title":"757. Set Intersection Size At Least Two $\\star\\star\\star$"},{"location":"java/0701-0800/0751-0760/#758-bold-words-in-string-star","text":"","title":"758. Bold Words in String $\\star$"},{"location":"java/0701-0800/0751-0760/#759-employee-free-time-starstarstar","text":"","title":"759. Employee Free Time $\\star\\star\\star$"},{"location":"java/0701-0800/0751-0760/#760-find-anagram-mappings-star","text":"","title":"760. Find Anagram Mappings $\\star$"},{"location":"java/0701-0800/0761-0770/","text":"761. Special Binary String $\\star\\star\\star$ 762. Prime Number of Set Bits in Binary Representation $\\star$ 763. Partition Labels $\\star\\star$ 764. Largest Plus Sign $\\star\\star$ 765. Couples Holding Hands $\\star\\star\\star$ 766. Toeplitz Matrix $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution { public boolean isToeplitzMatrix ( int [][] matrix ) { for ( int i = 0 ; i < matrix . length - 1 ; i ++) for ( int j = 0 ; j < matrix [ 0 ]. length - 1 ; j ++) if ( matrix [ i ][ j ] != matrix [ i + 1 ][ j + 1 ]) return false ; return true ; } } 767. Reorganize String $\\star\\star$ 768. Max Chunks To Make Sorted II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int maxChunksToSorted ( int [] arr ) { final int n = arr . length ; int ans = 0 ; int max = Integer . MIN_VALUE ; int [] min = new int [ n ]; min [ n - 1 ] = arr [ n - 1 ]; for ( int i = n - 2 ; i >= 0 ; i --) min [ i ] = Math . min ( min [ i + 1 ], arr [ i ]); for ( int i = 0 ; i < n - 1 ; i ++) { max = Math . max ( max , arr [ i ]); if ( max <= min [ i + 1 ]) ans ++; } return ans + 1 ; } } 769. Max Chunks To Make Sorted $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int maxChunksToSorted ( int [] arr ) { int ans = 0 ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < arr . length ; i ++) { max = Math . max ( max , arr [ i ]); if ( max == i ) ans ++; } return ans ; } } 770. Basic Calculator IV $\\star\\star\\star$","title":"0761-0770"},{"location":"java/0701-0800/0761-0770/#761-special-binary-string-starstarstar","text":"","title":"761. Special Binary String $\\star\\star\\star$"},{"location":"java/0701-0800/0761-0770/#762-prime-number-of-set-bits-in-binary-representation-star","text":"","title":"762. Prime Number of Set Bits in Binary Representation $\\star$"},{"location":"java/0701-0800/0761-0770/#763-partition-labels-starstar","text":"","title":"763. Partition Labels $\\star\\star$"},{"location":"java/0701-0800/0761-0770/#764-largest-plus-sign-starstar","text":"","title":"764. Largest Plus Sign $\\star\\star$"},{"location":"java/0701-0800/0761-0770/#765-couples-holding-hands-starstarstar","text":"","title":"765. Couples Holding Hands $\\star\\star\\star$"},{"location":"java/0701-0800/0761-0770/#766-toeplitz-matrix-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution { public boolean isToeplitzMatrix ( int [][] matrix ) { for ( int i = 0 ; i < matrix . length - 1 ; i ++) for ( int j = 0 ; j < matrix [ 0 ]. length - 1 ; j ++) if ( matrix [ i ][ j ] != matrix [ i + 1 ][ j + 1 ]) return false ; return true ; } }","title":"766. Toeplitz Matrix $\\star$"},{"location":"java/0701-0800/0761-0770/#767-reorganize-string-starstar","text":"","title":"767. Reorganize String $\\star\\star$"},{"location":"java/0701-0800/0761-0770/#768-max-chunks-to-make-sorted-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int maxChunksToSorted ( int [] arr ) { final int n = arr . length ; int ans = 0 ; int max = Integer . MIN_VALUE ; int [] min = new int [ n ]; min [ n - 1 ] = arr [ n - 1 ]; for ( int i = n - 2 ; i >= 0 ; i --) min [ i ] = Math . min ( min [ i + 1 ], arr [ i ]); for ( int i = 0 ; i < n - 1 ; i ++) { max = Math . max ( max , arr [ i ]); if ( max <= min [ i + 1 ]) ans ++; } return ans + 1 ; } }","title":"768. Max Chunks To Make Sorted II $\\star\\star\\star$"},{"location":"java/0701-0800/0761-0770/#769-max-chunks-to-make-sorted-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int maxChunksToSorted ( int [] arr ) { int ans = 0 ; int max = Integer . MIN_VALUE ; for ( int i = 0 ; i < arr . length ; i ++) { max = Math . max ( max , arr [ i ]); if ( max == i ) ans ++; } return ans ; } }","title":"769. Max Chunks To Make Sorted $\\star\\star$"},{"location":"java/0701-0800/0761-0770/#770-basic-calculator-iv-starstarstar","text":"","title":"770. Basic Calculator IV $\\star\\star\\star$"},{"location":"java/0701-0800/0771-0780/","text":"771. Jewels and Stones $\\star$ 772. Basic Calculator III $\\star\\star\\star$ 773. Sliding Puzzle $\\star\\star\\star$ 774. Minimize Max Distance to Gas Station $\\star\\star\\star$ 775. Global and Local Inversions $\\star\\star$ 1 2 3 4 5 6 7 8 9 class Solution { public boolean isIdealPermutation ( int [] A ) { for ( int i = 0 ; i < A . length ; i ++) if ( Math . abs ( A [ i ] - i ) > 1 ) return false ; return true ; } } 776. Split BST $\\star\\star$ 777. Swap Adjacent in LR String $\\star\\star$ 778. Swim in Rising Water $\\star\\star\\star$ 779. K-th Symbol in Grammar $\\star\\star$ 780. Reaching Points $\\star\\star\\star$","title":"0771-0780"},{"location":"java/0701-0800/0771-0780/#771-jewels-and-stones-star","text":"","title":"771. Jewels and Stones $\\star$"},{"location":"java/0701-0800/0771-0780/#772-basic-calculator-iii-starstarstar","text":"","title":"772. Basic Calculator III $\\star\\star\\star$"},{"location":"java/0701-0800/0771-0780/#773-sliding-puzzle-starstarstar","text":"","title":"773. Sliding Puzzle $\\star\\star\\star$"},{"location":"java/0701-0800/0771-0780/#774-minimize-max-distance-to-gas-station-starstarstar","text":"","title":"774. Minimize Max Distance to Gas Station $\\star\\star\\star$"},{"location":"java/0701-0800/0771-0780/#775-global-and-local-inversions-starstar","text":"1 2 3 4 5 6 7 8 9 class Solution { public boolean isIdealPermutation ( int [] A ) { for ( int i = 0 ; i < A . length ; i ++) if ( Math . abs ( A [ i ] - i ) > 1 ) return false ; return true ; } }","title":"775. Global and Local Inversions $\\star\\star$"},{"location":"java/0701-0800/0771-0780/#776-split-bst-starstar","text":"","title":"776. Split BST $\\star\\star$"},{"location":"java/0701-0800/0771-0780/#777-swap-adjacent-in-lr-string-starstar","text":"","title":"777. Swap Adjacent in LR String $\\star\\star$"},{"location":"java/0701-0800/0771-0780/#778-swim-in-rising-water-starstarstar","text":"","title":"778. Swim in Rising Water $\\star\\star\\star$"},{"location":"java/0701-0800/0771-0780/#779-k-th-symbol-in-grammar-starstar","text":"","title":"779. K-th Symbol in Grammar $\\star\\star$"},{"location":"java/0701-0800/0771-0780/#780-reaching-points-starstarstar","text":"","title":"780. Reaching Points $\\star\\star\\star$"},{"location":"java/0701-0800/0781-0790/","text":"781. Rabbits in Forest $\\star\\star$ 782. Transform to Chessboard $\\star\\star\\star$ 783. Minimum Distance Between BST Nodes $\\star$ 784. Letter Case Permutation $\\star$ 785. Is Graph Bipartite? $\\star\\star$ 786. K-th Smallest Prime Fraction $\\star\\star\\star$ 787. Cheapest Flights Within K Stops $\\star\\star$ 788. Rotated Digits $\\star$ 789. Escape The Ghosts $\\star\\star$ 790. Domino and Tromino Tiling $\\star\\star$","title":"0781-0790"},{"location":"java/0701-0800/0781-0790/#781-rabbits-in-forest-starstar","text":"","title":"781. Rabbits in Forest $\\star\\star$"},{"location":"java/0701-0800/0781-0790/#782-transform-to-chessboard-starstarstar","text":"","title":"782. Transform to Chessboard $\\star\\star\\star$"},{"location":"java/0701-0800/0781-0790/#783-minimum-distance-between-bst-nodes-star","text":"","title":"783. Minimum Distance Between BST Nodes $\\star$"},{"location":"java/0701-0800/0781-0790/#784-letter-case-permutation-star","text":"","title":"784. Letter Case Permutation $\\star$"},{"location":"java/0701-0800/0781-0790/#785-is-graph-bipartite-starstar","text":"","title":"785. Is Graph Bipartite? $\\star\\star$"},{"location":"java/0701-0800/0781-0790/#786-k-th-smallest-prime-fraction-starstarstar","text":"","title":"786. K-th Smallest Prime Fraction $\\star\\star\\star$"},{"location":"java/0701-0800/0781-0790/#787-cheapest-flights-within-k-stops-starstar","text":"","title":"787. Cheapest Flights Within K Stops $\\star\\star$"},{"location":"java/0701-0800/0781-0790/#788-rotated-digits-star","text":"","title":"788. Rotated Digits $\\star$"},{"location":"java/0701-0800/0781-0790/#789-escape-the-ghosts-starstar","text":"","title":"789. Escape The Ghosts $\\star\\star$"},{"location":"java/0701-0800/0781-0790/#790-domino-and-tromino-tiling-starstar","text":"","title":"790. Domino and Tromino Tiling $\\star\\star$"},{"location":"java/0701-0800/0791-0800/","text":"791. Custom Sort String $\\star\\star$ 792. Number of Matching Subsequences $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public int numMatchingSubseq ( String S , String [] words ) { for ( String word : words ) insert ( word ); return dfs ( S , 0 , root ); } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ]; private int count = 0 ; } private TrieNode root = new TrieNode (); private void insert ( String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ]; } node . count ++; } private int dfs ( String S , int s , TrieNode node ) { int ans = node . count ; if ( s >= S . length ()) return ans ; for ( int i = 0 ; i < 26 ; i ++) if ( node . children [ i ] != null ) { int index = S . indexOf ( i + 'a' , s ); if ( index != - 1 ) ans += dfs ( S , index + 1 , node . children [ i ]); } return ans ; } } 793. Preimage Size of Factorial Zeroes Function $\\star\\star\\star$ 794. Valid Tic-Tac-Toe State $\\star\\star$ 795. Number of Subarrays with Bounded Maximum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int numSubarrayBoundedMax ( int [] A , int L , int R ) { int ans = 0 ; int l = - 1 ; int r = - 1 ; for ( int i = 0 ; i < A . length ; i ++) { if ( A [ i ] > R ) l = i ; if ( A [ i ] >= L ) r = i ; ans += r - l ; } return ans ; } } 796. Rotate String $\\star$ 797. All Paths From Source to Target $\\star\\star$ 798. Smallest Rotation with Highest Score $\\star\\star\\star$ 799. Champagne Tower $\\star\\star$ 800. Similar RGB Color $\\star$","title":"0791-0800"},{"location":"java/0701-0800/0791-0800/#791-custom-sort-string-starstar","text":"","title":"791. Custom Sort String $\\star\\star$"},{"location":"java/0701-0800/0791-0800/#792-number-of-matching-subsequences-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution { public int numMatchingSubseq ( String S , String [] words ) { for ( String word : words ) insert ( word ); return dfs ( S , 0 , root ); } private class TrieNode { private TrieNode [] children = new TrieNode [ 26 ]; private int count = 0 ; } private TrieNode root = new TrieNode (); private void insert ( String word ) { TrieNode node = root ; for ( char c : word . toCharArray ()) { int index = c - 'a' ; if ( node . children [ index ] == null ) node . children [ index ] = new TrieNode (); node = node . children [ index ]; } node . count ++; } private int dfs ( String S , int s , TrieNode node ) { int ans = node . count ; if ( s >= S . length ()) return ans ; for ( int i = 0 ; i < 26 ; i ++) if ( node . children [ i ] != null ) { int index = S . indexOf ( i + 'a' , s ); if ( index != - 1 ) ans += dfs ( S , index + 1 , node . children [ i ]); } return ans ; } }","title":"792. Number of Matching Subsequences $\\star\\star$"},{"location":"java/0701-0800/0791-0800/#793-preimage-size-of-factorial-zeroes-function-starstarstar","text":"","title":"793. Preimage Size of Factorial Zeroes Function $\\star\\star\\star$"},{"location":"java/0701-0800/0791-0800/#794-valid-tic-tac-toe-state-starstar","text":"","title":"794. Valid Tic-Tac-Toe State $\\star\\star$"},{"location":"java/0701-0800/0791-0800/#795-number-of-subarrays-with-bounded-maximum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public int numSubarrayBoundedMax ( int [] A , int L , int R ) { int ans = 0 ; int l = - 1 ; int r = - 1 ; for ( int i = 0 ; i < A . length ; i ++) { if ( A [ i ] > R ) l = i ; if ( A [ i ] >= L ) r = i ; ans += r - l ; } return ans ; } }","title":"795. Number of Subarrays with Bounded Maximum $\\star\\star$"},{"location":"java/0701-0800/0791-0800/#796-rotate-string-star","text":"","title":"796. Rotate String $\\star$"},{"location":"java/0701-0800/0791-0800/#797-all-paths-from-source-to-target-starstar","text":"","title":"797. All Paths From Source to Target $\\star\\star$"},{"location":"java/0701-0800/0791-0800/#798-smallest-rotation-with-highest-score-starstarstar","text":"","title":"798. Smallest Rotation with Highest Score $\\star\\star\\star$"},{"location":"java/0701-0800/0791-0800/#799-champagne-tower-starstar","text":"","title":"799. Champagne Tower $\\star\\star$"},{"location":"java/0701-0800/0791-0800/#800-similar-rgb-color-star","text":"","title":"800. Similar RGB Color $\\star$"},{"location":"java/0801-0900/0801-0810/","text":"801. Minimum Swaps To Make Sequences Increasing $\\star\\star$ 802. Find Eventual Safe States $\\star\\star$ 803. Bricks Falling When Hit $\\star\\star\\star$ 804. Unique Morse Code Words $\\star$ 805. Split Array With Same Average $\\star\\star\\star$ 806. Number of Lines To Write String $\\star$ 807. Max Increase to Keep City Skyline $\\star\\star$ 808. Soup Servings $\\star\\star$ 809. Expressive Words $\\star\\star$ 810. Chalkboard XOR Game $\\star\\star\\star$","title":"0801-0810"},{"location":"java/0801-0900/0801-0810/#801-minimum-swaps-to-make-sequences-increasing-starstar","text":"","title":"801. Minimum Swaps To Make Sequences Increasing $\\star\\star$"},{"location":"java/0801-0900/0801-0810/#802-find-eventual-safe-states-starstar","text":"","title":"802. Find Eventual Safe States $\\star\\star$"},{"location":"java/0801-0900/0801-0810/#803-bricks-falling-when-hit-starstarstar","text":"","title":"803. Bricks Falling When Hit $\\star\\star\\star$"},{"location":"java/0801-0900/0801-0810/#804-unique-morse-code-words-star","text":"","title":"804. Unique Morse Code Words $\\star$"},{"location":"java/0801-0900/0801-0810/#805-split-array-with-same-average-starstarstar","text":"","title":"805. Split Array With Same Average $\\star\\star\\star$"},{"location":"java/0801-0900/0801-0810/#806-number-of-lines-to-write-string-star","text":"","title":"806. Number of Lines To Write String $\\star$"},{"location":"java/0801-0900/0801-0810/#807-max-increase-to-keep-city-skyline-starstar","text":"","title":"807. Max Increase to Keep City Skyline $\\star\\star$"},{"location":"java/0801-0900/0801-0810/#808-soup-servings-starstar","text":"","title":"808. Soup Servings $\\star\\star$"},{"location":"java/0801-0900/0801-0810/#809-expressive-words-starstar","text":"","title":"809. Expressive Words $\\star\\star$"},{"location":"java/0801-0900/0801-0810/#810-chalkboard-xor-game-starstarstar","text":"","title":"810. Chalkboard XOR Game $\\star\\star\\star$"},{"location":"java/0801-0900/0811-0820/","text":"811. Subdomain Visit Count $\\star$ 812. Largest Triangle Area $\\star$ 813. Largest Sum of Averages $\\star\\star$ 814. Binary Tree Pruning $\\star\\star$ 815. Bus Routes $\\star\\star\\star$ 816. Ambiguous Coordinates $\\star\\star$ 817. Linked List Components $\\star\\star$ 818. Race Car $\\star\\star\\star$ 819. Most Common Word $\\star$ 820. Short Encoding of Words $\\star\\star$","title":"0811-0820"},{"location":"java/0801-0900/0811-0820/#811-subdomain-visit-count-star","text":"","title":"811. Subdomain Visit Count $\\star$"},{"location":"java/0801-0900/0811-0820/#812-largest-triangle-area-star","text":"","title":"812. Largest Triangle Area $\\star$"},{"location":"java/0801-0900/0811-0820/#813-largest-sum-of-averages-starstar","text":"","title":"813. Largest Sum of Averages $\\star\\star$"},{"location":"java/0801-0900/0811-0820/#814-binary-tree-pruning-starstar","text":"","title":"814. Binary Tree Pruning $\\star\\star$"},{"location":"java/0801-0900/0811-0820/#815-bus-routes-starstarstar","text":"","title":"815. Bus Routes $\\star\\star\\star$"},{"location":"java/0801-0900/0811-0820/#816-ambiguous-coordinates-starstar","text":"","title":"816. Ambiguous Coordinates $\\star\\star$"},{"location":"java/0801-0900/0811-0820/#817-linked-list-components-starstar","text":"","title":"817. Linked List Components $\\star\\star$"},{"location":"java/0801-0900/0811-0820/#818-race-car-starstarstar","text":"","title":"818. Race Car $\\star\\star\\star$"},{"location":"java/0801-0900/0811-0820/#819-most-common-word-star","text":"","title":"819. Most Common Word $\\star$"},{"location":"java/0801-0900/0811-0820/#820-short-encoding-of-words-starstar","text":"","title":"820. Short Encoding of Words $\\star\\star$"},{"location":"java/0801-0900/0821-0830/","text":"821. Shortest Distance to a Character $\\star$ 822. Card Flipping Game $\\star\\star$ 823. Binary Trees With Factors $\\star\\star$ 824. Goat Latin $\\star$ 825. Friends Of Appropriate Ages $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int numFriendRequests ( int [] ages ) { int ans = 0 ; int [] count = new int [ 121 ]; for ( int age : ages ) count [ age ]++; for ( int i = 15 ; i <= 120 ; i ++) ans += count [ i ] * ( count [ i ] - 1 ); for ( int i = 15 ; i <= 120 ; i ++) for ( int j = i / 2 + 8 ; j < i ; j ++) ans += count [ i ] * count [ j ]; return ans ; } } 826. Most Profit Assigning Work $\\star\\star$ 827. Making A Large Island $\\star\\star\\star$ 828. Unique Letter String $\\star\\star\\star$ 829. Consecutive Numbers Sum $\\star\\star\\star$ 830. Positions of Large Groups $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public List < List < Integer >> largeGroupPositions ( String S ) { final int n = S . length (); List < List < Integer >> ans = new ArrayList <>(); for ( int i = 0 , j = 0 ; i < n ; i = j ) { while ( j < n && S . charAt ( j ) == S . charAt ( i )) j ++; if ( j - i >= 3 ) ans . add ( Arrays . asList ( i , j - 1 )); } return ans ; } }","title":"0821-0830"},{"location":"java/0801-0900/0821-0830/#821-shortest-distance-to-a-character-star","text":"","title":"821. Shortest Distance to a Character $\\star$"},{"location":"java/0801-0900/0821-0830/#822-card-flipping-game-starstar","text":"","title":"822. Card Flipping Game $\\star\\star$"},{"location":"java/0801-0900/0821-0830/#823-binary-trees-with-factors-starstar","text":"","title":"823. Binary Trees With Factors $\\star\\star$"},{"location":"java/0801-0900/0821-0830/#824-goat-latin-star","text":"","title":"824. Goat Latin $\\star$"},{"location":"java/0801-0900/0821-0830/#825-friends-of-appropriate-ages-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution { public int numFriendRequests ( int [] ages ) { int ans = 0 ; int [] count = new int [ 121 ]; for ( int age : ages ) count [ age ]++; for ( int i = 15 ; i <= 120 ; i ++) ans += count [ i ] * ( count [ i ] - 1 ); for ( int i = 15 ; i <= 120 ; i ++) for ( int j = i / 2 + 8 ; j < i ; j ++) ans += count [ i ] * count [ j ]; return ans ; } }","title":"825. Friends Of Appropriate Ages $\\star\\star$"},{"location":"java/0801-0900/0821-0830/#826-most-profit-assigning-work-starstar","text":"","title":"826. Most Profit Assigning Work $\\star\\star$"},{"location":"java/0801-0900/0821-0830/#827-making-a-large-island-starstarstar","text":"","title":"827. Making A Large Island $\\star\\star\\star$"},{"location":"java/0801-0900/0821-0830/#828-unique-letter-string-starstarstar","text":"","title":"828. Unique Letter String $\\star\\star\\star$"},{"location":"java/0801-0900/0821-0830/#829-consecutive-numbers-sum-starstarstar","text":"","title":"829. Consecutive Numbers Sum $\\star\\star\\star$"},{"location":"java/0801-0900/0821-0830/#830-positions-of-large-groups-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public List < List < Integer >> largeGroupPositions ( String S ) { final int n = S . length (); List < List < Integer >> ans = new ArrayList <>(); for ( int i = 0 , j = 0 ; i < n ; i = j ) { while ( j < n && S . charAt ( j ) == S . charAt ( i )) j ++; if ( j - i >= 3 ) ans . add ( Arrays . asList ( i , j - 1 )); } return ans ; } }","title":"830. Positions of Large Groups $\\star$"},{"location":"java/0801-0900/0831-0840/","text":"831. Masking Personal Information $\\star\\star$ 832. Flipping an Image $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int [][] flipAndInvertImage ( int [][] A ) { final int n = A . length ; for ( int i = 0 ; i < n ; i ++) for ( int j = 0 ; j < ( n + 1 ) / 2 ; j ++) { int temp = A [ i ][ j ]; A [ i ][ j ] = A [ i ][ n - j - 1 ] ^ 1 ; A [ i ][ n - j - 1 ] = temp ^ 1 ; } return A ; } } 833. Find And Replace in String $\\star\\star$ 834. Sum of Distances in Tree $\\star\\star\\star$ 835. Image Overlap $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public int largestOverlap ( int [][] A , int [][] B ) { final int n = A . length ; final int magic = 100 ; int ans = 0 ; List < int []> onesA = new ArrayList <>(); List < int []> onesB = new ArrayList <>(); Map < Integer , Integer > map = new HashMap <>(); for ( int i = 0 ; i < n ; i ++) for ( int j = 0 ; j < n ; j ++) { if ( A [ i ][ j ] == 1 ) onesA . add ( new int [] { i , j }); if ( B [ i ][ j ] == 1 ) onesB . add ( new int [] { i , j }); } for ( int [] a : onesA ) for ( int [] b : onesB ) { int key = ( a [ 0 ] - b [ 0 ]) * magic + a [ 1 ] - b [ 1 ]; map . put ( key , map . getOrDefault ( key , 0 ) + 1 ); } for ( int value : map . values ()) ans = Math . max ( ans , value ); return ans ; } } 836. Rectangle Overlap $\\star$ 837. New 21 Game $\\star\\star$ 838. Push Dominoes $\\star\\star$ 839. Similar String Groups $\\star\\star\\star$ 840. Magic Squares In Grid $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int numMagicSquaresInside ( int [][] grid ) { int ans = 0 ; for ( int i = 0 ; i + 2 < grid . length ; i ++) for ( int j = 0 ; j + 2 < grid [ 0 ]. length ; j ++) if ( grid [ i ][ j ] % 2 == 0 && grid [ i + 1 ][ j + 1 ] == 5 ) ans += isMagic ( grid , i , j ); return ans ; } private int isMagic ( int [][] grid , int i , int j ) { String s = new String ( \"\" ); for ( int num : new int [] { 0 , 1 , 2 , 5 , 8 , 7 , 6 , 3 }) s += Integer . toString ( grid [ i + num / 3 ][ j + num % 3 ]); return new String ( \"4381672943816729\" ). contains ( s ) || new String ( \"9276183492761834\" ). contains ( s ) ? 1 : 0 ; } }","title":"0831-0840"},{"location":"java/0801-0900/0831-0840/#831-masking-personal-information-starstar","text":"","title":"831. Masking Personal Information $\\star\\star$"},{"location":"java/0801-0900/0831-0840/#832-flipping-an-image-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int [][] flipAndInvertImage ( int [][] A ) { final int n = A . length ; for ( int i = 0 ; i < n ; i ++) for ( int j = 0 ; j < ( n + 1 ) / 2 ; j ++) { int temp = A [ i ][ j ]; A [ i ][ j ] = A [ i ][ n - j - 1 ] ^ 1 ; A [ i ][ n - j - 1 ] = temp ^ 1 ; } return A ; } }","title":"832. Flipping an Image $\\star$"},{"location":"java/0801-0900/0831-0840/#833-find-and-replace-in-string-starstar","text":"","title":"833. Find And Replace in String $\\star\\star$"},{"location":"java/0801-0900/0831-0840/#834-sum-of-distances-in-tree-starstarstar","text":"","title":"834. Sum of Distances in Tree $\\star\\star\\star$"},{"location":"java/0801-0900/0831-0840/#835-image-overlap-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution { public int largestOverlap ( int [][] A , int [][] B ) { final int n = A . length ; final int magic = 100 ; int ans = 0 ; List < int []> onesA = new ArrayList <>(); List < int []> onesB = new ArrayList <>(); Map < Integer , Integer > map = new HashMap <>(); for ( int i = 0 ; i < n ; i ++) for ( int j = 0 ; j < n ; j ++) { if ( A [ i ][ j ] == 1 ) onesA . add ( new int [] { i , j }); if ( B [ i ][ j ] == 1 ) onesB . add ( new int [] { i , j }); } for ( int [] a : onesA ) for ( int [] b : onesB ) { int key = ( a [ 0 ] - b [ 0 ]) * magic + a [ 1 ] - b [ 1 ]; map . put ( key , map . getOrDefault ( key , 0 ) + 1 ); } for ( int value : map . values ()) ans = Math . max ( ans , value ); return ans ; } }","title":"835. Image Overlap $\\star\\star$"},{"location":"java/0801-0900/0831-0840/#836-rectangle-overlap-star","text":"","title":"836. Rectangle Overlap $\\star$"},{"location":"java/0801-0900/0831-0840/#837-new-21-game-starstar","text":"","title":"837. New 21 Game $\\star\\star$"},{"location":"java/0801-0900/0831-0840/#838-push-dominoes-starstar","text":"","title":"838. Push Dominoes $\\star\\star$"},{"location":"java/0801-0900/0831-0840/#839-similar-string-groups-starstarstar","text":"","title":"839. Similar String Groups $\\star\\star\\star$"},{"location":"java/0801-0900/0831-0840/#840-magic-squares-in-grid-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int numMagicSquaresInside ( int [][] grid ) { int ans = 0 ; for ( int i = 0 ; i + 2 < grid . length ; i ++) for ( int j = 0 ; j + 2 < grid [ 0 ]. length ; j ++) if ( grid [ i ][ j ] % 2 == 0 && grid [ i + 1 ][ j + 1 ] == 5 ) ans += isMagic ( grid , i , j ); return ans ; } private int isMagic ( int [][] grid , int i , int j ) { String s = new String ( \"\" ); for ( int num : new int [] { 0 , 1 , 2 , 5 , 8 , 7 , 6 , 3 }) s += Integer . toString ( grid [ i + num / 3 ][ j + num % 3 ]); return new String ( \"4381672943816729\" ). contains ( s ) || new String ( \"9276183492761834\" ). contains ( s ) ? 1 : 0 ; } }","title":"840. Magic Squares In Grid $\\star$"},{"location":"java/0801-0900/0841-0850/","text":"841. Keys and Rooms $\\star\\star$ 842. Split Array into Fibonacci Sequence $\\star\\star$ 843. Guess the Word $\\star\\star\\star$ 844. Backspace String Compare $\\star$ 845. Longest Mountain in Array $\\star\\star$ 846. Hand of Straights $\\star\\star$ 847. Shortest Path Visiting All Nodes $\\star\\star\\star$ 848. Shifting Letters $\\star\\star$ 849. Maximize Distance to Closest Person $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int maxDistToClosest ( int [] seats ) { final int n = seats . length ; int ans = 0 ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++) if ( seats [ i ] == 1 ) { ans = j == - 1 ? i : Math . max ( ans , ( i - j ) / 2 ); j = i ; } return Math . max ( ans , n - j - 1 ); } } 850. Rectangle Area II $\\star\\star\\star$","title":"0841-0850"},{"location":"java/0801-0900/0841-0850/#841-keys-and-rooms-starstar","text":"","title":"841. Keys and Rooms $\\star\\star$"},{"location":"java/0801-0900/0841-0850/#842-split-array-into-fibonacci-sequence-starstar","text":"","title":"842. Split Array into Fibonacci Sequence $\\star\\star$"},{"location":"java/0801-0900/0841-0850/#843-guess-the-word-starstarstar","text":"","title":"843. Guess the Word $\\star\\star\\star$"},{"location":"java/0801-0900/0841-0850/#844-backspace-string-compare-star","text":"","title":"844. Backspace String Compare $\\star$"},{"location":"java/0801-0900/0841-0850/#845-longest-mountain-in-array-starstar","text":"","title":"845. Longest Mountain in Array $\\star\\star$"},{"location":"java/0801-0900/0841-0850/#846-hand-of-straights-starstar","text":"","title":"846. Hand of Straights $\\star\\star$"},{"location":"java/0801-0900/0841-0850/#847-shortest-path-visiting-all-nodes-starstarstar","text":"","title":"847. Shortest Path Visiting All Nodes $\\star\\star\\star$"},{"location":"java/0801-0900/0841-0850/#848-shifting-letters-starstar","text":"","title":"848. Shifting Letters $\\star\\star$"},{"location":"java/0801-0900/0841-0850/#849-maximize-distance-to-closest-person-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int maxDistToClosest ( int [] seats ) { final int n = seats . length ; int ans = 0 ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++) if ( seats [ i ] == 1 ) { ans = j == - 1 ? i : Math . max ( ans , ( i - j ) / 2 ); j = i ; } return Math . max ( ans , n - j - 1 ); } }","title":"849. Maximize Distance to Closest Person $\\star$"},{"location":"java/0801-0900/0841-0850/#850-rectangle-area-ii-starstarstar","text":"","title":"850. Rectangle Area II $\\star\\star\\star$"},{"location":"java/0801-0900/0851-0860/","text":"851. Loud and Rich $\\star\\star$ 852. Peak Index in a Mountain Array $\\star$ 853. Car Fleet $\\star\\star$ 854. K-Similar Strings $\\star\\star\\star$ 855. Exam Room $\\star\\star$ 856. Score of Parentheses $\\star\\star$ 857. Minimum Cost to Hire K Workers $\\star\\star\\star$ 858. Mirror Reflection $\\star\\star$ 859. Buddy Strings $\\star$ 860. Lemonade Change $\\star$","title":"0851-0860"},{"location":"java/0801-0900/0851-0860/#851-loud-and-rich-starstar","text":"","title":"851. Loud and Rich $\\star\\star$"},{"location":"java/0801-0900/0851-0860/#852-peak-index-in-a-mountain-array-star","text":"","title":"852. Peak Index in a Mountain Array $\\star$"},{"location":"java/0801-0900/0851-0860/#853-car-fleet-starstar","text":"","title":"853. Car Fleet $\\star\\star$"},{"location":"java/0801-0900/0851-0860/#854-k-similar-strings-starstarstar","text":"","title":"854. K-Similar Strings $\\star\\star\\star$"},{"location":"java/0801-0900/0851-0860/#855-exam-room-starstar","text":"","title":"855. Exam Room $\\star\\star$"},{"location":"java/0801-0900/0851-0860/#856-score-of-parentheses-starstar","text":"","title":"856. Score of Parentheses $\\star\\star$"},{"location":"java/0801-0900/0851-0860/#857-minimum-cost-to-hire-k-workers-starstarstar","text":"","title":"857. Minimum Cost to Hire K Workers $\\star\\star\\star$"},{"location":"java/0801-0900/0851-0860/#858-mirror-reflection-starstar","text":"","title":"858. Mirror Reflection $\\star\\star$"},{"location":"java/0801-0900/0851-0860/#859-buddy-strings-star","text":"","title":"859. Buddy Strings $\\star$"},{"location":"java/0801-0900/0851-0860/#860-lemonade-change-star","text":"","title":"860. Lemonade Change $\\star$"},{"location":"java/0801-0900/0861-0870/","text":"861. Score After Flipping Matrix $\\star\\star$ 862. Shortest Subarray with Sum at Least K $\\star\\star\\star$ 863. All Nodes Distance K in Binary Tree $\\star\\star$ 864. Shortest Path to Get All Keys $\\star\\star\\star$ 865. Smallest Subtree with all the Deepest Nodes $\\star\\star$ 866. Prime Palindrome $\\star\\star$ 867. Transpose Matrix $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution { public int [][] transpose ( int [][] A ) { int [][] ans = new int [ A [ 0 ]. length ][ A . length ]; for ( int i = 0 ; i < A . length ; i ++) for ( int j = 0 ; j < A [ 0 ]. length ; j ++) ans [ j ][ i ] = A [ i ][ j ]; return ans ; } } 868. Binary Gap $\\star$ 869. Reordered Power of 2 $\\star\\star$ 870. Advantage Shuffle $\\star\\star$","title":"0861-0870"},{"location":"java/0801-0900/0861-0870/#861-score-after-flipping-matrix-starstar","text":"","title":"861. Score After Flipping Matrix $\\star\\star$"},{"location":"java/0801-0900/0861-0870/#862-shortest-subarray-with-sum-at-least-k-starstarstar","text":"","title":"862. Shortest Subarray with Sum at Least K $\\star\\star\\star$"},{"location":"java/0801-0900/0861-0870/#863-all-nodes-distance-k-in-binary-tree-starstar","text":"","title":"863. All Nodes Distance K in Binary Tree $\\star\\star$"},{"location":"java/0801-0900/0861-0870/#864-shortest-path-to-get-all-keys-starstarstar","text":"","title":"864. Shortest Path to Get All Keys $\\star\\star\\star$"},{"location":"java/0801-0900/0861-0870/#865-smallest-subtree-with-all-the-deepest-nodes-starstar","text":"","title":"865. Smallest Subtree with all the Deepest Nodes $\\star\\star$"},{"location":"java/0801-0900/0861-0870/#866-prime-palindrome-starstar","text":"","title":"866. Prime Palindrome $\\star\\star$"},{"location":"java/0801-0900/0861-0870/#867-transpose-matrix-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution { public int [][] transpose ( int [][] A ) { int [][] ans = new int [ A [ 0 ]. length ][ A . length ]; for ( int i = 0 ; i < A . length ; i ++) for ( int j = 0 ; j < A [ 0 ]. length ; j ++) ans [ j ][ i ] = A [ i ][ j ]; return ans ; } }","title":"867. Transpose Matrix $\\star$"},{"location":"java/0801-0900/0861-0870/#868-binary-gap-star","text":"","title":"868. Binary Gap $\\star$"},{"location":"java/0801-0900/0861-0870/#869-reordered-power-of-2-starstar","text":"","title":"869. Reordered Power of 2 $\\star\\star$"},{"location":"java/0801-0900/0861-0870/#870-advantage-shuffle-starstar","text":"","title":"870. Advantage Shuffle $\\star\\star$"},{"location":"java/0801-0900/0871-0880/","text":"871. Minimum Number of Refueling Stops $\\star\\star\\star$ 872. Leaf-Similar Trees $\\star$ 873. Length of Longest Fibonacci Subsequence $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int lenLongestFibSubseq ( int [] A ) { final int n = A . length ; int ans = 0 ; Map < Integer , Integer > map = new HashMap <>(); for ( int i = 0 ; i < n ; i ++) map . put ( A [ i ], i ); int [][] dp = new int [ n ][ n ]; for ( int [] row : dp ) Arrays . fill ( row , 2 ); for ( int j = 0 ; j < n ; j ++) for ( int k = j + 1 ; k < n ; k ++) { int ai = A [ k ] - A [ j ]; if ( ai < A [ j ] && map . containsKey ( ai )) { int i = map . get ( ai ); dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = Math . max ( ans , dp [ j ][ k ]); } } return ans ; } } 874. Walking Robot Simulation $\\star$ 875. Koko Eating Bananas $\\star\\star$ 876. Middle of the Linked List $\\star$ 877. Stone Game $\\star\\star$ 878. Nth Magical Number $\\star\\star\\star$ 879. Profitable Schemes $\\star\\star\\star$ 880. Decoded String at Index $\\star\\star$","title":"0871-0880"},{"location":"java/0801-0900/0871-0880/#871-minimum-number-of-refueling-stops-starstarstar","text":"","title":"871. Minimum Number of Refueling Stops $\\star\\star\\star$"},{"location":"java/0801-0900/0871-0880/#872-leaf-similar-trees-star","text":"","title":"872. Leaf-Similar Trees $\\star$"},{"location":"java/0801-0900/0871-0880/#873-length-of-longest-fibonacci-subsequence-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int lenLongestFibSubseq ( int [] A ) { final int n = A . length ; int ans = 0 ; Map < Integer , Integer > map = new HashMap <>(); for ( int i = 0 ; i < n ; i ++) map . put ( A [ i ], i ); int [][] dp = new int [ n ][ n ]; for ( int [] row : dp ) Arrays . fill ( row , 2 ); for ( int j = 0 ; j < n ; j ++) for ( int k = j + 1 ; k < n ; k ++) { int ai = A [ k ] - A [ j ]; if ( ai < A [ j ] && map . containsKey ( ai )) { int i = map . get ( ai ); dp [ j ][ k ] = dp [ i ][ j ] + 1 ; ans = Math . max ( ans , dp [ j ][ k ]); } } return ans ; } }","title":"873. Length of Longest Fibonacci Subsequence $\\star\\star$"},{"location":"java/0801-0900/0871-0880/#874-walking-robot-simulation-star","text":"","title":"874. Walking Robot Simulation $\\star$"},{"location":"java/0801-0900/0871-0880/#875-koko-eating-bananas-starstar","text":"","title":"875. Koko Eating Bananas $\\star\\star$"},{"location":"java/0801-0900/0871-0880/#876-middle-of-the-linked-list-star","text":"","title":"876. Middle of the Linked List $\\star$"},{"location":"java/0801-0900/0871-0880/#877-stone-game-starstar","text":"","title":"877. Stone Game $\\star\\star$"},{"location":"java/0801-0900/0871-0880/#878-nth-magical-number-starstarstar","text":"","title":"878. Nth Magical Number $\\star\\star\\star$"},{"location":"java/0801-0900/0871-0880/#879-profitable-schemes-starstarstar","text":"","title":"879. Profitable Schemes $\\star\\star\\star$"},{"location":"java/0801-0900/0871-0880/#880-decoded-string-at-index-starstar","text":"","title":"880. Decoded String at Index $\\star\\star$"},{"location":"java/0801-0900/0881-0890/","text":"881. Boats to Save People $\\star\\star$ 882. Reachable Nodes In Subdivided Graph $\\star\\star\\star$ 883. Projection Area of 3D Shapes $\\star$ 884. Uncommon Words from Two Sentences $\\star$ 885. Spiral Matrix III $\\star\\star$ 886. Possible Bipartition $\\star\\star$ 887. Super Egg Drop $\\star\\star\\star$ 888. Fair Candy Swap $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int [] fairCandySwap ( int [] A , int [] B ) { int diff = ( IntStream . of ( A ). sum () - IntStream . of ( B ). sum ()) / 2 ; Set < Integer > set = new HashSet <>(); for ( int b : B ) set . add ( b ); for ( int a : A ) if ( set . contains ( a - diff )) return new int [] { a , a - diff }; throw new IllegalArgumentException (); } } 889. Construct Binary Tree from Preorder and Postorder Traversal $\\star\\star$ 890. Find and Replace Pattern $\\star\\star$","title":"0881-0890"},{"location":"java/0801-0900/0881-0890/#881-boats-to-save-people-starstar","text":"","title":"881. Boats to Save People $\\star\\star$"},{"location":"java/0801-0900/0881-0890/#882-reachable-nodes-in-subdivided-graph-starstarstar","text":"","title":"882. Reachable Nodes In Subdivided Graph $\\star\\star\\star$"},{"location":"java/0801-0900/0881-0890/#883-projection-area-of-3d-shapes-star","text":"","title":"883. Projection Area of 3D Shapes $\\star$"},{"location":"java/0801-0900/0881-0890/#884-uncommon-words-from-two-sentences-star","text":"","title":"884. Uncommon Words from Two Sentences $\\star$"},{"location":"java/0801-0900/0881-0890/#885-spiral-matrix-iii-starstar","text":"","title":"885. Spiral Matrix III $\\star\\star$"},{"location":"java/0801-0900/0881-0890/#886-possible-bipartition-starstar","text":"","title":"886. Possible Bipartition $\\star\\star$"},{"location":"java/0801-0900/0881-0890/#887-super-egg-drop-starstarstar","text":"","title":"887. Super Egg Drop $\\star\\star\\star$"},{"location":"java/0801-0900/0881-0890/#888-fair-candy-swap-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int [] fairCandySwap ( int [] A , int [] B ) { int diff = ( IntStream . of ( A ). sum () - IntStream . of ( B ). sum ()) / 2 ; Set < Integer > set = new HashSet <>(); for ( int b : B ) set . add ( b ); for ( int a : A ) if ( set . contains ( a - diff )) return new int [] { a , a - diff }; throw new IllegalArgumentException (); } }","title":"888. Fair Candy Swap $\\star$"},{"location":"java/0801-0900/0881-0890/#889-construct-binary-tree-from-preorder-and-postorder-traversal-starstar","text":"","title":"889. Construct Binary Tree from Preorder and Postorder Traversal $\\star\\star$"},{"location":"java/0801-0900/0881-0890/#890-find-and-replace-pattern-starstar","text":"","title":"890. Find and Replace Pattern $\\star\\star$"},{"location":"java/0801-0900/0891-0900/","text":"891. Sum of Subsequence Widths $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int sumSubseqWidths ( int [] A ) { final int n = A . length ; final long kMod = ( int ) 1e9 + 7 ; long ans = 0 ; long exp = 1 ; Arrays . sort ( A ); for ( int i = 0 ; i < n ; i ++, exp = exp * 2 % kMod ) ans = ( ans + A [ i ] * exp - A [ n - i - 1 ] * exp ) % kMod ; return ( int ) ans ; } } 892. Surface Area of 3D Shapes $\\star$ 893. Groups of Special-Equivalent Strings $\\star$ 894. All Possible Full Binary Trees $\\star\\star$ 895. Maximum Frequency Stack $\\star\\star\\star$ 896. Monotonic Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public boolean isMonotonic ( int [] A ) { boolean increasing = true ; boolean decreasing = true ; for ( int i = 1 ; i < A . length ; i ++) { increasing &= A [ i - 1 ] <= A [ i ]; decreasing &= A [ i - 1 ] >= A [ i ]; } return increasing || decreasing ; } } 897. Increasing Order Search Tree $\\star$ 898. Bitwise ORs of Subarrays $\\star\\star$ 899. Orderly Queue $\\star\\star\\star$ 900. RLE Iterator $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class RLEIterator { public RLEIterator ( int [] A ) { this . A = A ; } public int next ( int n ) { while ( index < A . length && A [ index ] < n ) { n -= A [ index ]; index += 2 ; } if ( index == A . length ) return - 1 ; A [ index ] -= n ; return A [ index + 1 ]; } private int index = 0 ; private int [] A ; }","title":"0891-0900"},{"location":"java/0801-0900/0891-0900/#891-sum-of-subsequence-widths-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int sumSubseqWidths ( int [] A ) { final int n = A . length ; final long kMod = ( int ) 1e9 + 7 ; long ans = 0 ; long exp = 1 ; Arrays . sort ( A ); for ( int i = 0 ; i < n ; i ++, exp = exp * 2 % kMod ) ans = ( ans + A [ i ] * exp - A [ n - i - 1 ] * exp ) % kMod ; return ( int ) ans ; } }","title":"891. Sum of Subsequence Widths $\\star\\star\\star$"},{"location":"java/0801-0900/0891-0900/#892-surface-area-of-3d-shapes-star","text":"","title":"892. Surface Area of 3D Shapes $\\star$"},{"location":"java/0801-0900/0891-0900/#893-groups-of-special-equivalent-strings-star","text":"","title":"893. Groups of Special-Equivalent Strings $\\star$"},{"location":"java/0801-0900/0891-0900/#894-all-possible-full-binary-trees-starstar","text":"","title":"894. All Possible Full Binary Trees $\\star\\star$"},{"location":"java/0801-0900/0891-0900/#895-maximum-frequency-stack-starstarstar","text":"","title":"895. Maximum Frequency Stack $\\star\\star\\star$"},{"location":"java/0801-0900/0891-0900/#896-monotonic-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public boolean isMonotonic ( int [] A ) { boolean increasing = true ; boolean decreasing = true ; for ( int i = 1 ; i < A . length ; i ++) { increasing &= A [ i - 1 ] <= A [ i ]; decreasing &= A [ i - 1 ] >= A [ i ]; } return increasing || decreasing ; } }","title":"896. Monotonic Array $\\star$"},{"location":"java/0801-0900/0891-0900/#897-increasing-order-search-tree-star","text":"","title":"897. Increasing Order Search Tree $\\star$"},{"location":"java/0801-0900/0891-0900/#898-bitwise-ors-of-subarrays-starstar","text":"","title":"898. Bitwise ORs of Subarrays $\\star\\star$"},{"location":"java/0801-0900/0891-0900/#899-orderly-queue-starstarstar","text":"","title":"899. Orderly Queue $\\star\\star\\star$"},{"location":"java/0801-0900/0891-0900/#900-rle-iterator-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class RLEIterator { public RLEIterator ( int [] A ) { this . A = A ; } public int next ( int n ) { while ( index < A . length && A [ index ] < n ) { n -= A [ index ]; index += 2 ; } if ( index == A . length ) return - 1 ; A [ index ] -= n ; return A [ index + 1 ]; } private int index = 0 ; private int [] A ; }","title":"900. RLE Iterator $\\star\\star$"},{"location":"java/0901-1000/0901-0910/","text":"901. Online Stock Span $\\star\\star$ 902. Numbers At Most N Given Digit Set $\\star\\star\\star$ 903. Valid Permutations for DI Sequence $\\star\\star\\star$ 904. Fruit Into Baskets $\\star\\star$ 905. Sort Array By Parity $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int [] sortArrayByParity ( int [] A ) { int l = 0 ; int r = A . length - 1 ; while ( l < r ) { if ( A [ l ] % 2 == 1 && A [ r ] % 2 == 0 ) { int temp = A [ l ]; A [ l ] = A [ r ]; A [ r ] = temp ; } if ( A [ l ] % 2 == 0 ) l ++; if ( A [ r ] % 2 == 1 ) r --; } return A ; } } 906. Super Palindromes $\\star\\star\\star$ 907. Sum of Subarray Minimums $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public int sumSubarrayMins ( int [] A ) { final int n = A . length ; final int kMod = ( int ) 1e9 + 7 ; int ans = 0 ; int [] prev = new int [ n ]; int [] next = new int [ n ]; Stack < Integer > stack1 = new Stack <>(); Stack < Integer > stack2 = new Stack <>(); Arrays . fill ( prev , - 1 ); Arrays . fill ( next , n ); for ( int i = 0 ; i < A . length ; i ++) { while (! stack1 . isEmpty () && A [ stack1 . peek ()] > A [ i ]) stack1 . pop (); prev [ i ] = stack1 . isEmpty () ? - 1 : stack1 . peek (); stack1 . add ( i ); while (! stack2 . isEmpty () && A [ stack2 . peek ()] > A [ i ]) { int index = stack2 . pop (); next [ index ] = i ; } stack2 . add ( i ); } for ( int i = 0 ; i < A . length ; i ++) ans = ( ans + A [ i ] * ( i - prev [ i ]) * ( next [ i ] - i )) % kMod ; return ans ; } } 908. Smallest Range I $\\star$ 909. Snakes and Ladders $\\star\\star$ 910. Smallest Range II $\\star\\star$","title":"0901-0910"},{"location":"java/0901-1000/0901-0910/#901-online-stock-span-starstar","text":"","title":"901. Online Stock Span $\\star\\star$"},{"location":"java/0901-1000/0901-0910/#902-numbers-at-most-n-given-digit-set-starstarstar","text":"","title":"902. Numbers At Most N Given Digit Set $\\star\\star\\star$"},{"location":"java/0901-1000/0901-0910/#903-valid-permutations-for-di-sequence-starstarstar","text":"","title":"903. Valid Permutations for DI Sequence $\\star\\star\\star$"},{"location":"java/0901-1000/0901-0910/#904-fruit-into-baskets-starstar","text":"","title":"904. Fruit Into Baskets $\\star\\star$"},{"location":"java/0901-1000/0901-0910/#905-sort-array-by-parity-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int [] sortArrayByParity ( int [] A ) { int l = 0 ; int r = A . length - 1 ; while ( l < r ) { if ( A [ l ] % 2 == 1 && A [ r ] % 2 == 0 ) { int temp = A [ l ]; A [ l ] = A [ r ]; A [ r ] = temp ; } if ( A [ l ] % 2 == 0 ) l ++; if ( A [ r ] % 2 == 1 ) r --; } return A ; } }","title":"905. Sort Array By Parity $\\star$"},{"location":"java/0901-1000/0901-0910/#906-super-palindromes-starstarstar","text":"","title":"906. Super Palindromes $\\star\\star\\star$"},{"location":"java/0901-1000/0901-0910/#907-sum-of-subarray-minimums-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public int sumSubarrayMins ( int [] A ) { final int n = A . length ; final int kMod = ( int ) 1e9 + 7 ; int ans = 0 ; int [] prev = new int [ n ]; int [] next = new int [ n ]; Stack < Integer > stack1 = new Stack <>(); Stack < Integer > stack2 = new Stack <>(); Arrays . fill ( prev , - 1 ); Arrays . fill ( next , n ); for ( int i = 0 ; i < A . length ; i ++) { while (! stack1 . isEmpty () && A [ stack1 . peek ()] > A [ i ]) stack1 . pop (); prev [ i ] = stack1 . isEmpty () ? - 1 : stack1 . peek (); stack1 . add ( i ); while (! stack2 . isEmpty () && A [ stack2 . peek ()] > A [ i ]) { int index = stack2 . pop (); next [ index ] = i ; } stack2 . add ( i ); } for ( int i = 0 ; i < A . length ; i ++) ans = ( ans + A [ i ] * ( i - prev [ i ]) * ( next [ i ] - i )) % kMod ; return ans ; } }","title":"907. Sum of Subarray Minimums $\\star\\star$"},{"location":"java/0901-1000/0901-0910/#908-smallest-range-i-star","text":"","title":"908. Smallest Range I $\\star$"},{"location":"java/0901-1000/0901-0910/#909-snakes-and-ladders-starstar","text":"","title":"909. Snakes and Ladders $\\star\\star$"},{"location":"java/0901-1000/0901-0910/#910-smallest-range-ii-starstar","text":"","title":"910. Smallest Range II $\\star\\star$"},{"location":"java/0901-1000/0911-0920/","text":"911. Online Election $\\star\\star$ 912. Sort an Array $\\star\\star$ 913. Cat and Mouse $\\star\\star\\star$ 914. X of a Kind in a Deck of Cards $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public boolean hasGroupsSizeX ( int [] deck ) { Map < Integer , Integer > numCounts = new HashMap <>(); for ( int d : deck ) numCounts . put ( d , numCounts . getOrDefault ( d , 0 ) + 1 ); int gcd = 0 ; for ( int value : numCounts . values ()) gcd = __gcd ( gcd , value ); return gcd >= 2 ; } private int __gcd ( int a , int b ) { return b > 0 ? __gcd ( b , a % b ) : a ; } } 915. Partition Array into Disjoint Intervals $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int partitionDisjoint ( int [] A ) { final int n = A . length ; int [] min = new int [ n ]; min [ n - 1 ] = A [ n - 1 ]; int max = Integer . MIN_VALUE ; for ( int i = n - 2 ; i >= 0 ; i --) min [ i ] = Math . min ( min [ i + 1 ], A [ i ]); for ( int i = 0 ; i < n ; i ++) { max = Math . max ( max , A [ i ]); if ( max <= min [ i + 1 ]) return i + 1 ; } throw new IllegalArgumentException (); } } 916. Word Subsets $\\star\\star$ 917. Reverse Only Letters $\\star$ 918. Maximum Sum Circular Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int maxSubarraySumCircular ( int [] A ) { int totalSum = 0 ; int currMaxSum = 0 ; int currMinSum = 0 ; int maxSum = Integer . MIN_VALUE ; int minSum = Integer . MAX_VALUE ; for ( int a : A ) { totalSum += a ; currMaxSum = Math . max ( currMaxSum + a , a ); currMinSum = Math . min ( currMinSum + a , a ); maxSum = Math . max ( maxSum , currMaxSum ); minSum = Math . min ( minSum , currMinSum ); } return maxSum < 0 ? maxSum : Math . max ( maxSum , totalSum - minSum ); } } 919. Complete Binary Tree Inserter $\\star\\star$ 920. Number of Music Playlists $\\star\\star\\star$","title":"0911-0920"},{"location":"java/0901-1000/0911-0920/#911-online-election-starstar","text":"","title":"911. Online Election $\\star\\star$"},{"location":"java/0901-1000/0911-0920/#912-sort-an-array-starstar","text":"","title":"912. Sort an Array $\\star\\star$"},{"location":"java/0901-1000/0911-0920/#913-cat-and-mouse-starstarstar","text":"","title":"913. Cat and Mouse $\\star\\star\\star$"},{"location":"java/0901-1000/0911-0920/#914-x-of-a-kind-in-a-deck-of-cards-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public boolean hasGroupsSizeX ( int [] deck ) { Map < Integer , Integer > numCounts = new HashMap <>(); for ( int d : deck ) numCounts . put ( d , numCounts . getOrDefault ( d , 0 ) + 1 ); int gcd = 0 ; for ( int value : numCounts . values ()) gcd = __gcd ( gcd , value ); return gcd >= 2 ; } private int __gcd ( int a , int b ) { return b > 0 ? __gcd ( b , a % b ) : a ; } }","title":"914. X of a Kind in a Deck of Cards $\\star$"},{"location":"java/0901-1000/0911-0920/#915-partition-array-into-disjoint-intervals-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int partitionDisjoint ( int [] A ) { final int n = A . length ; int [] min = new int [ n ]; min [ n - 1 ] = A [ n - 1 ]; int max = Integer . MIN_VALUE ; for ( int i = n - 2 ; i >= 0 ; i --) min [ i ] = Math . min ( min [ i + 1 ], A [ i ]); for ( int i = 0 ; i < n ; i ++) { max = Math . max ( max , A [ i ]); if ( max <= min [ i + 1 ]) return i + 1 ; } throw new IllegalArgumentException (); } }","title":"915. Partition Array into Disjoint Intervals $\\star\\star$"},{"location":"java/0901-1000/0911-0920/#916-word-subsets-starstar","text":"","title":"916. Word Subsets $\\star\\star$"},{"location":"java/0901-1000/0911-0920/#917-reverse-only-letters-star","text":"","title":"917. Reverse Only Letters $\\star$"},{"location":"java/0901-1000/0911-0920/#918-maximum-sum-circular-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int maxSubarraySumCircular ( int [] A ) { int totalSum = 0 ; int currMaxSum = 0 ; int currMinSum = 0 ; int maxSum = Integer . MIN_VALUE ; int minSum = Integer . MAX_VALUE ; for ( int a : A ) { totalSum += a ; currMaxSum = Math . max ( currMaxSum + a , a ); currMinSum = Math . min ( currMinSum + a , a ); maxSum = Math . max ( maxSum , currMaxSum ); minSum = Math . min ( minSum , currMinSum ); } return maxSum < 0 ? maxSum : Math . max ( maxSum , totalSum - minSum ); } }","title":"918. Maximum Sum Circular Subarray $\\star\\star$"},{"location":"java/0901-1000/0911-0920/#919-complete-binary-tree-inserter-starstar","text":"","title":"919. Complete Binary Tree Inserter $\\star\\star$"},{"location":"java/0901-1000/0911-0920/#920-number-of-music-playlists-starstarstar","text":"","title":"920. Number of Music Playlists $\\star\\star\\star$"},{"location":"java/0901-1000/0921-0930/","text":"921. Minimum Add to Make Parentheses Valid $\\star\\star$ 922. Sort Array By Parity II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int [] sortArrayByParityII ( int [] A ) { final int n = A . length ; for ( int i = 0 , j = 1 ; i < n ; i += 2 , j += 2 ) { while ( i < n && A [ i ] % 2 == 0 ) i += 2 ; while ( j < n && A [ j ] % 2 == 1 ) j += 2 ; if ( i < n ) { int temp = A [ i ]; A [ i ] = A [ j ]; A [ j ] = temp ; } } return A ; } } 923. 3Sum With Multiplicity $\\star\\star$ 924. Minimize Malware Spread $\\star\\star\\star$ 925. Long Pressed Name $\\star$ 926. Flip String to Monotone Increasing $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int minFlipsMonoIncr ( String S ) { int [] dp = new int [ 2 ]; for ( int i = 0 ; i < S . length (); i ++) { int temp = dp [ 0 ] + ( S . charAt ( i ) == '1' ? 1 : 0 ); dp [ 1 ] = Math . min ( dp [ 0 ], dp [ 1 ]) + ( S . charAt ( i ) == '0' ? 1 : 0 ); dp [ 0 ] = temp ; } return Math . min ( dp [ 0 ], dp [ 1 ]); } } 927. Three Equal Parts $\\star\\star\\star$ 928. Minimize Malware Spread II $\\star\\star\\star$ 929. Unique Email Addresses $\\star$ 930. Binary Subarrays With Sum $\\star\\star$","title":"0921-0930"},{"location":"java/0901-1000/0921-0930/#921-minimum-add-to-make-parentheses-valid-starstar","text":"","title":"921. Minimum Add to Make Parentheses Valid $\\star\\star$"},{"location":"java/0901-1000/0921-0930/#922-sort-array-by-parity-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution { public int [] sortArrayByParityII ( int [] A ) { final int n = A . length ; for ( int i = 0 , j = 1 ; i < n ; i += 2 , j += 2 ) { while ( i < n && A [ i ] % 2 == 0 ) i += 2 ; while ( j < n && A [ j ] % 2 == 1 ) j += 2 ; if ( i < n ) { int temp = A [ i ]; A [ i ] = A [ j ]; A [ j ] = temp ; } } return A ; } }","title":"922. Sort Array By Parity II $\\star$"},{"location":"java/0901-1000/0921-0930/#923-3sum-with-multiplicity-starstar","text":"","title":"923. 3Sum With Multiplicity $\\star\\star$"},{"location":"java/0901-1000/0921-0930/#924-minimize-malware-spread-starstarstar","text":"","title":"924. Minimize Malware Spread $\\star\\star\\star$"},{"location":"java/0901-1000/0921-0930/#925-long-pressed-name-star","text":"","title":"925. Long Pressed Name $\\star$"},{"location":"java/0901-1000/0921-0930/#926-flip-string-to-monotone-increasing-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int minFlipsMonoIncr ( String S ) { int [] dp = new int [ 2 ]; for ( int i = 0 ; i < S . length (); i ++) { int temp = dp [ 0 ] + ( S . charAt ( i ) == '1' ? 1 : 0 ); dp [ 1 ] = Math . min ( dp [ 0 ], dp [ 1 ]) + ( S . charAt ( i ) == '0' ? 1 : 0 ); dp [ 0 ] = temp ; } return Math . min ( dp [ 0 ], dp [ 1 ]); } }","title":"926. Flip String to Monotone Increasing $\\star\\star$"},{"location":"java/0901-1000/0921-0930/#927-three-equal-parts-starstarstar","text":"","title":"927. Three Equal Parts $\\star\\star\\star$"},{"location":"java/0901-1000/0921-0930/#928-minimize-malware-spread-ii-starstarstar","text":"","title":"928. Minimize Malware Spread II $\\star\\star\\star$"},{"location":"java/0901-1000/0921-0930/#929-unique-email-addresses-star","text":"","title":"929. Unique Email Addresses $\\star$"},{"location":"java/0901-1000/0921-0930/#930-binary-subarrays-with-sum-starstar","text":"","title":"930. Binary Subarrays With Sum $\\star\\star$"},{"location":"java/0901-1000/0931-0940/","text":"931. Minimum Falling Path Sum $\\star\\star$ 932. Beautiful Array $\\star\\star$ 933. Number of Recent Calls $\\star$ 934. Shortest Bridge $\\star\\star$ 935. Knight Dialer $\\star\\star$ 936. Stamping The Sequence $\\star\\star\\star$ 937. Reorder Data in Log Files $\\star$ 938. Range Sum of BST $\\star$ 939. Minimum Area Rectangle $\\star\\star$ 940. Distinct Subsequences II $\\star\\star\\star$","title":"0931-0940"},{"location":"java/0901-1000/0931-0940/#931-minimum-falling-path-sum-starstar","text":"","title":"931. Minimum Falling Path Sum $\\star\\star$"},{"location":"java/0901-1000/0931-0940/#932-beautiful-array-starstar","text":"","title":"932. Beautiful Array $\\star\\star$"},{"location":"java/0901-1000/0931-0940/#933-number-of-recent-calls-star","text":"","title":"933. Number of Recent Calls $\\star$"},{"location":"java/0901-1000/0931-0940/#934-shortest-bridge-starstar","text":"","title":"934. Shortest Bridge $\\star\\star$"},{"location":"java/0901-1000/0931-0940/#935-knight-dialer-starstar","text":"","title":"935. Knight Dialer $\\star\\star$"},{"location":"java/0901-1000/0931-0940/#936-stamping-the-sequence-starstarstar","text":"","title":"936. Stamping The Sequence $\\star\\star\\star$"},{"location":"java/0901-1000/0931-0940/#937-reorder-data-in-log-files-star","text":"","title":"937. Reorder Data in Log Files $\\star$"},{"location":"java/0901-1000/0931-0940/#938-range-sum-of-bst-star","text":"","title":"938. Range Sum of BST $\\star$"},{"location":"java/0901-1000/0931-0940/#939-minimum-area-rectangle-starstar","text":"","title":"939. Minimum Area Rectangle $\\star\\star$"},{"location":"java/0901-1000/0931-0940/#940-distinct-subsequences-ii-starstarstar","text":"","title":"940. Distinct Subsequences II $\\star\\star\\star$"},{"location":"java/0901-1000/0941-0950/","text":"941. Valid Mountain Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public boolean validMountainArray ( int [] A ) { if ( A . length < 3 ) return false ; int l = 0 ; int r = A . length - 1 ; while ( l + 1 < A . length && A [ l ] < A [ l + 1 ]) l ++; while ( r > 0 && A [ r ] < A [ r - 1 ]) r --; return l > 0 && r < A . length - 1 && l == r ; } } 942. DI String Match $\\star$ 943. Find the Shortest Superstring $\\star\\star\\star$ 944. Delete Columns to Make Sorted $\\star$ 945. Minimum Increment to Make Array Unique $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int minIncrementForUnique ( int [] A ) { int ans = 0 ; int minAvailable = 0 ; Arrays . sort ( A ); for ( int a : A ) { ans += Math . max ( minAvailable - a , 0 ); minAvailable = Math . max ( minAvailable , a ) + 1 ; } return ans ; } } 946. Validate Stack Sequences $\\star\\star$ 947. Most Stones Removed with Same Row or Column $\\star\\star$ 948. Bag of Tokens $\\star\\star$ 949. Largest Time for Given Digits $\\star$ 950. Reveal Cards In Increasing Order $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int [] deckRevealedIncreasing ( int [] deck ) { final int n = deck . length ; Arrays . sort ( deck ); Deque < Integer > deque = new ArrayDeque <>(); deque . addFirst ( deck [ n - 1 ]); for ( int i = n - 2 ; i >= 0 ; i --) { deque . addFirst ( deque . getLast ()); deque . pollLast (); deque . addFirst ( deck [ i ]); } for ( int i = 0 ; i < n ; i ++) deck [ i ] = deque . pollFirst (); return deck ; } }","title":"0941-0950"},{"location":"java/0901-1000/0941-0950/#941-valid-mountain-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public boolean validMountainArray ( int [] A ) { if ( A . length < 3 ) return false ; int l = 0 ; int r = A . length - 1 ; while ( l + 1 < A . length && A [ l ] < A [ l + 1 ]) l ++; while ( r > 0 && A [ r ] < A [ r - 1 ]) r --; return l > 0 && r < A . length - 1 && l == r ; } }","title":"941. Valid Mountain Array $\\star$"},{"location":"java/0901-1000/0941-0950/#942-di-string-match-star","text":"","title":"942. DI String Match $\\star$"},{"location":"java/0901-1000/0941-0950/#943-find-the-shortest-superstring-starstarstar","text":"","title":"943. Find the Shortest Superstring $\\star\\star\\star$"},{"location":"java/0901-1000/0941-0950/#944-delete-columns-to-make-sorted-star","text":"","title":"944. Delete Columns to Make Sorted $\\star$"},{"location":"java/0901-1000/0941-0950/#945-minimum-increment-to-make-array-unique-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int minIncrementForUnique ( int [] A ) { int ans = 0 ; int minAvailable = 0 ; Arrays . sort ( A ); for ( int a : A ) { ans += Math . max ( minAvailable - a , 0 ); minAvailable = Math . max ( minAvailable , a ) + 1 ; } return ans ; } }","title":"945. Minimum Increment to Make Array Unique $\\star\\star$"},{"location":"java/0901-1000/0941-0950/#946-validate-stack-sequences-starstar","text":"","title":"946. Validate Stack Sequences $\\star\\star$"},{"location":"java/0901-1000/0941-0950/#947-most-stones-removed-with-same-row-or-column-starstar","text":"","title":"947. Most Stones Removed with Same Row or Column $\\star\\star$"},{"location":"java/0901-1000/0941-0950/#948-bag-of-tokens-starstar","text":"","title":"948. Bag of Tokens $\\star\\star$"},{"location":"java/0901-1000/0941-0950/#949-largest-time-for-given-digits-star","text":"","title":"949. Largest Time for Given Digits $\\star$"},{"location":"java/0901-1000/0941-0950/#950-reveal-cards-in-increasing-order-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public int [] deckRevealedIncreasing ( int [] deck ) { final int n = deck . length ; Arrays . sort ( deck ); Deque < Integer > deque = new ArrayDeque <>(); deque . addFirst ( deck [ n - 1 ]); for ( int i = n - 2 ; i >= 0 ; i --) { deque . addFirst ( deque . getLast ()); deque . pollLast (); deque . addFirst ( deck [ i ]); } for ( int i = 0 ; i < n ; i ++) deck [ i ] = deque . pollFirst (); return deck ; } }","title":"950. Reveal Cards In Increasing Order $\\star\\star$"},{"location":"java/0901-1000/0951-0960/","text":"951. Flip Equivalent Binary Trees $\\star\\star$ 952. Largest Component Size by Common Factor $\\star\\star\\star$ 953. Verifying an Alien Dictionary $\\star$ 954. Array of Doubled Pairs $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public boolean canReorderDoubled ( int [] A ) { Map < Integer , Integer > count = new HashMap <>(); for ( int a : A ) count . put ( a , count . getOrDefault ( a , 0 ) + 1 ); Integer [] array = new Integer [ A . length ]; for ( int i = 0 ; i < A . length ; i ++) array [ i ] = Integer . valueOf ( A [ i ]); Arrays . sort ( array , ( a , b ) -> ( Math . abs ( a ) - Math . abs ( b ))); for ( Integer a : array ) { if ( count . get ( a ) == 0 ) continue ; if (! count . containsKey ( 2 * a ) || count . get ( 2 * a ) == 0 ) return false ; count . put ( a , count . get ( a ) - 1 ); count . put ( 2 * a , count . get ( 2 * a ) - 1 ); } return true ; } } 955. Delete Columns to Make Sorted II $\\star\\star$ 956. Tallest Billboard $\\star\\star\\star$ 957. Prison Cells After N Days $\\star\\star$ 958. Check Completeness of a Binary Tree $\\star\\star$ 959. Regions Cut By Slashes $\\star\\star$ 960. Delete Columns to Make Sorted III $\\star\\star\\star$","title":"0951-0960"},{"location":"java/0901-1000/0951-0960/#951-flip-equivalent-binary-trees-starstar","text":"","title":"951. Flip Equivalent Binary Trees $\\star\\star$"},{"location":"java/0901-1000/0951-0960/#952-largest-component-size-by-common-factor-starstarstar","text":"","title":"952. Largest Component Size by Common Factor $\\star\\star\\star$"},{"location":"java/0901-1000/0951-0960/#953-verifying-an-alien-dictionary-star","text":"","title":"953. Verifying an Alien Dictionary $\\star$"},{"location":"java/0901-1000/0951-0960/#954-array-of-doubled-pairs-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public boolean canReorderDoubled ( int [] A ) { Map < Integer , Integer > count = new HashMap <>(); for ( int a : A ) count . put ( a , count . getOrDefault ( a , 0 ) + 1 ); Integer [] array = new Integer [ A . length ]; for ( int i = 0 ; i < A . length ; i ++) array [ i ] = Integer . valueOf ( A [ i ]); Arrays . sort ( array , ( a , b ) -> ( Math . abs ( a ) - Math . abs ( b ))); for ( Integer a : array ) { if ( count . get ( a ) == 0 ) continue ; if (! count . containsKey ( 2 * a ) || count . get ( 2 * a ) == 0 ) return false ; count . put ( a , count . get ( a ) - 1 ); count . put ( 2 * a , count . get ( 2 * a ) - 1 ); } return true ; } }","title":"954. Array of Doubled Pairs $\\star\\star$"},{"location":"java/0901-1000/0951-0960/#955-delete-columns-to-make-sorted-ii-starstar","text":"","title":"955. Delete Columns to Make Sorted II $\\star\\star$"},{"location":"java/0901-1000/0951-0960/#956-tallest-billboard-starstarstar","text":"","title":"956. Tallest Billboard $\\star\\star\\star$"},{"location":"java/0901-1000/0951-0960/#957-prison-cells-after-n-days-starstar","text":"","title":"957. Prison Cells After N Days $\\star\\star$"},{"location":"java/0901-1000/0951-0960/#958-check-completeness-of-a-binary-tree-starstar","text":"","title":"958. Check Completeness of a Binary Tree $\\star\\star$"},{"location":"java/0901-1000/0951-0960/#959-regions-cut-by-slashes-starstar","text":"","title":"959. Regions Cut By Slashes $\\star\\star$"},{"location":"java/0901-1000/0951-0960/#960-delete-columns-to-make-sorted-iii-starstarstar","text":"","title":"960. Delete Columns to Make Sorted III $\\star\\star\\star$"},{"location":"java/0901-1000/0961-0970/","text":"961. N-Repeated Element in Size 2N Array $\\star$ 962. Maximum Width Ramp $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int maxWidthRamp ( int [] A ) { int ans = 0 ; Stack < Integer > stack = new Stack <>(); for ( int i = 0 ; i < A . length ; i ++) if ( stack . isEmpty () || A [ i ] < A [ stack . peek ()]) stack . add ( i ); for ( int i = A . length - 1 ; i > ans ; i --) while (! stack . isEmpty () && A [ i ] >= A [ stack . peek ()]) ans = Math . max ( ans , i - stack . pop ()); return ans ; } } 963. Minimum Area Rectangle II $\\star\\star$ 964. Least Operators to Express Number $\\star\\star\\star$ 965. Univalued Binary Tree $\\star$ 966. Vowel Spellchecker $\\star\\star$ 967. Numbers With Same Consecutive Differences $\\star\\star$ 968. Binary Tree Cameras $\\star\\star\\star$ 969. Pancake Sorting $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public List < Integer > pancakeSort ( int [] A ) { List < Integer > ans = new ArrayList <>(); for ( int target = A . length ; target >= 1 ; target --) { int index = find ( A , target ); reverse ( A , 0 , index ); reverse ( A , 0 , target - 1 ); ans . add ( index + 1 ); ans . add ( target ); } return ans ; } private int find ( int [] A , int target ) { for ( int i = 0 ; i < A . length ; i ++) if ( A [ i ] == target ) return i ; throw new IllegalArgumentException (); } private void reverse ( int [] A , int l , int r ) { while ( l < r ) swap ( A , l ++, r --); } private void swap ( int [] A , int l , int r ) { int temp = A [ l ]; A [ l ] = A [ r ]; A [ r ] = temp ; } } 970. Powerful Integers $\\star$","title":"0961-0970"},{"location":"java/0901-1000/0961-0970/#961-n-repeated-element-in-size-2n-array-star","text":"","title":"961. N-Repeated Element in Size 2N Array $\\star$"},{"location":"java/0901-1000/0961-0970/#962-maximum-width-ramp-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int maxWidthRamp ( int [] A ) { int ans = 0 ; Stack < Integer > stack = new Stack <>(); for ( int i = 0 ; i < A . length ; i ++) if ( stack . isEmpty () || A [ i ] < A [ stack . peek ()]) stack . add ( i ); for ( int i = A . length - 1 ; i > ans ; i --) while (! stack . isEmpty () && A [ i ] >= A [ stack . peek ()]) ans = Math . max ( ans , i - stack . pop ()); return ans ; } }","title":"962. Maximum Width Ramp $\\star\\star$"},{"location":"java/0901-1000/0961-0970/#963-minimum-area-rectangle-ii-starstar","text":"","title":"963. Minimum Area Rectangle II $\\star\\star$"},{"location":"java/0901-1000/0961-0970/#964-least-operators-to-express-number-starstarstar","text":"","title":"964. Least Operators to Express Number $\\star\\star\\star$"},{"location":"java/0901-1000/0961-0970/#965-univalued-binary-tree-star","text":"","title":"965. Univalued Binary Tree $\\star$"},{"location":"java/0901-1000/0961-0970/#966-vowel-spellchecker-starstar","text":"","title":"966. Vowel Spellchecker $\\star\\star$"},{"location":"java/0901-1000/0961-0970/#967-numbers-with-same-consecutive-differences-starstar","text":"","title":"967. Numbers With Same Consecutive Differences $\\star\\star$"},{"location":"java/0901-1000/0961-0970/#968-binary-tree-cameras-starstarstar","text":"","title":"968. Binary Tree Cameras $\\star\\star\\star$"},{"location":"java/0901-1000/0961-0970/#969-pancake-sorting-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution { public List < Integer > pancakeSort ( int [] A ) { List < Integer > ans = new ArrayList <>(); for ( int target = A . length ; target >= 1 ; target --) { int index = find ( A , target ); reverse ( A , 0 , index ); reverse ( A , 0 , target - 1 ); ans . add ( index + 1 ); ans . add ( target ); } return ans ; } private int find ( int [] A , int target ) { for ( int i = 0 ; i < A . length ; i ++) if ( A [ i ] == target ) return i ; throw new IllegalArgumentException (); } private void reverse ( int [] A , int l , int r ) { while ( l < r ) swap ( A , l ++, r --); } private void swap ( int [] A , int l , int r ) { int temp = A [ l ]; A [ l ] = A [ r ]; A [ r ] = temp ; } }","title":"969. Pancake Sorting $\\star\\star$"},{"location":"java/0901-1000/0961-0970/#970-powerful-integers-star","text":"","title":"970. Powerful Integers $\\star$"},{"location":"java/0901-1000/0971-0980/","text":"971. Flip Binary Tree To Match Preorder Traversal $\\star\\star$ 972. Equal Rational Numbers $\\star\\star\\star$ 973. K Closest Points to Origin $\\star\\star$ 974. Subarray Sums Divisible by K $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int subarraysDivByK ( int [] A , int K ) { int ans = 0 ; int presum = 0 ; int [] count = new int [ K ]; count [ 0 ] = 1 ; for ( int a : A ) { presum = ( presum + a % K + K ) % K ; ans += count [ presum ]; count [ presum ]++; } return ans ; } } 975. Odd Even Jump $\\star\\star\\star$ 976. Largest Perimeter Triangle $\\star$ 977. Squares of a Sorted Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int [] sortedSquares ( int [] A ) { int n = A . length ; int l = 0 ; int r = n - 1 ; int [] ans = new int [ n ]; while ( l <= r ) ans [-- n ] = Math . abs ( A [ l ]) > Math . abs ( A [ r ]) ? A [ l ] * A [ l ++] : A [ r ] * A [ r --]; return ans ; } } 978. Longest Turbulent Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int maxTurbulenceSize ( int [] A ) { int ans = 1 ; int increasing = 1 ; int decreasing = 1 ; for ( int i = 1 ; i < A . length ; i ++) { if ( A [ i ] > A [ i - 1 ]) { increasing = decreasing + 1 ; decreasing = 1 ; } else if ( A [ i ] < A [ i - 1 ]) { decreasing = increasing + 1 ; increasing = 1 ; } else { increasing = 1 ; decreasing = 1 ; } ans = Math . max ( ans , Math . max ( increasing , decreasing )); } return ans ; } } 979. Distribute Coins in Binary Tree $\\star\\star$ 980. Unique Paths III $\\star\\star\\star$","title":"0971-0980"},{"location":"java/0901-1000/0971-0980/#971-flip-binary-tree-to-match-preorder-traversal-starstar","text":"","title":"971. Flip Binary Tree To Match Preorder Traversal $\\star\\star$"},{"location":"java/0901-1000/0971-0980/#972-equal-rational-numbers-starstarstar","text":"","title":"972. Equal Rational Numbers $\\star\\star\\star$"},{"location":"java/0901-1000/0971-0980/#973-k-closest-points-to-origin-starstar","text":"","title":"973. K Closest Points to Origin $\\star\\star$"},{"location":"java/0901-1000/0971-0980/#974-subarray-sums-divisible-by-k-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int subarraysDivByK ( int [] A , int K ) { int ans = 0 ; int presum = 0 ; int [] count = new int [ K ]; count [ 0 ] = 1 ; for ( int a : A ) { presum = ( presum + a % K + K ) % K ; ans += count [ presum ]; count [ presum ]++; } return ans ; } }","title":"974. Subarray Sums Divisible by K $\\star\\star$"},{"location":"java/0901-1000/0971-0980/#975-odd-even-jump-starstarstar","text":"","title":"975. Odd Even Jump $\\star\\star\\star$"},{"location":"java/0901-1000/0971-0980/#976-largest-perimeter-triangle-star","text":"","title":"976. Largest Perimeter Triangle $\\star$"},{"location":"java/0901-1000/0971-0980/#977-squares-of-a-sorted-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int [] sortedSquares ( int [] A ) { int n = A . length ; int l = 0 ; int r = n - 1 ; int [] ans = new int [ n ]; while ( l <= r ) ans [-- n ] = Math . abs ( A [ l ]) > Math . abs ( A [ r ]) ? A [ l ] * A [ l ++] : A [ r ] * A [ r --]; return ans ; } }","title":"977. Squares of a Sorted Array $\\star$"},{"location":"java/0901-1000/0971-0980/#978-longest-turbulent-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution { public int maxTurbulenceSize ( int [] A ) { int ans = 1 ; int increasing = 1 ; int decreasing = 1 ; for ( int i = 1 ; i < A . length ; i ++) { if ( A [ i ] > A [ i - 1 ]) { increasing = decreasing + 1 ; decreasing = 1 ; } else if ( A [ i ] < A [ i - 1 ]) { decreasing = increasing + 1 ; increasing = 1 ; } else { increasing = 1 ; decreasing = 1 ; } ans = Math . max ( ans , Math . max ( increasing , decreasing )); } return ans ; } }","title":"978. Longest Turbulent Subarray $\\star\\star$"},{"location":"java/0901-1000/0971-0980/#979-distribute-coins-in-binary-tree-starstar","text":"","title":"979. Distribute Coins in Binary Tree $\\star\\star$"},{"location":"java/0901-1000/0971-0980/#980-unique-paths-iii-starstarstar","text":"","title":"980. Unique Paths III $\\star\\star\\star$"},{"location":"java/0901-1000/0981-0990/","text":"981. Time Based Key-Value Store $\\star\\star$ 982. Triples with Bitwise AND Equal To Zero $\\star\\star\\star$ 983. Minimum Cost For Tickets $\\star\\star$ 984. String Without AAA or BBB $\\star\\star$ 985. Sum of Even Numbers After Queries $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int [] sumEvenAfterQueries ( int [] A , int [][] queries ) { int [] ans = new int [ queries . length ]; int sum = 0 ; for ( int a : A ) sum += a % 2 == 0 ? a : 0 ; for ( int i = 0 ; i < queries . length ; i ++) { if ( A [ queries [ i ][ 1 ]] % 2 == 0 ) sum -= A [ queries [ i ][ 1 ]]; A [ queries [ i ][ 1 ]] += queries [ i ][ 0 ]; if ( A [ queries [ i ][ 1 ]] % 2 == 0 ) sum += A [ queries [ i ][ 1 ]]; ans [ i ] = sum ; } return ans ; } } 986. Interval List Intersections $\\star\\star$ 987. Vertical Order Traversal of a Binary Tree $\\star\\star$ 988. Smallest String Starting From Leaf $\\star\\star$ 989. Add to Array-Form of Integer $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public List < Integer > addToArrayForm ( int [] A , int K ) { List < Integer > ans = new LinkedList <>(); for ( int i = A . length - 1 ; i >= 0 ; i --) { ans . add ( 0 , ( A [ i ] + K ) % 10 ); K = ( A [ i ] + K ) / 10 ; } while ( K > 0 ) { ans . add ( 0 , K % 10 ); K /= 10 ; } return ans ; } } 990. Satisfiability of Equality Equations $\\star\\star$","title":"0981-0990"},{"location":"java/0901-1000/0981-0990/#981-time-based-key-value-store-starstar","text":"","title":"981. Time Based Key-Value Store $\\star\\star$"},{"location":"java/0901-1000/0981-0990/#982-triples-with-bitwise-and-equal-to-zero-starstarstar","text":"","title":"982. Triples with Bitwise AND Equal To Zero $\\star\\star\\star$"},{"location":"java/0901-1000/0981-0990/#983-minimum-cost-for-tickets-starstar","text":"","title":"983. Minimum Cost For Tickets $\\star\\star$"},{"location":"java/0901-1000/0981-0990/#984-string-without-aaa-or-bbb-starstar","text":"","title":"984. String Without AAA or BBB $\\star\\star$"},{"location":"java/0901-1000/0981-0990/#985-sum-of-even-numbers-after-queries-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int [] sumEvenAfterQueries ( int [] A , int [][] queries ) { int [] ans = new int [ queries . length ]; int sum = 0 ; for ( int a : A ) sum += a % 2 == 0 ? a : 0 ; for ( int i = 0 ; i < queries . length ; i ++) { if ( A [ queries [ i ][ 1 ]] % 2 == 0 ) sum -= A [ queries [ i ][ 1 ]]; A [ queries [ i ][ 1 ]] += queries [ i ][ 0 ]; if ( A [ queries [ i ][ 1 ]] % 2 == 0 ) sum += A [ queries [ i ][ 1 ]]; ans [ i ] = sum ; } return ans ; } }","title":"985. Sum of Even Numbers After Queries $\\star$"},{"location":"java/0901-1000/0981-0990/#986-interval-list-intersections-starstar","text":"","title":"986. Interval List Intersections $\\star\\star$"},{"location":"java/0901-1000/0981-0990/#987-vertical-order-traversal-of-a-binary-tree-starstar","text":"","title":"987. Vertical Order Traversal of a Binary Tree $\\star\\star$"},{"location":"java/0901-1000/0981-0990/#988-smallest-string-starting-from-leaf-starstar","text":"","title":"988. Smallest String Starting From Leaf $\\star\\star$"},{"location":"java/0901-1000/0981-0990/#989-add-to-array-form-of-integer-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution { public List < Integer > addToArrayForm ( int [] A , int K ) { List < Integer > ans = new LinkedList <>(); for ( int i = A . length - 1 ; i >= 0 ; i --) { ans . add ( 0 , ( A [ i ] + K ) % 10 ); K = ( A [ i ] + K ) / 10 ; } while ( K > 0 ) { ans . add ( 0 , K % 10 ); K /= 10 ; } return ans ; } }","title":"989. Add to Array-Form of Integer $\\star$"},{"location":"java/0901-1000/0981-0990/#990-satisfiability-of-equality-equations-starstar","text":"","title":"990. Satisfiability of Equality Equations $\\star\\star$"},{"location":"java/0901-1000/0991-1000/","text":"991. Broken Calculator $\\star\\star$ 992. Subarrays with K Different Integers $\\star\\star\\star$ 993. Cousins in Binary Tree $\\star$ 994. Rotting Oranges $\\star$ 995. Minimum Number of K Consecutive Bit Flips $\\star\\star\\star$ 996. Number of Squareful Arrays $\\star\\star\\star$ 997. Find the Town Judge $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int findJudge ( int N , int [][] trust ) { int [] count = new int [ N ]; for ( int [] t : trust ) { count [ t [ 0 ] - 1 ]--; count [ t [ 1 ] - 1 ]++; } for ( int i = 0 ; i < N ; i ++) if ( count [ i ] == N - 1 ) return i + 1 ; return - 1 ; } } 998. Maximum Binary Tree II $\\star\\star$ 999. Available Captures for Rook $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int numRookCaptures ( char [][] board ) { int ans = 0 ; int i0 = 0 ; int j0 = 0 ; for ( int i = 0 ; i < 8 ; i ++) for ( int j = 0 ; j < 8 ; j ++) if ( board [ i ][ j ] == 'R' ) { i0 = i ; j0 = j ; } for ( int [] d : new int [][] { { 1 , 0 }, { 0 , 1 }, { - 1 , 0 }, { 0 , - 1 } }) for ( int i = i0 + d [ 0 ], j = j0 + d [ 1 ]; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ], j += d [ 1 ]) { if ( board [ i ][ j ] == 'p' ) ans ++; if ( board [ i ][ j ] != '.' ) break ; } return ans ; } } 1000. Minimum Cost to Merge Stones $\\star\\star\\star$","title":"0991-1000"},{"location":"java/0901-1000/0991-1000/#991-broken-calculator-starstar","text":"","title":"991. Broken Calculator $\\star\\star$"},{"location":"java/0901-1000/0991-1000/#992-subarrays-with-k-different-integers-starstarstar","text":"","title":"992. Subarrays with K Different Integers $\\star\\star\\star$"},{"location":"java/0901-1000/0991-1000/#993-cousins-in-binary-tree-star","text":"","title":"993. Cousins in Binary Tree $\\star$"},{"location":"java/0901-1000/0991-1000/#994-rotting-oranges-star","text":"","title":"994. Rotting Oranges $\\star$"},{"location":"java/0901-1000/0991-1000/#995-minimum-number-of-k-consecutive-bit-flips-starstarstar","text":"","title":"995. Minimum Number of K Consecutive Bit Flips $\\star\\star\\star$"},{"location":"java/0901-1000/0991-1000/#996-number-of-squareful-arrays-starstarstar","text":"","title":"996. Number of Squareful Arrays $\\star\\star\\star$"},{"location":"java/0901-1000/0991-1000/#997-find-the-town-judge-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution { public int findJudge ( int N , int [][] trust ) { int [] count = new int [ N ]; for ( int [] t : trust ) { count [ t [ 0 ] - 1 ]--; count [ t [ 1 ] - 1 ]++; } for ( int i = 0 ; i < N ; i ++) if ( count [ i ] == N - 1 ) return i + 1 ; return - 1 ; } }","title":"997. Find the Town Judge $\\star$"},{"location":"java/0901-1000/0991-1000/#998-maximum-binary-tree-ii-starstar","text":"","title":"998. Maximum Binary Tree II $\\star\\star$"},{"location":"java/0901-1000/0991-1000/#999-available-captures-for-rook-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution { public int numRookCaptures ( char [][] board ) { int ans = 0 ; int i0 = 0 ; int j0 = 0 ; for ( int i = 0 ; i < 8 ; i ++) for ( int j = 0 ; j < 8 ; j ++) if ( board [ i ][ j ] == 'R' ) { i0 = i ; j0 = j ; } for ( int [] d : new int [][] { { 1 , 0 }, { 0 , 1 }, { - 1 , 0 }, { 0 , - 1 } }) for ( int i = i0 + d [ 0 ], j = j0 + d [ 1 ]; 0 <= i && i < 8 && 0 <= j && j < 8 ; i += d [ 0 ], j += d [ 1 ]) { if ( board [ i ][ j ] == 'p' ) ans ++; if ( board [ i ][ j ] != '.' ) break ; } return ans ; } }","title":"999. Available Captures for Rook $\\star$"},{"location":"java/0901-1000/0991-1000/#1000-minimum-cost-to-merge-stones-starstarstar","text":"","title":"1000. Minimum Cost to Merge Stones $\\star\\star\\star$"},{"location":"java/1001-1100/1001-1010/","text":"1001. Grid Illumination $\\star\\star\\star$ 1002. Find Common Characters $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public List < String > commonChars ( String [] A ) { List < String > ans = new ArrayList <>(); int [] commonCount = new int [ 26 ]; Arrays . fill ( commonCount , Integer . MAX_VALUE ); for ( String a : A ) { int [] count = new int [ 26 ]; for ( char c : a . toCharArray ()) count [ c - 'a' ]++; for ( int i = 0 ; i < 26 ; i ++) commonCount [ i ] = Math . min ( commonCount [ i ], count [ i ]); } for ( char c = 'a' ; c <= 'z' ; c ++) for ( int i = 0 ; i < commonCount [ c - 'a' ]; i ++) ans . add ( String . valueOf ( c )); return ans ; } } 1003. Check If Word Is Valid After Substitutions $\\star\\star$ 1004. Max Consecutive Ones III $\\star\\star$ 1005. Maximize Sum Of Array After K Negations $\\star$ 1006. Clumsy Factorial $\\star\\star$ 1007. Minimum Domino Rotations For Equal Row $\\star\\star$ 1008. Construct Binary Search Tree from Preorder Traversal $\\star\\star$ 1009. Complement of Base 10 Integer $\\star$ 1010. Pairs of Songs With Total Durations Divisible by 60 $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int numPairsDivisibleBy60 ( int [] time ) { int ans = 0 ; int [] count = new int [ 60 ]; for ( int t : time ) { t %= 60 ; ans += t == 0 ? count [ 0 ] : count [ 60 - t ]; count [ t ]++; } return ans ; } }","title":"1001-1010"},{"location":"java/1001-1100/1001-1010/#1001-grid-illumination-starstarstar","text":"","title":"1001. Grid Illumination $\\star\\star\\star$"},{"location":"java/1001-1100/1001-1010/#1002-find-common-characters-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution { public List < String > commonChars ( String [] A ) { List < String > ans = new ArrayList <>(); int [] commonCount = new int [ 26 ]; Arrays . fill ( commonCount , Integer . MAX_VALUE ); for ( String a : A ) { int [] count = new int [ 26 ]; for ( char c : a . toCharArray ()) count [ c - 'a' ]++; for ( int i = 0 ; i < 26 ; i ++) commonCount [ i ] = Math . min ( commonCount [ i ], count [ i ]); } for ( char c = 'a' ; c <= 'z' ; c ++) for ( int i = 0 ; i < commonCount [ c - 'a' ]; i ++) ans . add ( String . valueOf ( c )); return ans ; } }","title":"1002. Find Common Characters $\\star$"},{"location":"java/1001-1100/1001-1010/#1003-check-if-word-is-valid-after-substitutions-starstar","text":"","title":"1003. Check If Word Is Valid After Substitutions $\\star\\star$"},{"location":"java/1001-1100/1001-1010/#1004-max-consecutive-ones-iii-starstar","text":"","title":"1004. Max Consecutive Ones III $\\star\\star$"},{"location":"java/1001-1100/1001-1010/#1005-maximize-sum-of-array-after-k-negations-star","text":"","title":"1005. Maximize Sum Of Array After K Negations $\\star$"},{"location":"java/1001-1100/1001-1010/#1006-clumsy-factorial-starstar","text":"","title":"1006. Clumsy Factorial $\\star\\star$"},{"location":"java/1001-1100/1001-1010/#1007-minimum-domino-rotations-for-equal-row-starstar","text":"","title":"1007. Minimum Domino Rotations For Equal Row $\\star\\star$"},{"location":"java/1001-1100/1001-1010/#1008-construct-binary-search-tree-from-preorder-traversal-starstar","text":"","title":"1008. Construct Binary Search Tree from Preorder Traversal $\\star\\star$"},{"location":"java/1001-1100/1001-1010/#1009-complement-of-base-10-integer-star","text":"","title":"1009. Complement of Base 10 Integer $\\star$"},{"location":"java/1001-1100/1001-1010/#1010-pairs-of-songs-with-total-durations-divisible-by-60-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution { public int numPairsDivisibleBy60 ( int [] time ) { int ans = 0 ; int [] count = new int [ 60 ]; for ( int t : time ) { t %= 60 ; ans += t == 0 ? count [ 0 ] : count [ 60 - t ]; count [ t ]++; } return ans ; } }","title":"1010. Pairs of Songs With Total Durations Divisible by 60 $\\star$"},{"location":"java/1001-1100/1011-1020/","text":"1011. Capacity To Ship Packages Within D Days $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int shipWithinDays ( int [] weights , int D ) { int l = Arrays . stream ( weights ). max (). getAsInt (); int r = Arrays . stream ( weights ). sum (); while ( l < r ) { int m = l + ( r - l ) / 2 ; int day = 1 ; int capacity = 0 ; for ( int weight : weights ) { if ( capacity + weight > m ) { day ++; capacity = weight ; } else capacity += weight ; } if ( day <= D ) r = m ; else l = m + 1 ; } return l ; } } 1012. Numbers With Repeated Digits $\\star\\star\\star$ 1013. Partition Array Into Three Parts With Equal Sum $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public boolean canThreePartsEqualSum ( int [] A ) { int sum = Arrays . stream ( A ). sum (); int presum = 0 ; int parts = 1 ; for ( int a : A ) { presum += a ; if ( presum == sum * parts / 3 ) parts ++; } return sum % 3 == 0 && parts >= 3 ; } } 1014. Best Sightseeing Pair $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int maxScoreSightseeingPair ( int [] A ) { int ans = 0 ; int bestPrev = 0 ; for ( int a : A ) { ans = Math . max ( ans , a + bestPrev ); bestPrev = Math . max ( bestPrev , a ) - 1 ; } return ans ; } } 1015. Smallest Integer Divisible by K $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int smallestRepunitDivByK ( int K ) { if ( K % 10 != 1 && K % 10 != 3 && K % 10 != 7 && K % 10 != 9 ) return - 1 ; Set < Integer > set = new HashSet <>(); int mod = 0 ; for ( int N = 1 ; N <= K ; N ++) { mod = ( mod * 10 + 1 ) % K ; if ( mod == 0 ) return N ; if ( set . contains ( mod )) return - 1 ; set . add ( mod ); } return - 1 ; } } 1016. Binary String With Substrings Representing 1 To N $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public boolean queryString ( String S , int N ) { if ( N > 1511 ) return false ; for ( int i = N ; i > N / 2 ; i --) if (! S . contains ( Integer . toBinaryString ( i ))) return false ; return true ; } } 1017. Convert to Base -2 $\\star\\star$ 1018. Binary Prefix Divisible By 5 $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public List < Boolean > prefixesDivBy5 ( int [] A ) { List < Boolean > ans = new ArrayList <>(); int num = 0 ; for ( int a : A ) { num = ( num * 2 + a ) % 5 ; ans . add ( num % 5 == 0 ); } return ans ; } } 1019. Next Greater Node In Linked List $\\star\\star$ 1020. Number of Enclaves $\\star\\star$","title":"1011-1020"},{"location":"java/1001-1100/1011-1020/#1011-capacity-to-ship-packages-within-d-days-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution { public int shipWithinDays ( int [] weights , int D ) { int l = Arrays . stream ( weights ). max (). getAsInt (); int r = Arrays . stream ( weights ). sum (); while ( l < r ) { int m = l + ( r - l ) / 2 ; int day = 1 ; int capacity = 0 ; for ( int weight : weights ) { if ( capacity + weight > m ) { day ++; capacity = weight ; } else capacity += weight ; } if ( day <= D ) r = m ; else l = m + 1 ; } return l ; } }","title":"1011. Capacity To Ship Packages Within D Days $\\star\\star$"},{"location":"java/1001-1100/1011-1020/#1012-numbers-with-repeated-digits-starstarstar","text":"","title":"1012. Numbers With Repeated Digits $\\star\\star\\star$"},{"location":"java/1001-1100/1011-1020/#1013-partition-array-into-three-parts-with-equal-sum-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public boolean canThreePartsEqualSum ( int [] A ) { int sum = Arrays . stream ( A ). sum (); int presum = 0 ; int parts = 1 ; for ( int a : A ) { presum += a ; if ( presum == sum * parts / 3 ) parts ++; } return sum % 3 == 0 && parts >= 3 ; } }","title":"1013. Partition Array Into Three Parts With Equal Sum $\\star$"},{"location":"java/1001-1100/1011-1020/#1014-best-sightseeing-pair-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public int maxScoreSightseeingPair ( int [] A ) { int ans = 0 ; int bestPrev = 0 ; for ( int a : A ) { ans = Math . max ( ans , a + bestPrev ); bestPrev = Math . max ( bestPrev , a ) - 1 ; } return ans ; } }","title":"1014. Best Sightseeing Pair $\\star\\star$"},{"location":"java/1001-1100/1011-1020/#1015-smallest-integer-divisible-by-k-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution { public int smallestRepunitDivByK ( int K ) { if ( K % 10 != 1 && K % 10 != 3 && K % 10 != 7 && K % 10 != 9 ) return - 1 ; Set < Integer > set = new HashSet <>(); int mod = 0 ; for ( int N = 1 ; N <= K ; N ++) { mod = ( mod * 10 + 1 ) % K ; if ( mod == 0 ) return N ; if ( set . contains ( mod )) return - 1 ; set . add ( mod ); } return - 1 ; } }","title":"1015. Smallest Integer Divisible by K $\\star\\star$"},{"location":"java/1001-1100/1011-1020/#1016-binary-string-with-substrings-representing-1-to-n-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution { public boolean queryString ( String S , int N ) { if ( N > 1511 ) return false ; for ( int i = N ; i > N / 2 ; i --) if (! S . contains ( Integer . toBinaryString ( i ))) return false ; return true ; } }","title":"1016. Binary String With Substrings Representing 1 To N $\\star\\star$"},{"location":"java/1001-1100/1011-1020/#1017-convert-to-base-2-starstar","text":"","title":"1017. Convert to Base -2 $\\star\\star$"},{"location":"java/1001-1100/1011-1020/#1018-binary-prefix-divisible-by-5-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution { public List < Boolean > prefixesDivBy5 ( int [] A ) { List < Boolean > ans = new ArrayList <>(); int num = 0 ; for ( int a : A ) { num = ( num * 2 + a ) % 5 ; ans . add ( num % 5 == 0 ); } return ans ; } }","title":"1018. Binary Prefix Divisible By 5 $\\star$"},{"location":"java/1001-1100/1011-1020/#1019-next-greater-node-in-linked-list-starstar","text":"","title":"1019. Next Greater Node In Linked List $\\star\\star$"},{"location":"java/1001-1100/1011-1020/#1020-number-of-enclaves-starstar","text":"","title":"1020. Number of Enclaves $\\star\\star$"},{"location":"java/1001-1100/1021-1030/","text":"1021. Remove Outermost Parentheses $\\star$ 1022. Sum of Root To Leaf Binary Numbers $\\star$ 1023. Camelcase Matching $\\star\\star$ 1024. Video Stitching $\\star\\star$ 1025. Divisor Game $\\star$ 1026. Maximum Difference Between Node and Ancestor $\\star\\star$ 1027. Longest Arithmetic Sequence $\\star\\star$ 1028. Recover a Tree From Preorder Traversal $\\star\\star\\star$ 1029. Two City Scheduling $\\star$ 1030. Matrix Cells in Distance Order $\\star$","title":"1021-1030"},{"location":"java/1001-1100/1021-1030/#1021-remove-outermost-parentheses-star","text":"","title":"1021. Remove Outermost Parentheses $\\star$"},{"location":"java/1001-1100/1021-1030/#1022-sum-of-root-to-leaf-binary-numbers-star","text":"","title":"1022. Sum of Root To Leaf Binary Numbers $\\star$"},{"location":"java/1001-1100/1021-1030/#1023-camelcase-matching-starstar","text":"","title":"1023. Camelcase Matching $\\star\\star$"},{"location":"java/1001-1100/1021-1030/#1024-video-stitching-starstar","text":"","title":"1024. Video Stitching $\\star\\star$"},{"location":"java/1001-1100/1021-1030/#1025-divisor-game-star","text":"","title":"1025. Divisor Game $\\star$"},{"location":"java/1001-1100/1021-1030/#1026-maximum-difference-between-node-and-ancestor-starstar","text":"","title":"1026. Maximum Difference Between Node and Ancestor $\\star\\star$"},{"location":"java/1001-1100/1021-1030/#1027-longest-arithmetic-sequence-starstar","text":"","title":"1027. Longest Arithmetic Sequence $\\star\\star$"},{"location":"java/1001-1100/1021-1030/#1028-recover-a-tree-from-preorder-traversal-starstarstar","text":"","title":"1028. Recover a Tree From Preorder Traversal $\\star\\star\\star$"},{"location":"java/1001-1100/1021-1030/#1029-two-city-scheduling-star","text":"","title":"1029. Two City Scheduling $\\star$"},{"location":"java/1001-1100/1021-1030/#1030-matrix-cells-in-distance-order-star","text":"","title":"1030. Matrix Cells in Distance Order $\\star$"},{"location":"java/1001-1100/1031-1040/","text":"1031. Maximum Sum of Two Non-Overlapping Subarrays $\\star\\star$ 1032. Stream of Characters $\\star\\star\\star$ 1033. Moving Stones Until Consecutive $\\star$ 1034. Coloring A Border $\\star\\star$ 1035. Uncrossed Lines $\\star\\star$ 1036. Escape a Large Maze $\\star\\star\\star$ 1037. Valid Boomerang $\\star$ 1038. Binary Search Tree to Greater Sum Tree $\\star\\star$ 1039. Minimum Score Triangulation of Polygon $\\star\\star$ 1040. Moving Stones Until Consecutive II $\\star\\star$","title":"1031-1040"},{"location":"java/1001-1100/1031-1040/#1031-maximum-sum-of-two-non-overlapping-subarrays-starstar","text":"","title":"1031. Maximum Sum of Two Non-Overlapping Subarrays $\\star\\star$"},{"location":"java/1001-1100/1031-1040/#1032-stream-of-characters-starstarstar","text":"","title":"1032. Stream of Characters $\\star\\star\\star$"},{"location":"java/1001-1100/1031-1040/#1033-moving-stones-until-consecutive-star","text":"","title":"1033. Moving Stones Until Consecutive $\\star$"},{"location":"java/1001-1100/1031-1040/#1034-coloring-a-border-starstar","text":"","title":"1034. Coloring A Border $\\star\\star$"},{"location":"java/1001-1100/1031-1040/#1035-uncrossed-lines-starstar","text":"","title":"1035. Uncrossed Lines $\\star\\star$"},{"location":"java/1001-1100/1031-1040/#1036-escape-a-large-maze-starstarstar","text":"","title":"1036. Escape a Large Maze $\\star\\star\\star$"},{"location":"java/1001-1100/1031-1040/#1037-valid-boomerang-star","text":"","title":"1037. Valid Boomerang $\\star$"},{"location":"java/1001-1100/1031-1040/#1038-binary-search-tree-to-greater-sum-tree-starstar","text":"","title":"1038. Binary Search Tree to Greater Sum Tree $\\star\\star$"},{"location":"java/1001-1100/1031-1040/#1039-minimum-score-triangulation-of-polygon-starstar","text":"","title":"1039. Minimum Score Triangulation of Polygon $\\star\\star$"},{"location":"java/1001-1100/1031-1040/#1040-moving-stones-until-consecutive-ii-starstar","text":"","title":"1040. Moving Stones Until Consecutive II $\\star\\star$"},{"location":"java/1001-1100/1041-1050/","text":"1041. Robot Bounded In Circle $\\star\\star$ 1042. Flower Planting With No Adjacent $\\star$ 1043. Partition Array for Maximum Sum $\\star\\star$ 1044. Longest Duplicate Substring $\\star\\star\\star$ 1045. Customers Who Bought All Products $\\star\\star$ 1046. Last Stone Weight $\\star$ 1047. Remove All Adjacent Duplicates In String $\\star$ 1048. Longest String Chain $\\star\\star$ 1049. Last Stone Weight II $\\star\\star$ 1050. Actors and Directors Who Cooperated At Least Three Times $\\star$","title":"1041-1050"},{"location":"java/1001-1100/1041-1050/#1041-robot-bounded-in-circle-starstar","text":"","title":"1041. Robot Bounded In Circle $\\star\\star$"},{"location":"java/1001-1100/1041-1050/#1042-flower-planting-with-no-adjacent-star","text":"","title":"1042. Flower Planting With No Adjacent $\\star$"},{"location":"java/1001-1100/1041-1050/#1043-partition-array-for-maximum-sum-starstar","text":"","title":"1043. Partition Array for Maximum Sum $\\star\\star$"},{"location":"java/1001-1100/1041-1050/#1044-longest-duplicate-substring-starstarstar","text":"","title":"1044. Longest Duplicate Substring $\\star\\star\\star$"},{"location":"java/1001-1100/1041-1050/#1045-customers-who-bought-all-products-starstar","text":"","title":"1045. Customers Who Bought All Products $\\star\\star$"},{"location":"java/1001-1100/1041-1050/#1046-last-stone-weight-star","text":"","title":"1046. Last Stone Weight $\\star$"},{"location":"java/1001-1100/1041-1050/#1047-remove-all-adjacent-duplicates-in-string-star","text":"","title":"1047. Remove All Adjacent Duplicates In String $\\star$"},{"location":"java/1001-1100/1041-1050/#1048-longest-string-chain-starstar","text":"","title":"1048. Longest String Chain $\\star\\star$"},{"location":"java/1001-1100/1041-1050/#1049-last-stone-weight-ii-starstar","text":"","title":"1049. Last Stone Weight II $\\star\\star$"},{"location":"java/1001-1100/1041-1050/#1050-actors-and-directors-who-cooperated-at-least-three-times-star","text":"","title":"1050. Actors and Directors Who Cooperated At Least Three Times $\\star$"},{"location":"java/1001-1100/1051-1060/","text":"1051. Height Checker $\\star$ 1052. Grumpy Bookstore Owner $\\star\\star$ 1053. Previous Permutation With One Swap $\\star\\star$ 1054. Distant Barcodes $\\star\\star$ 1055. Shortest Way to Form String $\\star\\star$ 1056. Confusing Number $\\star$ 1057. Campus Bikes $\\star\\star$ 1058. Minimize Rounding Error to Meet Target $\\star\\star$ 1059. All Paths from Source Lead to Destination $\\star\\star$ 1060. Missing Element in Sorted Array $\\star\\star$","title":"1051-1060"},{"location":"java/1001-1100/1051-1060/#1051-height-checker-star","text":"","title":"1051. Height Checker $\\star$"},{"location":"java/1001-1100/1051-1060/#1052-grumpy-bookstore-owner-starstar","text":"","title":"1052. Grumpy Bookstore Owner $\\star\\star$"},{"location":"java/1001-1100/1051-1060/#1053-previous-permutation-with-one-swap-starstar","text":"","title":"1053. Previous Permutation With One Swap $\\star\\star$"},{"location":"java/1001-1100/1051-1060/#1054-distant-barcodes-starstar","text":"","title":"1054. Distant Barcodes $\\star\\star$"},{"location":"java/1001-1100/1051-1060/#1055-shortest-way-to-form-string-starstar","text":"","title":"1055. Shortest Way to Form String $\\star\\star$"},{"location":"java/1001-1100/1051-1060/#1056-confusing-number-star","text":"","title":"1056. Confusing Number $\\star$"},{"location":"java/1001-1100/1051-1060/#1057-campus-bikes-starstar","text":"","title":"1057. Campus Bikes $\\star\\star$"},{"location":"java/1001-1100/1051-1060/#1058-minimize-rounding-error-to-meet-target-starstar","text":"","title":"1058. Minimize Rounding Error to Meet Target $\\star\\star$"},{"location":"java/1001-1100/1051-1060/#1059-all-paths-from-source-lead-to-destination-starstar","text":"","title":"1059. All Paths from Source Lead to Destination $\\star\\star$"},{"location":"java/1001-1100/1051-1060/#1060-missing-element-in-sorted-array-starstar","text":"","title":"1060. Missing Element in Sorted Array $\\star\\star$"},{"location":"java/1001-1100/1061-1070/","text":"1061. Lexicographically Smallest Equivalent String $\\star\\star$ 1062. Longest Repeating Substring $\\star\\star$ 1063. Number of Valid Subarrays $\\star\\star\\star$ 1064. Fixed Point $\\star$ 1065. Index Pairs of a String $\\star$ 1066. Campus Bikes II $\\star\\star$ 1067. Digit Count in Range $\\star\\star\\star$ 1068. Product Sales Analysis I $\\star$ 1069. Product Sales Analysis II $\\star$ 1070. Product Sales Analysis III $\\star\\star$","title":"1061-1070"},{"location":"java/1001-1100/1061-1070/#1061-lexicographically-smallest-equivalent-string-starstar","text":"","title":"1061. Lexicographically Smallest Equivalent String $\\star\\star$"},{"location":"java/1001-1100/1061-1070/#1062-longest-repeating-substring-starstar","text":"","title":"1062. Longest Repeating Substring $\\star\\star$"},{"location":"java/1001-1100/1061-1070/#1063-number-of-valid-subarrays-starstarstar","text":"","title":"1063. Number of Valid Subarrays $\\star\\star\\star$"},{"location":"java/1001-1100/1061-1070/#1064-fixed-point-star","text":"","title":"1064. Fixed Point $\\star$"},{"location":"java/1001-1100/1061-1070/#1065-index-pairs-of-a-string-star","text":"","title":"1065. Index Pairs of a String $\\star$"},{"location":"java/1001-1100/1061-1070/#1066-campus-bikes-ii-starstar","text":"","title":"1066. Campus Bikes II $\\star\\star$"},{"location":"java/1001-1100/1061-1070/#1067-digit-count-in-range-starstarstar","text":"","title":"1067. Digit Count in Range $\\star\\star\\star$"},{"location":"java/1001-1100/1061-1070/#1068-product-sales-analysis-i-star","text":"","title":"1068. Product Sales Analysis I $\\star$"},{"location":"java/1001-1100/1061-1070/#1069-product-sales-analysis-ii-star","text":"","title":"1069. Product Sales Analysis II $\\star$"},{"location":"java/1001-1100/1061-1070/#1070-product-sales-analysis-iii-starstar","text":"","title":"1070. Product Sales Analysis III $\\star\\star$"},{"location":"java/1001-1100/1071-1080/","text":"1071. Greatest Common Divisor of Strings $\\star$ 1072. Flip Columns For Maximum Number of Equal Rows $\\star\\star$ 1073. Adding Two Negabinary Numbers $\\star\\star$ 1074. Number of Submatrices That Sum to Target $\\star\\star\\star$ 1075. Project Employees I $\\star$ 1076. Project Employees II $\\star$ 1077. Project Employees III $\\star\\star$ 1078. Occurrences After Bigram $\\star$ 1079. Letter Tile Possibilities $\\star\\star$ 1080. Insufficient Nodes in Root to Leaf Paths $\\star\\star$","title":"1071-1080"},{"location":"java/1001-1100/1071-1080/#1071-greatest-common-divisor-of-strings-star","text":"","title":"1071. Greatest Common Divisor of Strings $\\star$"},{"location":"java/1001-1100/1071-1080/#1072-flip-columns-for-maximum-number-of-equal-rows-starstar","text":"","title":"1072. Flip Columns For Maximum Number of Equal Rows $\\star\\star$"},{"location":"java/1001-1100/1071-1080/#1073-adding-two-negabinary-numbers-starstar","text":"","title":"1073. Adding Two Negabinary Numbers $\\star\\star$"},{"location":"java/1001-1100/1071-1080/#1074-number-of-submatrices-that-sum-to-target-starstarstar","text":"","title":"1074. Number of Submatrices That Sum to Target $\\star\\star\\star$"},{"location":"java/1001-1100/1071-1080/#1075-project-employees-i-star","text":"","title":"1075. Project Employees I $\\star$"},{"location":"java/1001-1100/1071-1080/#1076-project-employees-ii-star","text":"","title":"1076. Project Employees II $\\star$"},{"location":"java/1001-1100/1071-1080/#1077-project-employees-iii-starstar","text":"","title":"1077. Project Employees III $\\star\\star$"},{"location":"java/1001-1100/1071-1080/#1078-occurrences-after-bigram-star","text":"","title":"1078. Occurrences After Bigram $\\star$"},{"location":"java/1001-1100/1071-1080/#1079-letter-tile-possibilities-starstar","text":"","title":"1079. Letter Tile Possibilities $\\star\\star$"},{"location":"java/1001-1100/1071-1080/#1080-insufficient-nodes-in-root-to-leaf-paths-starstar","text":"","title":"1080. Insufficient Nodes in Root to Leaf Paths $\\star\\star$"},{"location":"java/1001-1100/1081-1090/","text":"1081. Smallest Subsequence of Distinct Characters $\\star\\star$ 1082. Sales Analysis I $\\star$ 1083. Sales Analysis II $\\star$ 1084. Sales Analysis III $\\star$ 1085. Sum of Digits in the Minimum Number $\\star$ 1086. High Five $\\star$ 1087. Brace Expansion $\\star\\star$ 1088. Confusing Number II $\\star\\star\\star$ 1089. Duplicate Zeros $\\star$ 1090. Largest Values From Labels $\\star\\star$","title":"1081-1090"},{"location":"java/1001-1100/1081-1090/#1081-smallest-subsequence-of-distinct-characters-starstar","text":"","title":"1081. Smallest Subsequence of Distinct Characters $\\star\\star$"},{"location":"java/1001-1100/1081-1090/#1082-sales-analysis-i-star","text":"","title":"1082. Sales Analysis I $\\star$"},{"location":"java/1001-1100/1081-1090/#1083-sales-analysis-ii-star","text":"","title":"1083. Sales Analysis II $\\star$"},{"location":"java/1001-1100/1081-1090/#1084-sales-analysis-iii-star","text":"","title":"1084. Sales Analysis III $\\star$"},{"location":"java/1001-1100/1081-1090/#1085-sum-of-digits-in-the-minimum-number-star","text":"","title":"1085. Sum of Digits in the Minimum Number $\\star$"},{"location":"java/1001-1100/1081-1090/#1086-high-five-star","text":"","title":"1086. High Five $\\star$"},{"location":"java/1001-1100/1081-1090/#1087-brace-expansion-starstar","text":"","title":"1087. Brace Expansion $\\star\\star$"},{"location":"java/1001-1100/1081-1090/#1088-confusing-number-ii-starstarstar","text":"","title":"1088. Confusing Number II $\\star\\star\\star$"},{"location":"java/1001-1100/1081-1090/#1089-duplicate-zeros-star","text":"","title":"1089. Duplicate Zeros $\\star$"},{"location":"java/1001-1100/1081-1090/#1090-largest-values-from-labels-starstar","text":"","title":"1090. Largest Values From Labels $\\star\\star$"},{"location":"java/1001-1100/1091-1100/","text":"1091. Shortest Path in Binary Matrix $\\star\\star$ 1092. Shortest Common Supersequence $\\star\\star\\star$ 1093. Statistics from a Large Sample $\\star\\star$ 1094. Car Pooling $\\star\\star$ 1095. Find in Mountain Array $\\star\\star\\star$ 1096. Brace Expansion II $\\star\\star\\star$ 1097. Game Play Analysis V $\\star\\star\\star$ 1098. Unpopular Books $\\star\\star$ 1099. Two Sum Less Than K $\\star$ 1100. Find K-Length Substrings With No Repeated Characters $\\star\\star$","title":"1091-1100"},{"location":"java/1001-1100/1091-1100/#1091-shortest-path-in-binary-matrix-starstar","text":"","title":"1091. Shortest Path in Binary Matrix $\\star\\star$"},{"location":"java/1001-1100/1091-1100/#1092-shortest-common-supersequence-starstarstar","text":"","title":"1092. Shortest Common Supersequence  $\\star\\star\\star$"},{"location":"java/1001-1100/1091-1100/#1093-statistics-from-a-large-sample-starstar","text":"","title":"1093. Statistics from a Large Sample $\\star\\star$"},{"location":"java/1001-1100/1091-1100/#1094-car-pooling-starstar","text":"","title":"1094. Car Pooling $\\star\\star$"},{"location":"java/1001-1100/1091-1100/#1095-find-in-mountain-array-starstarstar","text":"","title":"1095. Find in Mountain Array $\\star\\star\\star$"},{"location":"java/1001-1100/1091-1100/#1096-brace-expansion-ii-starstarstar","text":"","title":"1096. Brace Expansion II $\\star\\star\\star$"},{"location":"java/1001-1100/1091-1100/#1097-game-play-analysis-v-starstarstar","text":"","title":"1097. Game Play Analysis V $\\star\\star\\star$"},{"location":"java/1001-1100/1091-1100/#1098-unpopular-books-starstar","text":"","title":"1098. Unpopular Books $\\star\\star$"},{"location":"java/1001-1100/1091-1100/#1099-two-sum-less-than-k-star","text":"","title":"1099. Two Sum Less Than K $\\star$"},{"location":"java/1001-1100/1091-1100/#1100-find-k-length-substrings-with-no-repeated-characters-starstar","text":"","title":"1100. Find K-Length Substrings With No Repeated Characters $\\star\\star$"},{"location":"java/1101-1200/1101-1110/","text":"1101. The Earliest Moment When Everyone Become Friends $\\star\\star$ 1102. Path With Maximum Minimum Value $\\star\\star$ 1103. Distribute Candies to People $\\star$ 1104. Path In Zigzag Labelled Binary Tree $\\star\\star$ 1105. Filling Bookcase Shelves $\\star\\star$ 1106. Parsing A Boolean Expression $\\star\\star\\star$ 1107. New Users Daily Count $\\star\\star$ 1108. Defanging an IP Address $\\star$ 1109. Corporate Flight Bookings $\\star\\star$ 1110. Delete Nodes And Return Forest $\\star\\star$","title":"1101-1110"},{"location":"java/1101-1200/1101-1110/#1101-the-earliest-moment-when-everyone-become-friends-starstar","text":"","title":"1101. The Earliest Moment When Everyone Become Friends $\\star\\star$"},{"location":"java/1101-1200/1101-1110/#1102-path-with-maximum-minimum-value-starstar","text":"","title":"1102. Path With Maximum Minimum Value $\\star\\star$"},{"location":"java/1101-1200/1101-1110/#1103-distribute-candies-to-people-star","text":"","title":"1103. Distribute Candies to People $\\star$"},{"location":"java/1101-1200/1101-1110/#1104-path-in-zigzag-labelled-binary-tree-starstar","text":"","title":"1104. Path In Zigzag Labelled Binary Tree $\\star\\star$"},{"location":"java/1101-1200/1101-1110/#1105-filling-bookcase-shelves-starstar","text":"","title":"1105. Filling Bookcase Shelves $\\star\\star$"},{"location":"java/1101-1200/1101-1110/#1106-parsing-a-boolean-expression-starstarstar","text":"","title":"1106. Parsing A Boolean Expression $\\star\\star\\star$"},{"location":"java/1101-1200/1101-1110/#1107-new-users-daily-count-starstar","text":"","title":"1107. New Users Daily Count $\\star\\star$"},{"location":"java/1101-1200/1101-1110/#1108-defanging-an-ip-address-star","text":"","title":"1108. Defanging an IP Address $\\star$"},{"location":"java/1101-1200/1101-1110/#1109-corporate-flight-bookings-starstar","text":"","title":"1109. Corporate Flight Bookings $\\star\\star$"},{"location":"java/1101-1200/1101-1110/#1110-delete-nodes-and-return-forest-starstar","text":"","title":"1110. Delete Nodes And Return Forest $\\star\\star$"},{"location":"java/1101-1200/1111-1120/","text":"1111. Maximum Nesting Depth of Two Valid Parentheses Strings $\\star\\star$ 1112. Highest Grade For Each Student $\\star\\star$ 1113. Reported Posts $\\star$ 1114. Print in Order $\\star$ 1115. Print FooBar Alternately $\\star\\star$ 1116. Print Zero Even Odd $\\star\\star$ 1117. Building H2O $\\star\\star$ 1118. Number of Days in a Month $\\star$ 1119. Remove Vowels from a String $\\star$ 1120. Maximum Average Subtree $\\star\\star$","title":"1111-1120"},{"location":"java/1101-1200/1111-1120/#1111-maximum-nesting-depth-of-two-valid-parentheses-strings-starstar","text":"","title":"1111. Maximum Nesting Depth of Two Valid Parentheses Strings $\\star\\star$"},{"location":"java/1101-1200/1111-1120/#1112-highest-grade-for-each-student-starstar","text":"","title":"1112. Highest Grade For Each Student $\\star\\star$"},{"location":"java/1101-1200/1111-1120/#1113-reported-posts-star","text":"","title":"1113. Reported Posts $\\star$"},{"location":"java/1101-1200/1111-1120/#1114-print-in-order-star","text":"","title":"1114. Print in Order $\\star$"},{"location":"java/1101-1200/1111-1120/#1115-print-foobar-alternately-starstar","text":"","title":"1115. Print FooBar Alternately $\\star\\star$"},{"location":"java/1101-1200/1111-1120/#1116-print-zero-even-odd-starstar","text":"","title":"1116. Print Zero Even Odd $\\star\\star$"},{"location":"java/1101-1200/1111-1120/#1117-building-h2o-starstar","text":"","title":"1117. Building H2O $\\star\\star$"},{"location":"java/1101-1200/1111-1120/#1118-number-of-days-in-a-month-star","text":"","title":"1118. Number of Days in a Month $\\star$"},{"location":"java/1101-1200/1111-1120/#1119-remove-vowels-from-a-string-star","text":"","title":"1119. Remove Vowels from a String $\\star$"},{"location":"java/1101-1200/1111-1120/#1120-maximum-average-subtree-starstar","text":"","title":"1120. Maximum Average Subtree $\\star\\star$"},{"location":"java/1101-1200/1121-1130/","text":"1121. Divide Array Into Increasing Sequences $\\star\\star\\star$ 1122. Relative Sort Array $\\star$ 1123. Lowest Common Ancestor of Deepest Leaves $\\star\\star$ 1124. Longest Well-Performing Interval $\\star\\star$ 1125. Smallest Sufficient Team $\\star\\star\\star$ 1126. Active Businesses $\\star\\star$ 1127. User Purchase Platform $\\star\\star\\star$ 1128. Number of Equivalent Domino Pairs $\\star$ 1129. Shortest Path with Alternating Colors $\\star\\star$ 1130. Minimum Cost Tree From Leaf Values $\\star\\star$","title":"1121-1130"},{"location":"java/1101-1200/1121-1130/#1121-divide-array-into-increasing-sequences-starstarstar","text":"","title":"1121. Divide Array Into Increasing Sequences $\\star\\star\\star$"},{"location":"java/1101-1200/1121-1130/#1122-relative-sort-array-star","text":"","title":"1122. Relative Sort Array $\\star$"},{"location":"java/1101-1200/1121-1130/#1123-lowest-common-ancestor-of-deepest-leaves-starstar","text":"","title":"1123. Lowest Common Ancestor of Deepest Leaves $\\star\\star$"},{"location":"java/1101-1200/1121-1130/#1124-longest-well-performing-interval-starstar","text":"","title":"1124. Longest Well-Performing Interval $\\star\\star$"},{"location":"java/1101-1200/1121-1130/#1125-smallest-sufficient-team-starstarstar","text":"","title":"1125. Smallest Sufficient Team $\\star\\star\\star$"},{"location":"java/1101-1200/1121-1130/#1126-active-businesses-starstar","text":"","title":"1126. Active Businesses $\\star\\star$"},{"location":"java/1101-1200/1121-1130/#1127-user-purchase-platform-starstarstar","text":"","title":"1127. User Purchase Platform $\\star\\star\\star$"},{"location":"java/1101-1200/1121-1130/#1128-number-of-equivalent-domino-pairs-star","text":"","title":"1128. Number of Equivalent Domino Pairs $\\star$"},{"location":"java/1101-1200/1121-1130/#1129-shortest-path-with-alternating-colors-starstar","text":"","title":"1129. Shortest Path with Alternating Colors $\\star\\star$"},{"location":"java/1101-1200/1121-1130/#1130-minimum-cost-tree-from-leaf-values-starstar","text":"","title":"1130. Minimum Cost Tree From Leaf Values $\\star\\star$"},{"location":"java/1101-1200/1131-1140/","text":"1131. Maximum of Absolute Value Expression $\\star\\star$ 1132. Reported Posts II $\\star\\star$ 1133. Largest Unique Number $\\star$ 1134. Armstrong Number $\\star$ 1135. Connecting Cities With Minimum Cost $\\star\\star$ 1136. Parallel Courses $\\star\\star\\star$ 1137. N-th Tribonacci Number $\\star$ 1138. Alphabet Board Path $\\star\\star$ 1139. Largest 1-Bordered Square $\\star\\star$ 1140. Stone Game II $\\star\\star$","title":"1131-1140"},{"location":"java/1101-1200/1131-1140/#1131-maximum-of-absolute-value-expression-starstar","text":"","title":"1131. Maximum of Absolute Value Expression $\\star\\star$"},{"location":"java/1101-1200/1131-1140/#1132-reported-posts-ii-starstar","text":"","title":"1132. Reported Posts II $\\star\\star$"},{"location":"java/1101-1200/1131-1140/#1133-largest-unique-number-star","text":"","title":"1133. Largest Unique Number $\\star$"},{"location":"java/1101-1200/1131-1140/#1134-armstrong-number-star","text":"","title":"1134. Armstrong Number $\\star$"},{"location":"java/1101-1200/1131-1140/#1135-connecting-cities-with-minimum-cost-starstar","text":"","title":"1135. Connecting Cities With Minimum Cost $\\star\\star$"},{"location":"java/1101-1200/1131-1140/#1136-parallel-courses-starstarstar","text":"","title":"1136. Parallel Courses $\\star\\star\\star$"},{"location":"java/1101-1200/1131-1140/#1137-n-th-tribonacci-number-star","text":"","title":"1137. N-th Tribonacci Number $\\star$"},{"location":"java/1101-1200/1131-1140/#1138-alphabet-board-path-starstar","text":"","title":"1138. Alphabet Board Path $\\star\\star$"},{"location":"java/1101-1200/1131-1140/#1139-largest-1-bordered-square-starstar","text":"","title":"1139. Largest 1-Bordered Square $\\star\\star$"},{"location":"java/1101-1200/1131-1140/#1140-stone-game-ii-starstar","text":"","title":"1140. Stone Game II $\\star\\star$"},{"location":"java/1101-1200/1141-1150/","text":"1141. User Activity for the Past 30 Days I $\\star$ 1142. User Activity for the Past 30 Days II $\\star$ 1143. Longest Common Subsequence $\\star\\star$ 1144. Decrease Elements To Make Array Zigzag $\\star\\star$ 1145. Binary Tree Coloring Game $\\star\\star$ 1146. Snapshot Array $\\star\\star$ 1147. Longest Chunked Palindrome Decomposition $\\star\\star\\star$ 1148. Article Views I $\\star$ 1149. Article Views II $\\star\\star$ 1150. Check If a Number Is Majority Element in a Sorted Array $\\star$","title":"1141-1150"},{"location":"java/1101-1200/1141-1150/#1141-user-activity-for-the-past-30-days-i-star","text":"","title":"1141. User Activity for the Past 30 Days I $\\star$"},{"location":"java/1101-1200/1141-1150/#1142-user-activity-for-the-past-30-days-ii-star","text":"","title":"1142. User Activity for the Past 30 Days II $\\star$"},{"location":"java/1101-1200/1141-1150/#1143-longest-common-subsequence-starstar","text":"","title":"1143. Longest Common Subsequence $\\star\\star$"},{"location":"java/1101-1200/1141-1150/#1144-decrease-elements-to-make-array-zigzag-starstar","text":"","title":"1144. Decrease Elements To Make Array Zigzag $\\star\\star$"},{"location":"java/1101-1200/1141-1150/#1145-binary-tree-coloring-game-starstar","text":"","title":"1145. Binary Tree Coloring Game $\\star\\star$"},{"location":"java/1101-1200/1141-1150/#1146-snapshot-array-starstar","text":"","title":"1146. Snapshot Array $\\star\\star$"},{"location":"java/1101-1200/1141-1150/#1147-longest-chunked-palindrome-decomposition-starstarstar","text":"","title":"1147. Longest Chunked Palindrome Decomposition $\\star\\star\\star$"},{"location":"java/1101-1200/1141-1150/#1148-article-views-i-star","text":"","title":"1148. Article Views I $\\star$"},{"location":"java/1101-1200/1141-1150/#1149-article-views-ii-starstar","text":"","title":"1149. Article Views II $\\star\\star$"},{"location":"java/1101-1200/1141-1150/#1150-check-if-a-number-is-majority-element-in-a-sorted-array-star","text":"","title":"1150. Check If a Number Is Majority Element in a Sorted Array $\\star$"},{"location":"java/1101-1200/1151-1160/","text":"1151. Minimum Swaps to Group All 1's Together $\\star\\star$ 1152. Analyze User Website Visit Pattern $\\star\\star$ 1153. String Transforms Into Another String $\\star\\star\\star$ 1154. Day of the Year $\\star$ 1155. Number of Dice Rolls With Target Sum $\\star\\star$ 1156. Swap For Longest Repeated Character Substring $\\star\\star$ 1157. Online Majority Element In Subarray $\\star\\star\\star$ 1158. Market Analysis I $\\star\\star$ 1159. Market Analysis II $\\star\\star\\star$ 1160. Find Words That Can Be Formed by Characters $\\star$","title":"1151-1160"},{"location":"java/1101-1200/1151-1160/#1151-minimum-swaps-to-group-all-1s-together-starstar","text":"","title":"1151. Minimum Swaps to Group All 1's Together $\\star\\star$"},{"location":"java/1101-1200/1151-1160/#1152-analyze-user-website-visit-pattern-starstar","text":"","title":"1152. Analyze User Website Visit Pattern $\\star\\star$"},{"location":"java/1101-1200/1151-1160/#1153-string-transforms-into-another-string-starstarstar","text":"","title":"1153. String Transforms Into Another String $\\star\\star\\star$"},{"location":"java/1101-1200/1151-1160/#1154-day-of-the-year-star","text":"","title":"1154. Day of the Year $\\star$"},{"location":"java/1101-1200/1151-1160/#1155-number-of-dice-rolls-with-target-sum-starstar","text":"","title":"1155. Number of Dice Rolls With Target Sum $\\star\\star$"},{"location":"java/1101-1200/1151-1160/#1156-swap-for-longest-repeated-character-substring-starstar","text":"","title":"1156. Swap For Longest Repeated Character Substring $\\star\\star$"},{"location":"java/1101-1200/1151-1160/#1157-online-majority-element-in-subarray-starstarstar","text":"","title":"1157. Online Majority Element In Subarray $\\star\\star\\star$"},{"location":"java/1101-1200/1151-1160/#1158-market-analysis-i-starstar","text":"","title":"1158. Market Analysis I $\\star\\star$"},{"location":"java/1101-1200/1151-1160/#1159-market-analysis-ii-starstarstar","text":"","title":"1159. Market Analysis II $\\star\\star\\star$"},{"location":"java/1101-1200/1151-1160/#1160-find-words-that-can-be-formed-by-characters-star","text":"","title":"1160. Find Words That Can Be Formed by Characters $\\star$"},{"location":"java/1101-1200/1161-1170/","text":"1161. Maximum Level Sum of a Binary Tree $\\star\\star$ 1162. As Far from Land as Possible $\\star\\star$ 1163. Last Substring in Lexicographical Order $\\star\\star\\star$ 1164. Product Price at a Given Date $\\star\\star$ 1165. Single-Row Keyboard $\\star$ 1166. Design File System $\\star\\star$ 1167. Minimum Cost to Connect Sticks $\\star\\star$ 1168. Optimize Water Distribution in a Village $\\star\\star\\star$ 1169. Invalid Transactions $\\star\\star$ 1170. Compare Strings by Frequency of the Smallest Character $\\star$","title":"1161-1170"},{"location":"java/1101-1200/1161-1170/#1161-maximum-level-sum-of-a-binary-tree-starstar","text":"","title":"1161. Maximum Level Sum of a Binary Tree $\\star\\star$"},{"location":"java/1101-1200/1161-1170/#1162-as-far-from-land-as-possible-starstar","text":"","title":"1162. As Far from Land as Possible $\\star\\star$"},{"location":"java/1101-1200/1161-1170/#1163-last-substring-in-lexicographical-order-starstarstar","text":"","title":"1163. Last Substring in Lexicographical Order $\\star\\star\\star$"},{"location":"java/1101-1200/1161-1170/#1164-product-price-at-a-given-date-starstar","text":"","title":"1164. Product Price at a Given Date $\\star\\star$"},{"location":"java/1101-1200/1161-1170/#1165-single-row-keyboard-star","text":"","title":"1165. Single-Row Keyboard $\\star$"},{"location":"java/1101-1200/1161-1170/#1166-design-file-system-starstar","text":"","title":"1166. Design File System $\\star\\star$"},{"location":"java/1101-1200/1161-1170/#1167-minimum-cost-to-connect-sticks-starstar","text":"","title":"1167. Minimum Cost to Connect Sticks $\\star\\star$"},{"location":"java/1101-1200/1161-1170/#1168-optimize-water-distribution-in-a-village-starstarstar","text":"","title":"1168. Optimize Water Distribution in a Village $\\star\\star\\star$"},{"location":"java/1101-1200/1161-1170/#1169-invalid-transactions-starstar","text":"","title":"1169. Invalid Transactions $\\star\\star$"},{"location":"java/1101-1200/1161-1170/#1170-compare-strings-by-frequency-of-the-smallest-character-star","text":"","title":"1170. Compare Strings by Frequency of the Smallest Character $\\star$"},{"location":"java/1101-1200/1171-1180/","text":"1171. Remove Zero Sum Consecutive Nodes from Linked List $\\star\\star$ 1172. Dinner Plate Stacks $\\star\\star\\star$ 1173. Immediate Food Delivery I $\\star$ 1174. Immediate Food Delivery II $\\star\\star$ 1175. Prime Arrangements $\\star$ 1176. Diet Plan Performance $\\star$ 1177. Can Make Palindrome from Substring $\\star\\star$ 1178. Number of Valid Words for Each Puzzle $\\star\\star\\star$ 1179. Reformat Department Table $\\star$ 1180. Count Substrings with Only One Distinct Letter $\\star$","title":"1171-1180"},{"location":"java/1101-1200/1171-1180/#1171-remove-zero-sum-consecutive-nodes-from-linked-list-starstar","text":"","title":"1171. Remove Zero Sum Consecutive Nodes from Linked List $\\star\\star$"},{"location":"java/1101-1200/1171-1180/#1172-dinner-plate-stacks-starstarstar","text":"","title":"1172. Dinner Plate Stacks $\\star\\star\\star$"},{"location":"java/1101-1200/1171-1180/#1173-immediate-food-delivery-i-star","text":"","title":"1173. Immediate Food Delivery I $\\star$"},{"location":"java/1101-1200/1171-1180/#1174-immediate-food-delivery-ii-starstar","text":"","title":"1174. Immediate Food Delivery II $\\star\\star$"},{"location":"java/1101-1200/1171-1180/#1175-prime-arrangements-star","text":"","title":"1175. Prime Arrangements $\\star$"},{"location":"java/1101-1200/1171-1180/#1176-diet-plan-performance-star","text":"","title":"1176. Diet Plan Performance $\\star$"},{"location":"java/1101-1200/1171-1180/#1177-can-make-palindrome-from-substring-starstar","text":"","title":"1177. Can Make Palindrome from Substring $\\star\\star$"},{"location":"java/1101-1200/1171-1180/#1178-number-of-valid-words-for-each-puzzle-starstarstar","text":"","title":"1178. Number of Valid Words for Each Puzzle $\\star\\star\\star$"},{"location":"java/1101-1200/1171-1180/#1179-reformat-department-table-star","text":"","title":"1179. Reformat Department Table $\\star$"},{"location":"java/1101-1200/1171-1180/#1180-count-substrings-with-only-one-distinct-letter-star","text":"","title":"1180. Count Substrings with Only One Distinct Letter $\\star$"},{"location":"java/1101-1200/1181-1190/","text":"1181. Before and After Puzzle $\\star\\star$ 1182. Shortest Distance to Target Color $\\star\\star$ 1183. Maximum Number of Ones $\\star\\star\\star$ 1184. Distance Between Bus Stops $\\star$ 1185. Day of the Week $\\star$ 1186. Maximum Subarray Sum with One Deletion $\\star\\star$ 1187. Make Array Strictly Increasing $\\star\\star\\star$ 1188. Design Bounded Blocking Queue $\\star\\star$ 1189. Maximum Number of Balloons $\\star$ 1190. Reverse Substrings Between Each Pair of Parentheses $\\star\\star$","title":"1181-1190"},{"location":"java/1101-1200/1181-1190/#1181-before-and-after-puzzle-starstar","text":"","title":"1181. Before and After Puzzle $\\star\\star$"},{"location":"java/1101-1200/1181-1190/#1182-shortest-distance-to-target-color-starstar","text":"","title":"1182. Shortest Distance to Target Color $\\star\\star$"},{"location":"java/1101-1200/1181-1190/#1183-maximum-number-of-ones-starstarstar","text":"","title":"1183. Maximum Number of Ones $\\star\\star\\star$"},{"location":"java/1101-1200/1181-1190/#1184-distance-between-bus-stops-star","text":"","title":"1184. Distance Between Bus Stops $\\star$"},{"location":"java/1101-1200/1181-1190/#1185-day-of-the-week-star","text":"","title":"1185. Day of the Week $\\star$"},{"location":"java/1101-1200/1181-1190/#1186-maximum-subarray-sum-with-one-deletion-starstar","text":"","title":"1186. Maximum Subarray Sum with One Deletion $\\star\\star$"},{"location":"java/1101-1200/1181-1190/#1187-make-array-strictly-increasing-starstarstar","text":"","title":"1187. Make Array Strictly Increasing $\\star\\star\\star$"},{"location":"java/1101-1200/1181-1190/#1188-design-bounded-blocking-queue-starstar","text":"","title":"1188. Design Bounded Blocking Queue $\\star\\star$"},{"location":"java/1101-1200/1181-1190/#1189-maximum-number-of-balloons-star","text":"","title":"1189. Maximum Number of Balloons $\\star$"},{"location":"java/1101-1200/1181-1190/#1190-reverse-substrings-between-each-pair-of-parentheses-starstar","text":"","title":"1190. Reverse Substrings Between Each Pair of Parentheses $\\star\\star$"},{"location":"java/1101-1200/1191-1200/","text":"1191. K-Concatenation Maximum Sum $\\star\\star$ 1192. Critical Connections in a Network $\\star\\star\\star$ 1193. Monthly Transactions I $\\star\\star$ 1194. Tournament Winners $\\star\\star\\star$ 1195. Fizz Buzz Multithreaded $\\star\\star$ 1196. How Many Apples Can You Put into the Basket $\\star$ 1197. Minimum Knight Moves $\\star\\star$ 1198. Find Smallest Common Element in All Rows $\\star\\star$ 1199. Minimum Time to Build Blocks $\\star\\star\\star$ 1200. Minimum Absolute Difference $\\star$","title":"1191-1200"},{"location":"java/1101-1200/1191-1200/#1191-k-concatenation-maximum-sum-starstar","text":"","title":"1191. K-Concatenation Maximum Sum $\\star\\star$"},{"location":"java/1101-1200/1191-1200/#1192-critical-connections-in-a-network-starstarstar","text":"","title":"1192. Critical Connections in a Network $\\star\\star\\star$"},{"location":"java/1101-1200/1191-1200/#1193-monthly-transactions-i-starstar","text":"","title":"1193. Monthly Transactions I $\\star\\star$"},{"location":"java/1101-1200/1191-1200/#1194-tournament-winners-starstarstar","text":"","title":"1194. Tournament Winners $\\star\\star\\star$"},{"location":"java/1101-1200/1191-1200/#1195-fizz-buzz-multithreaded-starstar","text":"","title":"1195. Fizz Buzz Multithreaded $\\star\\star$"},{"location":"java/1101-1200/1191-1200/#1196-how-many-apples-can-you-put-into-the-basket-star","text":"","title":"1196. How Many Apples Can You Put into the Basket $\\star$"},{"location":"java/1101-1200/1191-1200/#1197-minimum-knight-moves-starstar","text":"","title":"1197. Minimum Knight Moves $\\star\\star$"},{"location":"java/1101-1200/1191-1200/#1198-find-smallest-common-element-in-all-rows-starstar","text":"","title":"1198. Find Smallest Common Element in All Rows $\\star\\star$"},{"location":"java/1101-1200/1191-1200/#1199-minimum-time-to-build-blocks-starstarstar","text":"","title":"1199. Minimum Time to Build Blocks $\\star\\star\\star$"},{"location":"java/1101-1200/1191-1200/#1200-minimum-absolute-difference-star","text":"","title":"1200. Minimum Absolute Difference $\\star$"},{"location":"java/1201-1300/1201-1210/","text":"1201. Ugly Number III $\\star\\star$ 1202. Smallest String With Swaps $\\star\\star$ 1203. Sort Items by Groups Respecting Dependencies $\\star\\star\\star$ 1204. Last Person to Fit in the Elevator $\\star\\star$ 1205. Monthly Transactions II $\\star\\star$ 1206. Design Skiplist $\\star\\star\\star$ 1207. Unique Number of Occurrences $\\star$ 1208. Get Equal Substrings Within Budget $\\star\\star$ 1209. Remove All Adjacent Duplicates in String II $\\star\\star$ 1210. Minimum Moves to Reach Target with Rotations $\\star\\star\\star$","title":"1201-1210"},{"location":"java/1201-1300/1201-1210/#1201-ugly-number-iii-starstar","text":"","title":"1201. Ugly Number III $\\star\\star$"},{"location":"java/1201-1300/1201-1210/#1202-smallest-string-with-swaps-starstar","text":"","title":"1202. Smallest String With Swaps $\\star\\star$"},{"location":"java/1201-1300/1201-1210/#1203-sort-items-by-groups-respecting-dependencies-starstarstar","text":"","title":"1203. Sort Items by Groups Respecting Dependencies $\\star\\star\\star$"},{"location":"java/1201-1300/1201-1210/#1204-last-person-to-fit-in-the-elevator-starstar","text":"","title":"1204. Last Person to Fit in the Elevator $\\star\\star$"},{"location":"java/1201-1300/1201-1210/#1205-monthly-transactions-ii-starstar","text":"","title":"1205. Monthly Transactions II $\\star\\star$"},{"location":"java/1201-1300/1201-1210/#1206-design-skiplist-starstarstar","text":"","title":"1206. Design Skiplist $\\star\\star\\star$"},{"location":"java/1201-1300/1201-1210/#1207-unique-number-of-occurrences-star","text":"","title":"1207. Unique Number of Occurrences $\\star$"},{"location":"java/1201-1300/1201-1210/#1208-get-equal-substrings-within-budget-starstar","text":"","title":"1208. Get Equal Substrings Within Budget $\\star\\star$"},{"location":"java/1201-1300/1201-1210/#1209-remove-all-adjacent-duplicates-in-string-ii-starstar","text":"","title":"1209. Remove All Adjacent Duplicates in String II $\\star\\star$"},{"location":"java/1201-1300/1201-1210/#1210-minimum-moves-to-reach-target-with-rotations-starstarstar","text":"","title":"1210. Minimum Moves to Reach Target with Rotations $\\star\\star\\star$"},{"location":"java/1201-1300/1211-1220/","text":"1211. Queries Quality and Percentage $\\star$ 1212. Team Scores in Football Tournament $\\star\\star$ 1213. Intersection of Three Sorted Arrays $\\star$ 1214. Two Sum BSTs $\\star\\star$ 1215. Stepping Numbers $\\star\\star$ 1216. Valid Palindrome III $\\star\\star\\star$ 1217. Play with Chips $\\star$ 1218. Longest Arithmetic Subsequence of Given Difference $\\star\\star$ 1219. Path with Maximum Gold $\\star\\star$ 1220. Count Vowels Permutation $\\star\\star\\star$","title":"1211-1220"},{"location":"java/1201-1300/1211-1220/#1211-queries-quality-and-percentage-star","text":"","title":"1211. Queries Quality and Percentage $\\star$"},{"location":"java/1201-1300/1211-1220/#1212-team-scores-in-football-tournament-starstar","text":"","title":"1212. Team Scores in Football Tournament $\\star\\star$"},{"location":"java/1201-1300/1211-1220/#1213-intersection-of-three-sorted-arrays-star","text":"","title":"1213. Intersection of Three Sorted Arrays $\\star$"},{"location":"java/1201-1300/1211-1220/#1214-two-sum-bsts-starstar","text":"","title":"1214. Two Sum BSTs $\\star\\star$"},{"location":"java/1201-1300/1211-1220/#1215-stepping-numbers-starstar","text":"","title":"1215. Stepping Numbers $\\star\\star$"},{"location":"java/1201-1300/1211-1220/#1216-valid-palindrome-iii-starstarstar","text":"","title":"1216. Valid Palindrome III $\\star\\star\\star$"},{"location":"java/1201-1300/1211-1220/#1217-play-with-chips-star","text":"","title":"1217. Play with Chips $\\star$"},{"location":"java/1201-1300/1211-1220/#1218-longest-arithmetic-subsequence-of-given-difference-starstar","text":"","title":"1218. Longest Arithmetic Subsequence of Given Difference $\\star\\star$"},{"location":"java/1201-1300/1211-1220/#1219-path-with-maximum-gold-starstar","text":"","title":"1219. Path with Maximum Gold $\\star\\star$"},{"location":"java/1201-1300/1211-1220/#1220-count-vowels-permutation-starstarstar","text":"","title":"1220. Count Vowels Permutation $\\star\\star\\star$"},{"location":"java/1201-1300/1221-1230/","text":"1221. Split a String in Balanced Strings $\\star$ 1222. Queens That Can Attack the King $\\star\\star$ 1223. Dice Roll Simulation $\\star\\star$ 1224. Maximum Equal Frequency $\\star\\star\\star$ 1225. Report Contiguous Dates $\\star\\star\\star$ 1226. The Dining Philosophers $\\star\\star$ 1227. Airplane Seat Assignment Probability $\\star\\star$ 1228. Missing Number In Arithmetic Progression $\\star$ 1229. Meeting Scheduler $\\star\\star$ 1230. Toss Strange Coins $\\star\\star$","title":"1221-1230"},{"location":"java/1201-1300/1221-1230/#1221-split-a-string-in-balanced-strings-star","text":"","title":"1221. Split a String in Balanced Strings $\\star$"},{"location":"java/1201-1300/1221-1230/#1222-queens-that-can-attack-the-king-starstar","text":"","title":"1222. Queens That Can Attack the King $\\star\\star$"},{"location":"java/1201-1300/1221-1230/#1223-dice-roll-simulation-starstar","text":"","title":"1223. Dice Roll Simulation $\\star\\star$"},{"location":"java/1201-1300/1221-1230/#1224-maximum-equal-frequency-starstarstar","text":"","title":"1224. Maximum Equal Frequency $\\star\\star\\star$"},{"location":"java/1201-1300/1221-1230/#1225-report-contiguous-dates-starstarstar","text":"","title":"1225. Report Contiguous Dates $\\star\\star\\star$"},{"location":"java/1201-1300/1221-1230/#1226-the-dining-philosophers-starstar","text":"","title":"1226. The Dining Philosophers $\\star\\star$"},{"location":"java/1201-1300/1221-1230/#1227-airplane-seat-assignment-probability-starstar","text":"","title":"1227. Airplane Seat Assignment Probability $\\star\\star$"},{"location":"java/1201-1300/1221-1230/#1228-missing-number-in-arithmetic-progression-star","text":"","title":"1228. Missing Number In Arithmetic Progression $\\star$"},{"location":"java/1201-1300/1221-1230/#1229-meeting-scheduler-starstar","text":"","title":"1229. Meeting Scheduler $\\star\\star$"},{"location":"java/1201-1300/1221-1230/#1230-toss-strange-coins-starstar","text":"","title":"1230. Toss Strange Coins $\\star\\star$"},{"location":"java/1201-1300/1231-1240/","text":"1231. Divide Chocolate $\\star\\star\\star$ 1232. Check If It Is a Straight Line $\\star$ 1233. Remove Sub-Folders from the Filesystem $\\star\\star$ 1234. Replace the Substring for Balanced String $\\star\\star$ 1235. Maximum Profit in Job Scheduling $\\star\\star\\star$ 1236. Web Crawler $\\star\\star$ 1237. Find Positive Integer Solution for a Given Equation $\\star$ 1238. Circular Permutation in Binary Representation $\\star\\star$ 1239. Maximum Length of a Concatenated String with Unique Characters $\\star\\star$ 1240. Tiling a Rectangle with the Fewest Squares $\\star\\star\\star$","title":"1231-1240"},{"location":"java/1201-1300/1231-1240/#1231-divide-chocolate-starstarstar","text":"","title":"1231. Divide Chocolate $\\star\\star\\star$"},{"location":"java/1201-1300/1231-1240/#1232-check-if-it-is-a-straight-line-star","text":"","title":"1232. Check If It Is a Straight Line $\\star$"},{"location":"java/1201-1300/1231-1240/#1233-remove-sub-folders-from-the-filesystem-starstar","text":"","title":"1233. Remove Sub-Folders from the Filesystem $\\star\\star$"},{"location":"java/1201-1300/1231-1240/#1234-replace-the-substring-for-balanced-string-starstar","text":"","title":"1234. Replace the Substring for Balanced String $\\star\\star$"},{"location":"java/1201-1300/1231-1240/#1235-maximum-profit-in-job-scheduling-starstarstar","text":"","title":"1235. Maximum Profit in Job Scheduling $\\star\\star\\star$"},{"location":"java/1201-1300/1231-1240/#1236-web-crawler-starstar","text":"","title":"1236. Web Crawler $\\star\\star$"},{"location":"java/1201-1300/1231-1240/#1237-find-positive-integer-solution-for-a-given-equation-star","text":"","title":"1237. Find Positive Integer Solution for a Given Equation $\\star$"},{"location":"java/1201-1300/1231-1240/#1238-circular-permutation-in-binary-representation-starstar","text":"","title":"1238. Circular Permutation in Binary Representation $\\star\\star$"},{"location":"java/1201-1300/1231-1240/#1239-maximum-length-of-a-concatenated-string-with-unique-characters-starstar","text":"","title":"1239. Maximum Length of a Concatenated String with Unique Characters $\\star\\star$"},{"location":"java/1201-1300/1231-1240/#1240-tiling-a-rectangle-with-the-fewest-squares-starstarstar","text":"","title":"1240. Tiling a Rectangle with the Fewest Squares $\\star\\star\\star$"},{"location":"java/1201-1300/1241-1250/","text":"1241. Number of Comments per Post $\\star$ 1242. Web Crawler Multithreaded $\\star\\star$ 1243. Array Transformation $\\star$ 1244. Design A Leaderboard $\\star\\star$ 1245. Tree Diameter $\\star\\star$ 1246. Palindrome Removal $\\star\\star\\star$ 1247. Minimum Swaps to Make Strings Equal $\\star\\star$ 1248. Count Number of Nice Subarrays $\\star\\star$ 1249. Minimum Remove to Make Valid Parentheses $\\star\\star$ 1250. Check If It Is a Good Array $\\star\\star\\star$","title":"1241-1250"},{"location":"java/1201-1300/1241-1250/#1241-number-of-comments-per-post-star","text":"","title":"1241. Number of Comments per Post $\\star$"},{"location":"java/1201-1300/1241-1250/#1242-web-crawler-multithreaded-starstar","text":"","title":"1242. Web Crawler Multithreaded $\\star\\star$"},{"location":"java/1201-1300/1241-1250/#1243-array-transformation-star","text":"","title":"1243. Array Transformation $\\star$"},{"location":"java/1201-1300/1241-1250/#1244-design-a-leaderboard-starstar","text":"","title":"1244. Design A Leaderboard $\\star\\star$"},{"location":"java/1201-1300/1241-1250/#1245-tree-diameter-starstar","text":"","title":"1245. Tree Diameter $\\star\\star$"},{"location":"java/1201-1300/1241-1250/#1246-palindrome-removal-starstarstar","text":"","title":"1246. Palindrome Removal $\\star\\star\\star$"},{"location":"java/1201-1300/1241-1250/#1247-minimum-swaps-to-make-strings-equal-starstar","text":"","title":"1247. Minimum Swaps to Make Strings Equal $\\star\\star$"},{"location":"java/1201-1300/1241-1250/#1248-count-number-of-nice-subarrays-starstar","text":"","title":"1248. Count Number of Nice Subarrays $\\star\\star$"},{"location":"java/1201-1300/1241-1250/#1249-minimum-remove-to-make-valid-parentheses-starstar","text":"","title":"1249. Minimum Remove to Make Valid Parentheses $\\star\\star$"},{"location":"java/1201-1300/1241-1250/#1250-check-if-it-is-a-good-array-starstarstar","text":"","title":"1250. Check If It Is a Good Array $\\star\\star\\star$"},{"location":"java/1201-1300/1251-1260/","text":"1251. Average Selling Price $\\star$ 1252. Cells with Odd Values in a Matrix $\\star$ 1253. Reconstruct a 2-Row Binary Matrix $\\star\\star$ 1254. Number of Closed Islands $\\star\\star$ 1255. Maximum Score Words Formed by Letters $\\star\\star\\star$ 1256. Encode Number $\\star\\star$ 1257. Smallest Common Region $\\star\\star$ 1258. Synonymous Sentences $\\star\\star$ 1259. Handshakes That Don't Cross $\\star\\star\\star$ 1260. Shift 2D Grid $\\star$","title":"1251-1260"},{"location":"java/1201-1300/1251-1260/#1251-average-selling-price-star","text":"","title":"1251. Average Selling Price $\\star$"},{"location":"java/1201-1300/1251-1260/#1252-cells-with-odd-values-in-a-matrix-star","text":"","title":"1252. Cells with Odd Values in a Matrix $\\star$"},{"location":"java/1201-1300/1251-1260/#1253-reconstruct-a-2-row-binary-matrix-starstar","text":"","title":"1253. Reconstruct a 2-Row Binary Matrix $\\star\\star$"},{"location":"java/1201-1300/1251-1260/#1254-number-of-closed-islands-starstar","text":"","title":"1254. Number of Closed Islands $\\star\\star$"},{"location":"java/1201-1300/1251-1260/#1255-maximum-score-words-formed-by-letters-starstarstar","text":"","title":"1255. Maximum Score Words Formed by Letters $\\star\\star\\star$"},{"location":"java/1201-1300/1251-1260/#1256-encode-number-starstar","text":"","title":"1256. Encode Number $\\star\\star$"},{"location":"java/1201-1300/1251-1260/#1257-smallest-common-region-starstar","text":"","title":"1257. Smallest Common Region $\\star\\star$"},{"location":"java/1201-1300/1251-1260/#1258-synonymous-sentences-starstar","text":"","title":"1258. Synonymous Sentences $\\star\\star$"},{"location":"java/1201-1300/1251-1260/#1259-handshakes-that-dont-cross-starstarstar","text":"","title":"1259. Handshakes That Don't Cross $\\star\\star\\star$"},{"location":"java/1201-1300/1251-1260/#1260-shift-2d-grid-star","text":"","title":"1260. Shift 2D Grid $\\star$"},{"location":"java/1201-1300/1261-1270/","text":"1261. Find Elements in a Contaminated Binary Tree $\\star\\star$ 1262. Greatest Sum Divisible by Three $\\star\\star$ 1263. Minimum Moves to Move a Box to Their Target Location $\\star\\star\\star$ 1264. Page Recommendations $\\star\\star$ 1265. Print Immutable Linked List in Reverse $\\star\\star$ 1266. Minimum Time Visiting All Points $\\star$ 1267. Count Servers that Communicate $\\star\\star$ 1268. Search Suggestions System $\\star\\star$ 1269. Number of Ways to Stay in the Same Place After Some Steps $\\star\\star\\star$ 1270. All People Report to the Given Manager $\\star\\star$","title":"1261-1270"},{"location":"java/1201-1300/1261-1270/#1261-find-elements-in-a-contaminated-binary-tree-starstar","text":"","title":"1261. Find Elements in a Contaminated Binary Tree $\\star\\star$"},{"location":"java/1201-1300/1261-1270/#1262-greatest-sum-divisible-by-three-starstar","text":"","title":"1262. Greatest Sum Divisible by Three $\\star\\star$"},{"location":"java/1201-1300/1261-1270/#1263-minimum-moves-to-move-a-box-to-their-target-location-starstarstar","text":"","title":"1263. Minimum Moves to Move a Box to Their Target Location $\\star\\star\\star$"},{"location":"java/1201-1300/1261-1270/#1264-page-recommendations-starstar","text":"","title":"1264. Page Recommendations $\\star\\star$"},{"location":"java/1201-1300/1261-1270/#1265-print-immutable-linked-list-in-reverse-starstar","text":"","title":"1265. Print Immutable Linked List in Reverse $\\star\\star$"},{"location":"java/1201-1300/1261-1270/#1266-minimum-time-visiting-all-points-star","text":"","title":"1266. Minimum Time Visiting All Points $\\star$"},{"location":"java/1201-1300/1261-1270/#1267-count-servers-that-communicate-starstar","text":"","title":"1267. Count Servers that Communicate $\\star\\star$"},{"location":"java/1201-1300/1261-1270/#1268-search-suggestions-system-starstar","text":"","title":"1268. Search Suggestions System $\\star\\star$"},{"location":"java/1201-1300/1261-1270/#1269-number-of-ways-to-stay-in-the-same-place-after-some-steps-starstarstar","text":"","title":"1269. Number of Ways to Stay in the Same Place After Some Steps $\\star\\star\\star$"},{"location":"java/1201-1300/1261-1270/#1270-all-people-report-to-the-given-manager-starstar","text":"","title":"1270. All People Report to the Given Manager $\\star\\star$"},{"location":"java/1201-1300/1271-1280/","text":"1271. Hexspeak $\\star$ 1272. Remove Interval $\\star\\star$ 1273. Delete Tree Nodes $\\star\\star$ 1274. Number of Ships in a Rectangle $\\star\\star\\star$ 1275. Find Winner on a Tic Tac Toe Game $\\star$ 1276. Number of Burgers with No Waste of Ingredients $\\star\\star$ 1277. Count Square Submatrices with All Ones $\\star\\star$ 1278. Palindrome Partitioning III $\\star\\star\\star$ 1279. Traffic Light Controlled Intersection $\\star$ 1280. Students and Examinations $\\star$","title":"1271-1280"},{"location":"java/1201-1300/1271-1280/#1271-hexspeak-star","text":"","title":"1271. Hexspeak $\\star$"},{"location":"java/1201-1300/1271-1280/#1272-remove-interval-starstar","text":"","title":"1272. Remove Interval $\\star\\star$"},{"location":"java/1201-1300/1271-1280/#1273-delete-tree-nodes-starstar","text":"","title":"1273. Delete Tree Nodes $\\star\\star$"},{"location":"java/1201-1300/1271-1280/#1274-number-of-ships-in-a-rectangle-starstarstar","text":"","title":"1274. Number of Ships in a Rectangle $\\star\\star\\star$"},{"location":"java/1201-1300/1271-1280/#1275-find-winner-on-a-tic-tac-toe-game-star","text":"","title":"1275. Find Winner on a Tic Tac Toe Game $\\star$"},{"location":"java/1201-1300/1271-1280/#1276-number-of-burgers-with-no-waste-of-ingredients-starstar","text":"","title":"1276. Number of Burgers with No Waste of Ingredients $\\star\\star$"},{"location":"java/1201-1300/1271-1280/#1277-count-square-submatrices-with-all-ones-starstar","text":"","title":"1277. Count Square Submatrices with All Ones $\\star\\star$"},{"location":"java/1201-1300/1271-1280/#1278-palindrome-partitioning-iii-starstarstar","text":"","title":"1278. Palindrome Partitioning III $\\star\\star\\star$"},{"location":"java/1201-1300/1271-1280/#1279-traffic-light-controlled-intersection-star","text":"","title":"1279. Traffic Light Controlled Intersection $\\star$"},{"location":"java/1201-1300/1271-1280/#1280-students-and-examinations-star","text":"","title":"1280. Students and Examinations $\\star$"},{"location":"java/1201-1300/1281-1290/","text":"1281. Subtract the Product and Sum of Digits of an Integer $\\star$ 1282. Group the People Given the Group Size They Belong To $\\star\\star$ 1283. Find the Smallest Divisor Given a Threshold $\\star\\star$ 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix $\\star\\star\\star$ 1285. Find the Start and End Number of Continuous Ranges $\\star\\star$ 1286. Iterator for Combination $\\star\\star$ 1287. Element Appearing More Than 25% In Sorted Array $\\star$ 1288. Remove Covered Intervals $\\star\\star$ 1289. Minimum Falling Path Sum II $\\star\\star\\star$ 1290. Convert Binary Number in a Linked List to Integer $\\star$","title":"1281-1290"},{"location":"java/1201-1300/1281-1290/#1281-subtract-the-product-and-sum-of-digits-of-an-integer-star","text":"","title":"1281. Subtract the Product and Sum of Digits of an Integer $\\star$"},{"location":"java/1201-1300/1281-1290/#1282-group-the-people-given-the-group-size-they-belong-to-starstar","text":"","title":"1282. Group the People Given the Group Size They Belong To $\\star\\star$"},{"location":"java/1201-1300/1281-1290/#1283-find-the-smallest-divisor-given-a-threshold-starstar","text":"","title":"1283. Find the Smallest Divisor Given a Threshold $\\star\\star$"},{"location":"java/1201-1300/1281-1290/#1284-minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix-starstarstar","text":"","title":"1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix $\\star\\star\\star$"},{"location":"java/1201-1300/1281-1290/#1285-find-the-start-and-end-number-of-continuous-ranges-starstar","text":"","title":"1285. Find the Start and End Number of Continuous Ranges $\\star\\star$"},{"location":"java/1201-1300/1281-1290/#1286-iterator-for-combination-starstar","text":"","title":"1286. Iterator for Combination $\\star\\star$"},{"location":"java/1201-1300/1281-1290/#1287-element-appearing-more-than-25-in-sorted-array-star","text":"","title":"1287. Element Appearing More Than 25% In Sorted Array $\\star$"},{"location":"java/1201-1300/1281-1290/#1288-remove-covered-intervals-starstar","text":"","title":"1288. Remove Covered Intervals $\\star\\star$"},{"location":"java/1201-1300/1281-1290/#1289-minimum-falling-path-sum-ii-starstarstar","text":"","title":"1289. Minimum Falling Path Sum II $\\star\\star\\star$"},{"location":"java/1201-1300/1281-1290/#1290-convert-binary-number-in-a-linked-list-to-integer-star","text":"","title":"1290. Convert Binary Number in a Linked List to Integer $\\star$"},{"location":"java/1201-1300/1291-1300/","text":"1291. Sequential Digits $\\star\\star$ 1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold $\\star\\star$ 1293. Shortest Path in a Grid with Obstacles Elimination $\\star\\star\\star$ 1294. Weather Type in Each Country $\\star$ 1295. Find Numbers with Even Number of Digits $\\star$ 1296. Divide Array in Sets of K Consecutive Numbers $\\star\\star$ 1297. Maximum Number of Occurrences of a Substring $\\star\\star$ 1298. Maximum Candies You Can Get from Boxes $\\star\\star\\star$ 1299. Replace Elements with Greatest Element on Right Side $\\star$ 1300. Sum of Mutated Array Closest to Target $\\star\\star$","title":"1291-1300"},{"location":"java/1201-1300/1291-1300/#1291-sequential-digits-starstar","text":"","title":"1291. Sequential Digits $\\star\\star$"},{"location":"java/1201-1300/1291-1300/#1292-maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold-starstar","text":"","title":"1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold $\\star\\star$"},{"location":"java/1201-1300/1291-1300/#1293-shortest-path-in-a-grid-with-obstacles-elimination-starstarstar","text":"","title":"1293. Shortest Path in a Grid with Obstacles Elimination $\\star\\star\\star$"},{"location":"java/1201-1300/1291-1300/#1294-weather-type-in-each-country-star","text":"","title":"1294. Weather Type in Each Country $\\star$"},{"location":"java/1201-1300/1291-1300/#1295-find-numbers-with-even-number-of-digits-star","text":"","title":"1295. Find Numbers with Even Number of Digits $\\star$"},{"location":"java/1201-1300/1291-1300/#1296-divide-array-in-sets-of-k-consecutive-numbers-starstar","text":"","title":"1296. Divide Array in Sets of K Consecutive Numbers $\\star\\star$"},{"location":"java/1201-1300/1291-1300/#1297-maximum-number-of-occurrences-of-a-substring-starstar","text":"","title":"1297. Maximum Number of Occurrences of a Substring $\\star\\star$"},{"location":"java/1201-1300/1291-1300/#1298-maximum-candies-you-can-get-from-boxes-starstarstar","text":"","title":"1298. Maximum Candies You Can Get from Boxes $\\star\\star\\star$"},{"location":"java/1201-1300/1291-1300/#1299-replace-elements-with-greatest-element-on-right-side-star","text":"","title":"1299. Replace Elements with Greatest Element on Right Side $\\star$"},{"location":"java/1201-1300/1291-1300/#1300-sum-of-mutated-array-closest-to-target-starstar","text":"","title":"1300. Sum of Mutated Array Closest to Target $\\star\\star$"},{"location":"java/1301-1400/1301-1310/","text":"1301. Number of Paths with Max Score $\\star\\star\\star$ 1302. Deepest Leaves Sum $\\star\\star$ 1303. Find the Team Size $\\star$ 1304. Find N Unique Integers Sum up to Zero $\\star$ 1305. All Elements in Two Binary Search Trees $\\star\\star$ 1306. Jump Game III $\\star\\star$ 1307. Verbal Arithmetic Puzzle $\\star\\star\\star$ 1308. Running Total for Different Genders $\\star\\star$ 1309. Decrypt String from Alphabet to Integer Mapping $\\star$ 1310. XOR Queries of a Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int [] xorQueries ( int [] arr , int [][] queries ) { int [] ans = new int [ queries . length ]; int [] xors = new int [ arr . length + 1 ]; for ( int i = 0 ; i < arr . length ; i ++) xors [ i + 1 ] ^= xors [ i ] ^ arr [ i ]; int i = 0 ; for ( int [] query : queries ) ans [ i ++] = xors [ query [ 0 ]] ^ xors [ query [ 1 ] + 1 ]; return ans ; } }","title":"1301-1310"},{"location":"java/1301-1400/1301-1310/#1301-number-of-paths-with-max-score-starstarstar","text":"","title":"1301. Number of Paths with Max Score $\\star\\star\\star$"},{"location":"java/1301-1400/1301-1310/#1302-deepest-leaves-sum-starstar","text":"","title":"1302. Deepest Leaves Sum $\\star\\star$"},{"location":"java/1301-1400/1301-1310/#1303-find-the-team-size-star","text":"","title":"1303. Find the Team Size $\\star$"},{"location":"java/1301-1400/1301-1310/#1304-find-n-unique-integers-sum-up-to-zero-star","text":"","title":"1304. Find N Unique Integers Sum up to Zero $\\star$"},{"location":"java/1301-1400/1301-1310/#1305-all-elements-in-two-binary-search-trees-starstar","text":"","title":"1305. All Elements in Two Binary Search Trees $\\star\\star$"},{"location":"java/1301-1400/1301-1310/#1306-jump-game-iii-starstar","text":"","title":"1306. Jump Game III $\\star\\star$"},{"location":"java/1301-1400/1301-1310/#1307-verbal-arithmetic-puzzle-starstarstar","text":"","title":"1307. Verbal Arithmetic Puzzle $\\star\\star\\star$"},{"location":"java/1301-1400/1301-1310/#1308-running-total-for-different-genders-starstar","text":"","title":"1308. Running Total for Different Genders $\\star\\star$"},{"location":"java/1301-1400/1301-1310/#1309-decrypt-string-from-alphabet-to-integer-mapping-star","text":"","title":"1309. Decrypt String from Alphabet to Integer Mapping $\\star$"},{"location":"java/1301-1400/1301-1310/#1310-xor-queries-of-a-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution { public int [] xorQueries ( int [] arr , int [][] queries ) { int [] ans = new int [ queries . length ]; int [] xors = new int [ arr . length + 1 ]; for ( int i = 0 ; i < arr . length ; i ++) xors [ i + 1 ] ^= xors [ i ] ^ arr [ i ]; int i = 0 ; for ( int [] query : queries ) ans [ i ++] = xors [ query [ 0 ]] ^ xors [ query [ 1 ] + 1 ]; return ans ; } }","title":"1310. XOR Queries of a Subarray $\\star\\star$"},{"location":"java/1301-1400/1311-1320/","text":"1311. Get Watched Videos by Your Friends $\\star\\star$ 1312. Minimum Insertion Steps to Make a String Palindrome $\\star\\star\\star$ 1313. Decompress Run-Length Encoded List $\\star$ 1314. Matrix Block Sum $\\star\\star$ 1315. Sum of Nodes with Even-Valued Grandparent $\\star\\star$ 1316. Distinct Echo Substrings $\\star\\star\\star$ 1317. Convert Integer to the Sum of Two No-Zero Integers $\\star$ 1318. Minimum Flips to Make a OR b Equal to c $\\star\\star$ 1319. Number of Operations to Make Network Connected $\\star\\star$ 1320. Minimum Distance to Type a Word Using Two Fingers $\\star\\star\\star$","title":"1311-1320"},{"location":"java/1301-1400/1311-1320/#1311-get-watched-videos-by-your-friends-starstar","text":"","title":"1311. Get Watched Videos by Your Friends $\\star\\star$"},{"location":"java/1301-1400/1311-1320/#1312-minimum-insertion-steps-to-make-a-string-palindrome-starstarstar","text":"","title":"1312. Minimum Insertion Steps to Make a String Palindrome $\\star\\star\\star$"},{"location":"java/1301-1400/1311-1320/#1313-decompress-run-length-encoded-list-star","text":"","title":"1313. Decompress Run-Length Encoded List $\\star$"},{"location":"java/1301-1400/1311-1320/#1314-matrix-block-sum-starstar","text":"","title":"1314. Matrix Block Sum $\\star\\star$"},{"location":"java/1301-1400/1311-1320/#1315-sum-of-nodes-with-even-valued-grandparent-starstar","text":"","title":"1315. Sum of Nodes with Even-Valued Grandparent $\\star\\star$"},{"location":"java/1301-1400/1311-1320/#1316-distinct-echo-substrings-starstarstar","text":"","title":"1316. Distinct Echo Substrings $\\star\\star\\star$"},{"location":"java/1301-1400/1311-1320/#1317-convert-integer-to-the-sum-of-two-no-zero-integers-star","text":"","title":"1317. Convert Integer to the Sum of Two No-Zero Integers $\\star$"},{"location":"java/1301-1400/1311-1320/#1318-minimum-flips-to-make-a-or-b-equal-to-c-starstar","text":"","title":"1318. Minimum Flips to Make a OR b Equal to c $\\star\\star$"},{"location":"java/1301-1400/1311-1320/#1319-number-of-operations-to-make-network-connected-starstar","text":"","title":"1319. Number of Operations to Make Network Connected $\\star\\star$"},{"location":"java/1301-1400/1311-1320/#1320-minimum-distance-to-type-a-word-using-two-fingers-starstarstar","text":"","title":"1320. Minimum Distance to Type a Word Using Two Fingers $\\star\\star\\star$"},{"location":"java/1301-1400/1321-1330/","text":"1321. Restaurant Growth $\\star\\star$ 1322. Ads Performance $\\star$","title":"1321-1321"},{"location":"java/1301-1400/1321-1330/#1321-restaurant-growth-starstar","text":"","title":"1321. Restaurant Growth $\\star\\star$"},{"location":"java/1301-1400/1321-1330/#1322-ads-performance-star","text":"","title":"1322. Ads Performance $\\star$"},{"location":"python3/","text":"LeetCode in Python","title":"Preface"},{"location":"python3/#leetcode-in-python","text":"","title":"LeetCode in Python"},{"location":"python3/0001-0100/0001-0010/","text":"1. Two Sum $\\star$ 1 2 3 4 5 6 7 8 class Solution : def twoSum ( self , nums : List [ int ], target : int ) -> List [ int ]: dict = {} for i , num in enumerate ( nums ): if num in dict : return dict [ num ], i dict [ target - num ] = i 2. Add Two Numbers $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def addTwoNumbers ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : dummy = ListNode ( 0 ) curr = dummy carry = 0 while carry or l1 or l2 : carry += ( l1 . val if l1 else 0 ) + ( l2 . val if l2 else 0 ) curr . next = ListNode ( carry % 10 ) curr = curr . next carry //= 10 if l1 : l1 = l1 . next if l2 : l2 = l2 . next return dummy . next 3. Longest Substring Without Repeating Characters $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def lengthOfLongestSubstring ( self , s : str ) -> int : ans = 0 dict = {} j = 0 for i in range ( len ( s )): c = s [ i ] if c in dict : j = max ( j , dict [ c ]) ans = max ( ans , i - j + 1 ) dict [ c ] = i + 1 return ans 4. Median of Two Sorted Arrays $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def findMedianSortedArrays ( self , nums1 : List [ int ], nums2 : List [ int ]) -> float : n1 = len ( nums1 ) n2 = len ( nums2 ) if n1 > n2 : return self . findMedianSortedArrays ( nums2 , nums1 ) l = 0 r = n1 while l <= r : partition1 = l + ( r - l ) // 2 partition2 = ( n1 + n2 + 1 ) // 2 - partition1 maxLeft1 = - 2 ** 31 if partition1 == 0 else nums1 [ partition1 - 1 ] maxLeft2 = - 2 ** 31 if partition2 == 0 else nums2 [ partition2 - 1 ] minRight1 = 2 ** 31 - 1 if partition1 == n1 else nums1 [ partition1 ] minRight2 = 2 ** 31 - 1 if partition2 == n2 else nums2 [ partition2 ] if maxLeft1 <= minRight2 and maxLeft2 <= minRight1 : return ( max ( maxLeft1 , maxLeft2 ) + min ( minRight1 , minRight2 )) * 0.5 if ( n1 + n2 ) % 2 == 0 else max ( maxLeft1 , maxLeft2 ) elif maxLeft1 > minRight2 : r = partition1 - 1 else : l = partition1 + 1 5. Longest Palindromic Substring $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def longestPalindrome ( self , s : str ) -> str : T = '$#' + '#' . join ( s ) + '#@' center = 1 right = 1 P = [ 0 ] * len ( T ) for i in range ( 1 , len ( T ) - 1 ): mirr = 2 * center - i if i < right : P [ i ] = min ( P [ mirr ], right - i ) while T [ i + P [ i ] + 1 ] == T [ i - P [ i ] - 1 ]: P [ i ] += 1 if i + P [ i ] > right : center = i right = i + P [ i ] max = 0 c = 0 for i in range ( len ( T )): if P [ i ] > max : max = P [ i ] c = i return T [ c - max + 1 : c + max ] . replace ( '#' , '' ) 6. ZigZag Conversion $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def convert ( self , s : str , numRows : int ) -> str : rows = [ '' ] * numRows k = 0 direction = ( numRows == 1 ) - 1 for c in s : rows [ k ] += c if k == 0 or k == numRows - 1 : direction *= - 1 k += direction return '' . join ( rows ) 7. Reverse Integer $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def reverse ( self , x : int ) -> int : ans = 0 sign = - 1 if x < 0 else 1 x *= sign while x : ans = ans * 10 + x % 10 x //= 10 if ans < - 2 ** 31 or ans > 2 ** 31 - 1 : return 0 return sign * ans 8. String to Integer (atoi) $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def myAtoi ( self , str : str ) -> int : ans = 0 str = str . strip () if not str : return 0 sign = - 1 if str [ 0 ] == '-' else 1 if str [ 0 ] in { '-' , '+' }: str = str [ 1 :] for c in str : if not c . isdigit (): break ans = ans * 10 + ord ( c ) - ord ( '0' ) return max ( - 2 ** 31 , min ( 2 ** 31 - 1 , sign * ans )) 9. Palindrome Number $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def isPalindrome ( self , x : int ) -> bool : if x < 0 : return False ans = 0 y = x while y : ans = ans * 10 + y % 10 y //= 10 return ans == x 10. Regular Expression Matching $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution : def isMatch ( self , s : str , p : str ) -> bool : if not p : return not s firstMatch = bool ( s ) and p [ 0 ] in { s [ 0 ], '.' } if len ( p ) >= 2 and p [ 1 ] == '*' : return ( self . isMatch ( s , p [ 2 :]) or firstMatch and self . isMatch ( s [ 1 :], p )) return firstMatch and self . isMatch ( s [ 1 :], p [ 1 :])","title":"0001-0010"},{"location":"python3/0001-0100/0001-0010/#1-two-sum-star","text":"1 2 3 4 5 6 7 8 class Solution : def twoSum ( self , nums : List [ int ], target : int ) -> List [ int ]: dict = {} for i , num in enumerate ( nums ): if num in dict : return dict [ num ], i dict [ target - num ] = i","title":"1. Two Sum $\\star$"},{"location":"python3/0001-0100/0001-0010/#2-add-two-numbers-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def addTwoNumbers ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : dummy = ListNode ( 0 ) curr = dummy carry = 0 while carry or l1 or l2 : carry += ( l1 . val if l1 else 0 ) + ( l2 . val if l2 else 0 ) curr . next = ListNode ( carry % 10 ) curr = curr . next carry //= 10 if l1 : l1 = l1 . next if l2 : l2 = l2 . next return dummy . next","title":"2. Add Two Numbers $\\star\\star$"},{"location":"python3/0001-0100/0001-0010/#3-longest-substring-without-repeating-characters-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def lengthOfLongestSubstring ( self , s : str ) -> int : ans = 0 dict = {} j = 0 for i in range ( len ( s )): c = s [ i ] if c in dict : j = max ( j , dict [ c ]) ans = max ( ans , i - j + 1 ) dict [ c ] = i + 1 return ans","title":"3. Longest Substring Without Repeating Characters $\\star\\star$"},{"location":"python3/0001-0100/0001-0010/#4-median-of-two-sorted-arrays-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def findMedianSortedArrays ( self , nums1 : List [ int ], nums2 : List [ int ]) -> float : n1 = len ( nums1 ) n2 = len ( nums2 ) if n1 > n2 : return self . findMedianSortedArrays ( nums2 , nums1 ) l = 0 r = n1 while l <= r : partition1 = l + ( r - l ) // 2 partition2 = ( n1 + n2 + 1 ) // 2 - partition1 maxLeft1 = - 2 ** 31 if partition1 == 0 else nums1 [ partition1 - 1 ] maxLeft2 = - 2 ** 31 if partition2 == 0 else nums2 [ partition2 - 1 ] minRight1 = 2 ** 31 - 1 if partition1 == n1 else nums1 [ partition1 ] minRight2 = 2 ** 31 - 1 if partition2 == n2 else nums2 [ partition2 ] if maxLeft1 <= minRight2 and maxLeft2 <= minRight1 : return ( max ( maxLeft1 , maxLeft2 ) + min ( minRight1 , minRight2 )) * 0.5 if ( n1 + n2 ) % 2 == 0 else max ( maxLeft1 , maxLeft2 ) elif maxLeft1 > minRight2 : r = partition1 - 1 else : l = partition1 + 1","title":"4. Median of Two Sorted Arrays $\\star\\star\\star$"},{"location":"python3/0001-0100/0001-0010/#5-longest-palindromic-substring-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def longestPalindrome ( self , s : str ) -> str : T = '$#' + '#' . join ( s ) + '#@' center = 1 right = 1 P = [ 0 ] * len ( T ) for i in range ( 1 , len ( T ) - 1 ): mirr = 2 * center - i if i < right : P [ i ] = min ( P [ mirr ], right - i ) while T [ i + P [ i ] + 1 ] == T [ i - P [ i ] - 1 ]: P [ i ] += 1 if i + P [ i ] > right : center = i right = i + P [ i ] max = 0 c = 0 for i in range ( len ( T )): if P [ i ] > max : max = P [ i ] c = i return T [ c - max + 1 : c + max ] . replace ( '#' , '' )","title":"5. Longest Palindromic Substring $\\star\\star$"},{"location":"python3/0001-0100/0001-0010/#6-zigzag-conversion-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def convert ( self , s : str , numRows : int ) -> str : rows = [ '' ] * numRows k = 0 direction = ( numRows == 1 ) - 1 for c in s : rows [ k ] += c if k == 0 or k == numRows - 1 : direction *= - 1 k += direction return '' . join ( rows )","title":"6. ZigZag Conversion $\\star\\star$"},{"location":"python3/0001-0100/0001-0010/#7-reverse-integer-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def reverse ( self , x : int ) -> int : ans = 0 sign = - 1 if x < 0 else 1 x *= sign while x : ans = ans * 10 + x % 10 x //= 10 if ans < - 2 ** 31 or ans > 2 ** 31 - 1 : return 0 return sign * ans","title":"7. Reverse Integer $\\star$"},{"location":"python3/0001-0100/0001-0010/#8-string-to-integer-atoi-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def myAtoi ( self , str : str ) -> int : ans = 0 str = str . strip () if not str : return 0 sign = - 1 if str [ 0 ] == '-' else 1 if str [ 0 ] in { '-' , '+' }: str = str [ 1 :] for c in str : if not c . isdigit (): break ans = ans * 10 + ord ( c ) - ord ( '0' ) return max ( - 2 ** 31 , min ( 2 ** 31 - 1 , sign * ans ))","title":"8. String to Integer (atoi) $\\star\\star$"},{"location":"python3/0001-0100/0001-0010/#9-palindrome-number-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def isPalindrome ( self , x : int ) -> bool : if x < 0 : return False ans = 0 y = x while y : ans = ans * 10 + y % 10 y //= 10 return ans == x","title":"9. Palindrome Number $\\star$"},{"location":"python3/0001-0100/0001-0010/#10-regular-expression-matching-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 class Solution : def isMatch ( self , s : str , p : str ) -> bool : if not p : return not s firstMatch = bool ( s ) and p [ 0 ] in { s [ 0 ], '.' } if len ( p ) >= 2 and p [ 1 ] == '*' : return ( self . isMatch ( s , p [ 2 :]) or firstMatch and self . isMatch ( s [ 1 :], p )) return firstMatch and self . isMatch ( s [ 1 :], p [ 1 :])","title":"10. Regular Expression Matching $\\star\\star\\star$"},{"location":"python3/0001-0100/0011-0020/","text":"11. Container With Most Water $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def maxArea ( self , height : List [ int ]) -> int : ans = 0 l = 0 r = len ( height ) - 1 while l < r : h = min ( height [ l ], height [ r ]) ans = max ( ans , ( r - l ) * h ) while height [ l ] <= h and l < r : l += 1 while height [ r ] <= h and l < r : r -= 1 return ans 12. Integer to Roman $\\star\\star$ 1 2 3 4 5 6 7 8 class Solution : def intToRoman ( self , num : int ) -> str : M = [ \"\" , \"M\" , \"MM\" , \"MMM\" ] C = [ \"\" , \"C\" , \"CC\" , \"CCC\" , \"CD\" , \"D\" , \"DC\" , \"DCC\" , \"DCCC\" , \"CM\" ] X = [ \"\" , \"X\" , \"XX\" , \"XXX\" , \"XL\" , \"L\" , \"LX\" , \"LXX\" , \"LXXX\" , \"XC\" ] I = [ \"\" , \"I\" , \"II\" , \"III\" , \"IV\" , \"V\" , \"VI\" , \"VII\" , \"VIII\" , \"IX\" ] return M [ num // 1000 ] + C [ num % 1000 // 100 ] + X [ num % 100 // 10 ] + I [ num % 10 ] 13. Roman to Integer $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def romanToInt ( self , s : str ) -> int : ans = 0 dict = { 'I' : 1 , 'V' : 5 , 'X' : 10 , 'L' : 50 , 'C' : 100 , 'D' : 500 , 'M' : 1000 } for i in range ( len ( s ) - 1 ): if dict [ s [ i ]] < dict [ s [ i + 1 ]]: ans -= dict [ s [ i ]] else : ans += dict [ s [ i ]] return ans + dict [ s [ - 1 ]] 14. Longest Common Prefix $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def longestCommonPrefix ( self , strs : List [ str ]) -> str : if len ( strs ) == 0 : return \"\" if len ( strs ) == 1 : return strs [ 0 ] ans = \"\" min_ = len ( strs [ 0 ]) isMatch = True for i in range ( 1 , len ( strs )): min_ = min ( min_ , len ( strs [ i ])) for i in range ( min_ ): c = strs [ 0 ][ i ] for j in range ( 1 , len ( strs )): if c != strs [ j ][ i ]: isMatch = False break if not isMatch : break ans += c return ans 15. 3Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def threeSum ( self , nums : List [ int ]) -> List [ List [ int ]]: ans = [] nums . sort () for i in range ( len ( nums ) - 2 ): if i > 0 and nums [ i ] == nums [ i - 1 ]: continue l = i + 1 r = len ( nums ) - 1 while l < r : sum = nums [ i ] + nums [ l ] + nums [ r ] if sum == 0 : ans . append (( nums [ i ], nums [ l ], nums [ r ])) l += 1 r -= 1 while nums [ l ] == nums [ l - 1 ] and l < r : l += 1 while nums [ r ] == nums [ r + 1 ] and l < r : r -= 1 elif sum < 0 : l += 1 else : r -= 1 return ans 16. 3Sum Closest $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def threeSumClosest ( self , nums : List [ int ], target : int ) -> int : ans = nums [ 0 ] + nums [ 1 ] + nums [ 2 ] nums . sort () for i in range ( len ( nums ) - 2 ): l = i + 1 r = len ( nums ) - 1 while l < r : sum = nums [ i ] + nums [ l ] + nums [ r ] if sum == target : return sum if abs ( sum - target ) < abs ( ans - target ): ans = sum if sum < target : l += 1 else : r -= 1 return ans 17. Letter Combinations of a Phone Number $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def letterCombinations ( self , digits : str ) -> List [ str ]: if not digits : return [] ans = [ '' ] dict = { '2' : 'abc' , '3' : 'def' , '4' : 'ghi' , '5' : 'jkl' , '6' : 'mno' , '7' : 'pqrs' , '8' : 'tuv' , '9' : 'wxyz' } for i in digits : tmp = [] for j in ans : for k in dict [ i ]: tmp . append ( j + k ) ans = tmp return ans 18. 4Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution : def fourSum ( self , nums : List [ int ], target : int ): def nSum ( l : int , r : int , target : int , n : int , path : List [ int ], ans : List [ List [ int ]]): if r - l + 1 < n or n < 2 or target < nums [ l ] * n or target > nums [ r ] * n : return if n == 2 : while l < r : sum = nums [ l ] + nums [ r ] if sum == target : ans . append ( path + [ nums [ l ], nums [ r ]]) l += 1 while nums [ l ] == nums [ l - 1 ] and l < r : l += 1 elif sum < target : l += 1 else : r -= 1 return for i in range ( l , r + 1 ): if i > l and nums [ i ] == nums [ i - 1 ]: continue nSum ( i + 1 , r , target - nums [ i ], n - 1 , path + [ nums [ i ]], ans ) ans = [] nums . sort () nSum ( 0 , len ( nums ) - 1 , target , 4 , [], ans ) return ans 19. Remove Nth Node From End of List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def removeNthFromEnd ( self , head : ListNode , n : int ) -> ListNode : slow = head fast = head for _ in range ( n ): fast = fast . next if not fast : return head . next while fast . next : slow = slow . next fast = fast . next slow . next = slow . next . next return head 20. Valid Parentheses $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def isValid ( self , s : str ) -> bool : stack = [] for c in s : if c == '(' or c == '{' or c == '[' : stack . append ( c ) else : if not stack or \\ c == ')' and stack [ - 1 ] != '(' or \\ c == '}' and stack [ - 1 ] != '{' or \\ c == ']' and stack [ - 1 ] != '[' : return False stack . pop () return not stack","title":"0011-0020"},{"location":"python3/0001-0100/0011-0020/#11-container-with-most-water-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def maxArea ( self , height : List [ int ]) -> int : ans = 0 l = 0 r = len ( height ) - 1 while l < r : h = min ( height [ l ], height [ r ]) ans = max ( ans , ( r - l ) * h ) while height [ l ] <= h and l < r : l += 1 while height [ r ] <= h and l < r : r -= 1 return ans","title":"11. Container With Most Water $\\star\\star$"},{"location":"python3/0001-0100/0011-0020/#12-integer-to-roman-starstar","text":"1 2 3 4 5 6 7 8 class Solution : def intToRoman ( self , num : int ) -> str : M = [ \"\" , \"M\" , \"MM\" , \"MMM\" ] C = [ \"\" , \"C\" , \"CC\" , \"CCC\" , \"CD\" , \"D\" , \"DC\" , \"DCC\" , \"DCCC\" , \"CM\" ] X = [ \"\" , \"X\" , \"XX\" , \"XXX\" , \"XL\" , \"L\" , \"LX\" , \"LXX\" , \"LXXX\" , \"XC\" ] I = [ \"\" , \"I\" , \"II\" , \"III\" , \"IV\" , \"V\" , \"VI\" , \"VII\" , \"VIII\" , \"IX\" ] return M [ num // 1000 ] + C [ num % 1000 // 100 ] + X [ num % 100 // 10 ] + I [ num % 10 ]","title":"12. Integer to Roman $\\star\\star$"},{"location":"python3/0001-0100/0011-0020/#13-roman-to-integer-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def romanToInt ( self , s : str ) -> int : ans = 0 dict = { 'I' : 1 , 'V' : 5 , 'X' : 10 , 'L' : 50 , 'C' : 100 , 'D' : 500 , 'M' : 1000 } for i in range ( len ( s ) - 1 ): if dict [ s [ i ]] < dict [ s [ i + 1 ]]: ans -= dict [ s [ i ]] else : ans += dict [ s [ i ]] return ans + dict [ s [ - 1 ]]","title":"13. Roman to Integer $\\star$"},{"location":"python3/0001-0100/0011-0020/#14-longest-common-prefix-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def longestCommonPrefix ( self , strs : List [ str ]) -> str : if len ( strs ) == 0 : return \"\" if len ( strs ) == 1 : return strs [ 0 ] ans = \"\" min_ = len ( strs [ 0 ]) isMatch = True for i in range ( 1 , len ( strs )): min_ = min ( min_ , len ( strs [ i ])) for i in range ( min_ ): c = strs [ 0 ][ i ] for j in range ( 1 , len ( strs )): if c != strs [ j ][ i ]: isMatch = False break if not isMatch : break ans += c return ans","title":"14. Longest Common Prefix $\\star$"},{"location":"python3/0001-0100/0011-0020/#15-3sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def threeSum ( self , nums : List [ int ]) -> List [ List [ int ]]: ans = [] nums . sort () for i in range ( len ( nums ) - 2 ): if i > 0 and nums [ i ] == nums [ i - 1 ]: continue l = i + 1 r = len ( nums ) - 1 while l < r : sum = nums [ i ] + nums [ l ] + nums [ r ] if sum == 0 : ans . append (( nums [ i ], nums [ l ], nums [ r ])) l += 1 r -= 1 while nums [ l ] == nums [ l - 1 ] and l < r : l += 1 while nums [ r ] == nums [ r + 1 ] and l < r : r -= 1 elif sum < 0 : l += 1 else : r -= 1 return ans","title":"15. 3Sum $\\star\\star$"},{"location":"python3/0001-0100/0011-0020/#16-3sum-closest-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def threeSumClosest ( self , nums : List [ int ], target : int ) -> int : ans = nums [ 0 ] + nums [ 1 ] + nums [ 2 ] nums . sort () for i in range ( len ( nums ) - 2 ): l = i + 1 r = len ( nums ) - 1 while l < r : sum = nums [ i ] + nums [ l ] + nums [ r ] if sum == target : return sum if abs ( sum - target ) < abs ( ans - target ): ans = sum if sum < target : l += 1 else : r -= 1 return ans","title":"16. 3Sum Closest $\\star\\star$"},{"location":"python3/0001-0100/0011-0020/#17-letter-combinations-of-a-phone-number-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def letterCombinations ( self , digits : str ) -> List [ str ]: if not digits : return [] ans = [ '' ] dict = { '2' : 'abc' , '3' : 'def' , '4' : 'ghi' , '5' : 'jkl' , '6' : 'mno' , '7' : 'pqrs' , '8' : 'tuv' , '9' : 'wxyz' } for i in digits : tmp = [] for j in ans : for k in dict [ i ]: tmp . append ( j + k ) ans = tmp return ans","title":"17. Letter Combinations of a Phone Number $\\star\\star$"},{"location":"python3/0001-0100/0011-0020/#18-4sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class Solution : def fourSum ( self , nums : List [ int ], target : int ): def nSum ( l : int , r : int , target : int , n : int , path : List [ int ], ans : List [ List [ int ]]): if r - l + 1 < n or n < 2 or target < nums [ l ] * n or target > nums [ r ] * n : return if n == 2 : while l < r : sum = nums [ l ] + nums [ r ] if sum == target : ans . append ( path + [ nums [ l ], nums [ r ]]) l += 1 while nums [ l ] == nums [ l - 1 ] and l < r : l += 1 elif sum < target : l += 1 else : r -= 1 return for i in range ( l , r + 1 ): if i > l and nums [ i ] == nums [ i - 1 ]: continue nSum ( i + 1 , r , target - nums [ i ], n - 1 , path + [ nums [ i ]], ans ) ans = [] nums . sort () nSum ( 0 , len ( nums ) - 1 , target , 4 , [], ans ) return ans","title":"18. 4Sum $\\star\\star$"},{"location":"python3/0001-0100/0011-0020/#19-remove-nth-node-from-end-of-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def removeNthFromEnd ( self , head : ListNode , n : int ) -> ListNode : slow = head fast = head for _ in range ( n ): fast = fast . next if not fast : return head . next while fast . next : slow = slow . next fast = fast . next slow . next = slow . next . next return head","title":"19. Remove Nth Node From End of List $\\star\\star$"},{"location":"python3/0001-0100/0011-0020/#20-valid-parentheses-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def isValid ( self , s : str ) -> bool : stack = [] for c in s : if c == '(' or c == '{' or c == '[' : stack . append ( c ) else : if not stack or \\ c == ')' and stack [ - 1 ] != '(' or \\ c == '}' and stack [ - 1 ] != '{' or \\ c == ']' and stack [ - 1 ] != '[' : return False stack . pop () return not stack","title":"20. Valid Parentheses $\\star$"},{"location":"python3/0001-0100/0021-0030/","text":"21. Merge Two Sorted Lists $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution : def mergeTwoLists ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : if not l1 or not l2 : return l1 if l1 else l2 if l1 . val > l2 . val : l1 , l2 = l2 , l1 l1 . next = self . mergeTwoLists ( l1 . next , l2 ) return l1 22. Generate Parentheses $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def generateParenthesis ( self , n ): ans = [] self . helper ( '' , n , n , ans ) return ans def helper ( self , str , l , r , ans ): if l == 0 and r == 0 : ans . append ( str ) if l > 0 : self . helper ( str + '(' , l - 1 , r , ans ) if l < r : self . helper ( str + ')' , l , r - 1 , ans ) 23. Merge k Sorted Lists $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from heapq import heappush , heappop class Solution : def mergeKLists ( self , lists : List [ ListNode ]) -> ListNode : dummy = ListNode ( 0 ) curr = dummy heap = [] for i in range ( len ( lists )): if lists [ i ]: heappush ( heap , ( lists [ i ] . val , i , lists [ i ])) while heap : node = heappop ( heap ) curr . next = node [ 2 ] curr = curr . next if curr . next : heappush ( heap , ( curr . next . val , node [ 1 ], curr . next )) return dummy . next 24. Swap Nodes in Pairs $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def swapPairs ( self , head : ListNode ) -> ListNode : if not head or not head . next : return head dummy = ListNode ( 0 ) dummy . next = head length = 0 curr = head while curr : length += 1 curr = curr . next prev = dummy curr = head for i in range ( length // 2 ): next = curr . next curr . next = next . next next . next = prev . next prev . next = next prev = curr curr = curr . next return dummy . next 25. Reverse Nodes in k-Group $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def reverseKGroup ( self , head : ListNode , k : int ) -> ListNode : if not head or k == 1 : return head dummy = ListNode ( 0 ) dummy . next = head length = 0 curr = head while curr : length += 1 curr = curr . next prev = dummy curr = head for i in range ( length // k ): for j in range ( k - 1 ): next = curr . next curr . next = next . next next . next = prev . next prev . next = next prev = curr curr = curr . next return dummy . next 26. Remove Duplicates from Sorted Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def removeDuplicates ( self , nums : List [ int ]) -> int : if len ( nums ) == 0 : return 0 j = 0 for i in range ( len ( nums )): if nums [ i ] != nums [ j ]: j += 1 nums [ j ] = nums [ i ] return j + 1 27. Remove Element $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution : def removeElement ( self , nums : List [ int ], val : int ) -> int : i = 0 for num in nums : if num != val : nums [ i ] = num i += 1 return i 28. Implement strStr() $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution : def strStr ( self , haystack : str , needle : str ) -> int : m = len ( haystack ) n = len ( needle ) for i in range ( m - n + 1 ): if haystack [ i : i + n ] == needle : return i return - 1 29. Divide Two Integers $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def divide ( self , dividend : int , divisor : int ) -> int : if dividend == - 2 ** 31 and divisor == - 1 : return 2 ** 31 - 1 ans = 0 sign = - 1 if ( dividend > 0 ) ^ ( divisor > 0 ) else 1 dividend = abs ( dividend ) divisor = abs ( divisor ) while dividend >= divisor : m = 1 temp = divisor while temp << 1 <= dividend : m <<= 1 temp <<= 1 dividend -= temp ans += m return sign * ans 30. Substring with Concatenation of All Words $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution : def findSubstring ( self , s : str , words : List [ str ]) -> List [ int ]: if not s or not words : return [] m = len ( s ) n = len ( words [ 0 ]) ans = [] dict = collections . Counter ( words ) for i in range ( n ): index = i count = 0 tempDict = collections . defaultdict ( int ) for j in range ( i , m - n + 1 , n ): str = s [ j : j + n ] if str in dict . keys (): tempDict [ str ] += 1 count += 1 while tempDict [ str ] > dict [ str ]: tempDict [ s [ index : index + n ]] -= 1 count -= 1 index += n if count == len ( words ): ans . append ( index ) tempDict [ s [ index : index + n ]] -= 1 count -= 1 index += n else : tempDict . clear () count = 0 index = j + n return ans","title":"0021-0030"},{"location":"python3/0001-0100/0021-0030/#21-merge-two-sorted-lists-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution : def mergeTwoLists ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : if not l1 or not l2 : return l1 if l1 else l2 if l1 . val > l2 . val : l1 , l2 = l2 , l1 l1 . next = self . mergeTwoLists ( l1 . next , l2 ) return l1","title":"21. Merge Two Sorted Lists $\\star$"},{"location":"python3/0001-0100/0021-0030/#22-generate-parentheses-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def generateParenthesis ( self , n ): ans = [] self . helper ( '' , n , n , ans ) return ans def helper ( self , str , l , r , ans ): if l == 0 and r == 0 : ans . append ( str ) if l > 0 : self . helper ( str + '(' , l - 1 , r , ans ) if l < r : self . helper ( str + ')' , l , r - 1 , ans )","title":"22. Generate Parentheses $\\star\\star$"},{"location":"python3/0001-0100/0021-0030/#23-merge-k-sorted-lists-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 from heapq import heappush , heappop class Solution : def mergeKLists ( self , lists : List [ ListNode ]) -> ListNode : dummy = ListNode ( 0 ) curr = dummy heap = [] for i in range ( len ( lists )): if lists [ i ]: heappush ( heap , ( lists [ i ] . val , i , lists [ i ])) while heap : node = heappop ( heap ) curr . next = node [ 2 ] curr = curr . next if curr . next : heappush ( heap , ( curr . next . val , node [ 1 ], curr . next )) return dummy . next","title":"23. Merge k Sorted Lists $\\star\\star\\star$"},{"location":"python3/0001-0100/0021-0030/#24-swap-nodes-in-pairs-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def swapPairs ( self , head : ListNode ) -> ListNode : if not head or not head . next : return head dummy = ListNode ( 0 ) dummy . next = head length = 0 curr = head while curr : length += 1 curr = curr . next prev = dummy curr = head for i in range ( length // 2 ): next = curr . next curr . next = next . next next . next = prev . next prev . next = next prev = curr curr = curr . next return dummy . next","title":"24. Swap Nodes in Pairs $\\star\\star$"},{"location":"python3/0001-0100/0021-0030/#25-reverse-nodes-in-k-group-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def reverseKGroup ( self , head : ListNode , k : int ) -> ListNode : if not head or k == 1 : return head dummy = ListNode ( 0 ) dummy . next = head length = 0 curr = head while curr : length += 1 curr = curr . next prev = dummy curr = head for i in range ( length // k ): for j in range ( k - 1 ): next = curr . next curr . next = next . next next . next = prev . next prev . next = next prev = curr curr = curr . next return dummy . next","title":"25. Reverse Nodes in k-Group $\\star\\star\\star$"},{"location":"python3/0001-0100/0021-0030/#26-remove-duplicates-from-sorted-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def removeDuplicates ( self , nums : List [ int ]) -> int : if len ( nums ) == 0 : return 0 j = 0 for i in range ( len ( nums )): if nums [ i ] != nums [ j ]: j += 1 nums [ j ] = nums [ i ] return j + 1","title":"26. Remove Duplicates from Sorted Array $\\star$"},{"location":"python3/0001-0100/0021-0030/#27-remove-element-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution : def removeElement ( self , nums : List [ int ], val : int ) -> int : i = 0 for num in nums : if num != val : nums [ i ] = num i += 1 return i","title":"27. Remove Element $\\star$"},{"location":"python3/0001-0100/0021-0030/#28-implement-strstr-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution : def strStr ( self , haystack : str , needle : str ) -> int : m = len ( haystack ) n = len ( needle ) for i in range ( m - n + 1 ): if haystack [ i : i + n ] == needle : return i return - 1","title":"28. Implement strStr() $\\star$"},{"location":"python3/0001-0100/0021-0030/#29-divide-two-integers-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def divide ( self , dividend : int , divisor : int ) -> int : if dividend == - 2 ** 31 and divisor == - 1 : return 2 ** 31 - 1 ans = 0 sign = - 1 if ( dividend > 0 ) ^ ( divisor > 0 ) else 1 dividend = abs ( dividend ) divisor = abs ( divisor ) while dividend >= divisor : m = 1 temp = divisor while temp << 1 <= dividend : m <<= 1 temp <<= 1 dividend -= temp ans += m return sign * ans","title":"29. Divide Two Integers $\\star\\star$"},{"location":"python3/0001-0100/0021-0030/#30-substring-with-concatenation-of-all-words-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Solution : def findSubstring ( self , s : str , words : List [ str ]) -> List [ int ]: if not s or not words : return [] m = len ( s ) n = len ( words [ 0 ]) ans = [] dict = collections . Counter ( words ) for i in range ( n ): index = i count = 0 tempDict = collections . defaultdict ( int ) for j in range ( i , m - n + 1 , n ): str = s [ j : j + n ] if str in dict . keys (): tempDict [ str ] += 1 count += 1 while tempDict [ str ] > dict [ str ]: tempDict [ s [ index : index + n ]] -= 1 count -= 1 index += n if count == len ( words ): ans . append ( index ) tempDict [ s [ index : index + n ]] -= 1 count -= 1 index += n else : tempDict . clear () count = 0 index = j + n return ans","title":"30. Substring with Concatenation of All Words $\\star\\star\\star$"},{"location":"python3/0001-0100/0031-0040/","text":"31. Next Permutation $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def nextPermutation ( self , nums : List [ int ]) -> None : i = len ( nums ) - 2 while i >= 0 : if nums [ i ] < nums [ i + 1 ]: break i -= 1 if i >= 0 : for j in range ( len ( nums ) - 1 , - 1 , - 1 ): if nums [ j ] > nums [ i ]: break nums [ i ], nums [ j ] = nums [ j ], nums [ i ] self . reverse ( nums , i + 1 , len ( nums ) - 1 ) def reverse ( self , nums : List [ int ], l : int , r : int ): while l < r : nums [ l ], nums [ r ] = nums [ r ], nums [ l ] l += 1 r -= 1 32. Longest Valid Parentheses $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution : def longestValidParentheses ( self , s : str ) -> int : ans = 0 l = 0 r = 0 for i in range ( len ( s )): if s [ i ] == '(' : l += 1 else : r += 1 if l == r : ans = max ( ans , 2 * r ) elif r > l : l = 0 r = 0 l = 0 r = 0 for i in range ( len ( s ) - 1 , - 1 , - 1 ): if s [ i ] == '(' : l += 1 else : r += 1 if l == r : ans = max ( ans , 2 * l ) elif l > r : l = 0 r = 0 return ans 33. Search in Rotated Sorted Array $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def search ( self , nums : List [ int ], target : int ) -> int : l = 0 r = len ( nums ) - 1 while l <= r : m = ( l + r ) // 2 if nums [ m ] == target : return m if nums [ l ] <= nums [ m ]: if nums [ l ] <= target < nums [ m ]: r = m - 1 else : l = m + 1 else : if nums [ m ] < target <= nums [ r ]: l = m + 1 else : r = m - 1 return - 1 34. Find First and Last Position of Element in Sorted Array $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def searchRange ( self , nums : List [ int ], target : int ) -> List [ int ]: leftIndex = self . find ( nums , target , True ) if leftIndex == len ( nums ) or nums [ leftIndex ] != target : return - 1 , - 1 return leftIndex , self . find ( nums , target , False ) - 1 def find ( self , nums : List [ int ], target : int , isLeft : bool ) -> int : l = 0 r = len ( nums ) while l < r : m = ( l + r ) // 2 if nums [ m ] > target or ( isLeft and nums [ m ] == target ): r = m else : l = m + 1 return l 35. Search Insert Position $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def searchInsert ( self , nums : List [ int ], target : int ) -> int : l = 0 r = len ( nums ) while l < r : m = ( l + r ) // 2 if nums [ m ] == target : return m if nums [ m ] < target : l = m + 1 else : r = m return l 36. Valid Sudoku $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def isValidSudoku ( self , board : List [ List [ str ]]) -> bool : def isValidRow ( board : List [ List [ str ]]) -> bool : for row in board : if isValid ( row ) == False : return False return True def isValidCol ( board : List [ List [ str ]]) -> bool : for col in zip ( * board ): if isValid ( col ) == False : return False return True def isValidSquare ( board : List [ List [ str ]]) -> bool : for i in ( 0 , 3 , 6 ): for j in ( 0 , 3 , 6 ): square = [ board [ x ][ y ] for x in range ( i , i + 3 ) for y in range ( j , j + 3 )] if isValid ( square ) == False : return False return True def isValid ( list : List [ str ]) -> bool : res = [ i for i in list if i != '.' ] return len ( res ) == len ( set ( res )) return isValidRow ( board ) and isValidCol ( board ) and isValidSquare ( board ) 37. Sudoku Solver $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution : def solveSudoku ( self , board : List [ List [ str ]]) -> None : self . dfs ( 0 , board ) def dfs ( self , s : int , board : List [ List [ str ]]) -> bool : if s == 81 : return True i = s // 9 j = s % 9 if board [ i ][ j ] != '.' : return self . dfs ( s + 1 , board ) for c in range ( 1 , 10 ): if self . isValid ( i , j , str ( c ), board ): board [ i ][ j ] = str ( c ) if self . dfs ( s + 1 , board ): return True board [ i ][ j ] = '.' return False def isValid ( self , row : int , col : int , c : str , board : List [ List [ str ]]) -> bool : for i in range ( 9 ): if board [ i ][ col ] != '.' and board [ i ][ col ] == c : return False if board [ row ][ i ] != '.' and board [ row ][ i ] == c : return False if board [ 3 * ( row // 3 ) + i // 3 ][ 3 * ( col // 3 ) + i % 3 ] != '.' and \\ board [ 3 * ( row // 3 ) + i // 3 ][ 3 * ( col // 3 ) + i % 3 ] == c : return False return True 38. Count and Say $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def countAndSay ( self , n : int ) -> str : dict = { 1 : '1' , 2 : '11' , 3 : '21' , 4 : '1211' , 5 : '111221' } if n <= 5 : return dict [ n ] for i in range ( 6 , n + 1 ): s = '' j = 0 while j <= len ( dict [ i - 1 ]) - 2 : count = 1 while j <= len ( dict [ i - 1 ]) - 2 and dict [ i - 1 ][ j ] == dict [ i - 1 ][ j + 1 ]: count += 1 j += 1 s += str ( count ) + dict [ i - 1 ][ j ] j += 1 if j == len ( dict [ i - 1 ]) - 1 : s += str ( 1 ) + dict [ i - 1 ][ j ] dict [ i ] = s return dict [ n ] 39. Combination Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def combinationSum ( self , candidates : List [ int ], target : int ) -> List [ List [ int ]]: def dfs ( target : int , s : int , path : List [ int ]) -> None : if target < 0 : return if target == 0 : ans . append ( path ) return for i in range ( s , len ( candidates )): dfs ( target - candidates [ i ], i , path + [ candidates [ i ]]) ans = [] candidates . sort () dfs ( target , 0 , []) return ans 40. Combination Sum II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def combinationSum2 ( self , candidates : List [ int ], target : int ) -> List [ List [ int ]]: def dfs ( target : int , s : int , path : List [ int ]) -> None : if target < 0 : return if target == 0 : ans . append ( path ) return for i in range ( s , len ( candidates )): if i > s and candidates [ i ] == candidates [ i - 1 ]: continue dfs ( target - candidates [ i ], i + 1 , path + [ candidates [ i ]]) ans = [] candidates . sort () dfs ( target , 0 , []) return ans","title":"0031-0040"},{"location":"python3/0001-0100/0031-0040/#31-next-permutation-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def nextPermutation ( self , nums : List [ int ]) -> None : i = len ( nums ) - 2 while i >= 0 : if nums [ i ] < nums [ i + 1 ]: break i -= 1 if i >= 0 : for j in range ( len ( nums ) - 1 , - 1 , - 1 ): if nums [ j ] > nums [ i ]: break nums [ i ], nums [ j ] = nums [ j ], nums [ i ] self . reverse ( nums , i + 1 , len ( nums ) - 1 ) def reverse ( self , nums : List [ int ], l : int , r : int ): while l < r : nums [ l ], nums [ r ] = nums [ r ], nums [ l ] l += 1 r -= 1","title":"31. Next Permutation $\\star\\star$"},{"location":"python3/0001-0100/0031-0040/#32-longest-valid-parentheses-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution : def longestValidParentheses ( self , s : str ) -> int : ans = 0 l = 0 r = 0 for i in range ( len ( s )): if s [ i ] == '(' : l += 1 else : r += 1 if l == r : ans = max ( ans , 2 * r ) elif r > l : l = 0 r = 0 l = 0 r = 0 for i in range ( len ( s ) - 1 , - 1 , - 1 ): if s [ i ] == '(' : l += 1 else : r += 1 if l == r : ans = max ( ans , 2 * l ) elif l > r : l = 0 r = 0 return ans","title":"32. Longest Valid Parentheses $\\star\\star\\star$"},{"location":"python3/0001-0100/0031-0040/#33-search-in-rotated-sorted-array-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def search ( self , nums : List [ int ], target : int ) -> int : l = 0 r = len ( nums ) - 1 while l <= r : m = ( l + r ) // 2 if nums [ m ] == target : return m if nums [ l ] <= nums [ m ]: if nums [ l ] <= target < nums [ m ]: r = m - 1 else : l = m + 1 else : if nums [ m ] < target <= nums [ r ]: l = m + 1 else : r = m - 1 return - 1","title":"33. Search in Rotated Sorted Array $\\star\\star$"},{"location":"python3/0001-0100/0031-0040/#34-find-first-and-last-position-of-element-in-sorted-array-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def searchRange ( self , nums : List [ int ], target : int ) -> List [ int ]: leftIndex = self . find ( nums , target , True ) if leftIndex == len ( nums ) or nums [ leftIndex ] != target : return - 1 , - 1 return leftIndex , self . find ( nums , target , False ) - 1 def find ( self , nums : List [ int ], target : int , isLeft : bool ) -> int : l = 0 r = len ( nums ) while l < r : m = ( l + r ) // 2 if nums [ m ] > target or ( isLeft and nums [ m ] == target ): r = m else : l = m + 1 return l","title":"34. Find First and Last Position of Element in Sorted Array $\\star\\star$"},{"location":"python3/0001-0100/0031-0040/#35-search-insert-position-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def searchInsert ( self , nums : List [ int ], target : int ) -> int : l = 0 r = len ( nums ) while l < r : m = ( l + r ) // 2 if nums [ m ] == target : return m if nums [ m ] < target : l = m + 1 else : r = m return l","title":"35. Search Insert Position $\\star$"},{"location":"python3/0001-0100/0031-0040/#36-valid-sudoku-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def isValidSudoku ( self , board : List [ List [ str ]]) -> bool : def isValidRow ( board : List [ List [ str ]]) -> bool : for row in board : if isValid ( row ) == False : return False return True def isValidCol ( board : List [ List [ str ]]) -> bool : for col in zip ( * board ): if isValid ( col ) == False : return False return True def isValidSquare ( board : List [ List [ str ]]) -> bool : for i in ( 0 , 3 , 6 ): for j in ( 0 , 3 , 6 ): square = [ board [ x ][ y ] for x in range ( i , i + 3 ) for y in range ( j , j + 3 )] if isValid ( square ) == False : return False return True def isValid ( list : List [ str ]) -> bool : res = [ i for i in list if i != '.' ] return len ( res ) == len ( set ( res )) return isValidRow ( board ) and isValidCol ( board ) and isValidSquare ( board )","title":"36. Valid Sudoku $\\star\\star$"},{"location":"python3/0001-0100/0031-0040/#37-sudoku-solver-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class Solution : def solveSudoku ( self , board : List [ List [ str ]]) -> None : self . dfs ( 0 , board ) def dfs ( self , s : int , board : List [ List [ str ]]) -> bool : if s == 81 : return True i = s // 9 j = s % 9 if board [ i ][ j ] != '.' : return self . dfs ( s + 1 , board ) for c in range ( 1 , 10 ): if self . isValid ( i , j , str ( c ), board ): board [ i ][ j ] = str ( c ) if self . dfs ( s + 1 , board ): return True board [ i ][ j ] = '.' return False def isValid ( self , row : int , col : int , c : str , board : List [ List [ str ]]) -> bool : for i in range ( 9 ): if board [ i ][ col ] != '.' and board [ i ][ col ] == c : return False if board [ row ][ i ] != '.' and board [ row ][ i ] == c : return False if board [ 3 * ( row // 3 ) + i // 3 ][ 3 * ( col // 3 ) + i % 3 ] != '.' and \\ board [ 3 * ( row // 3 ) + i // 3 ][ 3 * ( col // 3 ) + i % 3 ] == c : return False return True","title":"37. Sudoku Solver $\\star\\star\\star$"},{"location":"python3/0001-0100/0031-0040/#38-count-and-say-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def countAndSay ( self , n : int ) -> str : dict = { 1 : '1' , 2 : '11' , 3 : '21' , 4 : '1211' , 5 : '111221' } if n <= 5 : return dict [ n ] for i in range ( 6 , n + 1 ): s = '' j = 0 while j <= len ( dict [ i - 1 ]) - 2 : count = 1 while j <= len ( dict [ i - 1 ]) - 2 and dict [ i - 1 ][ j ] == dict [ i - 1 ][ j + 1 ]: count += 1 j += 1 s += str ( count ) + dict [ i - 1 ][ j ] j += 1 if j == len ( dict [ i - 1 ]) - 1 : s += str ( 1 ) + dict [ i - 1 ][ j ] dict [ i ] = s return dict [ n ]","title":"38. Count and Say $\\star$"},{"location":"python3/0001-0100/0031-0040/#39-combination-sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def combinationSum ( self , candidates : List [ int ], target : int ) -> List [ List [ int ]]: def dfs ( target : int , s : int , path : List [ int ]) -> None : if target < 0 : return if target == 0 : ans . append ( path ) return for i in range ( s , len ( candidates )): dfs ( target - candidates [ i ], i , path + [ candidates [ i ]]) ans = [] candidates . sort () dfs ( target , 0 , []) return ans","title":"39. Combination Sum $\\star\\star$"},{"location":"python3/0001-0100/0031-0040/#40-combination-sum-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def combinationSum2 ( self , candidates : List [ int ], target : int ) -> List [ List [ int ]]: def dfs ( target : int , s : int , path : List [ int ]) -> None : if target < 0 : return if target == 0 : ans . append ( path ) return for i in range ( s , len ( candidates )): if i > s and candidates [ i ] == candidates [ i - 1 ]: continue dfs ( target - candidates [ i ], i + 1 , path + [ candidates [ i ]]) ans = [] candidates . sort () dfs ( target , 0 , []) return ans","title":"40. Combination Sum II $\\star\\star$"},{"location":"python3/0001-0100/0041-0050/","text":"41. First Missing Positive $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def firstMissingPositive ( self , nums : List [ int ]) -> int : if not nums : return 1 n = len ( nums ) for i in range ( n ): while nums [ i ] > 0 and nums [ i ] <= n and nums [ nums [ i ] - 1 ] != nums [ i ]: nums [ nums [ i ] - 1 ], nums [ i ] = nums [ i ], nums [ nums [ i ] - 1 ] for i in range ( n ): if nums [ i ] != i + 1 : return i + 1 return n + 1 42. Trapping Rain Water $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def trap ( self , height : List [ int ]) -> int : ans = 0 l = 0 r = len ( height ) - 1 maxLeft = 0 maxRight = 0 while l < r : if height [ l ] < height [ r ]: maxLeft = max ( maxLeft , height [ l ]) ans += maxLeft - height [ l ] l += 1 else : maxRight = max ( maxRight , height [ r ]) ans += maxRight - height [ r ] r -= 1 return ans 43. Multiply Strings $\\star\\star$ 1 2 3 class Solution : def multiply ( self , num1 : str , num2 : str ) -> str : return str ( int ( num1 ) * int ( num2 )) 44. Wildcard Matching $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def isMatch ( self , s : str , p : str ) -> bool : m = len ( s ) n = len ( p ) dp = [[ False ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( m + 1 ): for j in range ( n + 1 ): if i == 0 and j == 0 : dp [ i ][ j ] = True elif i == 0 : dp [ i ][ j ] = dp [ i ][ j - 1 ] and p [ j - 1 ] == '*' elif j == 0 : dp [ i ][ j ] = dp [ i - 1 ][ j ] and s [ i - 1 ] == '*' else : dp [ i ][ j ] = \\ ( dp [ i - 1 ][ j ] or dp [ i ][ j - 1 ] or dp [ i - 1 ][ j - 1 ]) and \\ ( s [ i - 1 ] == '*' or p [ j - 1 ] == '*' ) or \\ ( dp [ i - 1 ][ j - 1 ]) and \\ ( s [ i - 1 ] == '?' or p [ j - 1 ] == '?' or s [ i - 1 ] == p [ j - 1 ]) return dp [ m ][ n ] 45. Jump Game II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def jump ( self , nums : List [ int ]) -> int : ans = 0 end = 0 farthest = 0 for i in range ( len ( nums ) - 1 ): farthest = max ( farthest , i + nums [ i ]) if i == end : ans += 1 end = farthest return ans 46. Permutations $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def permute ( self , nums : List [ int ]) -> List [ List [ int ]]: ans = [] self . dfs ( nums , len ( nums ), [ False ] * len ( nums ), [], ans ) return ans def dfs ( self , nums : List [ int ], target : int , used : List [ bool ], path : List [ int ], ans : List [ List [ int ]]) -> None : if target == 0 : ans . append ( path ) return for i in range ( len ( nums )): if used [ i ]: continue used [ i ] = True self . dfs ( nums , target - 1 , used , path + [ nums [ i ]], ans ) used [ i ] = False 47. Permutations II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def permuteUnique ( self , nums : List [ int ]) -> List [ List [ int ]]: ans = [] nums . sort () self . dfs ( nums , len ( nums ), [ False ] * len ( nums ), [], ans ) return ans def dfs ( self , nums : List [ int ], target : int , used : List [ bool ], path : List [ int ], ans : List [ List [ int ]]) -> None : if target == 0 : ans . append ( path ) return for i in range ( len ( nums )): if used [ i ] or i > 0 and used [ i - 1 ] and nums [ i ] == nums [ i - 1 ]: continue used [ i ] = True self . dfs ( nums , target - 1 , used , path + [ nums [ i ]], ans ) used [ i ] = False 48. Rotate Image $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution : def rotate ( self , matrix : List [ List [ int ]]) -> None : for min in range ( len ( matrix ) // 2 ): max = len ( matrix ) - min - 1 for i in range ( min , max ): offset = i - min top = matrix [ min ][ i ] matrix [ min ][ i ] = matrix [ max - offset ][ min ] matrix [ max - offset ][ min ] = matrix [ max ][ max - offset ] matrix [ max ][ max - offset ] = matrix [ i ][ max ] matrix [ i ][ max ] = top 49. Group Anagrams $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def groupAnagrams ( self , strs : List [ str ]) -> List [ List [ str ]]: ans = [] dict = collections . defaultdict ( list ) for str in strs : s = '' . join ( sorted ( str )) dict [ s ] . append ( str ) for value in dict . values (): ans . append ( value ) return ans 50. Pow(x, n) $\\star\\star$ 1 2 3 4 5 6 7 8 9 class Solution : def myPow ( self , x : float , n : int ) -> float : if n == 0 : return 1 if n < 0 : return 1 / self . myPow ( x , - n ) if n % 2 : return x * self . myPow ( x , n - 1 ) return self . myPow ( x * x , n / 2 )","title":"0041-0050"},{"location":"python3/0001-0100/0041-0050/#41-first-missing-positive-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def firstMissingPositive ( self , nums : List [ int ]) -> int : if not nums : return 1 n = len ( nums ) for i in range ( n ): while nums [ i ] > 0 and nums [ i ] <= n and nums [ nums [ i ] - 1 ] != nums [ i ]: nums [ nums [ i ] - 1 ], nums [ i ] = nums [ i ], nums [ nums [ i ] - 1 ] for i in range ( n ): if nums [ i ] != i + 1 : return i + 1 return n + 1","title":"41. First Missing Positive $\\star\\star\\star$"},{"location":"python3/0001-0100/0041-0050/#42-trapping-rain-water-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def trap ( self , height : List [ int ]) -> int : ans = 0 l = 0 r = len ( height ) - 1 maxLeft = 0 maxRight = 0 while l < r : if height [ l ] < height [ r ]: maxLeft = max ( maxLeft , height [ l ]) ans += maxLeft - height [ l ] l += 1 else : maxRight = max ( maxRight , height [ r ]) ans += maxRight - height [ r ] r -= 1 return ans","title":"42. Trapping Rain Water $\\star\\star\\star$"},{"location":"python3/0001-0100/0041-0050/#43-multiply-strings-starstar","text":"1 2 3 class Solution : def multiply ( self , num1 : str , num2 : str ) -> str : return str ( int ( num1 ) * int ( num2 ))","title":"43. Multiply Strings $\\star\\star$"},{"location":"python3/0001-0100/0041-0050/#44-wildcard-matching-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def isMatch ( self , s : str , p : str ) -> bool : m = len ( s ) n = len ( p ) dp = [[ False ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( m + 1 ): for j in range ( n + 1 ): if i == 0 and j == 0 : dp [ i ][ j ] = True elif i == 0 : dp [ i ][ j ] = dp [ i ][ j - 1 ] and p [ j - 1 ] == '*' elif j == 0 : dp [ i ][ j ] = dp [ i - 1 ][ j ] and s [ i - 1 ] == '*' else : dp [ i ][ j ] = \\ ( dp [ i - 1 ][ j ] or dp [ i ][ j - 1 ] or dp [ i - 1 ][ j - 1 ]) and \\ ( s [ i - 1 ] == '*' or p [ j - 1 ] == '*' ) or \\ ( dp [ i - 1 ][ j - 1 ]) and \\ ( s [ i - 1 ] == '?' or p [ j - 1 ] == '?' or s [ i - 1 ] == p [ j - 1 ]) return dp [ m ][ n ]","title":"44. Wildcard Matching $\\star\\star\\star$"},{"location":"python3/0001-0100/0041-0050/#45-jump-game-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def jump ( self , nums : List [ int ]) -> int : ans = 0 end = 0 farthest = 0 for i in range ( len ( nums ) - 1 ): farthest = max ( farthest , i + nums [ i ]) if i == end : ans += 1 end = farthest return ans","title":"45. Jump Game II $\\star\\star\\star$"},{"location":"python3/0001-0100/0041-0050/#46-permutations-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def permute ( self , nums : List [ int ]) -> List [ List [ int ]]: ans = [] self . dfs ( nums , len ( nums ), [ False ] * len ( nums ), [], ans ) return ans def dfs ( self , nums : List [ int ], target : int , used : List [ bool ], path : List [ int ], ans : List [ List [ int ]]) -> None : if target == 0 : ans . append ( path ) return for i in range ( len ( nums )): if used [ i ]: continue used [ i ] = True self . dfs ( nums , target - 1 , used , path + [ nums [ i ]], ans ) used [ i ] = False","title":"46. Permutations $\\star\\star$"},{"location":"python3/0001-0100/0041-0050/#47-permutations-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def permuteUnique ( self , nums : List [ int ]) -> List [ List [ int ]]: ans = [] nums . sort () self . dfs ( nums , len ( nums ), [ False ] * len ( nums ), [], ans ) return ans def dfs ( self , nums : List [ int ], target : int , used : List [ bool ], path : List [ int ], ans : List [ List [ int ]]) -> None : if target == 0 : ans . append ( path ) return for i in range ( len ( nums )): if used [ i ] or i > 0 and used [ i - 1 ] and nums [ i ] == nums [ i - 1 ]: continue used [ i ] = True self . dfs ( nums , target - 1 , used , path + [ nums [ i ]], ans ) used [ i ] = False","title":"47. Permutations II $\\star\\star$"},{"location":"python3/0001-0100/0041-0050/#48-rotate-image-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution : def rotate ( self , matrix : List [ List [ int ]]) -> None : for min in range ( len ( matrix ) // 2 ): max = len ( matrix ) - min - 1 for i in range ( min , max ): offset = i - min top = matrix [ min ][ i ] matrix [ min ][ i ] = matrix [ max - offset ][ min ] matrix [ max - offset ][ min ] = matrix [ max ][ max - offset ] matrix [ max ][ max - offset ] = matrix [ i ][ max ] matrix [ i ][ max ] = top","title":"48. Rotate Image $\\star\\star$"},{"location":"python3/0001-0100/0041-0050/#49-group-anagrams-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def groupAnagrams ( self , strs : List [ str ]) -> List [ List [ str ]]: ans = [] dict = collections . defaultdict ( list ) for str in strs : s = '' . join ( sorted ( str )) dict [ s ] . append ( str ) for value in dict . values (): ans . append ( value ) return ans","title":"49. Group Anagrams $\\star\\star$"},{"location":"python3/0001-0100/0041-0050/#50-powx-n-starstar","text":"1 2 3 4 5 6 7 8 9 class Solution : def myPow ( self , x : float , n : int ) -> float : if n == 0 : return 1 if n < 0 : return 1 / self . myPow ( x , - n ) if n % 2 : return x * self . myPow ( x , n - 1 ) return self . myPow ( x * x , n / 2 )","title":"50. Pow(x, n) $\\star\\star$"},{"location":"python3/0001-0100/0051-0060/","text":"51. N-Queens $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def solveNQueens ( self , n : int ) -> List [ List [ str ]]: ans = [] self . dfs ( 0 , [ False ] * n , [ False ] * ( 2 * n - 1 ), [ False ] * ( 2 * n - 1 ), [], ans ) return ans def dfs ( self , y : int , cols : List [ bool ], diag1 : List [ bool ], diag2 : List [ bool ], board : List [ str ], ans : List [ List [ str ]]) -> None : if y == len ( cols ): ans . append ( board ) return for x in range ( len ( cols )): if not cols [ x ] and not diag1 [ x + y ] and not diag2 [ x - y + len ( cols ) - 1 ]: cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + len ( cols ) - 1 ] = True self . dfs ( y + 1 , cols , diag1 , diag2 , board + [ '.' * x + 'Q' + '.' * ( len ( cols ) - x - 1 )], ans ) cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + len ( cols ) - 1 ] = False 52. N-Queens II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def totalNQueens ( self , n : int ) -> int : self . ans = 0 self . dfs ( 0 , [ False ] * n , [ False ] * ( 2 * n - 1 ), [ False ] * ( 2 * n - 1 )) return self . ans def dfs ( self , y : int , cols : List [ bool ], diag1 : List [ bool ], diag2 : List [ bool ]) -> None : if y == len ( cols ): self . ans += 1 return for x in range ( len ( cols )): if not cols [ x ] and not diag1 [ x + y ] and not diag2 [ x - y + len ( cols ) - 1 ]: cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + len ( cols ) - 1 ] = True self . dfs ( y + 1 , cols , diag1 , diag2 ) cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + len ( cols ) - 1 ] = False 53. Maximum Subarray $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution : def maxSubArray ( self , nums : List [ int ]) -> int : ans = float ( '-inf' ) sum = 0 for num in nums : sum += num ans = max ( ans , sum ) sum = max ( sum , 0 ) return ans 54. Spiral Matrix $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def spiralOrder ( self , matrix : List [ List [ int ]]) -> List [ int ]: if not matrix : return [] ans = [] r1 = 0 c1 = 0 r2 = len ( matrix ) - 1 c2 = len ( matrix [ 0 ]) - 1 while r1 <= r2 and c1 <= c2 : for c in range ( c1 , c2 + 1 ): ans . append ( matrix [ r1 ][ c ]) for r in range ( r1 + 1 , r2 + 1 ): ans . append ( matrix [ r ][ c2 ]) if r1 < r2 and c1 < c2 : for c in range ( c2 - 1 , c1 , - 1 ): ans . append ( matrix [ r2 ][ c ]) for r in range ( r2 , r1 , - 1 ): ans . append ( matrix [ r ][ c1 ]) r1 += 1 c1 += 1 r2 -= 1 c2 -= 1 return ans 55. Jump Game $\\star\\star$ 1 2 3 4 5 6 7 8 9 class Solution : def canJump ( self , nums : List [ int ]) -> bool : goal = len ( nums ) - 1 for i in range ( goal , - 1 , - 1 ): if i + nums [ i ] >= goal : goal = i return goal == 0 56. Merge Intervals $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def merge ( self , intervals : List [ List [ int ]]) -> List [ List [ int ]]: ans = [] intervals . sort () for interval in intervals : if not ans or ans [ - 1 ][ 1 ] < interval [ 0 ]: ans . append ( interval ) else : ans [ - 1 ][ 1 ] = max ( ans [ - 1 ][ 1 ], interval [ 1 ]) return ans 57. Insert Interval $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def insert ( self , intervals : List [ List [ int ]], newInterval : List [ int ]) -> List [ List [ int ]]: ans = [] index = len ( intervals ) for i in range ( len ( intervals )): if intervals [ i ][ 0 ] >= newInterval [ 0 ]: index = i break intervals . insert ( index , newInterval ) for interval in intervals : if not ans or ans [ - 1 ][ 1 ] < interval [ 0 ]: ans . append ( interval ) else : ans [ - 1 ][ 1 ] = max ( ans [ - 1 ][ 1 ], interval [ 1 ]) return ans 58. Length of Last Word $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def lengthOfLastWord ( self , s : str ) -> int : ans = 0 i = len ( s ) - 1 while i >= 0 and s [ i ] == ' ' : i -= 1 while i >= 0 and s [ i ] != ' ' : i -= 1 ans += 1 return ans 59. Spiral Matrix II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def generateMatrix ( self , n : int ) -> List [ List [ int ]]: ans = [[ 0 for j in range ( n )] for i in range ( n )] count = 1 for min in range ( n // 2 ): max = n - min - 1 for i in range ( min , max ): ans [ min ][ i ] = count count += 1 for i in range ( min , max ): ans [ i ][ max ] = count count += 1 for i in range ( max , min , - 1 ): ans [ max ][ i ] = count count += 1 for i in range ( max , min , - 1 ): ans [ i ][ min ] = count count += 1 if n & 1 : ans [ n // 2 ][ n // 2 ] = count return ans 60. Permutation Sequence $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def getPermutation ( self , n : int , k : int ) -> str : ans = '' nums = [ i + 1 for i in range ( n )] fact = [ 1 ] * n for i in range ( 1 , n ): fact [ i ] = fact [ i - 1 ] * i k -= 1 for i in range ( n , 0 , - 1 ): j = k // fact [ i - 1 ] k %= fact [ i - 1 ] ans += str ( nums [ j ]) nums . pop ( j ) return ans","title":"0051-0060"},{"location":"python3/0001-0100/0051-0060/#51-n-queens-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def solveNQueens ( self , n : int ) -> List [ List [ str ]]: ans = [] self . dfs ( 0 , [ False ] * n , [ False ] * ( 2 * n - 1 ), [ False ] * ( 2 * n - 1 ), [], ans ) return ans def dfs ( self , y : int , cols : List [ bool ], diag1 : List [ bool ], diag2 : List [ bool ], board : List [ str ], ans : List [ List [ str ]]) -> None : if y == len ( cols ): ans . append ( board ) return for x in range ( len ( cols )): if not cols [ x ] and not diag1 [ x + y ] and not diag2 [ x - y + len ( cols ) - 1 ]: cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + len ( cols ) - 1 ] = True self . dfs ( y + 1 , cols , diag1 , diag2 , board + [ '.' * x + 'Q' + '.' * ( len ( cols ) - x - 1 )], ans ) cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + len ( cols ) - 1 ] = False","title":"51. N-Queens $\\star\\star\\star$"},{"location":"python3/0001-0100/0051-0060/#52-n-queens-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def totalNQueens ( self , n : int ) -> int : self . ans = 0 self . dfs ( 0 , [ False ] * n , [ False ] * ( 2 * n - 1 ), [ False ] * ( 2 * n - 1 )) return self . ans def dfs ( self , y : int , cols : List [ bool ], diag1 : List [ bool ], diag2 : List [ bool ]) -> None : if y == len ( cols ): self . ans += 1 return for x in range ( len ( cols )): if not cols [ x ] and not diag1 [ x + y ] and not diag2 [ x - y + len ( cols ) - 1 ]: cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + len ( cols ) - 1 ] = True self . dfs ( y + 1 , cols , diag1 , diag2 ) cols [ x ] = diag1 [ x + y ] = diag2 [ x - y + len ( cols ) - 1 ] = False","title":"52. N-Queens II $\\star\\star\\star$"},{"location":"python3/0001-0100/0051-0060/#53-maximum-subarray-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution : def maxSubArray ( self , nums : List [ int ]) -> int : ans = float ( '-inf' ) sum = 0 for num in nums : sum += num ans = max ( ans , sum ) sum = max ( sum , 0 ) return ans","title":"53. Maximum Subarray $\\star$"},{"location":"python3/0001-0100/0051-0060/#54-spiral-matrix-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def spiralOrder ( self , matrix : List [ List [ int ]]) -> List [ int ]: if not matrix : return [] ans = [] r1 = 0 c1 = 0 r2 = len ( matrix ) - 1 c2 = len ( matrix [ 0 ]) - 1 while r1 <= r2 and c1 <= c2 : for c in range ( c1 , c2 + 1 ): ans . append ( matrix [ r1 ][ c ]) for r in range ( r1 + 1 , r2 + 1 ): ans . append ( matrix [ r ][ c2 ]) if r1 < r2 and c1 < c2 : for c in range ( c2 - 1 , c1 , - 1 ): ans . append ( matrix [ r2 ][ c ]) for r in range ( r2 , r1 , - 1 ): ans . append ( matrix [ r ][ c1 ]) r1 += 1 c1 += 1 r2 -= 1 c2 -= 1 return ans","title":"54. Spiral Matrix $\\star\\star$"},{"location":"python3/0001-0100/0051-0060/#55-jump-game-starstar","text":"1 2 3 4 5 6 7 8 9 class Solution : def canJump ( self , nums : List [ int ]) -> bool : goal = len ( nums ) - 1 for i in range ( goal , - 1 , - 1 ): if i + nums [ i ] >= goal : goal = i return goal == 0","title":"55. Jump Game $\\star\\star$"},{"location":"python3/0001-0100/0051-0060/#56-merge-intervals-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def merge ( self , intervals : List [ List [ int ]]) -> List [ List [ int ]]: ans = [] intervals . sort () for interval in intervals : if not ans or ans [ - 1 ][ 1 ] < interval [ 0 ]: ans . append ( interval ) else : ans [ - 1 ][ 1 ] = max ( ans [ - 1 ][ 1 ], interval [ 1 ]) return ans","title":"56. Merge Intervals $\\star\\star$"},{"location":"python3/0001-0100/0051-0060/#57-insert-interval-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def insert ( self , intervals : List [ List [ int ]], newInterval : List [ int ]) -> List [ List [ int ]]: ans = [] index = len ( intervals ) for i in range ( len ( intervals )): if intervals [ i ][ 0 ] >= newInterval [ 0 ]: index = i break intervals . insert ( index , newInterval ) for interval in intervals : if not ans or ans [ - 1 ][ 1 ] < interval [ 0 ]: ans . append ( interval ) else : ans [ - 1 ][ 1 ] = max ( ans [ - 1 ][ 1 ], interval [ 1 ]) return ans","title":"57. Insert Interval $\\star\\star\\star$"},{"location":"python3/0001-0100/0051-0060/#58-length-of-last-word-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def lengthOfLastWord ( self , s : str ) -> int : ans = 0 i = len ( s ) - 1 while i >= 0 and s [ i ] == ' ' : i -= 1 while i >= 0 and s [ i ] != ' ' : i -= 1 ans += 1 return ans","title":"58. Length of Last Word $\\star$"},{"location":"python3/0001-0100/0051-0060/#59-spiral-matrix-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def generateMatrix ( self , n : int ) -> List [ List [ int ]]: ans = [[ 0 for j in range ( n )] for i in range ( n )] count = 1 for min in range ( n // 2 ): max = n - min - 1 for i in range ( min , max ): ans [ min ][ i ] = count count += 1 for i in range ( min , max ): ans [ i ][ max ] = count count += 1 for i in range ( max , min , - 1 ): ans [ max ][ i ] = count count += 1 for i in range ( max , min , - 1 ): ans [ i ][ min ] = count count += 1 if n & 1 : ans [ n // 2 ][ n // 2 ] = count return ans","title":"59. Spiral Matrix II $\\star\\star$"},{"location":"python3/0001-0100/0051-0060/#60-permutation-sequence-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def getPermutation ( self , n : int , k : int ) -> str : ans = '' nums = [ i + 1 for i in range ( n )] fact = [ 1 ] * n for i in range ( 1 , n ): fact [ i ] = fact [ i - 1 ] * i k -= 1 for i in range ( n , 0 , - 1 ): j = k // fact [ i - 1 ] k %= fact [ i - 1 ] ans += str ( nums [ j ]) nums . pop ( j ) return ans","title":"60. Permutation Sequence $\\star\\star$"},{"location":"python3/0001-0100/0061-0070/","text":"61. Rotate List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def rotateRight ( self , head : ListNode , k : int ) -> ListNode : if not head or not head . next or k == 0 : return head length = 0 curr = head while curr : length += 1 curr = curr . next k %= length if k == 0 : return head slow = head fast = head for _ in range ( k ): fast = fast . next while fast and fast . next : slow = slow . next fast = fast . next ans = slow . next slow . next = None fast . next = head return ans 62. Unique Paths $\\star\\star$ 1 2 3 4 5 6 7 8 9 class Solution : def uniquePaths ( self , m : int , n : int ) -> int : dp = [ 1 ] * n for i in range ( 1 , m ): for j in range ( 1 , n ): dp [ j ] += dp [ j - 1 ] return dp [ n - 1 ] 63. Unique Paths II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def uniquePathsWithObstacles ( self , obstacleGrid : List [ List [ int ]]) -> int : m = len ( obstacleGrid ) n = len ( obstacleGrid [ 0 ]) dp = [ 0 ] * n dp [ 0 ] = 1 for i in range ( m ): for j in range ( n ): if obstacleGrid [ i ][ j ]: dp [ j ] = 0 elif j > 0 : dp [ j ] += dp [ j - 1 ] return dp [ n - 1 ] 64. Minimum Path Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def minPathSum ( self , grid : List [ List [ int ]]) -> int : m = len ( grid ) n = len ( grid [ 0 ]) for i in range ( 1 , m ): grid [ i ][ 0 ] += grid [ i - 1 ][ 0 ] for j in range ( 1 , n ): grid [ 0 ][ j ] += grid [ 0 ][ j - 1 ] for i in range ( 1 , m ): for j in range ( 1 , n ): grid [ i ][ j ] += min ( grid [ i - 1 ][ j ], grid [ i ][ j - 1 ]) return grid [ m - 1 ][ n - 1 ] 65. Valid Number $\\star\\star\\star$ 1 2 3 4 5 6 7 class Solution : def isNumber ( self , s : str ) -> bool : try : float ( s ) return True except : return False 66. Plus One $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def plusOne ( self , digits : List [ int ]) -> List [ int ]: n = len ( digits ) for i in range ( n - 1 , - 1 , - 1 ): if digits [ i ] < 9 : digits [ i ] += 1 return digits digits [ i ] = 0 return [ 1 ] + [ 0 ] * n 67. Add Binary $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def addBinary ( self , a : str , b : str ) -> str : ans = '' carry = 0 i = len ( a ) - 1 j = len ( b ) - 1 while i >= 0 or j >= 0 or carry == 1 : if i >= 0 : carry += ord ( a [ i ]) - ord ( '0' ) i -= 1 if j >= 0 : carry += ord ( b [ j ]) - ord ( '0' ) j -= 1 ans = chr ( carry % 2 + ord ( '0' )) + ans carry >>= 1 return ans 68. Text Justification $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def fullJustify ( self , words : List [ str ], maxWidth : int ) -> List [ str ]: ans = [] curr = [] numOfLetters = 0 for word in words : if numOfLetters + len ( word ) + len ( curr ) > maxWidth : for i in range ( maxWidth - numOfLetters ): curr [ i % ( len ( curr ) - 1 or 1 )] += ' ' ans . append ( '' . join ( curr )) curr = [] numOfLetters = 0 curr . append ( word ) numOfLetters += len ( word ) return ans + [ ' ' . join ( curr ) . ljust ( maxWidth )] 69. Sqrt(x) $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def mySqrt ( self , x : int ) -> int : l = 0 r = x + 1 while l < r : m = ( l + r ) >> 1 if m * m > x : r = m else : l = m + 1 return l - 1 70. Climbing Stairs $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def climbStairs ( self , n : int ) -> int : if n == 1 : return 1 dp = [ 0 ] * ( n + 1 ) dp [ 1 ] = 1 dp [ 2 ] = 2 for i in range ( 3 , n + 1 ): dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] return dp [ n ]","title":"0061-0070"},{"location":"python3/0001-0100/0061-0070/#61-rotate-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def rotateRight ( self , head : ListNode , k : int ) -> ListNode : if not head or not head . next or k == 0 : return head length = 0 curr = head while curr : length += 1 curr = curr . next k %= length if k == 0 : return head slow = head fast = head for _ in range ( k ): fast = fast . next while fast and fast . next : slow = slow . next fast = fast . next ans = slow . next slow . next = None fast . next = head return ans","title":"61. Rotate List $\\star\\star$"},{"location":"python3/0001-0100/0061-0070/#62-unique-paths-starstar","text":"1 2 3 4 5 6 7 8 9 class Solution : def uniquePaths ( self , m : int , n : int ) -> int : dp = [ 1 ] * n for i in range ( 1 , m ): for j in range ( 1 , n ): dp [ j ] += dp [ j - 1 ] return dp [ n - 1 ]","title":"62. Unique Paths $\\star\\star$"},{"location":"python3/0001-0100/0061-0070/#63-unique-paths-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def uniquePathsWithObstacles ( self , obstacleGrid : List [ List [ int ]]) -> int : m = len ( obstacleGrid ) n = len ( obstacleGrid [ 0 ]) dp = [ 0 ] * n dp [ 0 ] = 1 for i in range ( m ): for j in range ( n ): if obstacleGrid [ i ][ j ]: dp [ j ] = 0 elif j > 0 : dp [ j ] += dp [ j - 1 ] return dp [ n - 1 ]","title":"63. Unique Paths II $\\star\\star$"},{"location":"python3/0001-0100/0061-0070/#64-minimum-path-sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def minPathSum ( self , grid : List [ List [ int ]]) -> int : m = len ( grid ) n = len ( grid [ 0 ]) for i in range ( 1 , m ): grid [ i ][ 0 ] += grid [ i - 1 ][ 0 ] for j in range ( 1 , n ): grid [ 0 ][ j ] += grid [ 0 ][ j - 1 ] for i in range ( 1 , m ): for j in range ( 1 , n ): grid [ i ][ j ] += min ( grid [ i - 1 ][ j ], grid [ i ][ j - 1 ]) return grid [ m - 1 ][ n - 1 ]","title":"64. Minimum Path Sum $\\star\\star$"},{"location":"python3/0001-0100/0061-0070/#65-valid-number-starstarstar","text":"1 2 3 4 5 6 7 class Solution : def isNumber ( self , s : str ) -> bool : try : float ( s ) return True except : return False","title":"65. Valid Number $\\star\\star\\star$"},{"location":"python3/0001-0100/0061-0070/#66-plus-one-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def plusOne ( self , digits : List [ int ]) -> List [ int ]: n = len ( digits ) for i in range ( n - 1 , - 1 , - 1 ): if digits [ i ] < 9 : digits [ i ] += 1 return digits digits [ i ] = 0 return [ 1 ] + [ 0 ] * n","title":"66. Plus One $\\star$"},{"location":"python3/0001-0100/0061-0070/#67-add-binary-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def addBinary ( self , a : str , b : str ) -> str : ans = '' carry = 0 i = len ( a ) - 1 j = len ( b ) - 1 while i >= 0 or j >= 0 or carry == 1 : if i >= 0 : carry += ord ( a [ i ]) - ord ( '0' ) i -= 1 if j >= 0 : carry += ord ( b [ j ]) - ord ( '0' ) j -= 1 ans = chr ( carry % 2 + ord ( '0' )) + ans carry >>= 1 return ans","title":"67. Add Binary $\\star$"},{"location":"python3/0001-0100/0061-0070/#68-text-justification-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def fullJustify ( self , words : List [ str ], maxWidth : int ) -> List [ str ]: ans = [] curr = [] numOfLetters = 0 for word in words : if numOfLetters + len ( word ) + len ( curr ) > maxWidth : for i in range ( maxWidth - numOfLetters ): curr [ i % ( len ( curr ) - 1 or 1 )] += ' ' ans . append ( '' . join ( curr )) curr = [] numOfLetters = 0 curr . append ( word ) numOfLetters += len ( word ) return ans + [ ' ' . join ( curr ) . ljust ( maxWidth )]","title":"68. Text Justification $\\star\\star\\star$"},{"location":"python3/0001-0100/0061-0070/#69-sqrtx-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def mySqrt ( self , x : int ) -> int : l = 0 r = x + 1 while l < r : m = ( l + r ) >> 1 if m * m > x : r = m else : l = m + 1 return l - 1","title":"69. Sqrt(x) $\\star$"},{"location":"python3/0001-0100/0061-0070/#70-climbing-stairs-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def climbStairs ( self , n : int ) -> int : if n == 1 : return 1 dp = [ 0 ] * ( n + 1 ) dp [ 1 ] = 1 dp [ 2 ] = 2 for i in range ( 3 , n + 1 ): dp [ i ] = dp [ i - 1 ] + dp [ i - 2 ] return dp [ n ]","title":"70. Climbing Stairs $\\star$"},{"location":"python3/0001-0100/0071-0080/","text":"71. Simplify Path $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def simplifyPath ( self , path : str ) -> str : stack = [] for str in path . split ( '/' ): if str in ( '' , '.' ): continue if str == '..' : if stack : stack . pop () else : stack . append ( str ) return '/' + '/' . join ( stack ) 72. Edit Distance $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def minDistance ( self , word1 : str , word2 : str ) -> int : m = len ( word1 ) n = len ( word2 ) dp = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( m + 1 ): for j in range ( n + 1 ): if i == 0 : dp [ i ][ j ] = j elif j == 0 : dp [ i ][ j ] = i else : dp [ i ][ j ] = min ( dp [ i - 1 ][ j - 1 ] + ( 0 if word1 [ i - 1 ] == word2 [ j - 1 ] else 1 ), dp [ i - 1 ][ j ] + 1 , dp [ i ][ j - 1 ] + 1 ) return dp [ m ][ n ] 73. Set Matrix Zeroes $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def setZeroes ( self , matrix : List [ List [ int ]]) -> None : m = len ( matrix ) n = len ( matrix [ 0 ]) isFirstRow = 0 in matrix [ 0 ] isFirstCol = 0 in list ( zip ( * matrix ))[ 0 ] for i in range ( 1 , m ): for j in range ( 1 , n ): if matrix [ i ][ j ] == 0 : matrix [ i ][ 0 ] = 0 matrix [ 0 ][ j ] = 0 for i in range ( 1 , m ): for j in range ( 1 , n ): if matrix [ i ][ 0 ] == 0 or matrix [ 0 ][ j ] == 0 : matrix [ i ][ j ] = 0 if isFirstRow : matrix [ 0 ] = [ 0 ] * n if isFirstCol : for row in matrix : row [ 0 ] = 0 74. Search a 2D Matrix $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def searchMatrix ( self , matrix : List [ List [ int ]], target : int ) -> bool : if not matrix : return False m = len ( matrix ) n = len ( matrix [ 0 ]) l = 0 r = m * n while l < r : mid = l + ( r - l ) // 2 i = mid // n j = mid % n if matrix [ i ][ j ] == target : return True if matrix [ i ][ j ] < target : l = mid + 1 else : r = mid return False 75. Sort Colors $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def sortColors ( self , nums : List [ int ]) -> None : zero = - 1 one = - 1 two = - 1 for num in nums : if num == 0 : two += 1 one += 1 zero += 1 nums [ two ] = 2 nums [ one ] = 1 nums [ zero ] = 0 elif num == 1 : two += 1 one += 1 nums [ two ] = 2 nums [ one ] = 1 else : two += 1 nums [ two ] = 2 76. Minimum Window Substring $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution : def minWindow ( self , s : str , t : str ) -> str : if not s or not t : return \"\" dict = collections . Counter ( t ) l = 0 r = 0 bestLeft = 0 bestRight = 0 required = len ( dict ) windowLength = len ( s ) + 1 for r in range ( len ( s )): if s [ r ] in dict : dict [ s [ r ]] -= 1 if dict [ s [ r ]] == 0 : required -= 1 while required == 0 and l <= r : if r - l + 1 < windowLength : windowLength = r - l + 1 bestLeft = l bestRight = r if s [ l ] in dict : dict [ s [ l ]] += 1 if dict [ s [ l ]] > 0 : required += 1 l += 1 return \"\" if windowLength == len ( s ) + 1 else s [ bestLeft : bestRight + 1 ] 77. Combinations $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def combine ( self , n : int , k : int ) -> List [ List [ int ]]: ans = [] self . dfs ( n , k , 1 , [], ans ) return ans def dfs ( self , n : int , k : int , s : int , path : List [ int ], ans : List [ List [ int ]]) -> None : if k == 0 : ans . append ( path ) return for i in range ( s , n + 1 ): self . dfs ( n , k - 1 , i + 1 , path + [ i ], ans ) 78. Subsets $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def subsets ( self , nums : List [ int ]) -> List [ List [ int ]]: def dfs ( s : int , path : List [ int ]) -> None : ans . append ( path ) if s == len ( nums ): return for i in range ( s , len ( nums )): dfs ( i + 1 , path + [ nums [ i ]]) ans = [] dfs ( 0 , []) return ans 79. Word Search $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def exist ( self , board : List [ List [ str ]], word : str ) -> bool : def dfs ( i : int , j : int , pos : int ) -> bool : if not 0 <= i < len ( board ) or not 0 <= j < len ( board [ 0 ]) or board [ i ][ j ] != word [ pos ] or board [ i ][ j ] == '*' : return False if pos == len ( word ) - 1 : return True c = board [ i ][ j ] board [ i ][ j ] = '*' flag = \\ dfs ( i + 1 , j , pos + 1 ) or \\ dfs ( i - 1 , j , pos + 1 ) or \\ dfs ( i , j + 1 , pos + 1 ) or \\ dfs ( i , j - 1 , pos + 1 ) board [ i ][ j ] = c return flag if not board : return False for i in range ( len ( board )): for j in range ( len ( board [ 0 ])): if dfs ( i , j , 0 ): return True return False 80. Remove Duplicates from Sorted Array II $\\star\\star$ 1 2 3 4 5 6 7 8 9 class Solution : def removeDuplicates ( self , nums : List [ int ]) -> int : i = 0 for num in nums : if i < 2 or num != nums [ i - 2 ]: nums [ i ] = num i += 1 return i","title":"0071-0080"},{"location":"python3/0001-0100/0071-0080/#71-simplify-path-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def simplifyPath ( self , path : str ) -> str : stack = [] for str in path . split ( '/' ): if str in ( '' , '.' ): continue if str == '..' : if stack : stack . pop () else : stack . append ( str ) return '/' + '/' . join ( stack )","title":"71. Simplify Path $\\star\\star$"},{"location":"python3/0001-0100/0071-0080/#72-edit-distance-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def minDistance ( self , word1 : str , word2 : str ) -> int : m = len ( word1 ) n = len ( word2 ) dp = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( m + 1 ): for j in range ( n + 1 ): if i == 0 : dp [ i ][ j ] = j elif j == 0 : dp [ i ][ j ] = i else : dp [ i ][ j ] = min ( dp [ i - 1 ][ j - 1 ] + ( 0 if word1 [ i - 1 ] == word2 [ j - 1 ] else 1 ), dp [ i - 1 ][ j ] + 1 , dp [ i ][ j - 1 ] + 1 ) return dp [ m ][ n ]","title":"72. Edit Distance $\\star\\star\\star$"},{"location":"python3/0001-0100/0071-0080/#73-set-matrix-zeroes-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def setZeroes ( self , matrix : List [ List [ int ]]) -> None : m = len ( matrix ) n = len ( matrix [ 0 ]) isFirstRow = 0 in matrix [ 0 ] isFirstCol = 0 in list ( zip ( * matrix ))[ 0 ] for i in range ( 1 , m ): for j in range ( 1 , n ): if matrix [ i ][ j ] == 0 : matrix [ i ][ 0 ] = 0 matrix [ 0 ][ j ] = 0 for i in range ( 1 , m ): for j in range ( 1 , n ): if matrix [ i ][ 0 ] == 0 or matrix [ 0 ][ j ] == 0 : matrix [ i ][ j ] = 0 if isFirstRow : matrix [ 0 ] = [ 0 ] * n if isFirstCol : for row in matrix : row [ 0 ] = 0","title":"73. Set Matrix Zeroes $\\star\\star$"},{"location":"python3/0001-0100/0071-0080/#74-search-a-2d-matrix-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def searchMatrix ( self , matrix : List [ List [ int ]], target : int ) -> bool : if not matrix : return False m = len ( matrix ) n = len ( matrix [ 0 ]) l = 0 r = m * n while l < r : mid = l + ( r - l ) // 2 i = mid // n j = mid % n if matrix [ i ][ j ] == target : return True if matrix [ i ][ j ] < target : l = mid + 1 else : r = mid return False","title":"74. Search a 2D Matrix $\\star\\star$"},{"location":"python3/0001-0100/0071-0080/#75-sort-colors-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def sortColors ( self , nums : List [ int ]) -> None : zero = - 1 one = - 1 two = - 1 for num in nums : if num == 0 : two += 1 one += 1 zero += 1 nums [ two ] = 2 nums [ one ] = 1 nums [ zero ] = 0 elif num == 1 : two += 1 one += 1 nums [ two ] = 2 nums [ one ] = 1 else : two += 1 nums [ two ] = 2","title":"75. Sort Colors $\\star\\star$"},{"location":"python3/0001-0100/0071-0080/#76-minimum-window-substring-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Solution : def minWindow ( self , s : str , t : str ) -> str : if not s or not t : return \"\" dict = collections . Counter ( t ) l = 0 r = 0 bestLeft = 0 bestRight = 0 required = len ( dict ) windowLength = len ( s ) + 1 for r in range ( len ( s )): if s [ r ] in dict : dict [ s [ r ]] -= 1 if dict [ s [ r ]] == 0 : required -= 1 while required == 0 and l <= r : if r - l + 1 < windowLength : windowLength = r - l + 1 bestLeft = l bestRight = r if s [ l ] in dict : dict [ s [ l ]] += 1 if dict [ s [ l ]] > 0 : required += 1 l += 1 return \"\" if windowLength == len ( s ) + 1 else s [ bestLeft : bestRight + 1 ]","title":"76. Minimum Window Substring $\\star\\star\\star$"},{"location":"python3/0001-0100/0071-0080/#77-combinations-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def combine ( self , n : int , k : int ) -> List [ List [ int ]]: ans = [] self . dfs ( n , k , 1 , [], ans ) return ans def dfs ( self , n : int , k : int , s : int , path : List [ int ], ans : List [ List [ int ]]) -> None : if k == 0 : ans . append ( path ) return for i in range ( s , n + 1 ): self . dfs ( n , k - 1 , i + 1 , path + [ i ], ans )","title":"77. Combinations $\\star\\star$"},{"location":"python3/0001-0100/0071-0080/#78-subsets-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def subsets ( self , nums : List [ int ]) -> List [ List [ int ]]: def dfs ( s : int , path : List [ int ]) -> None : ans . append ( path ) if s == len ( nums ): return for i in range ( s , len ( nums )): dfs ( i + 1 , path + [ nums [ i ]]) ans = [] dfs ( 0 , []) return ans","title":"78. Subsets $\\star\\star$"},{"location":"python3/0001-0100/0071-0080/#79-word-search-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def exist ( self , board : List [ List [ str ]], word : str ) -> bool : def dfs ( i : int , j : int , pos : int ) -> bool : if not 0 <= i < len ( board ) or not 0 <= j < len ( board [ 0 ]) or board [ i ][ j ] != word [ pos ] or board [ i ][ j ] == '*' : return False if pos == len ( word ) - 1 : return True c = board [ i ][ j ] board [ i ][ j ] = '*' flag = \\ dfs ( i + 1 , j , pos + 1 ) or \\ dfs ( i - 1 , j , pos + 1 ) or \\ dfs ( i , j + 1 , pos + 1 ) or \\ dfs ( i , j - 1 , pos + 1 ) board [ i ][ j ] = c return flag if not board : return False for i in range ( len ( board )): for j in range ( len ( board [ 0 ])): if dfs ( i , j , 0 ): return True return False","title":"79. Word Search $\\star\\star$"},{"location":"python3/0001-0100/0071-0080/#80-remove-duplicates-from-sorted-array-ii-starstar","text":"1 2 3 4 5 6 7 8 9 class Solution : def removeDuplicates ( self , nums : List [ int ]) -> int : i = 0 for num in nums : if i < 2 or num != nums [ i - 2 ]: nums [ i ] = num i += 1 return i","title":"80. Remove Duplicates from Sorted Array II $\\star\\star$"},{"location":"python3/0001-0100/0081-0090/","text":"81. Search in Rotated Sorted Array II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def search ( self , nums : List [ int ], target : int ) -> bool : l = 0 r = len ( nums ) - 1 while l <= r : m = l + ( r - l ) // 2 if nums [ m ] == target : return True if nums [ l ] == nums [ m ] == nums [ r ]: l += 1 r -= 1 elif nums [ l ] <= nums [ m ]: if nums [ l ] <= target < nums [ m ]: r = m - 1 else : l = m + 1 else : if nums [ m ] < target <= nums [ r ]: l = m + 1 else : r = m - 1 return False 82. Remove Duplicates from Sorted List II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def deleteDuplicates ( self , head : ListNode ) -> ListNode : dummy = ListNode ( 0 ) dummy . next = head prev = dummy while head : while head . next and head . val == head . next . val : head = head . next if prev . next == head : prev = prev . next else : prev . next = head . next head = head . next return dummy . next 83. Remove Duplicates from Sorted List $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution : def deleteDuplicates ( self , head : ListNode ) -> ListNode : curr = head while curr : while curr . next and curr . val == curr . next . val : curr . next = curr . next . next curr = curr . next return head 84. Largest Rectangle in Histogram $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def largestRectangleArea ( self , heights : List [ int ]) -> int : ans = 0 stack = [] for i in range ( len ( heights ) + 1 ): while stack != [] and ( i == len ( heights ) or heights [ i ] < heights [ stack [ - 1 ]]): h = heights [ stack . pop ()] w = i if stack == [] else i - stack [ - 1 ] - 1 ans = max ( ans , h * w ) stack . append ( i ) return ans 85. Maximal Rectangle $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def maximalRectangle ( self , matrix : List [ List [ str ]]) -> int : def largestRectangleArea ( heights : List [ int ]) -> int : ans = 0 stack = [] for i in range ( len ( heights ) + 1 ): while stack != [] and ( i == len ( heights ) or heights [ i ] < heights [ stack [ - 1 ]]): h = heights [ stack . pop ()] w = i if stack == [] else i - stack [ - 1 ] - 1 ans = max ( ans , h * w ) stack . append ( i ) return ans if matrix == []: return 0 ans = 0 temp = [ 0 ] * len ( matrix [ 0 ]) for i in range ( len ( matrix )): for j in range ( len ( matrix [ 0 ])): temp [ j ] = 0 if matrix [ i ][ j ] == '0' else temp [ j ] + 1 ans = max ( ans , largestRectangleArea ( temp )) return ans 86. Partition List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def partition ( self , head : ListNode , x : int ) -> ListNode : beforeHead = ListNode ( 0 ) afterHead = ListNode ( 0 ) before = beforeHead after = afterHead while head : if head . val < x : before . next = head before = before . next else : after . next = head after = after . next head = head . next after . next = None before . next = afterHead . next return beforeHead . next 87. Scramble String $\\star\\star\\star$ 88. Merge Sorted Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def merge ( self , nums1 : List [ int ], m : int , nums2 : List [ int ], n : int ) -> None : k = m + n while n > 0 : k -= 1 if m > 0 and nums1 [ m - 1 ] > nums2 [ n - 1 ]: m -= 1 nums1 [ k ] = nums1 [ m ] else : n -= 1 nums1 [ k ] = nums2 [ n ] 89. Gray Code $\\star\\star$ 1 2 3 4 5 6 7 8 9 class Solution : def grayCode ( self , n : int ) -> List [ int ]: ans = [ 0 ] for i in range ( n ): for j in range ( len ( ans ) - 1 , - 1 , - 1 ): ans . append ( ans [ j ] | 1 << i ) return ans 90. Subsets II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def subsetsWithDup ( self , nums : List [ int ]) -> List [ List [ int ]]: def dfs ( s : int , path : List [ int ]) -> None : ans . append ( path ) if s == len ( nums ): return for i in range ( s , len ( nums )): if i > s and nums [ i ] == nums [ i - 1 ]: continue dfs ( i + 1 , path + [ nums [ i ]]) ans = [] nums . sort () dfs ( 0 , []) return ans","title":"0081-0090"},{"location":"python3/0001-0100/0081-0090/#81-search-in-rotated-sorted-array-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Solution : def search ( self , nums : List [ int ], target : int ) -> bool : l = 0 r = len ( nums ) - 1 while l <= r : m = l + ( r - l ) // 2 if nums [ m ] == target : return True if nums [ l ] == nums [ m ] == nums [ r ]: l += 1 r -= 1 elif nums [ l ] <= nums [ m ]: if nums [ l ] <= target < nums [ m ]: r = m - 1 else : l = m + 1 else : if nums [ m ] < target <= nums [ r ]: l = m + 1 else : r = m - 1 return False","title":"81. Search in Rotated Sorted Array II $\\star\\star$"},{"location":"python3/0001-0100/0081-0090/#82-remove-duplicates-from-sorted-list-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def deleteDuplicates ( self , head : ListNode ) -> ListNode : dummy = ListNode ( 0 ) dummy . next = head prev = dummy while head : while head . next and head . val == head . next . val : head = head . next if prev . next == head : prev = prev . next else : prev . next = head . next head = head . next return dummy . next","title":"82. Remove Duplicates from Sorted List II $\\star\\star$"},{"location":"python3/0001-0100/0081-0090/#83-remove-duplicates-from-sorted-list-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution : def deleteDuplicates ( self , head : ListNode ) -> ListNode : curr = head while curr : while curr . next and curr . val == curr . next . val : curr . next = curr . next . next curr = curr . next return head","title":"83. Remove Duplicates from Sorted List $\\star$"},{"location":"python3/0001-0100/0081-0090/#84-largest-rectangle-in-histogram-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def largestRectangleArea ( self , heights : List [ int ]) -> int : ans = 0 stack = [] for i in range ( len ( heights ) + 1 ): while stack != [] and ( i == len ( heights ) or heights [ i ] < heights [ stack [ - 1 ]]): h = heights [ stack . pop ()] w = i if stack == [] else i - stack [ - 1 ] - 1 ans = max ( ans , h * w ) stack . append ( i ) return ans","title":"84. Largest Rectangle in Histogram $\\star\\star\\star$"},{"location":"python3/0001-0100/0081-0090/#85-maximal-rectangle-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def maximalRectangle ( self , matrix : List [ List [ str ]]) -> int : def largestRectangleArea ( heights : List [ int ]) -> int : ans = 0 stack = [] for i in range ( len ( heights ) + 1 ): while stack != [] and ( i == len ( heights ) or heights [ i ] < heights [ stack [ - 1 ]]): h = heights [ stack . pop ()] w = i if stack == [] else i - stack [ - 1 ] - 1 ans = max ( ans , h * w ) stack . append ( i ) return ans if matrix == []: return 0 ans = 0 temp = [ 0 ] * len ( matrix [ 0 ]) for i in range ( len ( matrix )): for j in range ( len ( matrix [ 0 ])): temp [ j ] = 0 if matrix [ i ][ j ] == '0' else temp [ j ] + 1 ans = max ( ans , largestRectangleArea ( temp )) return ans","title":"85. Maximal Rectangle $\\star\\star\\star$"},{"location":"python3/0001-0100/0081-0090/#86-partition-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def partition ( self , head : ListNode , x : int ) -> ListNode : beforeHead = ListNode ( 0 ) afterHead = ListNode ( 0 ) before = beforeHead after = afterHead while head : if head . val < x : before . next = head before = before . next else : after . next = head after = after . next head = head . next after . next = None before . next = afterHead . next return beforeHead . next","title":"86. Partition List $\\star\\star$"},{"location":"python3/0001-0100/0081-0090/#87-scramble-string-starstarstar","text":"","title":"87. Scramble String $\\star\\star\\star$"},{"location":"python3/0001-0100/0081-0090/#88-merge-sorted-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def merge ( self , nums1 : List [ int ], m : int , nums2 : List [ int ], n : int ) -> None : k = m + n while n > 0 : k -= 1 if m > 0 and nums1 [ m - 1 ] > nums2 [ n - 1 ]: m -= 1 nums1 [ k ] = nums1 [ m ] else : n -= 1 nums1 [ k ] = nums2 [ n ]","title":"88. Merge Sorted Array $\\star$"},{"location":"python3/0001-0100/0081-0090/#89-gray-code-starstar","text":"1 2 3 4 5 6 7 8 9 class Solution : def grayCode ( self , n : int ) -> List [ int ]: ans = [ 0 ] for i in range ( n ): for j in range ( len ( ans ) - 1 , - 1 , - 1 ): ans . append ( ans [ j ] | 1 << i ) return ans","title":"89. Gray Code $\\star\\star$"},{"location":"python3/0001-0100/0081-0090/#90-subsets-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def subsetsWithDup ( self , nums : List [ int ]) -> List [ List [ int ]]: def dfs ( s : int , path : List [ int ]) -> None : ans . append ( path ) if s == len ( nums ): return for i in range ( s , len ( nums )): if i > s and nums [ i ] == nums [ i - 1 ]: continue dfs ( i + 1 , path + [ nums [ i ]]) ans = [] nums . sort () dfs ( 0 , []) return ans","title":"90. Subsets II $\\star\\star$"},{"location":"python3/0001-0100/0091-0100/","text":"91. Decode Ways $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def numDecodings ( self , s : str ) -> int : if not s or s [ 0 ] == '0' : return 0 if len ( s ) == 1 : return 1 dp1 = 1 dp2 = 1 for i in range ( 1 , len ( s )): dp = 0 if not self . isValid ( s [ i ]) and not self . isValid ( s [ i - 1 ], s [ i ]): return 0 if self . isValid ( s [ i ]): dp += dp1 if self . isValid ( s [ i - 1 ], s [ i ]): dp += dp2 dp2 = dp1 dp1 = dp return dp1 def isValid ( self , a : chr , b = None ) -> bool : if b : return a == '1' or ( a == '2' and b <= '6' ) return a != '0' 92. Reverse Linked List II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def reverseBetween ( self , head : ListNode , m : int , n : int ) -> ListNode : if not head : return None prev = None curr = head for _ in range ( m - 1 ): prev = curr curr = curr . next conn = prev tail = curr for _ in range ( n - m + 1 ): next = curr . next curr . next = prev prev = curr curr = next if conn : conn . next = prev else : head = prev tail . next = curr return head 93. Restore IP Addresses $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def restoreIpAddresses ( self , s : str ) -> List [ str ]: ans = [] self . dfs ( s , 0 , 0 , [ \"\" ] * 4 , ans ) return ans def dfs ( self , s : str , depth : int , index : int , path : List [ str ], ans : List [ str ]) -> None : if depth == 4 and index == len ( s ): ans . append ( \".\" . join ( path )) return if depth == 4 or index == len ( s ): return for i in range ( 1 , 4 ): if index + i > len ( s ): return if i > 1 and s [ index ] == '0' : return temp = s [ index : index + i ] if int ( temp ) > 255 : return path [ depth ] = temp self . dfs ( s , depth + 1 , index + i , path , ans ) path [ depth ] = \"\" 94. Binary Tree Inorder Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def inorderTraversal ( self , root : TreeNode ) -> List [ int ]: ans = [] stack = [] curr = root while curr or stack : while curr : stack . append ( curr ) curr = curr . left curr = stack . pop () ans . append ( curr . val ) curr = curr . right return ans 95. Unique Binary Search Trees II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def generateTrees ( self , n : int ) -> List [ TreeNode ]: if n == 0 : return [] return self . helper ( 1 , n ) def helper ( self , min : int , max : int ) -> List [ TreeNode ]: ans = [] if min > max : ans . append ( None ) return ans for i in range ( min , max + 1 ): leftTree = self . helper ( min , i - 1 ) rightTree = self . helper ( i + 1 , max ) for left in leftTree : for right in rightTree : root = TreeNode ( i ) root . left = left root . right = right ans . append ( root ) return ans 96. Unique Binary Search Trees $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def numTrees ( self , n : int ) -> int : G = [ 0 ] * ( n + 1 ) G [ 0 ] = 1 G [ 1 ] = 1 for i in range ( 2 , n + 1 ): for j in range ( i ): G [ i ] += G [ j ] * G [ i - j - 1 ] return G [ n ] 97. Interleaving String $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def isInterleave ( self , s1 : str , s2 : str , s3 : str ) -> bool : if len ( s1 ) + len ( s2 ) != len ( s3 ): return False dp = [ False ] * ( len ( s2 ) + 1 ) for i in range ( len ( s1 ) + 1 ): for j in range ( len ( s2 ) + 1 ): if i == 0 and j == 0 : dp [ j ] = True elif i == 0 : dp [ j ] = dp [ j - 1 ] and s2 [ j - 1 ] == s3 [ i + j - 1 ] elif j == 0 : dp [ j ] = dp [ j ] and s1 [ i - 1 ] == s3 [ i + j - 1 ] else : dp [ j ] = ( dp [ j ] and s1 [ i - 1 ] == s3 [ i + j - 1 ]) or ( dp [ j - 1 ] and s2 [ j - 1 ] == s3 [ i + j - 1 ]) return dp [ len ( s2 )] 98. Validate Binary Search Tree $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution : def isValidBST ( self , root : TreeNode ) -> bool : return self . helper ( root , None , None ) def helper ( self , root : TreeNode , minNode : TreeNode , maxNode : TreeNode ) -> bool : if not root : return True if minNode and root . val <= minNode . val or maxNode and root . val >= maxNode . val : return False return self . helper ( root . left , minNode , root ) and self . helper ( root . right , root , maxNode ) 99. Recover Binary Search Tree $\\star\\star\\star$ 100. Same Tree $\\star$ 1 2 3 4 5 6 7 8 class Solution : def isSameTree ( self , p : TreeNode , q : TreeNode ) -> bool : if not p or not q : return p == q return p . val == q . val and \\ self . isSameTree ( p . left , q . left ) and \\ self . isSameTree ( p . right , q . right )","title":"0091-0100"},{"location":"python3/0001-0100/0091-0100/#91-decode-ways-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def numDecodings ( self , s : str ) -> int : if not s or s [ 0 ] == '0' : return 0 if len ( s ) == 1 : return 1 dp1 = 1 dp2 = 1 for i in range ( 1 , len ( s )): dp = 0 if not self . isValid ( s [ i ]) and not self . isValid ( s [ i - 1 ], s [ i ]): return 0 if self . isValid ( s [ i ]): dp += dp1 if self . isValid ( s [ i - 1 ], s [ i ]): dp += dp2 dp2 = dp1 dp1 = dp return dp1 def isValid ( self , a : chr , b = None ) -> bool : if b : return a == '1' or ( a == '2' and b <= '6' ) return a != '0'","title":"91. Decode Ways $\\star\\star$"},{"location":"python3/0001-0100/0091-0100/#92-reverse-linked-list-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class Solution : def reverseBetween ( self , head : ListNode , m : int , n : int ) -> ListNode : if not head : return None prev = None curr = head for _ in range ( m - 1 ): prev = curr curr = curr . next conn = prev tail = curr for _ in range ( n - m + 1 ): next = curr . next curr . next = prev prev = curr curr = next if conn : conn . next = prev else : head = prev tail . next = curr return head","title":"92. Reverse Linked List II $\\star\\star$"},{"location":"python3/0001-0100/0091-0100/#93-restore-ip-addresses-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def restoreIpAddresses ( self , s : str ) -> List [ str ]: ans = [] self . dfs ( s , 0 , 0 , [ \"\" ] * 4 , ans ) return ans def dfs ( self , s : str , depth : int , index : int , path : List [ str ], ans : List [ str ]) -> None : if depth == 4 and index == len ( s ): ans . append ( \".\" . join ( path )) return if depth == 4 or index == len ( s ): return for i in range ( 1 , 4 ): if index + i > len ( s ): return if i > 1 and s [ index ] == '0' : return temp = s [ index : index + i ] if int ( temp ) > 255 : return path [ depth ] = temp self . dfs ( s , depth + 1 , index + i , path , ans ) path [ depth ] = \"\"","title":"93. Restore IP Addresses $\\star\\star$"},{"location":"python3/0001-0100/0091-0100/#94-binary-tree-inorder-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def inorderTraversal ( self , root : TreeNode ) -> List [ int ]: ans = [] stack = [] curr = root while curr or stack : while curr : stack . append ( curr ) curr = curr . left curr = stack . pop () ans . append ( curr . val ) curr = curr . right return ans","title":"94. Binary Tree Inorder Traversal $\\star\\star$"},{"location":"python3/0001-0100/0091-0100/#95-unique-binary-search-trees-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def generateTrees ( self , n : int ) -> List [ TreeNode ]: if n == 0 : return [] return self . helper ( 1 , n ) def helper ( self , min : int , max : int ) -> List [ TreeNode ]: ans = [] if min > max : ans . append ( None ) return ans for i in range ( min , max + 1 ): leftTree = self . helper ( min , i - 1 ) rightTree = self . helper ( i + 1 , max ) for left in leftTree : for right in rightTree : root = TreeNode ( i ) root . left = left root . right = right ans . append ( root ) return ans","title":"95. Unique Binary Search Trees II $\\star\\star$"},{"location":"python3/0001-0100/0091-0100/#96-unique-binary-search-trees-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def numTrees ( self , n : int ) -> int : G = [ 0 ] * ( n + 1 ) G [ 0 ] = 1 G [ 1 ] = 1 for i in range ( 2 , n + 1 ): for j in range ( i ): G [ i ] += G [ j ] * G [ i - j - 1 ] return G [ n ]","title":"96. Unique Binary Search Trees $\\star\\star$"},{"location":"python3/0001-0100/0091-0100/#97-interleaving-string-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def isInterleave ( self , s1 : str , s2 : str , s3 : str ) -> bool : if len ( s1 ) + len ( s2 ) != len ( s3 ): return False dp = [ False ] * ( len ( s2 ) + 1 ) for i in range ( len ( s1 ) + 1 ): for j in range ( len ( s2 ) + 1 ): if i == 0 and j == 0 : dp [ j ] = True elif i == 0 : dp [ j ] = dp [ j - 1 ] and s2 [ j - 1 ] == s3 [ i + j - 1 ] elif j == 0 : dp [ j ] = dp [ j ] and s1 [ i - 1 ] == s3 [ i + j - 1 ] else : dp [ j ] = ( dp [ j ] and s1 [ i - 1 ] == s3 [ i + j - 1 ]) or ( dp [ j - 1 ] and s2 [ j - 1 ] == s3 [ i + j - 1 ]) return dp [ len ( s2 )]","title":"97. Interleaving String $\\star\\star\\star$"},{"location":"python3/0001-0100/0091-0100/#98-validate-binary-search-tree-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution : def isValidBST ( self , root : TreeNode ) -> bool : return self . helper ( root , None , None ) def helper ( self , root : TreeNode , minNode : TreeNode , maxNode : TreeNode ) -> bool : if not root : return True if minNode and root . val <= minNode . val or maxNode and root . val >= maxNode . val : return False return self . helper ( root . left , minNode , root ) and self . helper ( root . right , root , maxNode )","title":"98. Validate Binary Search Tree $\\star\\star$"},{"location":"python3/0001-0100/0091-0100/#99-recover-binary-search-tree-starstarstar","text":"","title":"99. Recover Binary Search Tree $\\star\\star\\star$"},{"location":"python3/0001-0100/0091-0100/#100-same-tree-star","text":"1 2 3 4 5 6 7 8 class Solution : def isSameTree ( self , p : TreeNode , q : TreeNode ) -> bool : if not p or not q : return p == q return p . val == q . val and \\ self . isSameTree ( p . left , q . left ) and \\ self . isSameTree ( p . right , q . right )","title":"100. Same Tree $\\star$"},{"location":"python3/0101-0200/0101-0110/","text":"101. Symmetric Tree $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution : def isSymmetric ( self , root : TreeNode ) -> bool : return self . helper ( root , root ) def helper ( self , p : TreeNode , q : TreeNode ) -> bool : if not p or not q : return p == q return p . val == q . val and \\ self . helper ( p . left , q . right ) and \\ self . helper ( p . right , q . left ) 102. Binary Tree Level Order Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def levelOrder ( self , root : TreeNode ) -> List [ List [ int ]]: if not root : return [] ans = [] queue = collections . deque ([ root ]) while queue : currLevel = [] for _ in range ( len ( queue )): node = queue . popleft () currLevel . append ( node . val ) if node . left : queue . append ( node . left ) if node . right : queue . append ( node . right ) ans . append ( currLevel ) return ans 103. Binary Tree Zigzag Level Order Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def zigzagLevelOrder ( self , root : TreeNode ) -> List [ List [ int ]]: if not root : return [] ans = [] deque = collections . deque ([ root ]) isLeftToRight = True while deque : currLevel = [] for i in range ( len ( deque )): if isLeftToRight : node = deque . popleft () currLevel . append ( node . val ) if node . left : deque . append ( node . left ) if node . right : deque . append ( node . right ) else : node = deque . pop () currLevel . append ( node . val ) if node . right : deque . appendleft ( node . right ) if node . left : deque . appendleft ( node . left ) ans . append ( currLevel ) isLeftToRight = not isLeftToRight return ans 104. Maximum Depth of Binary Tree $\\star$ 1 2 3 4 5 6 class Solution : def maxDepth ( self , root : TreeNode ) -> int : if not root : return 0 return 1 + max ( self . maxDepth ( root . left ), self . maxDepth ( root . right )) 105. Construct Binary Tree from Preorder and Inorder Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def buildTree ( self , preorder : List [ int ], inorder : List [ int ]) -> TreeNode : def helper ( pLeft : int , pRight : int , iLeft : int , iRight : int ) -> TreeNode : if pLeft > pRight or iLeft > iRight : return None i = dict [ preorder [ pLeft ]] curr = TreeNode ( preorder [ pLeft ]) curr . left = helper ( pLeft + 1 , pLeft + i - iLeft , iLeft , i - 1 ) curr . right = helper ( pLeft + i - iLeft + 1 , pRight , i + 1 , iRight ) return curr dict = { val : i for i , val in enumerate ( inorder )} return helper ( 0 , len ( preorder ) - 1 , 0 , len ( inorder ) - 1 ) 106. Construct Binary Tree from Inorder and Postorder Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def buildTree ( self , inorder : List [ int ], postorder : List [ int ]) -> TreeNode : def helper ( iLeft : int , iRight : int , pLeft : int , pRight : int ) -> TreeNode : if iLeft > iRight or pLeft > pRight : return None i = dict [ postorder [ pRight ]] curr = TreeNode ( postorder [ pRight ]) curr . left = helper ( iLeft , i - 1 , pLeft , pLeft + i - iLeft - 1 ) curr . right = helper ( i + 1 , iRight , pLeft + i - iLeft , pRight - 1 ) return curr dict = { val : i for i , val in enumerate ( inorder )} return helper ( 0 , len ( inorder ) - 1 , 0 , len ( postorder ) - 1 ) 107. Binary Tree Level Order Traversal II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def levelOrderBottom ( self , root : TreeNode ) -> List [ List [ int ]]: if not root : return [] ans = [] queue = collections . deque ([ root ]) while queue : currLevel = [] for _ in range ( len ( queue )): node = queue . popleft () currLevel . append ( node . val ) if node . left : queue . append ( node . left ) if node . right : queue . append ( node . right ) ans . insert ( 0 , currLevel ) return ans 108. Convert Sorted Array to Binary Search Tree $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def sortedArrayToBST ( self , nums : List [ int ]) -> TreeNode : return self . helper ( nums , 0 , len ( nums ) - 1 ) def helper ( self , nums : List [ int ], l : int , r : int ) -> TreeNode : if l > r : return None mid = ( l + r ) >> 1 root = TreeNode ( nums [ mid ]) root . left = self . helper ( nums , l , mid - 1 ) root . right = self . helper ( nums , mid + 1 , r ) return root 109. Convert Sorted List to Binary Search Tree $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def sortedListToBST ( self , head : ListNode ) -> TreeNode : def helper ( l , r ): nonlocal head if l > r : return None mid = ( l + r ) >> 1 left = helper ( l , mid - 1 ) node = TreeNode ( head . val ) head = head . next node . left = left node . right = helper ( mid + 1 , r ) return node length = 0 curr = head while curr : length += 1 curr = curr . next return helper ( 0 , length - 1 ) 110. Balanced Binary Tree $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def isBalanced ( self , root : TreeNode ) -> bool : if not root : return True return abs ( self . maxDepth ( root . left ) - self . maxDepth ( root . right )) <= 1 and \\ self . isBalanced ( root . left ) and \\ self . isBalanced ( root . right ) def maxDepth ( self , root : TreeNode ) -> int : if not root : return 0 return 1 + max ( self . maxDepth ( root . left ), self . maxDepth ( root . right ))","title":"0101-0110"},{"location":"python3/0101-0200/0101-0110/#101-symmetric-tree-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution : def isSymmetric ( self , root : TreeNode ) -> bool : return self . helper ( root , root ) def helper ( self , p : TreeNode , q : TreeNode ) -> bool : if not p or not q : return p == q return p . val == q . val and \\ self . helper ( p . left , q . right ) and \\ self . helper ( p . right , q . left )","title":"101. Symmetric Tree $\\star$"},{"location":"python3/0101-0200/0101-0110/#102-binary-tree-level-order-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def levelOrder ( self , root : TreeNode ) -> List [ List [ int ]]: if not root : return [] ans = [] queue = collections . deque ([ root ]) while queue : currLevel = [] for _ in range ( len ( queue )): node = queue . popleft () currLevel . append ( node . val ) if node . left : queue . append ( node . left ) if node . right : queue . append ( node . right ) ans . append ( currLevel ) return ans","title":"102. Binary Tree Level Order Traversal $\\star\\star$"},{"location":"python3/0101-0200/0101-0110/#103-binary-tree-zigzag-level-order-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def zigzagLevelOrder ( self , root : TreeNode ) -> List [ List [ int ]]: if not root : return [] ans = [] deque = collections . deque ([ root ]) isLeftToRight = True while deque : currLevel = [] for i in range ( len ( deque )): if isLeftToRight : node = deque . popleft () currLevel . append ( node . val ) if node . left : deque . append ( node . left ) if node . right : deque . append ( node . right ) else : node = deque . pop () currLevel . append ( node . val ) if node . right : deque . appendleft ( node . right ) if node . left : deque . appendleft ( node . left ) ans . append ( currLevel ) isLeftToRight = not isLeftToRight return ans","title":"103. Binary Tree Zigzag Level Order Traversal $\\star\\star$"},{"location":"python3/0101-0200/0101-0110/#104-maximum-depth-of-binary-tree-star","text":"1 2 3 4 5 6 class Solution : def maxDepth ( self , root : TreeNode ) -> int : if not root : return 0 return 1 + max ( self . maxDepth ( root . left ), self . maxDepth ( root . right ))","title":"104. Maximum Depth of Binary Tree $\\star$"},{"location":"python3/0101-0200/0101-0110/#105-construct-binary-tree-from-preorder-and-inorder-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def buildTree ( self , preorder : List [ int ], inorder : List [ int ]) -> TreeNode : def helper ( pLeft : int , pRight : int , iLeft : int , iRight : int ) -> TreeNode : if pLeft > pRight or iLeft > iRight : return None i = dict [ preorder [ pLeft ]] curr = TreeNode ( preorder [ pLeft ]) curr . left = helper ( pLeft + 1 , pLeft + i - iLeft , iLeft , i - 1 ) curr . right = helper ( pLeft + i - iLeft + 1 , pRight , i + 1 , iRight ) return curr dict = { val : i for i , val in enumerate ( inorder )} return helper ( 0 , len ( preorder ) - 1 , 0 , len ( inorder ) - 1 )","title":"105. Construct Binary Tree from Preorder and Inorder Traversal $\\star\\star$"},{"location":"python3/0101-0200/0101-0110/#106-construct-binary-tree-from-inorder-and-postorder-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def buildTree ( self , inorder : List [ int ], postorder : List [ int ]) -> TreeNode : def helper ( iLeft : int , iRight : int , pLeft : int , pRight : int ) -> TreeNode : if iLeft > iRight or pLeft > pRight : return None i = dict [ postorder [ pRight ]] curr = TreeNode ( postorder [ pRight ]) curr . left = helper ( iLeft , i - 1 , pLeft , pLeft + i - iLeft - 1 ) curr . right = helper ( i + 1 , iRight , pLeft + i - iLeft , pRight - 1 ) return curr dict = { val : i for i , val in enumerate ( inorder )} return helper ( 0 , len ( inorder ) - 1 , 0 , len ( postorder ) - 1 )","title":"106. Construct Binary Tree from Inorder and Postorder Traversal $\\star\\star$"},{"location":"python3/0101-0200/0101-0110/#107-binary-tree-level-order-traversal-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def levelOrderBottom ( self , root : TreeNode ) -> List [ List [ int ]]: if not root : return [] ans = [] queue = collections . deque ([ root ]) while queue : currLevel = [] for _ in range ( len ( queue )): node = queue . popleft () currLevel . append ( node . val ) if node . left : queue . append ( node . left ) if node . right : queue . append ( node . right ) ans . insert ( 0 , currLevel ) return ans","title":"107. Binary Tree Level Order Traversal II $\\star$"},{"location":"python3/0101-0200/0101-0110/#108-convert-sorted-array-to-binary-search-tree-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def sortedArrayToBST ( self , nums : List [ int ]) -> TreeNode : return self . helper ( nums , 0 , len ( nums ) - 1 ) def helper ( self , nums : List [ int ], l : int , r : int ) -> TreeNode : if l > r : return None mid = ( l + r ) >> 1 root = TreeNode ( nums [ mid ]) root . left = self . helper ( nums , l , mid - 1 ) root . right = self . helper ( nums , mid + 1 , r ) return root","title":"108. Convert Sorted Array to Binary Search Tree $\\star$"},{"location":"python3/0101-0200/0101-0110/#109-convert-sorted-list-to-binary-search-tree-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def sortedListToBST ( self , head : ListNode ) -> TreeNode : def helper ( l , r ): nonlocal head if l > r : return None mid = ( l + r ) >> 1 left = helper ( l , mid - 1 ) node = TreeNode ( head . val ) head = head . next node . left = left node . right = helper ( mid + 1 , r ) return node length = 0 curr = head while curr : length += 1 curr = curr . next return helper ( 0 , length - 1 )","title":"109. Convert Sorted List to Binary Search Tree $\\star\\star$"},{"location":"python3/0101-0200/0101-0110/#110-balanced-binary-tree-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def isBalanced ( self , root : TreeNode ) -> bool : if not root : return True return abs ( self . maxDepth ( root . left ) - self . maxDepth ( root . right )) <= 1 and \\ self . isBalanced ( root . left ) and \\ self . isBalanced ( root . right ) def maxDepth ( self , root : TreeNode ) -> int : if not root : return 0 return 1 + max ( self . maxDepth ( root . left ), self . maxDepth ( root . right ))","title":"110. Balanced Binary Tree $\\star$"},{"location":"python3/0101-0200/0111-0120/","text":"111. Minimum Depth of Binary Tree $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def minDepth ( self , root : TreeNode ) -> int : if not root : return 0 ans = 0 queue = collections . deque ([ root ]) while queue : ans += 1 for i in range ( len ( queue )): node = queue . popleft () if not node . left and not node . right : return ans if node . left : queue . append ( node . left ) if node . right : queue . append ( node . right ) return - 1 112. Path Sum $\\star$ 1 2 3 4 5 6 7 8 9 class Solution : def hasPathSum ( self , root : TreeNode , sum : int ) -> bool : if not root : return False if root . val == sum and not root . left and not root . right : return True return self . hasPathSum ( root . left , sum - root . val ) or \\ self . hasPathSum ( root . right , sum - root . val ) 113. Path Sum II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def pathSum ( self , root : TreeNode , sum : int ) -> List [ List [ int ]]: ans = [] self . dfs ( root , sum , [], ans ) return ans def dfs ( self , root : TreeNode , sum : int , path : List [ int ], ans : List [ List [ int ]]) -> None : if not root : return if sum == root . val and not root . left and not root . right : ans . append ( path + [ root . val ]) return self . dfs ( root . left , sum - root . val , path + [ root . val ], ans ) self . dfs ( root . right , sum - root . val , path + [ root . val ], ans ) 114. Flatten Binary Tree to Linked List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def flatten ( self , root : TreeNode ) -> None : if not root : return self . flatten ( root . right ) self . flatten ( root . left ) root . right = self . next root . left = None self . next = root next = None 115. Distinct Subsequences $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def numDistinct ( self , s : str , t : str ) -> int : m = len ( s ) n = len ( t ) dp = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( m + 1 ): for j in range ( n + 1 ): if j == 0 : dp [ i ][ j ] = 1 elif i == 0 : dp [ i ][ j ] = 0 else : dp [ i ][ j ] = dp [ i - 1 ][ j ] + \\ ( dp [ i - 1 ][ j - 1 ] if s [ i - 1 ] == t [ j - 1 ] else 0 ) return dp [ m ][ n ] 116. Populating Next Right Pointers in Each Node $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def connect ( self , root : 'Node' ) -> 'Node' : node = root while node and node . left : next = node . left while node : node . left . next = node . right node . right . next = node . next and node . next . left node = node . next node = next return root 117. Populating Next Right Pointers in Each Node II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def connect ( self , root : 'Node' ) -> 'Node' : node = root curr = Node ( None , None , None , None ) prev = curr while node : while node : curr . next = node . left curr = curr . next or curr curr . next = node . right curr = curr . next or curr node = node . next node = prev . next curr = prev return root 118. Pascal's Triangle $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def generate ( self , numRows : int ) -> List [ List [ int ]]: ans = [] for i in range ( numRows ): ans . append ([ 1 ] * ( i + 1 )) for i in range ( 2 , numRows ): for j in range ( 1 , len ( ans [ i ]) - 1 ): ans [ i ][ j ] = ans [ i - 1 ][ j - 1 ] + ans [ i - 1 ][ j ] return ans 119. Pascal's Triangle II $\\star$ 1 2 3 4 5 6 7 8 9 class Solution : def getRow ( self , rowIndex : int ) -> List [ int ]: ans = [ 1 ] * ( rowIndex + 1 ) for i in range ( 2 , rowIndex + 1 ): for j in range ( 1 , i ): ans [ i - j ] += ans [ i - j - 1 ] return ans 120. Triangle $\\star\\star$ 1 2 3 4 5 6 7 8 class Solution : def minimumTotal ( self , triangle : List [ List [ int ]]) -> int : for i in range ( len ( triangle ) - 2 , - 1 , - 1 ): for j in range ( i + 1 ): triangle [ i ][ j ] += min ( triangle [ i + 1 ][ j ], triangle [ i + 1 ][ j + 1 ]) return triangle [ 0 ][ 0 ]","title":"0111-0120"},{"location":"python3/0101-0200/0111-0120/#111-minimum-depth-of-binary-tree-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def minDepth ( self , root : TreeNode ) -> int : if not root : return 0 ans = 0 queue = collections . deque ([ root ]) while queue : ans += 1 for i in range ( len ( queue )): node = queue . popleft () if not node . left and not node . right : return ans if node . left : queue . append ( node . left ) if node . right : queue . append ( node . right ) return - 1","title":"111. Minimum Depth of Binary Tree $\\star$"},{"location":"python3/0101-0200/0111-0120/#112-path-sum-star","text":"1 2 3 4 5 6 7 8 9 class Solution : def hasPathSum ( self , root : TreeNode , sum : int ) -> bool : if not root : return False if root . val == sum and not root . left and not root . right : return True return self . hasPathSum ( root . left , sum - root . val ) or \\ self . hasPathSum ( root . right , sum - root . val )","title":"112. Path Sum $\\star$"},{"location":"python3/0101-0200/0111-0120/#113-path-sum-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def pathSum ( self , root : TreeNode , sum : int ) -> List [ List [ int ]]: ans = [] self . dfs ( root , sum , [], ans ) return ans def dfs ( self , root : TreeNode , sum : int , path : List [ int ], ans : List [ List [ int ]]) -> None : if not root : return if sum == root . val and not root . left and not root . right : ans . append ( path + [ root . val ]) return self . dfs ( root . left , sum - root . val , path + [ root . val ], ans ) self . dfs ( root . right , sum - root . val , path + [ root . val ], ans )","title":"113. Path Sum II $\\star\\star$"},{"location":"python3/0101-0200/0111-0120/#114-flatten-binary-tree-to-linked-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def flatten ( self , root : TreeNode ) -> None : if not root : return self . flatten ( root . right ) self . flatten ( root . left ) root . right = self . next root . left = None self . next = root next = None","title":"114. Flatten Binary Tree to Linked List $\\star\\star$"},{"location":"python3/0101-0200/0111-0120/#115-distinct-subsequences-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def numDistinct ( self , s : str , t : str ) -> int : m = len ( s ) n = len ( t ) dp = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( m + 1 ): for j in range ( n + 1 ): if j == 0 : dp [ i ][ j ] = 1 elif i == 0 : dp [ i ][ j ] = 0 else : dp [ i ][ j ] = dp [ i - 1 ][ j ] + \\ ( dp [ i - 1 ][ j - 1 ] if s [ i - 1 ] == t [ j - 1 ] else 0 ) return dp [ m ][ n ]","title":"115. Distinct Subsequences $\\star\\star\\star$"},{"location":"python3/0101-0200/0111-0120/#116-populating-next-right-pointers-in-each-node-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def connect ( self , root : 'Node' ) -> 'Node' : node = root while node and node . left : next = node . left while node : node . left . next = node . right node . right . next = node . next and node . next . left node = node . next node = next return root","title":"116. Populating Next Right Pointers in Each Node $\\star\\star$"},{"location":"python3/0101-0200/0111-0120/#117-populating-next-right-pointers-in-each-node-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def connect ( self , root : 'Node' ) -> 'Node' : node = root curr = Node ( None , None , None , None ) prev = curr while node : while node : curr . next = node . left curr = curr . next or curr curr . next = node . right curr = curr . next or curr node = node . next node = prev . next curr = prev return root","title":"117. Populating Next Right Pointers in Each Node II $\\star\\star$"},{"location":"python3/0101-0200/0111-0120/#118-pascals-triangle-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def generate ( self , numRows : int ) -> List [ List [ int ]]: ans = [] for i in range ( numRows ): ans . append ([ 1 ] * ( i + 1 )) for i in range ( 2 , numRows ): for j in range ( 1 , len ( ans [ i ]) - 1 ): ans [ i ][ j ] = ans [ i - 1 ][ j - 1 ] + ans [ i - 1 ][ j ] return ans","title":"118. Pascal's Triangle $\\star$"},{"location":"python3/0101-0200/0111-0120/#119-pascals-triangle-ii-star","text":"1 2 3 4 5 6 7 8 9 class Solution : def getRow ( self , rowIndex : int ) -> List [ int ]: ans = [ 1 ] * ( rowIndex + 1 ) for i in range ( 2 , rowIndex + 1 ): for j in range ( 1 , i ): ans [ i - j ] += ans [ i - j - 1 ] return ans","title":"119. Pascal's Triangle II $\\star$"},{"location":"python3/0101-0200/0111-0120/#120-triangle-starstar","text":"1 2 3 4 5 6 7 8 class Solution : def minimumTotal ( self , triangle : List [ List [ int ]]) -> int : for i in range ( len ( triangle ) - 2 , - 1 , - 1 ): for j in range ( i + 1 ): triangle [ i ][ j ] += min ( triangle [ i + 1 ][ j ], triangle [ i + 1 ][ j + 1 ]) return triangle [ 0 ][ 0 ]","title":"120. Triangle $\\star\\star$"},{"location":"python3/0101-0200/0121-0130/","text":"121. Best Time to Buy and Sell Stock $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution : def maxProfit ( self , prices : List [ int ]) -> int : sellOne = 0 holdOne = float ( '-inf' ) for price in prices : sellOne = max ( sellOne , holdOne + price ) holdOne = max ( holdOne , - price ) return sellOne 122. Best Time to Buy and Sell Stock II $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution : def maxProfit ( self , prices : List [ int ]) -> int : sell = 0 hold = float ( '-inf' ) for price in prices : sell = max ( sell , hold + price ) hold = max ( hold , sell - price ) return sell 123. Best Time to Buy and Sell Stock III $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def maxProfit ( self , prices : List [ int ]) -> int : sellTwo = 0 holdTwo = float ( '-inf' ) sellOne = 0 holdOne = float ( '-inf' ) for price in prices : sellTwo = max ( sellTwo , holdTwo + price ) holdTwo = max ( holdTwo , sellOne - price ) sellOne = max ( sellOne , holdOne + price ) holdOne = max ( holdOne , - price ) return sellTwo 124. Binary Tree Maximum Path Sum $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def maxPathSum ( self , root : TreeNode ) -> int : self . helper ( root ) return self . ans ans = float ( '-inf' ) def helper ( self , root : TreeNode ) -> int : if not root : return 0 left = max ( self . helper ( root . left ), 0 ) right = max ( self . helper ( root . right ), 0 ) self . ans = max ( self . ans , root . val + left + right ) return root . val + max ( left , right ) 125. Valid Palindrome $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def isPalindrome ( self , s : str ) -> bool : l = 0 r = len ( s ) - 1 while l < r : while l < r and not s [ l ] . isalnum (): l += 1 while l < r and not s [ r ] . isalnum (): r -= 1 if s [ l ] . lower () != s [ r ] . lower (): return False l += 1 r -= 1 return True 126. Word Ladder II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution : def findLadders ( self , beginWord : str , endWord : str , wordList : List [ str ]) -> List [ List [ str ]]: def dfs ( word : str , path : List [ str ]) -> None : if word == endWord : ans . append ( path ) return if word not in dict : return for child in dict [ word ]: dfs ( child , path + [ child ]) ans = [] set_ = set ( wordList ) if endWord not in set_ : return ans set1 = set ([ beginWord ]) dict = collections . defaultdict ( list ) isFound = False while set1 and not isFound : for word in set1 : set_ . discard ( word ) tempSet = set () for parent in set1 : for i in range ( len ( parent )): for j in string . ascii_lowercase : newWord = parent [: i ] + j + parent [ i + 1 :] if newWord == endWord : dict [ parent ] . append ( newWord ) isFound = True elif newWord in set_ and not isFound : tempSet . add ( newWord ) dict [ parent ] . append ( newWord ) set1 = tempSet if isFound : dfs ( beginWord , [ beginWord ]) return ans 127. Word Ladder $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def ladderLength ( self , beginWord : str , endWord : str , wordList : List [ str ]) -> int : set_ = set ( wordList ) if endWord not in set_ : return 0 ans = 0 set1 = set ([ beginWord ]) set2 = set ([ endWord ]) while set1 and set2 : ans += 1 if len ( set1 ) > len ( set2 ): set1 , set2 = set2 , set1 tempSet = set () for word in set1 : for i in range ( len ( word )): for j in string . ascii_lowercase : newWord = word [: i ] + j + word [ i + 1 :] if newWord in set2 : return ans + 1 if newWord not in set_ : continue set_ . remove ( newWord ) tempSet . add ( newWord ) set1 = tempSet return 0 128. Longest Consecutive Sequence $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def longestConsecutive ( self , nums : List [ int ]) -> int : ans = 0 set_ = set ( nums ) for num in nums : if num - 1 not in set_ : length = 0 while num in set_ : num += 1 length += 1 ans = max ( ans , length ) return ans 129. Sum Root to Leaf Numbers $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def sumNumbers ( self , root : TreeNode ) -> int : self . dfs ( root , 0 ) return self . ans ans = 0 def dfs ( self , root : TreeNode , path : int ) -> None : if not root : return if not root . left and not root . right : self . ans += ( path * 10 + root . val ) return self . dfs ( root . left , path * 10 + root . val ) self . dfs ( root . right , path * 10 + root . val ) 130. Surrounded Regions $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def solve ( self , board : List [ List [ str ]]) -> None : if not board : return m = len ( board ) n = len ( board [ 0 ]) for i in range ( m ): self . dfs ( board , i , 0 ) self . dfs ( board , i , n - 1 ) for j in range ( 1 , n - 1 ): self . dfs ( board , 0 , j ) self . dfs ( board , m - 1 , j ) for i in range ( m ): for j in range ( n ): board [ i ][ j ] = 'O' if board [ i ][ j ] == '.' else 'X' def dfs ( self , board : List [ List [ str ]], i : int , j : int ) -> None : if i < 0 or j < 0 or i >= len ( board ) or j >= len ( board [ 0 ]) or board [ i ][ j ] != 'O' : return board [ i ][ j ] = '.' self . dfs ( board , i , j + 1 ) self . dfs ( board , i , j - 1 ) self . dfs ( board , i + 1 , j ) self . dfs ( board , i - 1 , j )","title":"0121-0130"},{"location":"python3/0101-0200/0121-0130/#121-best-time-to-buy-and-sell-stock-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution : def maxProfit ( self , prices : List [ int ]) -> int : sellOne = 0 holdOne = float ( '-inf' ) for price in prices : sellOne = max ( sellOne , holdOne + price ) holdOne = max ( holdOne , - price ) return sellOne","title":"121. Best Time to Buy and Sell Stock $\\star$"},{"location":"python3/0101-0200/0121-0130/#122-best-time-to-buy-and-sell-stock-ii-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution : def maxProfit ( self , prices : List [ int ]) -> int : sell = 0 hold = float ( '-inf' ) for price in prices : sell = max ( sell , hold + price ) hold = max ( hold , sell - price ) return sell","title":"122. Best Time to Buy and Sell Stock II $\\star$"},{"location":"python3/0101-0200/0121-0130/#123-best-time-to-buy-and-sell-stock-iii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def maxProfit ( self , prices : List [ int ]) -> int : sellTwo = 0 holdTwo = float ( '-inf' ) sellOne = 0 holdOne = float ( '-inf' ) for price in prices : sellTwo = max ( sellTwo , holdTwo + price ) holdTwo = max ( holdTwo , sellOne - price ) sellOne = max ( sellOne , holdOne + price ) holdOne = max ( holdOne , - price ) return sellTwo","title":"123. Best Time to Buy and Sell Stock III $\\star\\star\\star$"},{"location":"python3/0101-0200/0121-0130/#124-binary-tree-maximum-path-sum-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def maxPathSum ( self , root : TreeNode ) -> int : self . helper ( root ) return self . ans ans = float ( '-inf' ) def helper ( self , root : TreeNode ) -> int : if not root : return 0 left = max ( self . helper ( root . left ), 0 ) right = max ( self . helper ( root . right ), 0 ) self . ans = max ( self . ans , root . val + left + right ) return root . val + max ( left , right )","title":"124. Binary Tree Maximum Path Sum $\\star\\star\\star$"},{"location":"python3/0101-0200/0121-0130/#125-valid-palindrome-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def isPalindrome ( self , s : str ) -> bool : l = 0 r = len ( s ) - 1 while l < r : while l < r and not s [ l ] . isalnum (): l += 1 while l < r and not s [ r ] . isalnum (): r -= 1 if s [ l ] . lower () != s [ r ] . lower (): return False l += 1 r -= 1 return True","title":"125. Valid Palindrome $\\star$"},{"location":"python3/0101-0200/0121-0130/#126-word-ladder-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class Solution : def findLadders ( self , beginWord : str , endWord : str , wordList : List [ str ]) -> List [ List [ str ]]: def dfs ( word : str , path : List [ str ]) -> None : if word == endWord : ans . append ( path ) return if word not in dict : return for child in dict [ word ]: dfs ( child , path + [ child ]) ans = [] set_ = set ( wordList ) if endWord not in set_ : return ans set1 = set ([ beginWord ]) dict = collections . defaultdict ( list ) isFound = False while set1 and not isFound : for word in set1 : set_ . discard ( word ) tempSet = set () for parent in set1 : for i in range ( len ( parent )): for j in string . ascii_lowercase : newWord = parent [: i ] + j + parent [ i + 1 :] if newWord == endWord : dict [ parent ] . append ( newWord ) isFound = True elif newWord in set_ and not isFound : tempSet . add ( newWord ) dict [ parent ] . append ( newWord ) set1 = tempSet if isFound : dfs ( beginWord , [ beginWord ]) return ans","title":"126. Word Ladder II $\\star\\star\\star$"},{"location":"python3/0101-0200/0121-0130/#127-word-ladder-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def ladderLength ( self , beginWord : str , endWord : str , wordList : List [ str ]) -> int : set_ = set ( wordList ) if endWord not in set_ : return 0 ans = 0 set1 = set ([ beginWord ]) set2 = set ([ endWord ]) while set1 and set2 : ans += 1 if len ( set1 ) > len ( set2 ): set1 , set2 = set2 , set1 tempSet = set () for word in set1 : for i in range ( len ( word )): for j in string . ascii_lowercase : newWord = word [: i ] + j + word [ i + 1 :] if newWord in set2 : return ans + 1 if newWord not in set_ : continue set_ . remove ( newWord ) tempSet . add ( newWord ) set1 = tempSet return 0","title":"127. Word Ladder $\\star\\star$"},{"location":"python3/0101-0200/0121-0130/#128-longest-consecutive-sequence-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def longestConsecutive ( self , nums : List [ int ]) -> int : ans = 0 set_ = set ( nums ) for num in nums : if num - 1 not in set_ : length = 0 while num in set_ : num += 1 length += 1 ans = max ( ans , length ) return ans","title":"128. Longest Consecutive Sequence $\\star\\star\\star$"},{"location":"python3/0101-0200/0121-0130/#129-sum-root-to-leaf-numbers-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def sumNumbers ( self , root : TreeNode ) -> int : self . dfs ( root , 0 ) return self . ans ans = 0 def dfs ( self , root : TreeNode , path : int ) -> None : if not root : return if not root . left and not root . right : self . ans += ( path * 10 + root . val ) return self . dfs ( root . left , path * 10 + root . val ) self . dfs ( root . right , path * 10 + root . val )","title":"129. Sum Root to Leaf Numbers $\\star\\star$"},{"location":"python3/0101-0200/0121-0130/#130-surrounded-regions-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def solve ( self , board : List [ List [ str ]]) -> None : if not board : return m = len ( board ) n = len ( board [ 0 ]) for i in range ( m ): self . dfs ( board , i , 0 ) self . dfs ( board , i , n - 1 ) for j in range ( 1 , n - 1 ): self . dfs ( board , 0 , j ) self . dfs ( board , m - 1 , j ) for i in range ( m ): for j in range ( n ): board [ i ][ j ] = 'O' if board [ i ][ j ] == '.' else 'X' def dfs ( self , board : List [ List [ str ]], i : int , j : int ) -> None : if i < 0 or j < 0 or i >= len ( board ) or j >= len ( board [ 0 ]) or board [ i ][ j ] != 'O' : return board [ i ][ j ] = '.' self . dfs ( board , i , j + 1 ) self . dfs ( board , i , j - 1 ) self . dfs ( board , i + 1 , j ) self . dfs ( board , i - 1 , j )","title":"130. Surrounded Regions $\\star\\star$"},{"location":"python3/0101-0200/0131-0140/","text":"131. Palindrome Partitioning $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def partition ( self , s : str ) -> List [ List [ str ]]: ans = [] self . dfs ( s , 0 , [], ans ) return ans def dfs ( self , s : str , j : int , path : List [ str ], ans : List [ List [ str ]]) -> None : if j == len ( s ): ans . append ( path ) return for i in range ( j , len ( s )): if self . isPalindrome ( s [ j : i + 1 ]): self . dfs ( s , i + 1 , path + [ s [ j : i + 1 ]], ans ) def isPalindrome ( self , s : str ) -> bool : return s == s [:: - 1 ] 132. Palindrome Partitioning II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def minCut ( self , s : str ) -> int : n = len ( s ) cut = [ 0 ] * n dp = [[ False ] * n for _ in range ( n )] for i in range ( n ): min_ = i for j in range ( i + 1 ): if s [ j ] == s [ i ] and ( j + 1 > i - 1 or dp [ j + 1 ][ i - 1 ]): dp [ j ][ i ] = True min_ = 0 if j == 0 else min ( min_ , cut [ j - 1 ] + 1 ) cut [ i ] = min_ return cut [ n - 1 ] 133. Clone Graph $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def cloneGraph ( self , node : 'Node' ) -> 'Node' : if not node : return None if node in self . dict : return self . dict [ node ] self . dict [ node ] = Node ( node . val , []) for neighbor in node . neighbors : self . dict [ node ] . neighbors . append ( self . cloneGraph ( neighbor )) return self . dict [ node ] dict = {} 134. Gas Station $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def canCompleteCircuit ( self , gas : List [ int ], cost : List [ int ]) -> int : ans = 0 net = 0 sum = 0 for i in range ( len ( gas )): net += gas [ i ] - cost [ i ] sum += gas [ i ] - cost [ i ] if sum < 0 : sum = 0 ans = i + 1 return - 1 if net < 0 else ans 135. Candy $\\star\\star\\star$ 136. Single Number $\\star$ 1 2 3 4 5 6 7 8 class Solution : def singleNumber ( self , nums : List [ int ]) -> int : ans = 0 for num in nums : ans ^= num return ans 137. Single Number II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution : def singleNumber ( self , nums : List [ int ]) -> int : ones = 0 twos = 0 for num in nums : ones ^= ( num & ~ twos ) twos ^= ( num & ~ ones ) return ones 138. Copy List with Random Pointer $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def copyRandomList ( self , head : 'Node' ) -> 'Node' : if not head : return None if head in self . dict : return self . dict [ head ] self . dict [ head ] = Node ( head . val , None , None ) self . dict [ head ] . next = self . copyRandomList ( head . next ) self . dict [ head ] . random = self . copyRandomList ( head . random ) return self . dict [ head ] dict = {} 139. Word Break $\\star\\star$ 140. Word Break II $\\star\\star\\star$","title":"0131-0140"},{"location":"python3/0101-0200/0131-0140/#131-palindrome-partitioning-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def partition ( self , s : str ) -> List [ List [ str ]]: ans = [] self . dfs ( s , 0 , [], ans ) return ans def dfs ( self , s : str , j : int , path : List [ str ], ans : List [ List [ str ]]) -> None : if j == len ( s ): ans . append ( path ) return for i in range ( j , len ( s )): if self . isPalindrome ( s [ j : i + 1 ]): self . dfs ( s , i + 1 , path + [ s [ j : i + 1 ]], ans ) def isPalindrome ( self , s : str ) -> bool : return s == s [:: - 1 ]","title":"131. Palindrome Partitioning $\\star\\star$"},{"location":"python3/0101-0200/0131-0140/#132-palindrome-partitioning-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def minCut ( self , s : str ) -> int : n = len ( s ) cut = [ 0 ] * n dp = [[ False ] * n for _ in range ( n )] for i in range ( n ): min_ = i for j in range ( i + 1 ): if s [ j ] == s [ i ] and ( j + 1 > i - 1 or dp [ j + 1 ][ i - 1 ]): dp [ j ][ i ] = True min_ = 0 if j == 0 else min ( min_ , cut [ j - 1 ] + 1 ) cut [ i ] = min_ return cut [ n - 1 ]","title":"132. Palindrome Partitioning II $\\star\\star\\star$"},{"location":"python3/0101-0200/0131-0140/#133-clone-graph-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def cloneGraph ( self , node : 'Node' ) -> 'Node' : if not node : return None if node in self . dict : return self . dict [ node ] self . dict [ node ] = Node ( node . val , []) for neighbor in node . neighbors : self . dict [ node ] . neighbors . append ( self . cloneGraph ( neighbor )) return self . dict [ node ] dict = {}","title":"133. Clone Graph $\\star\\star$"},{"location":"python3/0101-0200/0131-0140/#134-gas-station-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def canCompleteCircuit ( self , gas : List [ int ], cost : List [ int ]) -> int : ans = 0 net = 0 sum = 0 for i in range ( len ( gas )): net += gas [ i ] - cost [ i ] sum += gas [ i ] - cost [ i ] if sum < 0 : sum = 0 ans = i + 1 return - 1 if net < 0 else ans","title":"134. Gas Station $\\star\\star$"},{"location":"python3/0101-0200/0131-0140/#135-candy-starstarstar","text":"","title":"135. Candy $\\star\\star\\star$"},{"location":"python3/0101-0200/0131-0140/#136-single-number-star","text":"1 2 3 4 5 6 7 8 class Solution : def singleNumber ( self , nums : List [ int ]) -> int : ans = 0 for num in nums : ans ^= num return ans","title":"136. Single Number $\\star$"},{"location":"python3/0101-0200/0131-0140/#137-single-number-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 class Solution : def singleNumber ( self , nums : List [ int ]) -> int : ones = 0 twos = 0 for num in nums : ones ^= ( num & ~ twos ) twos ^= ( num & ~ ones ) return ones","title":"137. Single Number II $\\star\\star$"},{"location":"python3/0101-0200/0131-0140/#138-copy-list-with-random-pointer-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def copyRandomList ( self , head : 'Node' ) -> 'Node' : if not head : return None if head in self . dict : return self . dict [ head ] self . dict [ head ] = Node ( head . val , None , None ) self . dict [ head ] . next = self . copyRandomList ( head . next ) self . dict [ head ] . random = self . copyRandomList ( head . random ) return self . dict [ head ] dict = {}","title":"138. Copy List with Random Pointer $\\star\\star$"},{"location":"python3/0101-0200/0131-0140/#139-word-break-starstar","text":"","title":"139. Word Break $\\star\\star$"},{"location":"python3/0101-0200/0131-0140/#140-word-break-ii-starstarstar","text":"","title":"140. Word Break II $\\star\\star\\star$"},{"location":"python3/0101-0200/0141-0150/","text":"141. Linked List Cycle $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def hasCycle ( self , head : ListNode ) -> bool : slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next if slow == fast : return True return False 142. Linked List Cycle II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def detectCycle ( self , head : ListNode ) -> ListNode : slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next if slow == fast : slow = head while slow != fast : slow = slow . next fast = fast . next return slow return None 143. Reorder List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution : def reorderList ( self , head : ListNode ) -> None : if not head or not head . next : return prev = None slow = head fast = head l1 = head while fast and fast . next : prev = slow slow = slow . next fast = fast . next . next prev . next = None l2 = self . reverse ( slow ) self . merge ( l1 , l2 ) def reverse ( self , head : ListNode ) -> ListNode : prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev def merge ( self , l1 : ListNode , l2 : ListNode ) -> None : while l2 : next = l1 . next l1 . next = l2 l1 = l2 l2 = next 144. Binary Tree Preorder Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def preorderTraversal ( self , root : TreeNode ) -> List [ int ]: if not root : return [] ans = [] stack = [ root ] while stack : node = stack . pop () ans . append ( node . val ) if node . right : stack . append ( node . right ) if node . left : stack . append ( node . left ) return ans 145. Binary Tree Postorder Traversal $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def postorderTraversal ( self , root : TreeNode ) -> List [ int ]: if not root : return [] ans = [] stack = [ root ] while stack : node = stack . pop () ans . append ( node . val ) if node . left : stack . append ( node . left ) if node . right : stack . append ( node . right ) return ans [:: - 1 ] 146. LRU Cache $\\star\\star$ 147. Insertion Sort List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def insertionSortList ( self , head : ListNode ) -> ListNode : dummy = ListNode ( 0 ) curr = head while curr : prev = dummy while prev . next and prev . next . val < curr . val : prev = prev . next next = curr . next curr . next = prev . next prev . next = curr curr = next return dummy . next 148. Sort List $\\star\\star$ 149. Max Points on a Line $\\star\\star\\star$ 150. Evaluate Reverse Polish Notation $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def evalRPN ( self , tokens : List [ str ]) -> int : stack = [] for token in tokens : if token == \"+\" : b = stack . pop () a = stack . pop () stack . append ( a + b ) elif token == \"-\" : b = stack . pop () a = stack . pop () stack . append ( a - b ) elif token == \"*\" : b = stack . pop () a = stack . pop () stack . append ( a * b ) elif token == \"/\" : b = stack . pop () a = stack . pop () stack . append ( int ( float ( a ) / b )) else : stack . append ( int ( token )) return stack . pop ()","title":"0141-0150"},{"location":"python3/0101-0200/0141-0150/#141-linked-list-cycle-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def hasCycle ( self , head : ListNode ) -> bool : slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next if slow == fast : return True return False","title":"141. Linked List Cycle $\\star$"},{"location":"python3/0101-0200/0141-0150/#142-linked-list-cycle-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def detectCycle ( self , head : ListNode ) -> ListNode : slow = head fast = head while fast and fast . next : slow = slow . next fast = fast . next . next if slow == fast : slow = head while slow != fast : slow = slow . next fast = fast . next return slow return None","title":"142. Linked List Cycle II $\\star\\star$"},{"location":"python3/0101-0200/0141-0150/#143-reorder-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 class Solution : def reorderList ( self , head : ListNode ) -> None : if not head or not head . next : return prev = None slow = head fast = head l1 = head while fast and fast . next : prev = slow slow = slow . next fast = fast . next . next prev . next = None l2 = self . reverse ( slow ) self . merge ( l1 , l2 ) def reverse ( self , head : ListNode ) -> ListNode : prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev def merge ( self , l1 : ListNode , l2 : ListNode ) -> None : while l2 : next = l1 . next l1 . next = l2 l1 = l2 l2 = next","title":"143. Reorder List $\\star\\star$"},{"location":"python3/0101-0200/0141-0150/#144-binary-tree-preorder-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def preorderTraversal ( self , root : TreeNode ) -> List [ int ]: if not root : return [] ans = [] stack = [ root ] while stack : node = stack . pop () ans . append ( node . val ) if node . right : stack . append ( node . right ) if node . left : stack . append ( node . left ) return ans","title":"144. Binary Tree Preorder Traversal $\\star\\star$"},{"location":"python3/0101-0200/0141-0150/#145-binary-tree-postorder-traversal-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def postorderTraversal ( self , root : TreeNode ) -> List [ int ]: if not root : return [] ans = [] stack = [ root ] while stack : node = stack . pop () ans . append ( node . val ) if node . left : stack . append ( node . left ) if node . right : stack . append ( node . right ) return ans [:: - 1 ]","title":"145. Binary Tree Postorder Traversal $\\star\\star\\star$"},{"location":"python3/0101-0200/0141-0150/#146-lru-cache-starstar","text":"","title":"146. LRU Cache $\\star\\star$"},{"location":"python3/0101-0200/0141-0150/#147-insertion-sort-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def insertionSortList ( self , head : ListNode ) -> ListNode : dummy = ListNode ( 0 ) curr = head while curr : prev = dummy while prev . next and prev . next . val < curr . val : prev = prev . next next = curr . next curr . next = prev . next prev . next = curr curr = next return dummy . next","title":"147. Insertion Sort List $\\star\\star$"},{"location":"python3/0101-0200/0141-0150/#148-sort-list-starstar","text":"","title":"148. Sort List $\\star\\star$"},{"location":"python3/0101-0200/0141-0150/#149-max-points-on-a-line-starstarstar","text":"","title":"149. Max Points on a Line $\\star\\star\\star$"},{"location":"python3/0101-0200/0141-0150/#150-evaluate-reverse-polish-notation-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def evalRPN ( self , tokens : List [ str ]) -> int : stack = [] for token in tokens : if token == \"+\" : b = stack . pop () a = stack . pop () stack . append ( a + b ) elif token == \"-\" : b = stack . pop () a = stack . pop () stack . append ( a - b ) elif token == \"*\" : b = stack . pop () a = stack . pop () stack . append ( a * b ) elif token == \"/\" : b = stack . pop () a = stack . pop () stack . append ( int ( float ( a ) / b )) else : stack . append ( int ( token )) return stack . pop ()","title":"150. Evaluate Reverse Polish Notation $\\star\\star$"},{"location":"python3/0101-0200/0151-0160/","text":"151. Reverse Words in a String $\\star\\star$ 152. Maximum Product Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def maxProduct ( self , nums : List [ int ]) -> int : ans = nums [ 0 ] prevMin = nums [ 0 ] prevMax = nums [ 0 ] for i in range ( 1 , len ( nums )): min_ = prevMin * nums [ i ] max_ = prevMax * nums [ i ] prevMin = min ( nums [ i ], min_ , max_ ) prevMax = max ( nums [ i ], min_ , max_ ) ans = max ( ans , prevMax ) return ans 153. Find Minimum in Rotated Sorted Array $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def findMin ( self , nums : List [ int ]) -> int : l = 0 r = len ( nums ) - 1 while l < r : m = ( l + r ) // 2 if nums [ m ] < nums [ r ]: r = m else : l = m + 1 return nums [ l ] 154. Find Minimum in Rotated Sorted Array II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def findMin ( self , nums : List [ int ]) -> int : l = 0 r = len ( nums ) - 1 while l < r : m = ( l + r ) // 2 if nums [ m ] == nums [ r ]: r -= 1 elif nums [ m ] < nums [ r ]: r = m else : l = m + 1 return nums [ l ] 155. Min Stack $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MinStack : def __init__ ( self ): self . stack = [] def push ( self , x : int ) -> None : min_ = x if not self . stack else min ( self . stack [ - 1 ][ 1 ], x ) self . stack . append ([ x , min_ ]) def pop ( self ) -> None : self . stack . pop () def top ( self ) -> int : return self . stack [ - 1 ][ 0 ] def getMin ( self ) -> int : return self . stack [ - 1 ][ 1 ] 156. Binary Tree Upside Down $\\star\\star$ 157. Read N Characters Given Read4 $\\star$ 158. Read N Characters Given Read4 II - Call multiple times $\\star\\star\\star$ 159. Longest Substring with At Most Two Distinct Characters $\\star\\star$ 160. Intersection of Two Linked Lists $\\star$","title":"0151-0160"},{"location":"python3/0101-0200/0151-0160/#151-reverse-words-in-a-string-starstar","text":"","title":"151. Reverse Words in a String $\\star\\star$"},{"location":"python3/0101-0200/0151-0160/#152-maximum-product-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def maxProduct ( self , nums : List [ int ]) -> int : ans = nums [ 0 ] prevMin = nums [ 0 ] prevMax = nums [ 0 ] for i in range ( 1 , len ( nums )): min_ = prevMin * nums [ i ] max_ = prevMax * nums [ i ] prevMin = min ( nums [ i ], min_ , max_ ) prevMax = max ( nums [ i ], min_ , max_ ) ans = max ( ans , prevMax ) return ans","title":"152. Maximum Product Subarray $\\star\\star$"},{"location":"python3/0101-0200/0151-0160/#153-find-minimum-in-rotated-sorted-array-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def findMin ( self , nums : List [ int ]) -> int : l = 0 r = len ( nums ) - 1 while l < r : m = ( l + r ) // 2 if nums [ m ] < nums [ r ]: r = m else : l = m + 1 return nums [ l ]","title":"153. Find Minimum in Rotated Sorted Array $\\star\\star$"},{"location":"python3/0101-0200/0151-0160/#154-find-minimum-in-rotated-sorted-array-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def findMin ( self , nums : List [ int ]) -> int : l = 0 r = len ( nums ) - 1 while l < r : m = ( l + r ) // 2 if nums [ m ] == nums [ r ]: r -= 1 elif nums [ m ] < nums [ r ]: r = m else : l = m + 1 return nums [ l ]","title":"154. Find Minimum in Rotated Sorted Array II $\\star\\star\\star$"},{"location":"python3/0101-0200/0151-0160/#155-min-stack-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class MinStack : def __init__ ( self ): self . stack = [] def push ( self , x : int ) -> None : min_ = x if not self . stack else min ( self . stack [ - 1 ][ 1 ], x ) self . stack . append ([ x , min_ ]) def pop ( self ) -> None : self . stack . pop () def top ( self ) -> int : return self . stack [ - 1 ][ 0 ] def getMin ( self ) -> int : return self . stack [ - 1 ][ 1 ]","title":"155. Min Stack $\\star$"},{"location":"python3/0101-0200/0151-0160/#156-binary-tree-upside-down-starstar","text":"","title":"156. Binary Tree Upside Down $\\star\\star$"},{"location":"python3/0101-0200/0151-0160/#157-read-n-characters-given-read4-star","text":"","title":"157. Read N Characters Given Read4 $\\star$"},{"location":"python3/0101-0200/0151-0160/#158-read-n-characters-given-read4-ii-call-multiple-times-starstarstar","text":"","title":"158. Read N Characters Given Read4 II - Call multiple times $\\star\\star\\star$"},{"location":"python3/0101-0200/0151-0160/#159-longest-substring-with-at-most-two-distinct-characters-starstar","text":"","title":"159. Longest Substring with At Most Two Distinct Characters $\\star\\star$"},{"location":"python3/0101-0200/0151-0160/#160-intersection-of-two-linked-lists-star","text":"","title":"160. Intersection of Two Linked Lists $\\star$"},{"location":"python3/0101-0200/0161-0170/","text":"161. One Edit Distance $\\star\\star$ 162. Find Peak Element $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def findPeakElement ( self , nums : List [ int ]) -> int : l = 0 r = len ( nums ) - 1 while l < r : m = ( l + r ) // 2 if nums [ m ] > nums [ m + 1 ]: r = m else : l = m + 1 return l 163. Missing Ranges $\\star\\star$ 164. Maximum Gap $\\star\\star\\star$ 165. Compare Version Numbers $\\star\\star$ 166. Fraction to Recurring Decimal $\\star\\star$ 167. Two Sum II - Input array is sorted $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def twoSum ( self , numbers : List [ int ], target : int ) -> List [ int ]: l = 0 r = len ( numbers ) - 1 while l < r : sum = numbers [ l ] + numbers [ r ] if sum == target : return [ l + 1 , r + 1 ] if sum < target : l += 1 else : r -= 1 168. Excel Sheet Column Title $\\star$ 1 2 3 class Solution : def convertToTitle ( self , n : int ) -> str : return self . convertToTitle (( n - 1 ) // 26 ) + chr ( ord ( 'A' ) + ( n - 1 ) % 26 ) if n else \"\" 169. Majority Element $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution : def majorityElement ( self , nums : List [ int ]) -> int : ans = None count = 0 for num in nums : if count == 0 : ans = num count += ( 1 if num == ans else - 1 ) return ans 170. Two Sum III - Data structure design $\\star$","title":"0161-0170"},{"location":"python3/0101-0200/0161-0170/#161-one-edit-distance-starstar","text":"","title":"161. One Edit Distance $\\star\\star$"},{"location":"python3/0101-0200/0161-0170/#162-find-peak-element-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def findPeakElement ( self , nums : List [ int ]) -> int : l = 0 r = len ( nums ) - 1 while l < r : m = ( l + r ) // 2 if nums [ m ] > nums [ m + 1 ]: r = m else : l = m + 1 return l","title":"162. Find Peak Element $\\star\\star$"},{"location":"python3/0101-0200/0161-0170/#163-missing-ranges-starstar","text":"","title":"163. Missing Ranges $\\star\\star$"},{"location":"python3/0101-0200/0161-0170/#164-maximum-gap-starstarstar","text":"","title":"164. Maximum Gap $\\star\\star\\star$"},{"location":"python3/0101-0200/0161-0170/#165-compare-version-numbers-starstar","text":"","title":"165. Compare Version Numbers $\\star\\star$"},{"location":"python3/0101-0200/0161-0170/#166-fraction-to-recurring-decimal-starstar","text":"","title":"166. Fraction to Recurring Decimal $\\star\\star$"},{"location":"python3/0101-0200/0161-0170/#167-two-sum-ii-input-array-is-sorted-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def twoSum ( self , numbers : List [ int ], target : int ) -> List [ int ]: l = 0 r = len ( numbers ) - 1 while l < r : sum = numbers [ l ] + numbers [ r ] if sum == target : return [ l + 1 , r + 1 ] if sum < target : l += 1 else : r -= 1","title":"167. Two Sum II - Input array is sorted $\\star$"},{"location":"python3/0101-0200/0161-0170/#168-excel-sheet-column-title-star","text":"1 2 3 class Solution : def convertToTitle ( self , n : int ) -> str : return self . convertToTitle (( n - 1 ) // 26 ) + chr ( ord ( 'A' ) + ( n - 1 ) % 26 ) if n else \"\"","title":"168. Excel Sheet Column Title $\\star$"},{"location":"python3/0101-0200/0161-0170/#169-majority-element-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution : def majorityElement ( self , nums : List [ int ]) -> int : ans = None count = 0 for num in nums : if count == 0 : ans = num count += ( 1 if num == ans else - 1 ) return ans","title":"169. Majority Element $\\star$"},{"location":"python3/0101-0200/0161-0170/#170-two-sum-iii-data-structure-design-star","text":"","title":"170. Two Sum III - Data structure design $\\star$"},{"location":"python3/0101-0200/0171-0180/","text":"171. Excel Sheet Column Number $\\star$ 1 2 3 4 5 6 import functools class Solution : def titleToNumber ( self , s : str ) -> int : return functools . reduce ( lambda a , b : a * 26 + b , [ ord ( c ) - 64 for c in s ]) 172. Factorial Trailing Zeroes $\\star$ 1 2 3 class Solution : def trailingZeroes ( self , n : int ) -> int : return 0 if n == 0 else n // 5 + self . trailingZeroes ( n // 5 ) 173. Binary Search Tree Iterator $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class BSTIterator : def __init__ ( self , root : TreeNode ): self . helper ( root ) def next ( self ) -> int : node = self . stack . pop () if node . right : self . helper ( node . right ) return node . val def hasNext ( self ) -> bool : return len ( self . stack ) > 0 stack = [] def helper ( self , root : TreeNode ) -> None : while root : self . stack . append ( root ) root = root . left 174. Dungeon Game $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def calculateMinimumHP ( self , dungeon : List [ List [ int ]]) -> int : m = len ( dungeon ) n = len ( dungeon [ 0 ]) dp = [[ float ( 'inf' )] * ( n + 1 ) for _ in range ( m + 1 )] dp [ m ][ n - 1 ] = 1 dp [ m - 1 ][ n ] = 1 for i in range ( m - 1 , - 1 , - 1 ): for j in range ( n - 1 , - 1 , - 1 ): dp [ i ][ j ] = max ( 1 , min ( dp [ i + 1 ][ j ], dp [ i ][ j + 1 ]) - dungeon [ i ][ j ]) return dp [ 0 ][ 0 ] 175. Combine Two Tables $\\star$ 176. Second Highest Salary $\\star$ 177. Nth Highest Salary $\\star\\star$ 178. Rank Scores $\\star\\star$ 179. Largest Number $\\star\\star$ 180. Consecutive Numbers $\\star\\star$","title":"0171-0180"},{"location":"python3/0101-0200/0171-0180/#171-excel-sheet-column-number-star","text":"1 2 3 4 5 6 import functools class Solution : def titleToNumber ( self , s : str ) -> int : return functools . reduce ( lambda a , b : a * 26 + b , [ ord ( c ) - 64 for c in s ])","title":"171. Excel Sheet Column Number $\\star$"},{"location":"python3/0101-0200/0171-0180/#172-factorial-trailing-zeroes-star","text":"1 2 3 class Solution : def trailingZeroes ( self , n : int ) -> int : return 0 if n == 0 else n // 5 + self . trailingZeroes ( n // 5 )","title":"172. Factorial Trailing Zeroes $\\star$"},{"location":"python3/0101-0200/0171-0180/#173-binary-search-tree-iterator-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class BSTIterator : def __init__ ( self , root : TreeNode ): self . helper ( root ) def next ( self ) -> int : node = self . stack . pop () if node . right : self . helper ( node . right ) return node . val def hasNext ( self ) -> bool : return len ( self . stack ) > 0 stack = [] def helper ( self , root : TreeNode ) -> None : while root : self . stack . append ( root ) root = root . left","title":"173. Binary Search Tree Iterator $\\star\\star$"},{"location":"python3/0101-0200/0171-0180/#174-dungeon-game-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def calculateMinimumHP ( self , dungeon : List [ List [ int ]]) -> int : m = len ( dungeon ) n = len ( dungeon [ 0 ]) dp = [[ float ( 'inf' )] * ( n + 1 ) for _ in range ( m + 1 )] dp [ m ][ n - 1 ] = 1 dp [ m - 1 ][ n ] = 1 for i in range ( m - 1 , - 1 , - 1 ): for j in range ( n - 1 , - 1 , - 1 ): dp [ i ][ j ] = max ( 1 , min ( dp [ i + 1 ][ j ], dp [ i ][ j + 1 ]) - dungeon [ i ][ j ]) return dp [ 0 ][ 0 ]","title":"174. Dungeon Game $\\star\\star\\star$"},{"location":"python3/0101-0200/0171-0180/#175-combine-two-tables-star","text":"","title":"175. Combine Two Tables $\\star$"},{"location":"python3/0101-0200/0171-0180/#176-second-highest-salary-star","text":"","title":"176. Second Highest Salary $\\star$"},{"location":"python3/0101-0200/0171-0180/#177-nth-highest-salary-starstar","text":"","title":"177. Nth Highest Salary $\\star\\star$"},{"location":"python3/0101-0200/0171-0180/#178-rank-scores-starstar","text":"","title":"178. Rank Scores $\\star\\star$"},{"location":"python3/0101-0200/0171-0180/#179-largest-number-starstar","text":"","title":"179. Largest Number $\\star\\star$"},{"location":"python3/0101-0200/0171-0180/#180-consecutive-numbers-starstar","text":"","title":"180. Consecutive Numbers $\\star\\star$"},{"location":"python3/0101-0200/0181-0190/","text":"181. Employees Earning More Than Their Managers $\\star$ 182. Duplicate Emails $\\star$ 183. Customers Who Never Order $\\star$ 184. Department Highest Salary $\\star\\star$ 185. Department Top Three Salaries $\\star\\star\\star$ 186. Reverse Words in a String II $\\star\\star$ 187. Repeated DNA Sequences $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def findRepeatedDnaSequences ( self , s : str ) -> List [ str ]: ans = set () set_ = set () for i in range ( len ( s ) - 9 ): seq = s [ i : i + 10 ] if seq in set_ : ans . add ( seq ) set_ . add ( seq ) return list ( ans ) 188. Best Time to Buy and Sell Stock IV $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def maxProfit ( self , k : int , prices : List [ int ]) -> int : if k >= len ( prices ) // 2 : sell = 0 hold = float ( '-inf' ) for price in prices : sell = max ( sell , hold + price ) hold = max ( hold , sell - price ) return sell sell = [ 0 ] * ( k + 1 ) hold = [ float ( '-inf' )] * ( k + 1 ) for price in prices : for i in range ( k , 0 , - 1 ): sell [ i ] = max ( sell [ i ], hold [ i ] + price ) hold [ i ] = max ( hold [ i ], sell [ i - 1 ] - price ) return sell [ k ] 189. Rotate Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def rotate ( self , nums : List [ int ], k : int ) -> None : k %= len ( nums ) self . reverse ( nums , 0 , len ( nums ) - 1 ) self . reverse ( nums , 0 , k - 1 ) self . reverse ( nums , k , len ( nums ) - 1 ) def reverse ( self , nums : List [ int ], l : int , r : int ) -> None : while l < r : nums [ l ], nums [ r ] = nums [ r ], nums [ l ] l += 1 r -= 1 190. Reverse Bits $\\star$","title":"0181-0190"},{"location":"python3/0101-0200/0181-0190/#181-employees-earning-more-than-their-managers-star","text":"","title":"181. Employees Earning More Than Their Managers $\\star$"},{"location":"python3/0101-0200/0181-0190/#182-duplicate-emails-star","text":"","title":"182. Duplicate Emails $\\star$"},{"location":"python3/0101-0200/0181-0190/#183-customers-who-never-order-star","text":"","title":"183. Customers Who Never Order $\\star$"},{"location":"python3/0101-0200/0181-0190/#184-department-highest-salary-starstar","text":"","title":"184. Department Highest Salary $\\star\\star$"},{"location":"python3/0101-0200/0181-0190/#185-department-top-three-salaries-starstarstar","text":"","title":"185. Department Top Three Salaries $\\star\\star\\star$"},{"location":"python3/0101-0200/0181-0190/#186-reverse-words-in-a-string-ii-starstar","text":"","title":"186. Reverse Words in a String II $\\star\\star$"},{"location":"python3/0101-0200/0181-0190/#187-repeated-dna-sequences-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def findRepeatedDnaSequences ( self , s : str ) -> List [ str ]: ans = set () set_ = set () for i in range ( len ( s ) - 9 ): seq = s [ i : i + 10 ] if seq in set_ : ans . add ( seq ) set_ . add ( seq ) return list ( ans )","title":"187. Repeated DNA Sequences $\\star\\star$"},{"location":"python3/0101-0200/0181-0190/#188-best-time-to-buy-and-sell-stock-iv-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def maxProfit ( self , k : int , prices : List [ int ]) -> int : if k >= len ( prices ) // 2 : sell = 0 hold = float ( '-inf' ) for price in prices : sell = max ( sell , hold + price ) hold = max ( hold , sell - price ) return sell sell = [ 0 ] * ( k + 1 ) hold = [ float ( '-inf' )] * ( k + 1 ) for price in prices : for i in range ( k , 0 , - 1 ): sell [ i ] = max ( sell [ i ], hold [ i ] + price ) hold [ i ] = max ( hold [ i ], sell [ i - 1 ] - price ) return sell [ k ]","title":"188. Best Time to Buy and Sell Stock IV $\\star\\star\\star$"},{"location":"python3/0101-0200/0181-0190/#189-rotate-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def rotate ( self , nums : List [ int ], k : int ) -> None : k %= len ( nums ) self . reverse ( nums , 0 , len ( nums ) - 1 ) self . reverse ( nums , 0 , k - 1 ) self . reverse ( nums , k , len ( nums ) - 1 ) def reverse ( self , nums : List [ int ], l : int , r : int ) -> None : while l < r : nums [ l ], nums [ r ] = nums [ r ], nums [ l ] l += 1 r -= 1","title":"189. Rotate Array $\\star$"},{"location":"python3/0101-0200/0181-0190/#190-reverse-bits-star","text":"","title":"190. Reverse Bits $\\star$"},{"location":"python3/0101-0200/0191-0200/","text":"191. Number of 1 Bits $\\star$ 192. Word Frequency $\\star\\star$ 193. Valid Phone Numbers $\\star$ 194. Transpose File $\\star\\star$ 195. Tenth Line $\\star$ 196. Delete Duplicate Emails $\\star$ 197. Rising Temperature $\\star$ 198. House Robber $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution : def rob ( self , nums : List [ int ]) -> int : dp1 = 0 dp2 = 0 for num in nums : temp = dp1 dp1 = max ( dp1 , dp2 + num ) dp2 = temp return dp1 199. Binary Tree Right Side View $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def rightSideView ( self , root : TreeNode ) -> List [ int ]: def dfs ( root : TreeNode , level : int ) -> None : if not root : return if level > len ( ans ): ans . append ( root . val ) dfs ( root . right , level + 1 ) dfs ( root . left , level + 1 ) ans = [] dfs ( root , 1 ) return ans 200. Number of Islands $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution : def numIslands ( self , grid : List [ List [ str ]]) -> int : def dfs ( i : int , j : int ) -> None : if i < 0 or j < 0 or i >= len ( grid ) or j >= len ( grid [ 0 ]) or visited [ i ][ j ] or grid [ i ][ j ] == '0' : return visited [ i ][ j ] = True dfs ( i + 1 , j ) dfs ( i - 1 , j ) dfs ( i , j + 1 ) dfs ( i , j - 1 ) if not grid : return 0 m = len ( grid ) n = len ( grid [ 0 ]) ans = 0 visited = [[ False ] * n for _ in range ( m )] for i in range ( m ): for j in range ( n ): if not visited [ i ][ j ] and grid [ i ][ j ] == '1' : ans += 1 dfs ( i , j ) return ans","title":"0191-0200"},{"location":"python3/0101-0200/0191-0200/#191-number-of-1-bits-star","text":"","title":"191. Number of 1 Bits $\\star$"},{"location":"python3/0101-0200/0191-0200/#192-word-frequency-starstar","text":"","title":"192. Word Frequency $\\star\\star$"},{"location":"python3/0101-0200/0191-0200/#193-valid-phone-numbers-star","text":"","title":"193. Valid Phone Numbers $\\star$"},{"location":"python3/0101-0200/0191-0200/#194-transpose-file-starstar","text":"","title":"194. Transpose File $\\star\\star$"},{"location":"python3/0101-0200/0191-0200/#195-tenth-line-star","text":"","title":"195. Tenth Line $\\star$"},{"location":"python3/0101-0200/0191-0200/#196-delete-duplicate-emails-star","text":"","title":"196. Delete Duplicate Emails $\\star$"},{"location":"python3/0101-0200/0191-0200/#197-rising-temperature-star","text":"","title":"197. Rising Temperature $\\star$"},{"location":"python3/0101-0200/0191-0200/#198-house-robber-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution : def rob ( self , nums : List [ int ]) -> int : dp1 = 0 dp2 = 0 for num in nums : temp = dp1 dp1 = max ( dp1 , dp2 + num ) dp2 = temp return dp1","title":"198. House Robber $\\star$"},{"location":"python3/0101-0200/0191-0200/#199-binary-tree-right-side-view-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def rightSideView ( self , root : TreeNode ) -> List [ int ]: def dfs ( root : TreeNode , level : int ) -> None : if not root : return if level > len ( ans ): ans . append ( root . val ) dfs ( root . right , level + 1 ) dfs ( root . left , level + 1 ) ans = [] dfs ( root , 1 ) return ans","title":"199. Binary Tree Right Side View $\\star\\star$"},{"location":"python3/0101-0200/0191-0200/#200-number-of-islands-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution : def numIslands ( self , grid : List [ List [ str ]]) -> int : def dfs ( i : int , j : int ) -> None : if i < 0 or j < 0 or i >= len ( grid ) or j >= len ( grid [ 0 ]) or visited [ i ][ j ] or grid [ i ][ j ] == '0' : return visited [ i ][ j ] = True dfs ( i + 1 , j ) dfs ( i - 1 , j ) dfs ( i , j + 1 ) dfs ( i , j - 1 ) if not grid : return 0 m = len ( grid ) n = len ( grid [ 0 ]) ans = 0 visited = [[ False ] * n for _ in range ( m )] for i in range ( m ): for j in range ( n ): if not visited [ i ][ j ] and grid [ i ][ j ] == '1' : ans += 1 dfs ( i , j ) return ans","title":"200. Number of Islands $\\star\\star$"},{"location":"python3/0201-0300/0201-0210/","text":"201. Bitwise AND of Numbers Range $\\star\\star$ 1 2 3 class Solution : def rangeBitwiseAnd ( self , m : int , n : int ) -> int : return self . rangeBitwiseAnd ( m >> 1 , n >> 1 ) << 1 if m < n else m 202. Happy Number $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def isHappy ( self , n : int ) -> bool : slow = self . helper ( n ) fast = self . helper ( self . helper ( n )) while slow != fast : slow = self . helper ( slow ) fast = self . helper ( self . helper ( fast )) if slow == 1 : return True return False def helper ( self , n : int ) -> bool : sum = 0 while n : sum += pow ( n % 10 , 2 ) n //= 10 return sum 203. Remove Linked List Elements $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def removeElements ( self , head : ListNode , val : int ) -> ListNode : dummy = ListNode ( None ) dummy . next = head curr = dummy while curr : next = curr . next while next and next . val == val : next = next . next curr . next = next curr = next return dummy . next 204. Count Primes $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def countPrimes ( self , n : int ) -> int : if n <= 2 : return 0 isPrime = [ True ] * n isPrime [ 0 ] = False isPrime [ 1 ] = False for i in range ( 2 , int ( n ** 0.5 ) + 1 ): if isPrime [ i ]: for j in range ( i * 2 , n , i ): isPrime [ j ] = False return sum ( isPrime ) 205. Isomorphic Strings $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def isIsomorphic ( self , s : str , t : str ) -> bool : dict_s = collections . defaultdict ( int ) dict_t = collections . defaultdict ( int ) for i in range ( len ( s )): if dict_s [ s [ i ]] != dict_t [ t [ i ]]: return False dict_s [ s [ i ]] = i + 1 dict_t [ t [ i ]] = i + 1 return True 206. Reverse Linked List $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def reverseList ( self , head : ListNode ) -> ListNode : prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev 207. Course Schedule $\\star\\star$ 208. Implement Trie (Prefix Tree) $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Trie : def __init__ ( self ): self . root = {} def insert ( self , word : str ) -> None : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'isWord' ] = True def search ( self , word : str ) -> bool : node = self . find ( word ) return node is not None and 'isWord' in node def startsWith ( self , prefix : str ) -> bool : return self . find ( prefix ) is not None def find ( self , prefix ): node = self . root for c in prefix : if c not in node : return None node = node [ c ] return node 209. Minimum Size Subarray Sum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def minSubArrayLen ( self , s : int , nums : List [ int ]) -> int : ans = float ( 'inf' ) sum = 0 j = 0 for i , num in enumerate ( nums ): sum += num while sum >= s : ans = min ( ans , i - j + 1 ) sum -= nums [ j ] j += 1 return ans if ans != float ( 'inf' ) else 0 210. Course Schedule II $\\star\\star$","title":"0201-0210"},{"location":"python3/0201-0300/0201-0210/#201-bitwise-and-of-numbers-range-starstar","text":"1 2 3 class Solution : def rangeBitwiseAnd ( self , m : int , n : int ) -> int : return self . rangeBitwiseAnd ( m >> 1 , n >> 1 ) << 1 if m < n else m","title":"201. Bitwise AND of Numbers Range $\\star\\star$"},{"location":"python3/0201-0300/0201-0210/#202-happy-number-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def isHappy ( self , n : int ) -> bool : slow = self . helper ( n ) fast = self . helper ( self . helper ( n )) while slow != fast : slow = self . helper ( slow ) fast = self . helper ( self . helper ( fast )) if slow == 1 : return True return False def helper ( self , n : int ) -> bool : sum = 0 while n : sum += pow ( n % 10 , 2 ) n //= 10 return sum","title":"202. Happy Number $\\star$"},{"location":"python3/0201-0300/0201-0210/#203-remove-linked-list-elements-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def removeElements ( self , head : ListNode , val : int ) -> ListNode : dummy = ListNode ( None ) dummy . next = head curr = dummy while curr : next = curr . next while next and next . val == val : next = next . next curr . next = next curr = next return dummy . next","title":"203. Remove Linked List Elements $\\star$"},{"location":"python3/0201-0300/0201-0210/#204-count-primes-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def countPrimes ( self , n : int ) -> int : if n <= 2 : return 0 isPrime = [ True ] * n isPrime [ 0 ] = False isPrime [ 1 ] = False for i in range ( 2 , int ( n ** 0.5 ) + 1 ): if isPrime [ i ]: for j in range ( i * 2 , n , i ): isPrime [ j ] = False return sum ( isPrime )","title":"204. Count Primes $\\star$"},{"location":"python3/0201-0300/0201-0210/#205-isomorphic-strings-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def isIsomorphic ( self , s : str , t : str ) -> bool : dict_s = collections . defaultdict ( int ) dict_t = collections . defaultdict ( int ) for i in range ( len ( s )): if dict_s [ s [ i ]] != dict_t [ t [ i ]]: return False dict_s [ s [ i ]] = i + 1 dict_t [ t [ i ]] = i + 1 return True","title":"205. Isomorphic Strings $\\star$"},{"location":"python3/0201-0300/0201-0210/#206-reverse-linked-list-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def reverseList ( self , head : ListNode ) -> ListNode : prev = None curr = head while curr : next = curr . next curr . next = prev prev = curr curr = next return prev","title":"206. Reverse Linked List $\\star$"},{"location":"python3/0201-0300/0201-0210/#207-course-schedule-starstar","text":"","title":"207. Course Schedule $\\star\\star$"},{"location":"python3/0201-0300/0201-0210/#208-implement-trie-prefix-tree-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Trie : def __init__ ( self ): self . root = {} def insert ( self , word : str ) -> None : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'isWord' ] = True def search ( self , word : str ) -> bool : node = self . find ( word ) return node is not None and 'isWord' in node def startsWith ( self , prefix : str ) -> bool : return self . find ( prefix ) is not None def find ( self , prefix ): node = self . root for c in prefix : if c not in node : return None node = node [ c ] return node","title":"208. Implement Trie (Prefix Tree) $\\star\\star$"},{"location":"python3/0201-0300/0201-0210/#209-minimum-size-subarray-sum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def minSubArrayLen ( self , s : int , nums : List [ int ]) -> int : ans = float ( 'inf' ) sum = 0 j = 0 for i , num in enumerate ( nums ): sum += num while sum >= s : ans = min ( ans , i - j + 1 ) sum -= nums [ j ] j += 1 return ans if ans != float ( 'inf' ) else 0","title":"209. Minimum Size Subarray Sum $\\star\\star$"},{"location":"python3/0201-0300/0201-0210/#210-course-schedule-ii-starstar","text":"","title":"210. Course Schedule II $\\star\\star$"},{"location":"python3/0201-0300/0211-0220/","text":"211. Add and Search Word - Data structure design $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class WordDictionary : def __init__ ( self ): self . root = {} def addWord ( self , word : str ) -> None : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'isWord' ] = True def search ( self , word : str ) -> bool : return self . dfs ( word , 0 , self . root ) def dfs ( self , word : str , depth : int , node : dict ) -> bool : if depth == len ( word ): return 'isWord' in node if word [ depth ] != '.' : if word [ depth ] in node : return self . dfs ( word , depth + 1 , node [ word [ depth ]]) return False for c in string . ascii_lowercase : if c in node and self . dfs ( word , depth + 1 , node [ c ]): return True return False 212. Word Search II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution : def findWords ( self , board : List [ List [ str ]], words : List [ str ]) -> List [ str ]: def dfs ( i : int , j : int , node : dict ) -> None : if not 0 <= i < len ( board ) or not 0 <= j < len ( board [ 0 ]) or board [ i ][ j ] == '*' : return c = board [ i ][ j ] if c not in node : return next = node [ c ] if 'word' in next : ans . append ( next [ 'word' ]) del next [ 'word' ] board [ i ][ j ] = '*' dfs ( i + 1 , j , next ) dfs ( i - 1 , j , next ) dfs ( i , j + 1 , next ) dfs ( i , j - 1 , next ) board [ i ][ j ] = c self . root = {} for word in words : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'word' ] = word ans = [] for i in range ( len ( board )): for j in range ( len ( board [ 0 ])): dfs ( i , j , self . root ) return ans 213. House Robber II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def rob ( self , nums : List [ int ]) -> int : def rob ( l : int , r : int ) -> int : dp1 = 0 dp2 = 0 for i in range ( l , r + 1 ): temp = dp1 dp1 = max ( dp1 , dp2 + nums [ i ]) dp2 = temp return dp1 if not nums : return 0 if len ( nums ) < 2 : return nums [ 0 ] return max ( rob ( 0 , len ( nums ) - 2 ), rob ( 1 , len ( nums ) - 1 )) 214. Shortest Palindrome $\\star\\star\\star$ 215. Kth Largest Element in an Array $\\star\\star$ 216. Combination Sum III $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def combinationSum3 ( self , k : int , n : int ) -> List [ List [ int ]]: def dfs ( k : int , n : int , s : int , path : List [ int ]) -> None : if k == 0 and n == 0 : ans . append ( path ) return if k == 0 or n < 0 : return for i in range ( s , 10 ): dfs ( k - 1 , n - i , i + 1 , path + [ i ]) ans = [] dfs ( k , n , 1 , []) return ans 217. Contains Duplicate $\\star$ 1 2 3 class Solution : def containsDuplicate ( self , nums : List [ int ]) -> bool : return len ( nums ) != len ( set ( nums )) 218. The Skyline Problem $\\star\\star\\star$ 219. Contains Duplicate II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def containsNearbyDuplicate ( self , nums : List [ int ], k : int ) -> bool : set_ = set () for i , num in enumerate ( nums ): if i > k : set_ . remove ( nums [ i - k - 1 ]) if num in set_ : return True set_ . add ( num ) return False 220. Contains Duplicate III $\\star\\star$","title":"0211-0220"},{"location":"python3/0201-0300/0211-0220/#211-add-and-search-word-data-structure-design-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class WordDictionary : def __init__ ( self ): self . root = {} def addWord ( self , word : str ) -> None : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'isWord' ] = True def search ( self , word : str ) -> bool : return self . dfs ( word , 0 , self . root ) def dfs ( self , word : str , depth : int , node : dict ) -> bool : if depth == len ( word ): return 'isWord' in node if word [ depth ] != '.' : if word [ depth ] in node : return self . dfs ( word , depth + 1 , node [ word [ depth ]]) return False for c in string . ascii_lowercase : if c in node and self . dfs ( word , depth + 1 , node [ c ]): return True return False","title":"211. Add and Search Word - Data structure design $\\star\\star$"},{"location":"python3/0201-0300/0211-0220/#212-word-search-ii-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class Solution : def findWords ( self , board : List [ List [ str ]], words : List [ str ]) -> List [ str ]: def dfs ( i : int , j : int , node : dict ) -> None : if not 0 <= i < len ( board ) or not 0 <= j < len ( board [ 0 ]) or board [ i ][ j ] == '*' : return c = board [ i ][ j ] if c not in node : return next = node [ c ] if 'word' in next : ans . append ( next [ 'word' ]) del next [ 'word' ] board [ i ][ j ] = '*' dfs ( i + 1 , j , next ) dfs ( i - 1 , j , next ) dfs ( i , j + 1 , next ) dfs ( i , j - 1 , next ) board [ i ][ j ] = c self . root = {} for word in words : node = self . root for c in word : if c not in node : node [ c ] = {} node = node [ c ] node [ 'word' ] = word ans = [] for i in range ( len ( board )): for j in range ( len ( board [ 0 ])): dfs ( i , j , self . root ) return ans","title":"212. Word Search II $\\star\\star\\star$"},{"location":"python3/0201-0300/0211-0220/#213-house-robber-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def rob ( self , nums : List [ int ]) -> int : def rob ( l : int , r : int ) -> int : dp1 = 0 dp2 = 0 for i in range ( l , r + 1 ): temp = dp1 dp1 = max ( dp1 , dp2 + nums [ i ]) dp2 = temp return dp1 if not nums : return 0 if len ( nums ) < 2 : return nums [ 0 ] return max ( rob ( 0 , len ( nums ) - 2 ), rob ( 1 , len ( nums ) - 1 ))","title":"213. House Robber II $\\star\\star$"},{"location":"python3/0201-0300/0211-0220/#214-shortest-palindrome-starstarstar","text":"","title":"214. Shortest Palindrome $\\star\\star\\star$"},{"location":"python3/0201-0300/0211-0220/#215-kth-largest-element-in-an-array-starstar","text":"","title":"215. Kth Largest Element in an Array $\\star\\star$"},{"location":"python3/0201-0300/0211-0220/#216-combination-sum-iii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def combinationSum3 ( self , k : int , n : int ) -> List [ List [ int ]]: def dfs ( k : int , n : int , s : int , path : List [ int ]) -> None : if k == 0 and n == 0 : ans . append ( path ) return if k == 0 or n < 0 : return for i in range ( s , 10 ): dfs ( k - 1 , n - i , i + 1 , path + [ i ]) ans = [] dfs ( k , n , 1 , []) return ans","title":"216. Combination Sum III $\\star\\star$"},{"location":"python3/0201-0300/0211-0220/#217-contains-duplicate-star","text":"1 2 3 class Solution : def containsDuplicate ( self , nums : List [ int ]) -> bool : return len ( nums ) != len ( set ( nums ))","title":"217. Contains Duplicate $\\star$"},{"location":"python3/0201-0300/0211-0220/#218-the-skyline-problem-starstarstar","text":"","title":"218. The Skyline Problem $\\star\\star\\star$"},{"location":"python3/0201-0300/0211-0220/#219-contains-duplicate-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def containsNearbyDuplicate ( self , nums : List [ int ], k : int ) -> bool : set_ = set () for i , num in enumerate ( nums ): if i > k : set_ . remove ( nums [ i - k - 1 ]) if num in set_ : return True set_ . add ( num ) return False","title":"219. Contains Duplicate II $\\star$"},{"location":"python3/0201-0300/0211-0220/#220-contains-duplicate-iii-starstar","text":"","title":"220. Contains Duplicate III $\\star\\star$"},{"location":"python3/0201-0300/0221-0230/","text":"221. Maximal Square $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def maximalSquare ( self , matrix : List [ List [ str ]]) -> int : if not matrix : return 0 m = len ( matrix ) n = len ( matrix [ 0 ]) dp = [ 0 ] * n max_ = 0 prev = 0 for i in range ( m ): for j in range ( n ): temp = dp [ j ] if i == 0 or j == 0 or matrix [ i ][ j ] == '0' : dp [ j ] = ord ( matrix [ i ][ j ]) - ord ( '0' ) else : dp [ j ] = min ( dp [ j ], dp [ j - 1 ], prev ) + 1 max_ = max ( max_ , dp [ j ]) prev = temp return max_ * max_ 222. Count Complete Tree Nodes $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def countNodes ( self , root : TreeNode ) -> int : if not root : return 0 ans = 0 queue = collections . deque ([ root ]) while queue : ans += 1 node = queue . popleft () if node . left : queue . append ( node . left ) if node . right : queue . append ( node . right ) return ans 223. Rectangle Area $\\star\\star$ 1 2 3 4 5 6 class Solution : def computeArea ( self , A : int , B : int , C : int , D : int , E : int , F : int , G : int , H : int ) -> int : x = min ( C , G ) - max ( A , E ) if max ( A , E ) < min ( C , G ) else 0 y = min ( D , H ) - max ( B , F ) if max ( B , F ) < min ( D , H ) else 0 return ( C - A ) * ( D - B ) + ( G - E ) * ( H - F ) - x * y 224. Basic Calculator $\\star\\star\\star$ 225. Implement Stack using Queues $\\star$ 226. Invert Binary Tree $\\star$ 227. Basic Calculator II $\\star\\star$ 228. Summary Ranges $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def summaryRanges ( self , nums : List [ int ]) -> List [ str ]: ans = [] i = 0 while i < len ( nums ): begin = nums [ i ] while i < len ( nums ) - 1 and nums [ i ] == nums [ i + 1 ] - 1 : i += 1 end = nums [ i ] if begin == end : ans . append ( str ( begin )) else : ans . append ( str ( begin ) + \"->\" + str ( end )) i += 1 return ans 229. Majority Element II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def majorityElement ( self , nums : List [ int ]) -> List [ int ]: ans1 = 0 ans2 = 1 count1 = 0 count2 = 0 for num in nums : if num == ans1 : count1 += 1 elif num == ans2 : count2 += 1 elif count1 == 0 : ans1 = num count1 = 1 elif count2 == 0 : ans2 = num count2 = 1 else : count1 -= 1 count2 -= 1 return [ ans for ans in ( ans1 , ans2 ) if nums . count ( ans ) > len ( nums ) // 3 ] 230. Kth Smallest Element in a BST $\\star\\star$ 1 2 3 4 5 6 7 8 9 class Solution : def kthSmallest ( self , root : TreeNode , k : int ) -> int : def inorder ( root : TreeNode ) -> List [ TreeNode ]: if not root : return [] return inorder ( root . left ) + [ root . val ] + inorder ( root . right ) return inorder ( root )[ k - 1 ]","title":"0221-0230"},{"location":"python3/0201-0300/0221-0230/#221-maximal-square-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def maximalSquare ( self , matrix : List [ List [ str ]]) -> int : if not matrix : return 0 m = len ( matrix ) n = len ( matrix [ 0 ]) dp = [ 0 ] * n max_ = 0 prev = 0 for i in range ( m ): for j in range ( n ): temp = dp [ j ] if i == 0 or j == 0 or matrix [ i ][ j ] == '0' : dp [ j ] = ord ( matrix [ i ][ j ]) - ord ( '0' ) else : dp [ j ] = min ( dp [ j ], dp [ j - 1 ], prev ) + 1 max_ = max ( max_ , dp [ j ]) prev = temp return max_ * max_","title":"221. Maximal Square $\\star\\star$"},{"location":"python3/0201-0300/0221-0230/#222-count-complete-tree-nodes-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def countNodes ( self , root : TreeNode ) -> int : if not root : return 0 ans = 0 queue = collections . deque ([ root ]) while queue : ans += 1 node = queue . popleft () if node . left : queue . append ( node . left ) if node . right : queue . append ( node . right ) return ans","title":"222. Count Complete Tree Nodes $\\star\\star$"},{"location":"python3/0201-0300/0221-0230/#223-rectangle-area-starstar","text":"1 2 3 4 5 6 class Solution : def computeArea ( self , A : int , B : int , C : int , D : int , E : int , F : int , G : int , H : int ) -> int : x = min ( C , G ) - max ( A , E ) if max ( A , E ) < min ( C , G ) else 0 y = min ( D , H ) - max ( B , F ) if max ( B , F ) < min ( D , H ) else 0 return ( C - A ) * ( D - B ) + ( G - E ) * ( H - F ) - x * y","title":"223. Rectangle Area $\\star\\star$"},{"location":"python3/0201-0300/0221-0230/#224-basic-calculator-starstarstar","text":"","title":"224. Basic Calculator $\\star\\star\\star$"},{"location":"python3/0201-0300/0221-0230/#225-implement-stack-using-queues-star","text":"","title":"225. Implement Stack using Queues $\\star$"},{"location":"python3/0201-0300/0221-0230/#226-invert-binary-tree-star","text":"","title":"226. Invert Binary Tree $\\star$"},{"location":"python3/0201-0300/0221-0230/#227-basic-calculator-ii-starstar","text":"","title":"227. Basic Calculator II $\\star\\star$"},{"location":"python3/0201-0300/0221-0230/#228-summary-ranges-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def summaryRanges ( self , nums : List [ int ]) -> List [ str ]: ans = [] i = 0 while i < len ( nums ): begin = nums [ i ] while i < len ( nums ) - 1 and nums [ i ] == nums [ i + 1 ] - 1 : i += 1 end = nums [ i ] if begin == end : ans . append ( str ( begin )) else : ans . append ( str ( begin ) + \"->\" + str ( end )) i += 1 return ans","title":"228. Summary Ranges $\\star\\star$"},{"location":"python3/0201-0300/0221-0230/#229-majority-element-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def majorityElement ( self , nums : List [ int ]) -> List [ int ]: ans1 = 0 ans2 = 1 count1 = 0 count2 = 0 for num in nums : if num == ans1 : count1 += 1 elif num == ans2 : count2 += 1 elif count1 == 0 : ans1 = num count1 = 1 elif count2 == 0 : ans2 = num count2 = 1 else : count1 -= 1 count2 -= 1 return [ ans for ans in ( ans1 , ans2 ) if nums . count ( ans ) > len ( nums ) // 3 ]","title":"229. Majority Element II $\\star\\star$"},{"location":"python3/0201-0300/0221-0230/#230-kth-smallest-element-in-a-bst-starstar","text":"1 2 3 4 5 6 7 8 9 class Solution : def kthSmallest ( self , root : TreeNode , k : int ) -> int : def inorder ( root : TreeNode ) -> List [ TreeNode ]: if not root : return [] return inorder ( root . left ) + [ root . val ] + inorder ( root . right ) return inorder ( root )[ k - 1 ]","title":"230. Kth Smallest Element in a BST $\\star\\star$"},{"location":"python3/0201-0300/0231-0240/","text":"231. Power of Two $\\star$ 232. Implement Queue using Stacks $\\star$ 233. Number of Digit One $\\star\\star\\star$ 234. Palindrome Linked List $\\star$ 235. Lowest Common Ancestor of a Binary Search Tree $\\star$ 236. Lowest Common Ancestor of a Binary Tree $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def lowestCommonAncestor ( self , root : 'TreeNode' , p : 'TreeNode' , q : 'TreeNode' ) -> 'TreeNode' : if not root or root == p or root == q : return root left = self . lowestCommonAncestor ( root . left , p , q ) right = self . lowestCommonAncestor ( root . right , p , q ) if not left : return right if not right : return left return root 237. Delete Node in a Linked List $\\star$ 1 2 3 4 class Solution : def deleteNode ( self , node ): node . val = node . next . val node . next = node . next . next 238. Product of Array Except Self $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def productExceptSelf ( self , nums : List [ int ]) -> List [ int ]: ans = [ 0 ] * len ( nums ) ans [ 0 ] = 1 r = 1 for i in range ( 1 , len ( nums )): ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ] for i in range ( len ( nums ) - 1 , - 1 , - 1 ): ans [ i ] *= r r *= nums [ i ] return ans 239. Sliding Window Maximum $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def maxSlidingWindow ( self , nums : List [ int ], k : int ) -> List [ int ]: ans = [] deque = collections . deque () for i in range ( len ( nums )): while deque and nums [ i ] > deque [ - 1 ]: deque . pop () deque . append ( nums [ i ]) if i - k + 1 >= 0 : ans . append ( deque [ 0 ]) if nums [ i - k + 1 ] == deque [ 0 ]: deque . popleft () return ans 240. Search a 2D Matrix II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def searchMatrix ( self , matrix : List [ List [ int ]], target : int ) -> bool : if not matrix : return False r = 0 c = len ( matrix [ 0 ]) - 1 while r < len ( matrix ) and c >= 0 : if matrix [ r ][ c ] == target : return True if target < matrix [ r ][ c ]: c -= 1 else : r += 1 return False","title":"0231-0240"},{"location":"python3/0201-0300/0231-0240/#231-power-of-two-star","text":"","title":"231. Power of Two $\\star$"},{"location":"python3/0201-0300/0231-0240/#232-implement-queue-using-stacks-star","text":"","title":"232. Implement Queue using Stacks $\\star$"},{"location":"python3/0201-0300/0231-0240/#233-number-of-digit-one-starstarstar","text":"","title":"233. Number of Digit One $\\star\\star\\star$"},{"location":"python3/0201-0300/0231-0240/#234-palindrome-linked-list-star","text":"","title":"234. Palindrome Linked List $\\star$"},{"location":"python3/0201-0300/0231-0240/#235-lowest-common-ancestor-of-a-binary-search-tree-star","text":"","title":"235. Lowest Common Ancestor of a Binary Search Tree $\\star$"},{"location":"python3/0201-0300/0231-0240/#236-lowest-common-ancestor-of-a-binary-tree-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def lowestCommonAncestor ( self , root : 'TreeNode' , p : 'TreeNode' , q : 'TreeNode' ) -> 'TreeNode' : if not root or root == p or root == q : return root left = self . lowestCommonAncestor ( root . left , p , q ) right = self . lowestCommonAncestor ( root . right , p , q ) if not left : return right if not right : return left return root","title":"236. Lowest Common Ancestor of a Binary Tree $\\star\\star$"},{"location":"python3/0201-0300/0231-0240/#237-delete-node-in-a-linked-list-star","text":"1 2 3 4 class Solution : def deleteNode ( self , node ): node . val = node . next . val node . next = node . next . next","title":"237. Delete Node in a Linked List $\\star$"},{"location":"python3/0201-0300/0231-0240/#238-product-of-array-except-self-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def productExceptSelf ( self , nums : List [ int ]) -> List [ int ]: ans = [ 0 ] * len ( nums ) ans [ 0 ] = 1 r = 1 for i in range ( 1 , len ( nums )): ans [ i ] = ans [ i - 1 ] * nums [ i - 1 ] for i in range ( len ( nums ) - 1 , - 1 , - 1 ): ans [ i ] *= r r *= nums [ i ] return ans","title":"238. Product of Array Except Self $\\star\\star$"},{"location":"python3/0201-0300/0231-0240/#239-sliding-window-maximum-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def maxSlidingWindow ( self , nums : List [ int ], k : int ) -> List [ int ]: ans = [] deque = collections . deque () for i in range ( len ( nums )): while deque and nums [ i ] > deque [ - 1 ]: deque . pop () deque . append ( nums [ i ]) if i - k + 1 >= 0 : ans . append ( deque [ 0 ]) if nums [ i - k + 1 ] == deque [ 0 ]: deque . popleft () return ans","title":"239. Sliding Window Maximum $\\star\\star\\star$"},{"location":"python3/0201-0300/0231-0240/#240-search-a-2d-matrix-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def searchMatrix ( self , matrix : List [ List [ int ]], target : int ) -> bool : if not matrix : return False r = 0 c = len ( matrix [ 0 ]) - 1 while r < len ( matrix ) and c >= 0 : if matrix [ r ][ c ] == target : return True if target < matrix [ r ][ c ]: c -= 1 else : r += 1 return False","title":"240. Search a 2D Matrix II $\\star\\star$"},{"location":"python3/0201-0300/0241-0250/","text":"241. Different Ways to Add Parentheses $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def diffWaysToCompute ( self , input : str ) -> List [ int ]: ans = [] for i , c in enumerate ( input ): if c in '+-*' : left = self . diffWaysToCompute ( input [: i ]) right = self . diffWaysToCompute ( input [ i + 1 :]) for a in left : for b in right : ans . append ( eval ( str ( a ) + c + str ( b ))) return ans or [ int ( input )] 242. Valid Anagram $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def isAnagram ( self , s : str , t : str ) -> bool : if len ( s ) != len ( t ): return False dict = collections . Counter ( s ) for c in t : dict [ c ] -= 1 if dict [ c ] < 0 : return False return True 243. Shortest Word Distance $\\star$ 244. Shortest Word Distance II $\\star\\star$ 245. Shortest Word Distance III $\\star\\star$ 246. Strobogrammatic Number $\\star$ 247. Strobogrammatic Number II $\\star\\star$ 248. Strobogrammatic Number III $\\star\\star\\star$ 249. Group Shifted Strings $\\star\\star$ 250. Count Univalue Subtrees $\\star\\star$","title":"0241-0250"},{"location":"python3/0201-0300/0241-0250/#241-different-ways-to-add-parentheses-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def diffWaysToCompute ( self , input : str ) -> List [ int ]: ans = [] for i , c in enumerate ( input ): if c in '+-*' : left = self . diffWaysToCompute ( input [: i ]) right = self . diffWaysToCompute ( input [ i + 1 :]) for a in left : for b in right : ans . append ( eval ( str ( a ) + c + str ( b ))) return ans or [ int ( input )]","title":"241. Different Ways to Add Parentheses $\\star\\star$"},{"location":"python3/0201-0300/0241-0250/#242-valid-anagram-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def isAnagram ( self , s : str , t : str ) -> bool : if len ( s ) != len ( t ): return False dict = collections . Counter ( s ) for c in t : dict [ c ] -= 1 if dict [ c ] < 0 : return False return True","title":"242. Valid Anagram $\\star$"},{"location":"python3/0201-0300/0241-0250/#243-shortest-word-distance-star","text":"","title":"243. Shortest Word Distance $\\star$"},{"location":"python3/0201-0300/0241-0250/#244-shortest-word-distance-ii-starstar","text":"","title":"244. Shortest Word Distance II $\\star\\star$"},{"location":"python3/0201-0300/0241-0250/#245-shortest-word-distance-iii-starstar","text":"","title":"245. Shortest Word Distance III $\\star\\star$"},{"location":"python3/0201-0300/0241-0250/#246-strobogrammatic-number-star","text":"","title":"246. Strobogrammatic Number $\\star$"},{"location":"python3/0201-0300/0241-0250/#247-strobogrammatic-number-ii-starstar","text":"","title":"247. Strobogrammatic Number II $\\star\\star$"},{"location":"python3/0201-0300/0241-0250/#248-strobogrammatic-number-iii-starstarstar","text":"","title":"248. Strobogrammatic Number III $\\star\\star\\star$"},{"location":"python3/0201-0300/0241-0250/#249-group-shifted-strings-starstar","text":"","title":"249. Group Shifted Strings $\\star\\star$"},{"location":"python3/0201-0300/0241-0250/#250-count-univalue-subtrees-starstar","text":"","title":"250. Count Univalue Subtrees $\\star\\star$"},{"location":"python3/0201-0300/0251-0260/","text":"251. Flatten 2D Vector $\\star\\star$ 252. Meeting Rooms $\\star$ 253. Meeting Rooms II $\\star\\star$ 254. Factor Combinations $\\star\\star$ 255. Verify Preorder Sequence in Binary Search Tree $\\star\\star$ 256. Paint House $\\star$ 257. Binary Tree Paths $\\star$ 258. Add Digits $\\star$ 259. 3Sum Smaller $\\star\\star$ 260. Single Number III $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import functools class Solution : def singleNumber ( self , nums : List [ int ]) -> List [ int ]: ans = [ 0 , 0 ] xor = functools . reduce ( lambda x , y : x ^ y , nums ) xor &= - xor for num in nums : if num & xor : ans [ 0 ] ^= num else : ans [ 1 ] ^= num return ans","title":"0251-0260"},{"location":"python3/0201-0300/0251-0260/#251-flatten-2d-vector-starstar","text":"","title":"251. Flatten 2D Vector $\\star\\star$"},{"location":"python3/0201-0300/0251-0260/#252-meeting-rooms-star","text":"","title":"252. Meeting Rooms $\\star$"},{"location":"python3/0201-0300/0251-0260/#253-meeting-rooms-ii-starstar","text":"","title":"253. Meeting Rooms II $\\star\\star$"},{"location":"python3/0201-0300/0251-0260/#254-factor-combinations-starstar","text":"","title":"254. Factor Combinations $\\star\\star$"},{"location":"python3/0201-0300/0251-0260/#255-verify-preorder-sequence-in-binary-search-tree-starstar","text":"","title":"255. Verify Preorder Sequence in Binary Search Tree $\\star\\star$"},{"location":"python3/0201-0300/0251-0260/#256-paint-house-star","text":"","title":"256. Paint House $\\star$"},{"location":"python3/0201-0300/0251-0260/#257-binary-tree-paths-star","text":"","title":"257. Binary Tree Paths $\\star$"},{"location":"python3/0201-0300/0251-0260/#258-add-digits-star","text":"","title":"258. Add Digits $\\star$"},{"location":"python3/0201-0300/0251-0260/#259-3sum-smaller-starstar","text":"","title":"259. 3Sum Smaller $\\star\\star$"},{"location":"python3/0201-0300/0251-0260/#260-single-number-iii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import functools class Solution : def singleNumber ( self , nums : List [ int ]) -> List [ int ]: ans = [ 0 , 0 ] xor = functools . reduce ( lambda x , y : x ^ y , nums ) xor &= - xor for num in nums : if num & xor : ans [ 0 ] ^= num else : ans [ 1 ] ^= num return ans","title":"260. Single Number III $\\star\\star$"},{"location":"python3/0201-0300/0261-0270/","text":"261. Graph Valid Tree $\\star\\star$ 262. Trips and Users $\\star\\star\\star$ 263. Ugly Number $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution : def isUgly ( self , num : int ) -> bool : if num == 0 : return False for factor in 2 , 3 , 5 : while num % factor == 0 : num //= factor return num == 1 264. Ugly Number II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def nthUglyNumber ( self , n : int ) -> int : nums = [ 1 ] i2 = 0 i3 = 0 i5 = 0 while len ( nums ) < n : next2 = nums [ i2 ] * 2 next3 = nums [ i3 ] * 3 next5 = nums [ i5 ] * 5 next = min ( next2 , next3 , next5 ) if next == next2 : i2 += 1 if next == next3 : i3 += 1 if next == next5 : i5 += 1 nums . append ( next ) return nums [ - 1 ] 265. Paint House II $\\star\\star\\star$ 266. Palindrome Permutation $\\star$ 267. Palindrome Permutation II $\\star\\star$ 268. Missing Number $\\star$ 1 2 3 4 5 6 7 8 class Solution : def missingNumber ( self , nums : List [ int ]) -> int : ans = len ( nums ) for i , num in enumerate ( nums ): ans ^= i ^ num return ans 269. Alien Dictionary $\\star\\star\\star$ 270. Closest Binary Search Tree Value $\\star$","title":"0261-0270"},{"location":"python3/0201-0300/0261-0270/#261-graph-valid-tree-starstar","text":"","title":"261. Graph Valid Tree $\\star\\star$"},{"location":"python3/0201-0300/0261-0270/#262-trips-and-users-starstarstar","text":"","title":"262. Trips and Users $\\star\\star\\star$"},{"location":"python3/0201-0300/0261-0270/#263-ugly-number-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution : def isUgly ( self , num : int ) -> bool : if num == 0 : return False for factor in 2 , 3 , 5 : while num % factor == 0 : num //= factor return num == 1","title":"263. Ugly Number $\\star$"},{"location":"python3/0201-0300/0261-0270/#264-ugly-number-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def nthUglyNumber ( self , n : int ) -> int : nums = [ 1 ] i2 = 0 i3 = 0 i5 = 0 while len ( nums ) < n : next2 = nums [ i2 ] * 2 next3 = nums [ i3 ] * 3 next5 = nums [ i5 ] * 5 next = min ( next2 , next3 , next5 ) if next == next2 : i2 += 1 if next == next3 : i3 += 1 if next == next5 : i5 += 1 nums . append ( next ) return nums [ - 1 ]","title":"264. Ugly Number II $\\star\\star$"},{"location":"python3/0201-0300/0261-0270/#265-paint-house-ii-starstarstar","text":"","title":"265. Paint House II $\\star\\star\\star$"},{"location":"python3/0201-0300/0261-0270/#266-palindrome-permutation-star","text":"","title":"266. Palindrome Permutation $\\star$"},{"location":"python3/0201-0300/0261-0270/#267-palindrome-permutation-ii-starstar","text":"","title":"267. Palindrome Permutation II $\\star\\star$"},{"location":"python3/0201-0300/0261-0270/#268-missing-number-star","text":"1 2 3 4 5 6 7 8 class Solution : def missingNumber ( self , nums : List [ int ]) -> int : ans = len ( nums ) for i , num in enumerate ( nums ): ans ^= i ^ num return ans","title":"268. Missing Number $\\star$"},{"location":"python3/0201-0300/0261-0270/#269-alien-dictionary-starstarstar","text":"","title":"269. Alien Dictionary $\\star\\star\\star$"},{"location":"python3/0201-0300/0261-0270/#270-closest-binary-search-tree-value-star","text":"","title":"270. Closest Binary Search Tree Value $\\star$"},{"location":"python3/0201-0300/0271-0280/","text":"271. Encode and Decode Strings $\\star\\star$ 272. Closest Binary Search Tree Value II $\\star\\star\\star$ 273. Integer to English Words $\\star\\star\\star$ 274. H-Index $\\star\\star$ 275. H-Index II $\\star\\star$ 276. Paint Fence $\\star$ 277. Find the Celebrity $\\star\\star$ 278. First Bad Version $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def firstBadVersion ( self , n : int ) -> int : l = 1 r = n while l < r : m = ( l + r ) >> 1 if isBadVersion ( m ): r = m else : l = m + 1 return l 279. Perfect Squares $\\star\\star$ 280. Wiggle Sort $\\star\\star$","title":"0271-0280"},{"location":"python3/0201-0300/0271-0280/#271-encode-and-decode-strings-starstar","text":"","title":"271. Encode and Decode Strings $\\star\\star$"},{"location":"python3/0201-0300/0271-0280/#272-closest-binary-search-tree-value-ii-starstarstar","text":"","title":"272. Closest Binary Search Tree Value II $\\star\\star\\star$"},{"location":"python3/0201-0300/0271-0280/#273-integer-to-english-words-starstarstar","text":"","title":"273. Integer to English Words $\\star\\star\\star$"},{"location":"python3/0201-0300/0271-0280/#274-h-index-starstar","text":"","title":"274. H-Index $\\star\\star$"},{"location":"python3/0201-0300/0271-0280/#275-h-index-ii-starstar","text":"","title":"275. H-Index II $\\star\\star$"},{"location":"python3/0201-0300/0271-0280/#276-paint-fence-star","text":"","title":"276. Paint Fence $\\star$"},{"location":"python3/0201-0300/0271-0280/#277-find-the-celebrity-starstar","text":"","title":"277. Find the Celebrity $\\star\\star$"},{"location":"python3/0201-0300/0271-0280/#278-first-bad-version-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def firstBadVersion ( self , n : int ) -> int : l = 1 r = n while l < r : m = ( l + r ) >> 1 if isBadVersion ( m ): r = m else : l = m + 1 return l","title":"278. First Bad Version $\\star$"},{"location":"python3/0201-0300/0271-0280/#279-perfect-squares-starstar","text":"","title":"279. Perfect Squares $\\star\\star$"},{"location":"python3/0201-0300/0271-0280/#280-wiggle-sort-starstar","text":"","title":"280. Wiggle Sort $\\star\\star$"},{"location":"python3/0201-0300/0281-0290/","text":"281. Zigzag Iterator $\\star\\star$ 282. Expression Add Operators $\\star\\star\\star$ 283. Move Zeroes $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution : def moveZeroes ( self , nums : List [ int ]) -> None : j = 0 for num in nums : if num != 0 : nums [ j ] = num j += 1 for i in range ( j , len ( nums )): nums [ i ] = 0 284. Peeking Iterator $\\star\\star$ 285. Inorder Successor in BST $\\star\\star$ 286. Walls and Gates $\\star\\star$ 287. Find the Duplicate Number $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def findDuplicate ( self , nums : List [ int ]) -> int : slow = nums [ nums [ 0 ]] fast = nums [ nums [ nums [ 0 ]]] while slow != fast : slow = nums [ slow ] fast = nums [ nums [ fast ]] slow = nums [ 0 ] while slow != fast : slow = nums [ slow ] fast = nums [ fast ] return slow 288. Unique Word Abbreviation $\\star\\star$ 289. Game of Life $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def gameOfLife ( self , board : List [ List [ int ]]) -> None : m = len ( board ) n = len ( board [ 0 ]) for i in range ( m ): for j in range ( n ): ones = 0 for y in range ( max ( 0 , i - 1 ), min ( m , i + 2 )): for x in range ( max ( 0 , j - 1 ), min ( n , j + 2 )): ones += board [ y ][ x ] & 1 if ( board [ i ][ j ] == 1 and ( ones == 3 or ones == 4 )) or ( board [ i ][ j ] == 0 and ones == 3 ): board [ i ][ j ] |= 0b10 for i in range ( m ): for j in range ( n ): board [ i ][ j ] >>= 1 290. Word Pattern $\\star$","title":"0281-0290"},{"location":"python3/0201-0300/0281-0290/#281-zigzag-iterator-starstar","text":"","title":"281. Zigzag Iterator $\\star\\star$"},{"location":"python3/0201-0300/0281-0290/#282-expression-add-operators-starstarstar","text":"","title":"282. Expression Add Operators $\\star\\star\\star$"},{"location":"python3/0201-0300/0281-0290/#283-move-zeroes-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution : def moveZeroes ( self , nums : List [ int ]) -> None : j = 0 for num in nums : if num != 0 : nums [ j ] = num j += 1 for i in range ( j , len ( nums )): nums [ i ] = 0","title":"283. Move Zeroes $\\star$"},{"location":"python3/0201-0300/0281-0290/#284-peeking-iterator-starstar","text":"","title":"284. Peeking Iterator $\\star\\star$"},{"location":"python3/0201-0300/0281-0290/#285-inorder-successor-in-bst-starstar","text":"","title":"285. Inorder Successor in BST $\\star\\star$"},{"location":"python3/0201-0300/0281-0290/#286-walls-and-gates-starstar","text":"","title":"286. Walls and Gates $\\star\\star$"},{"location":"python3/0201-0300/0281-0290/#287-find-the-duplicate-number-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def findDuplicate ( self , nums : List [ int ]) -> int : slow = nums [ nums [ 0 ]] fast = nums [ nums [ nums [ 0 ]]] while slow != fast : slow = nums [ slow ] fast = nums [ nums [ fast ]] slow = nums [ 0 ] while slow != fast : slow = nums [ slow ] fast = nums [ fast ] return slow","title":"287. Find the Duplicate Number $\\star\\star$"},{"location":"python3/0201-0300/0281-0290/#288-unique-word-abbreviation-starstar","text":"","title":"288. Unique Word Abbreviation $\\star\\star$"},{"location":"python3/0201-0300/0281-0290/#289-game-of-life-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def gameOfLife ( self , board : List [ List [ int ]]) -> None : m = len ( board ) n = len ( board [ 0 ]) for i in range ( m ): for j in range ( n ): ones = 0 for y in range ( max ( 0 , i - 1 ), min ( m , i + 2 )): for x in range ( max ( 0 , j - 1 ), min ( n , j + 2 )): ones += board [ y ][ x ] & 1 if ( board [ i ][ j ] == 1 and ( ones == 3 or ones == 4 )) or ( board [ i ][ j ] == 0 and ones == 3 ): board [ i ][ j ] |= 0b10 for i in range ( m ): for j in range ( n ): board [ i ][ j ] >>= 1","title":"289. Game of Life $\\star\\star$"},{"location":"python3/0201-0300/0281-0290/#290-word-pattern-star","text":"","title":"290. Word Pattern $\\star$"},{"location":"python3/0201-0300/0291-0300/","text":"291. Word Pattern II $\\star\\star\\star$ 292. Nim Game $\\star$ 293. Flip Game $\\star$ 294. Flip Game II $\\star\\star$ 295. Find Median from Data Stream $\\star\\star\\star$ 296. Best Meeting Point $\\star\\star\\star$ 297. Serialize and Deserialize Binary Tree $\\star\\star\\star$ 298. Binary Tree Longest Consecutive Sequence $\\star\\star$ 299. Bulls and Cows $\\star$ 300. Longest Increasing Subsequence $\\star\\star$","title":"0291-0300"},{"location":"python3/0201-0300/0291-0300/#291-word-pattern-ii-starstarstar","text":"","title":"291. Word Pattern II $\\star\\star\\star$"},{"location":"python3/0201-0300/0291-0300/#292-nim-game-star","text":"","title":"292. Nim Game $\\star$"},{"location":"python3/0201-0300/0291-0300/#293-flip-game-star","text":"","title":"293. Flip Game $\\star$"},{"location":"python3/0201-0300/0291-0300/#294-flip-game-ii-starstar","text":"","title":"294. Flip Game II $\\star\\star$"},{"location":"python3/0201-0300/0291-0300/#295-find-median-from-data-stream-starstarstar","text":"","title":"295. Find Median from Data Stream $\\star\\star\\star$"},{"location":"python3/0201-0300/0291-0300/#296-best-meeting-point-starstarstar","text":"","title":"296. Best Meeting Point $\\star\\star\\star$"},{"location":"python3/0201-0300/0291-0300/#297-serialize-and-deserialize-binary-tree-starstarstar","text":"","title":"297. Serialize and Deserialize Binary Tree $\\star\\star\\star$"},{"location":"python3/0201-0300/0291-0300/#298-binary-tree-longest-consecutive-sequence-starstar","text":"","title":"298. Binary Tree Longest Consecutive Sequence $\\star\\star$"},{"location":"python3/0201-0300/0291-0300/#299-bulls-and-cows-star","text":"","title":"299. Bulls and Cows $\\star$"},{"location":"python3/0201-0300/0291-0300/#300-longest-increasing-subsequence-starstar","text":"","title":"300. Longest Increasing Subsequence $\\star\\star$"},{"location":"python3/0301-0400/0301-0310/","text":"301. Remove Invalid Parentheses $\\star\\star\\star$ 302. Smallest Rectangle Enclosing Black Pixels $\\star\\star\\star$ 303. Range Sum Query - Immutable $\\star$ 304. Range Sum Query 2D - Immutable $\\star\\star$ 305. Number of Islands II $\\star\\star\\star$ 306. Additive Number $\\star\\star$ 307. Range Sum Query - Mutable $\\star\\star$ 308. Range Sum Query 2D - Mutable $\\star\\star\\star$ 309. Best Time to Buy and Sell Stock with Cooldown $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def maxProfit ( self , prices : List [ int ]) -> int : sell = 0 hold = float ( '-inf' ) prev = 0 for price in prices : cache = sell sell = max ( sell , hold + price ) hold = max ( hold , prev - price ) prev = cache return sell 310. Minimum Height Trees $\\star\\star$","title":"0301-0310"},{"location":"python3/0301-0400/0301-0310/#301-remove-invalid-parentheses-starstarstar","text":"","title":"301. Remove Invalid Parentheses $\\star\\star\\star$"},{"location":"python3/0301-0400/0301-0310/#302-smallest-rectangle-enclosing-black-pixels-starstarstar","text":"","title":"302. Smallest Rectangle Enclosing Black Pixels $\\star\\star\\star$"},{"location":"python3/0301-0400/0301-0310/#303-range-sum-query-immutable-star","text":"","title":"303. Range Sum Query - Immutable $\\star$"},{"location":"python3/0301-0400/0301-0310/#304-range-sum-query-2d-immutable-starstar","text":"","title":"304. Range Sum Query 2D - Immutable $\\star\\star$"},{"location":"python3/0301-0400/0301-0310/#305-number-of-islands-ii-starstarstar","text":"","title":"305. Number of Islands II $\\star\\star\\star$"},{"location":"python3/0301-0400/0301-0310/#306-additive-number-starstar","text":"","title":"306. Additive Number $\\star\\star$"},{"location":"python3/0301-0400/0301-0310/#307-range-sum-query-mutable-starstar","text":"","title":"307. Range Sum Query - Mutable $\\star\\star$"},{"location":"python3/0301-0400/0301-0310/#308-range-sum-query-2d-mutable-starstarstar","text":"","title":"308. Range Sum Query 2D - Mutable $\\star\\star\\star$"},{"location":"python3/0301-0400/0301-0310/#309-best-time-to-buy-and-sell-stock-with-cooldown-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def maxProfit ( self , prices : List [ int ]) -> int : sell = 0 hold = float ( '-inf' ) prev = 0 for price in prices : cache = sell sell = max ( sell , hold + price ) hold = max ( hold , prev - price ) prev = cache return sell","title":"309. Best Time to Buy and Sell Stock with Cooldown $\\star\\star$"},{"location":"python3/0301-0400/0301-0310/#310-minimum-height-trees-starstar","text":"","title":"310. Minimum Height Trees $\\star\\star$"},{"location":"python3/0301-0400/0311-0320/","text":"311. Sparse Matrix Multiplication $\\star\\star$ 312. Burst Balloons $\\star\\star\\star$ 313. Super Ugly Number $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def nthSuperUglyNumber ( self , n : int , primes : List [ int ]) -> int : k = len ( primes ) nums = [ 1 ] indices = [ 0 ] * k while len ( nums ) < n : nexts = [ 0 ] * k for i in range ( k ): nexts [ i ] = nums [ indices [ i ]] * primes [ i ] next = min ( nexts ) for i in range ( k ): if next == nexts [ i ]: indices [ i ] += 1 nums . append ( next ) return nums [ - 1 ] 314. Binary Tree Vertical Order Traversal $\\star\\star$ 315. Count of Smaller Numbers After Self $\\star\\star\\star$ 316. Remove Duplicate Letters $\\star\\star\\star$ 317. Shortest Distance from All Buildings $\\star\\star\\star$ 318. Maximum Product of Word Lengths $\\star\\star$ 319. Bulb Switcher $\\star\\star$ 1 2 3 class Solution : def bulbSwitch ( self , n : int ) -> int : return int ( math . sqrt ( n )) 320. Generalized Abbreviation $\\star\\star$","title":"0311-0320"},{"location":"python3/0301-0400/0311-0320/#311-sparse-matrix-multiplication-starstar","text":"","title":"311. Sparse Matrix Multiplication $\\star\\star$"},{"location":"python3/0301-0400/0311-0320/#312-burst-balloons-starstarstar","text":"","title":"312. Burst Balloons $\\star\\star\\star$"},{"location":"python3/0301-0400/0311-0320/#313-super-ugly-number-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Solution : def nthSuperUglyNumber ( self , n : int , primes : List [ int ]) -> int : k = len ( primes ) nums = [ 1 ] indices = [ 0 ] * k while len ( nums ) < n : nexts = [ 0 ] * k for i in range ( k ): nexts [ i ] = nums [ indices [ i ]] * primes [ i ] next = min ( nexts ) for i in range ( k ): if next == nexts [ i ]: indices [ i ] += 1 nums . append ( next ) return nums [ - 1 ]","title":"313. Super Ugly Number $\\star\\star$"},{"location":"python3/0301-0400/0311-0320/#314-binary-tree-vertical-order-traversal-starstar","text":"","title":"314. Binary Tree Vertical Order Traversal $\\star\\star$"},{"location":"python3/0301-0400/0311-0320/#315-count-of-smaller-numbers-after-self-starstarstar","text":"","title":"315. Count of Smaller Numbers After Self $\\star\\star\\star$"},{"location":"python3/0301-0400/0311-0320/#316-remove-duplicate-letters-starstarstar","text":"","title":"316. Remove Duplicate Letters $\\star\\star\\star$"},{"location":"python3/0301-0400/0311-0320/#317-shortest-distance-from-all-buildings-starstarstar","text":"","title":"317. Shortest Distance from All Buildings $\\star\\star\\star$"},{"location":"python3/0301-0400/0311-0320/#318-maximum-product-of-word-lengths-starstar","text":"","title":"318. Maximum Product of Word Lengths $\\star\\star$"},{"location":"python3/0301-0400/0311-0320/#319-bulb-switcher-starstar","text":"1 2 3 class Solution : def bulbSwitch ( self , n : int ) -> int : return int ( math . sqrt ( n ))","title":"319. Bulb Switcher $\\star\\star$"},{"location":"python3/0301-0400/0311-0320/#320-generalized-abbreviation-starstar","text":"","title":"320. Generalized Abbreviation $\\star\\star$"},{"location":"python3/0301-0400/0321-0330/","text":"321. Create Maximum Number $\\star\\star\\star$ 322. Coin Change $\\star\\star$ 323. Number of Connected Components in an Undirected Graph $\\star\\star$ 324. Wiggle Sort II $\\star\\star$ 325. Maximum Size Subarray Sum Equals k $\\star\\star$ 326. Power of Three $\\star$ 327. Count of Range Sum $\\star\\star\\star$ 328. Odd Even Linked List $\\star\\star$ 329. Longest Increasing Path in a Matrix $\\star\\star\\star$ 330. Patching Array $\\star\\star\\star$","title":"0321-0330"},{"location":"python3/0301-0400/0321-0330/#321-create-maximum-number-starstarstar","text":"","title":"321. Create Maximum Number $\\star\\star\\star$"},{"location":"python3/0301-0400/0321-0330/#322-coin-change-starstar","text":"","title":"322. Coin Change $\\star\\star$"},{"location":"python3/0301-0400/0321-0330/#323-number-of-connected-components-in-an-undirected-graph-starstar","text":"","title":"323. Number of Connected Components in an Undirected Graph $\\star\\star$"},{"location":"python3/0301-0400/0321-0330/#324-wiggle-sort-ii-starstar","text":"","title":"324. Wiggle Sort II $\\star\\star$"},{"location":"python3/0301-0400/0321-0330/#325-maximum-size-subarray-sum-equals-k-starstar","text":"","title":"325. Maximum Size Subarray Sum Equals k $\\star\\star$"},{"location":"python3/0301-0400/0321-0330/#326-power-of-three-star","text":"","title":"326. Power of Three $\\star$"},{"location":"python3/0301-0400/0321-0330/#327-count-of-range-sum-starstarstar","text":"","title":"327. Count of Range Sum $\\star\\star\\star$"},{"location":"python3/0301-0400/0321-0330/#328-odd-even-linked-list-starstar","text":"","title":"328. Odd Even Linked List $\\star\\star$"},{"location":"python3/0301-0400/0321-0330/#329-longest-increasing-path-in-a-matrix-starstarstar","text":"","title":"329. Longest Increasing Path in a Matrix $\\star\\star\\star$"},{"location":"python3/0301-0400/0321-0330/#330-patching-array-starstarstar","text":"","title":"330. Patching Array $\\star\\star\\star$"},{"location":"python3/0301-0400/0331-0340/","text":"331. Verify Preorder Serialization of a Binary Tree $\\star\\star$ 332. Reconstruct Itinerary $\\star\\star$ 333. Largest BST Subtree $\\star\\star$ 334. Increasing Triplet Subsequence $\\star\\star$ 335. Self Crossing $\\star\\star\\star$ 336. Palindrome Pairs $\\star\\star\\star$ 337. House Robber III $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def rob ( self , root : TreeNode ) -> int : return max ( self . helper ( root )) def helper ( self , root : TreeNode ) -> List [ int ]: if not root : return 0 , 0 left = self . helper ( root . left ) right = self . helper ( root . right ) return max ( left [ 0 ], left [ 1 ]) + max ( right [ 0 ], right [ 1 ]), \\ root . val + left [ 0 ] + right [ 0 ] 338. Counting Bits $\\star\\star$ 339. Nested List Weight Sum $\\star$ 340. Longest Substring with At Most K Distinct Characters $\\star\\star\\star$","title":"0331-0340"},{"location":"python3/0301-0400/0331-0340/#331-verify-preorder-serialization-of-a-binary-tree-starstar","text":"","title":"331. Verify Preorder Serialization of a Binary Tree $\\star\\star$"},{"location":"python3/0301-0400/0331-0340/#332-reconstruct-itinerary-starstar","text":"","title":"332. Reconstruct Itinerary $\\star\\star$"},{"location":"python3/0301-0400/0331-0340/#333-largest-bst-subtree-starstar","text":"","title":"333. Largest BST Subtree $\\star\\star$"},{"location":"python3/0301-0400/0331-0340/#334-increasing-triplet-subsequence-starstar","text":"","title":"334. Increasing Triplet Subsequence $\\star\\star$"},{"location":"python3/0301-0400/0331-0340/#335-self-crossing-starstarstar","text":"","title":"335. Self Crossing $\\star\\star\\star$"},{"location":"python3/0301-0400/0331-0340/#336-palindrome-pairs-starstarstar","text":"","title":"336. Palindrome Pairs $\\star\\star\\star$"},{"location":"python3/0301-0400/0331-0340/#337-house-robber-iii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def rob ( self , root : TreeNode ) -> int : return max ( self . helper ( root )) def helper ( self , root : TreeNode ) -> List [ int ]: if not root : return 0 , 0 left = self . helper ( root . left ) right = self . helper ( root . right ) return max ( left [ 0 ], left [ 1 ]) + max ( right [ 0 ], right [ 1 ]), \\ root . val + left [ 0 ] + right [ 0 ]","title":"337. House Robber III $\\star\\star$"},{"location":"python3/0301-0400/0331-0340/#338-counting-bits-starstar","text":"","title":"338. Counting Bits $\\star\\star$"},{"location":"python3/0301-0400/0331-0340/#339-nested-list-weight-sum-star","text":"","title":"339. Nested List Weight Sum $\\star$"},{"location":"python3/0301-0400/0331-0340/#340-longest-substring-with-at-most-k-distinct-characters-starstarstar","text":"","title":"340. Longest Substring with At Most K Distinct Characters $\\star\\star\\star$"},{"location":"python3/0301-0400/0341-0350/","text":"341. Flatten Nested List Iterator $\\star\\star$ 342. Power of Four $\\star$ 343. Integer Break $\\star\\star$ 344. Reverse String $\\star$ 345. Reverse Vowels of a String $\\star$ 346. Moving Average from Data Stream $\\star$ 347. Top K Frequent Elements $\\star\\star$ 348. Design Tic-Tac-Toe $\\star\\star$ 349. Intersection of Two Arrays $\\star$ 350. Intersection of Two Arrays II $\\star$","title":"0341-0350"},{"location":"python3/0301-0400/0341-0350/#341-flatten-nested-list-iterator-starstar","text":"","title":"341. Flatten Nested List Iterator $\\star\\star$"},{"location":"python3/0301-0400/0341-0350/#342-power-of-four-star","text":"","title":"342. Power of Four $\\star$"},{"location":"python3/0301-0400/0341-0350/#343-integer-break-starstar","text":"","title":"343. Integer Break $\\star\\star$"},{"location":"python3/0301-0400/0341-0350/#344-reverse-string-star","text":"","title":"344. Reverse String $\\star$"},{"location":"python3/0301-0400/0341-0350/#345-reverse-vowels-of-a-string-star","text":"","title":"345. Reverse Vowels of a String $\\star$"},{"location":"python3/0301-0400/0341-0350/#346-moving-average-from-data-stream-star","text":"","title":"346. Moving Average from Data Stream $\\star$"},{"location":"python3/0301-0400/0341-0350/#347-top-k-frequent-elements-starstar","text":"","title":"347. Top K Frequent Elements $\\star\\star$"},{"location":"python3/0301-0400/0341-0350/#348-design-tic-tac-toe-starstar","text":"","title":"348. Design Tic-Tac-Toe $\\star\\star$"},{"location":"python3/0301-0400/0341-0350/#349-intersection-of-two-arrays-star","text":"","title":"349. Intersection of Two Arrays $\\star$"},{"location":"python3/0301-0400/0341-0350/#350-intersection-of-two-arrays-ii-star","text":"","title":"350. Intersection of Two Arrays II $\\star$"},{"location":"python3/0301-0400/0351-0360/","text":"351. Android Unlock Patterns $\\star\\star$ 352. Data Stream as Disjoint Intervals $\\star\\star\\star$ 353. Design Snake Game $\\star\\star$ 354. Russian Doll Envelopes $\\star\\star\\star$ 355. Design Twitter $\\star\\star$ 356. Line Reflection $\\star\\star$ 357. Count Numbers with Unique Digits $\\star\\star$ 358. Rearrange String k Distance Apart $\\star\\star\\star$ 359. Logger Rate Limiter $\\star$ 360. Sort Transformed Array $\\star\\star$","title":"0351-0360"},{"location":"python3/0301-0400/0351-0360/#351-android-unlock-patterns-starstar","text":"","title":"351. Android Unlock Patterns $\\star\\star$"},{"location":"python3/0301-0400/0351-0360/#352-data-stream-as-disjoint-intervals-starstarstar","text":"","title":"352. Data Stream as Disjoint Intervals $\\star\\star\\star$"},{"location":"python3/0301-0400/0351-0360/#353-design-snake-game-starstar","text":"","title":"353. Design Snake Game $\\star\\star$"},{"location":"python3/0301-0400/0351-0360/#354-russian-doll-envelopes-starstarstar","text":"","title":"354. Russian Doll Envelopes $\\star\\star\\star$"},{"location":"python3/0301-0400/0351-0360/#355-design-twitter-starstar","text":"","title":"355. Design Twitter $\\star\\star$"},{"location":"python3/0301-0400/0351-0360/#356-line-reflection-starstar","text":"","title":"356. Line Reflection $\\star\\star$"},{"location":"python3/0301-0400/0351-0360/#357-count-numbers-with-unique-digits-starstar","text":"","title":"357. Count Numbers with Unique Digits $\\star\\star$"},{"location":"python3/0301-0400/0351-0360/#358-rearrange-string-k-distance-apart-starstarstar","text":"","title":"358. Rearrange String k Distance Apart $\\star\\star\\star$"},{"location":"python3/0301-0400/0351-0360/#359-logger-rate-limiter-star","text":"","title":"359. Logger Rate Limiter $\\star$"},{"location":"python3/0301-0400/0351-0360/#360-sort-transformed-array-starstar","text":"","title":"360. Sort Transformed Array $\\star\\star$"},{"location":"python3/0301-0400/0361-0370/","text":"361. Bomb Enemy $\\star\\star$ 362. Design Hit Counter $\\star\\star$ 363. Max Sum of Rectangle No Larger Than K $\\star\\star\\star$ 364. Nested List Weight Sum II $\\star\\star$ 365. Water and Jug Problem $\\star\\star$ 366. Find Leaves of Binary Tree $\\star\\star$ 367. Valid Perfect Square $\\star$ 368. Largest Divisible Subset $\\star\\star$ 369. Plus One Linked List $\\star\\star$ 370. Range Addition $\\star\\star$","title":"0361-0370"},{"location":"python3/0301-0400/0361-0370/#361-bomb-enemy-starstar","text":"","title":"361. Bomb Enemy $\\star\\star$"},{"location":"python3/0301-0400/0361-0370/#362-design-hit-counter-starstar","text":"","title":"362. Design Hit Counter $\\star\\star$"},{"location":"python3/0301-0400/0361-0370/#363-max-sum-of-rectangle-no-larger-than-k-starstarstar","text":"","title":"363. Max Sum of Rectangle No Larger Than K $\\star\\star\\star$"},{"location":"python3/0301-0400/0361-0370/#364-nested-list-weight-sum-ii-starstar","text":"","title":"364. Nested List Weight Sum II $\\star\\star$"},{"location":"python3/0301-0400/0361-0370/#365-water-and-jug-problem-starstar","text":"","title":"365. Water and Jug Problem $\\star\\star$"},{"location":"python3/0301-0400/0361-0370/#366-find-leaves-of-binary-tree-starstar","text":"","title":"366. Find Leaves of Binary Tree $\\star\\star$"},{"location":"python3/0301-0400/0361-0370/#367-valid-perfect-square-star","text":"","title":"367. Valid Perfect Square $\\star$"},{"location":"python3/0301-0400/0361-0370/#368-largest-divisible-subset-starstar","text":"","title":"368. Largest Divisible Subset $\\star\\star$"},{"location":"python3/0301-0400/0361-0370/#369-plus-one-linked-list-starstar","text":"","title":"369. Plus One Linked List $\\star\\star$"},{"location":"python3/0301-0400/0361-0370/#370-range-addition-starstar","text":"","title":"370. Range Addition $\\star\\star$"},{"location":"python3/0301-0400/0371-0380/","text":"371. Sum of Two Integers $\\star$ 372. Super Pow $\\star\\star$ 373. Find K Pairs with Smallest Sums $\\star\\star$ 374. Guess Number Higher or Lower $\\star$ 375. Guess Number Higher or Lower II $\\star\\star$ 376. Wiggle Subsequence $\\star\\star$ 377. Combination Sum IV $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def combinationSum4 ( self , nums : List [ int ], target : int ) -> int : m = [ - 1 ] * ( target + 1 ) m [ 0 ] = 1 return self . dp ( nums , target , m ) def dp ( self , nums : List [ int ], target : int , m : List [ int ]) -> int : if target < 0 : return 0 if m [ target ] != - 1 : return m [ target ] ans = 0 for num in nums : ans += self . dp ( nums , target - num , m ) m [ target ] = ans return ans 378. Kth Smallest Element in a Sorted Matrix $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def kthSmallest ( self , matrix : List [ List [ int ]], k : int ) -> int : l = matrix [ 0 ][ 0 ] r = matrix [ - 1 ][ - 1 ] while l < r : m = ( l + r ) >> 1 count = 0 for row in matrix : count += bisect . bisect ( row , m ) if count >= k : r = m else : l = m + 1 return l 379. Design Phone Directory $\\star\\star$ 380. Insert Delete GetRandom O(1) $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class RandomizedSet : def __init__ ( self ): self . vals = [] self . dict = collections . defaultdict ( int ) def insert ( self , val : int ) -> bool : if val in self . dict : return False self . dict [ val ] = len ( self . vals ) self . vals . append ( val ) return True def remove ( self , val : int ) -> bool : if val not in self . dict : return False index = self . dict [ val ] self . dict [ self . vals [ - 1 ]] = index del self . dict [ val ] self . vals [ index ] = self . vals [ - 1 ] self . vals . pop () return True def getRandom ( self ) -> int : index = random . randint ( 0 , len ( self . vals ) - 1 ) return self . vals [ index ]","title":"0371-0380"},{"location":"python3/0301-0400/0371-0380/#371-sum-of-two-integers-star","text":"","title":"371. Sum of Two Integers $\\star$"},{"location":"python3/0301-0400/0371-0380/#372-super-pow-starstar","text":"","title":"372. Super Pow $\\star\\star$"},{"location":"python3/0301-0400/0371-0380/#373-find-k-pairs-with-smallest-sums-starstar","text":"","title":"373. Find K Pairs with Smallest Sums $\\star\\star$"},{"location":"python3/0301-0400/0371-0380/#374-guess-number-higher-or-lower-star","text":"","title":"374. Guess Number Higher or Lower $\\star$"},{"location":"python3/0301-0400/0371-0380/#375-guess-number-higher-or-lower-ii-starstar","text":"","title":"375. Guess Number Higher or Lower II $\\star\\star$"},{"location":"python3/0301-0400/0371-0380/#376-wiggle-subsequence-starstar","text":"","title":"376. Wiggle Subsequence $\\star\\star$"},{"location":"python3/0301-0400/0371-0380/#377-combination-sum-iv-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def combinationSum4 ( self , nums : List [ int ], target : int ) -> int : m = [ - 1 ] * ( target + 1 ) m [ 0 ] = 1 return self . dp ( nums , target , m ) def dp ( self , nums : List [ int ], target : int , m : List [ int ]) -> int : if target < 0 : return 0 if m [ target ] != - 1 : return m [ target ] ans = 0 for num in nums : ans += self . dp ( nums , target - num , m ) m [ target ] = ans return ans","title":"377. Combination Sum IV $\\star\\star$"},{"location":"python3/0301-0400/0371-0380/#378-kth-smallest-element-in-a-sorted-matrix-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def kthSmallest ( self , matrix : List [ List [ int ]], k : int ) -> int : l = matrix [ 0 ][ 0 ] r = matrix [ - 1 ][ - 1 ] while l < r : m = ( l + r ) >> 1 count = 0 for row in matrix : count += bisect . bisect ( row , m ) if count >= k : r = m else : l = m + 1 return l","title":"378. Kth Smallest Element in a Sorted Matrix $\\star\\star$"},{"location":"python3/0301-0400/0371-0380/#379-design-phone-directory-starstar","text":"","title":"379. Design Phone Directory $\\star\\star$"},{"location":"python3/0301-0400/0371-0380/#380-insert-delete-getrandom-o1-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class RandomizedSet : def __init__ ( self ): self . vals = [] self . dict = collections . defaultdict ( int ) def insert ( self , val : int ) -> bool : if val in self . dict : return False self . dict [ val ] = len ( self . vals ) self . vals . append ( val ) return True def remove ( self , val : int ) -> bool : if val not in self . dict : return False index = self . dict [ val ] self . dict [ self . vals [ - 1 ]] = index del self . dict [ val ] self . vals [ index ] = self . vals [ - 1 ] self . vals . pop () return True def getRandom ( self ) -> int : index = random . randint ( 0 , len ( self . vals ) - 1 ) return self . vals [ index ]","title":"380. Insert Delete GetRandom O(1) $\\star\\star$"},{"location":"python3/0301-0400/0381-0390/","text":"381. Insert Delete GetRandom O(1) - Duplicates allowed $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class RandomizedCollection : def __init__ ( self ): self . vals = [] self . dict = collections . defaultdict ( list ) def insert ( self , val : int ) -> bool : self . dict [ val ] . append ( len ( self . vals )) self . vals . append ([ val , len ( self . dict [ val ]) - 1 ]) return len ( self . dict [ val ]) == 1 def remove ( self , val : int ) -> bool : if val not in self . dict or self . dict [ val ] == []: return False index = self . dict [ val ][ - 1 ] self . dict [ self . vals [ - 1 ][ 0 ]][ self . vals [ - 1 ][ 1 ]] = index self . dict [ val ] . pop () self . vals [ index ] = self . vals [ - 1 ] self . vals . pop () return True def getRandom ( self ) -> int : index = random . randint ( 0 , len ( self . vals ) - 1 ) return self . vals [ index ][ 0 ] 382. Linked List Random Node $\\star\\star$ 383. Ransom Note $\\star$ 384. Shuffle an Array $\\star\\star$ 385. Mini Parser $\\star\\star$ 386. Lexicographical Numbers $\\star\\star$ 387. First Unique Character in a String $\\star$ 388. Longest Absolute File Path $\\star\\star$ 389. Find the Difference $\\star$ 390. Elimination Game $\\star\\star$","title":"0381-0390"},{"location":"python3/0301-0400/0381-0390/#381-insert-delete-getrandom-o1-duplicates-allowed-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class RandomizedCollection : def __init__ ( self ): self . vals = [] self . dict = collections . defaultdict ( list ) def insert ( self , val : int ) -> bool : self . dict [ val ] . append ( len ( self . vals )) self . vals . append ([ val , len ( self . dict [ val ]) - 1 ]) return len ( self . dict [ val ]) == 1 def remove ( self , val : int ) -> bool : if val not in self . dict or self . dict [ val ] == []: return False index = self . dict [ val ][ - 1 ] self . dict [ self . vals [ - 1 ][ 0 ]][ self . vals [ - 1 ][ 1 ]] = index self . dict [ val ] . pop () self . vals [ index ] = self . vals [ - 1 ] self . vals . pop () return True def getRandom ( self ) -> int : index = random . randint ( 0 , len ( self . vals ) - 1 ) return self . vals [ index ][ 0 ]","title":"381. Insert Delete GetRandom O(1) - Duplicates allowed $\\star\\star\\star$"},{"location":"python3/0301-0400/0381-0390/#382-linked-list-random-node-starstar","text":"","title":"382. Linked List Random Node $\\star\\star$"},{"location":"python3/0301-0400/0381-0390/#383-ransom-note-star","text":"","title":"383. Ransom Note $\\star$"},{"location":"python3/0301-0400/0381-0390/#384-shuffle-an-array-starstar","text":"","title":"384. Shuffle an Array $\\star\\star$"},{"location":"python3/0301-0400/0381-0390/#385-mini-parser-starstar","text":"","title":"385. Mini Parser $\\star\\star$"},{"location":"python3/0301-0400/0381-0390/#386-lexicographical-numbers-starstar","text":"","title":"386. Lexicographical Numbers $\\star\\star$"},{"location":"python3/0301-0400/0381-0390/#387-first-unique-character-in-a-string-star","text":"","title":"387. First Unique Character in a String $\\star$"},{"location":"python3/0301-0400/0381-0390/#388-longest-absolute-file-path-starstar","text":"","title":"388. Longest Absolute File Path $\\star\\star$"},{"location":"python3/0301-0400/0381-0390/#389-find-the-difference-star","text":"","title":"389. Find the Difference $\\star$"},{"location":"python3/0301-0400/0381-0390/#390-elimination-game-starstar","text":"","title":"390. Elimination Game $\\star\\star$"},{"location":"python3/0301-0400/0391-0400/","text":"391. Perfect Rectangle $\\star\\star\\star$ 392. Is Subsequence $\\star$ 393. UTF-8 Validation $\\star\\star$ 394. Decode String $\\star\\star$ 395. Longest Substring with At Least K Repeating Characters $\\star\\star$ 396. Rotate Function $\\star\\star$ 397. Integer Replacement $\\star\\star$ 398. Random Pick Index $\\star\\star$ 399. Evaluate Division $\\star\\star$ 400. Nth Digit $\\star\\star$","title":"0391-0300"},{"location":"python3/0301-0400/0391-0400/#391-perfect-rectangle-starstarstar","text":"","title":"391. Perfect Rectangle $\\star\\star\\star$"},{"location":"python3/0301-0400/0391-0400/#392-is-subsequence-star","text":"","title":"392. Is Subsequence $\\star$"},{"location":"python3/0301-0400/0391-0400/#393-utf-8-validation-starstar","text":"","title":"393. UTF-8 Validation $\\star\\star$"},{"location":"python3/0301-0400/0391-0400/#394-decode-string-starstar","text":"","title":"394. Decode String $\\star\\star$"},{"location":"python3/0301-0400/0391-0400/#395-longest-substring-with-at-least-k-repeating-characters-starstar","text":"","title":"395. Longest Substring with At Least K Repeating Characters $\\star\\star$"},{"location":"python3/0301-0400/0391-0400/#396-rotate-function-starstar","text":"","title":"396. Rotate Function $\\star\\star$"},{"location":"python3/0301-0400/0391-0400/#397-integer-replacement-starstar","text":"","title":"397. Integer Replacement $\\star\\star$"},{"location":"python3/0301-0400/0391-0400/#398-random-pick-index-starstar","text":"","title":"398. Random Pick Index $\\star\\star$"},{"location":"python3/0301-0400/0391-0400/#399-evaluate-division-starstar","text":"","title":"399. Evaluate Division $\\star\\star$"},{"location":"python3/0301-0400/0391-0400/#400-nth-digit-starstar","text":"","title":"400. Nth Digit $\\star\\star$"},{"location":"python3/0401-0500/0401-0410/","text":"401. Binary Watch $\\star$ 402. Remove K Digits $\\star\\star$ 403. Frog Jump $\\star\\star\\star$ 404. Sum of Left Leaves $\\star$ 405. Convert a Number to Hexadecimal $\\star$ 406. Queue Reconstruction by Height $\\star\\star$ 407. Trapping Rain Water II $\\star\\star\\star$ 408. Valid Word Abbreviation $\\star$ 409. Longest Palindrome $\\star$ 410. Split Array Largest Sum $\\star\\star\\star$","title":"0401-0410"},{"location":"python3/0401-0500/0401-0410/#401-binary-watch-star","text":"","title":"401. Binary Watch $\\star$"},{"location":"python3/0401-0500/0401-0410/#402-remove-k-digits-starstar","text":"","title":"402. Remove K Digits $\\star\\star$"},{"location":"python3/0401-0500/0401-0410/#403-frog-jump-starstarstar","text":"","title":"403. Frog Jump $\\star\\star\\star$"},{"location":"python3/0401-0500/0401-0410/#404-sum-of-left-leaves-star","text":"","title":"404. Sum of Left Leaves $\\star$"},{"location":"python3/0401-0500/0401-0410/#405-convert-a-number-to-hexadecimal-star","text":"","title":"405. Convert a Number to Hexadecimal $\\star$"},{"location":"python3/0401-0500/0401-0410/#406-queue-reconstruction-by-height-starstar","text":"","title":"406. Queue Reconstruction by Height $\\star\\star$"},{"location":"python3/0401-0500/0401-0410/#407-trapping-rain-water-ii-starstarstar","text":"","title":"407. Trapping Rain Water II $\\star\\star\\star$"},{"location":"python3/0401-0500/0401-0410/#408-valid-word-abbreviation-star","text":"","title":"408. Valid Word Abbreviation $\\star$"},{"location":"python3/0401-0500/0401-0410/#409-longest-palindrome-star","text":"","title":"409. Longest Palindrome $\\star$"},{"location":"python3/0401-0500/0401-0410/#410-split-array-largest-sum-starstarstar","text":"","title":"410. Split Array Largest Sum $\\star\\star\\star$"},{"location":"python3/0401-0500/0411-0420/","text":"411. Minimum Unique Word Abbreviation $\\star\\star\\star$ 412. Fizz Buzz $\\star$ 413. Arithmetic Slices $\\star\\star$ 414. Third Maximum Number $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from heapq import heappush , heappop class Solution : def thirdMax ( self , nums : List [ int ]) -> int : heap = [] set_ = set () for num in nums : if num not in set_ : set_ . add ( num ) heappush ( heap , num ) if len ( heap ) > 3 : heappop ( heap ) if len ( heap ) == 2 : heappop ( heap ) return heap [ 0 ] 415. Add Strings $\\star$ 416. Partition Equal Subset Sum $\\star\\star$ 417. Pacific Atlantic Water Flow $\\star\\star$ 418. Sentence Screen Fitting $\\star\\star$ 419. Battleships in a Board $\\star\\star$ 420. Strong Password Checker $\\star\\star\\star$","title":"0411-0420"},{"location":"python3/0401-0500/0411-0420/#411-minimum-unique-word-abbreviation-starstarstar","text":"","title":"411. Minimum Unique Word Abbreviation $\\star\\star\\star$"},{"location":"python3/0401-0500/0411-0420/#412-fizz-buzz-star","text":"","title":"412. Fizz Buzz $\\star$"},{"location":"python3/0401-0500/0411-0420/#413-arithmetic-slices-starstar","text":"","title":"413. Arithmetic Slices $\\star\\star$"},{"location":"python3/0401-0500/0411-0420/#414-third-maximum-number-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from heapq import heappush , heappop class Solution : def thirdMax ( self , nums : List [ int ]) -> int : heap = [] set_ = set () for num in nums : if num not in set_ : set_ . add ( num ) heappush ( heap , num ) if len ( heap ) > 3 : heappop ( heap ) if len ( heap ) == 2 : heappop ( heap ) return heap [ 0 ]","title":"414. Third Maximum Number $\\star$"},{"location":"python3/0401-0500/0411-0420/#415-add-strings-star","text":"","title":"415. Add Strings $\\star$"},{"location":"python3/0401-0500/0411-0420/#416-partition-equal-subset-sum-starstar","text":"","title":"416. Partition Equal Subset Sum $\\star\\star$"},{"location":"python3/0401-0500/0411-0420/#417-pacific-atlantic-water-flow-starstar","text":"","title":"417. Pacific Atlantic Water Flow $\\star\\star$"},{"location":"python3/0401-0500/0411-0420/#418-sentence-screen-fitting-starstar","text":"","title":"418. Sentence Screen Fitting $\\star\\star$"},{"location":"python3/0401-0500/0411-0420/#419-battleships-in-a-board-starstar","text":"","title":"419. Battleships in a Board $\\star\\star$"},{"location":"python3/0401-0500/0411-0420/#420-strong-password-checker-starstarstar","text":"","title":"420. Strong Password Checker $\\star\\star\\star$"},{"location":"python3/0401-0500/0421-0430/","text":"421. Maximum XOR of Two Numbers in an Array $\\star\\star$ 422. Valid Word Square $\\star$ 423. Reconstruct Original Digits from English $\\star\\star$ 424. Longest Repeating Character Replacement $\\star\\star$ 425. Word Squares $\\star\\star\\star$ 426. Convert Binary Search Tree to Sorted Doubly Linked List $\\star\\star$ 427. Construct Quad Tree $\\star\\star$ 428. Serialize and Deserialize N-ary Tree $\\star\\star\\star$ 429. N-ary Tree Level Order Traversal $\\star\\star$ 430. Flatten a Multilevel Doubly Linked List $\\star\\star$","title":"0421-0430"},{"location":"python3/0401-0500/0421-0430/#421-maximum-xor-of-two-numbers-in-an-array-starstar","text":"","title":"421. Maximum XOR of Two Numbers in an Array $\\star\\star$"},{"location":"python3/0401-0500/0421-0430/#422-valid-word-square-star","text":"","title":"422. Valid Word Square $\\star$"},{"location":"python3/0401-0500/0421-0430/#423-reconstruct-original-digits-from-english-starstar","text":"","title":"423. Reconstruct Original Digits from English $\\star\\star$"},{"location":"python3/0401-0500/0421-0430/#424-longest-repeating-character-replacement-starstar","text":"","title":"424. Longest Repeating Character Replacement $\\star\\star$"},{"location":"python3/0401-0500/0421-0430/#425-word-squares-starstarstar","text":"","title":"425. Word Squares $\\star\\star\\star$"},{"location":"python3/0401-0500/0421-0430/#426-convert-binary-search-tree-to-sorted-doubly-linked-list-starstar","text":"","title":"426. Convert Binary Search Tree to Sorted Doubly Linked List $\\star\\star$"},{"location":"python3/0401-0500/0421-0430/#427-construct-quad-tree-starstar","text":"","title":"427. Construct Quad Tree $\\star\\star$"},{"location":"python3/0401-0500/0421-0430/#428-serialize-and-deserialize-n-ary-tree-starstarstar","text":"","title":"428. Serialize and Deserialize N-ary Tree $\\star\\star\\star$"},{"location":"python3/0401-0500/0421-0430/#429-n-ary-tree-level-order-traversal-starstar","text":"","title":"429. N-ary Tree Level Order Traversal $\\star\\star$"},{"location":"python3/0401-0500/0421-0430/#430-flatten-a-multilevel-doubly-linked-list-starstar","text":"","title":"430. Flatten a Multilevel Doubly Linked List $\\star\\star$"},{"location":"python3/0401-0500/0431-0440/","text":"431. Encode N-ary Tree to Binary Tree $\\star\\star\\star$ 432. All O`one Data Structure $\\star\\star\\star$ 433. Minimum Genetic Mutation $\\star\\star$ 434. Number of Segments in a String $\\star$ 435. Non-overlapping Intervals $\\star\\star$ 436. Find Right Interval $\\star\\star$ 437. Path Sum III $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def pathSum ( self , root : TreeNode , sum : int ) -> int : if not root : return 0 return self . helper ( root , sum ) + \\ self . pathSum ( root . left , sum ) + \\ self . pathSum ( root . right , sum ) def helper ( self , root : TreeNode , sum : int ) -> int : if not root : return 0 return ( sum == root . val ) + \\ self . helper ( root . left , sum - root . val ) + \\ self . helper ( root . right , sum - root . val ) 438. Find All Anagrams in a String $\\star\\star$ 439. Ternary Expression Parser $\\star\\star$ 440. K-th Smallest in Lexicographical Order $\\star\\star\\star$","title":"0431-0440"},{"location":"python3/0401-0500/0431-0440/#431-encode-n-ary-tree-to-binary-tree-starstarstar","text":"","title":"431. Encode N-ary Tree to Binary Tree $\\star\\star\\star$"},{"location":"python3/0401-0500/0431-0440/#432-all-oone-data-structure-starstarstar","text":"","title":"432. All O`one Data Structure $\\star\\star\\star$"},{"location":"python3/0401-0500/0431-0440/#433-minimum-genetic-mutation-starstar","text":"","title":"433. Minimum Genetic Mutation $\\star\\star$"},{"location":"python3/0401-0500/0431-0440/#434-number-of-segments-in-a-string-star","text":"","title":"434. Number of Segments in a String $\\star$"},{"location":"python3/0401-0500/0431-0440/#435-non-overlapping-intervals-starstar","text":"","title":"435. Non-overlapping Intervals $\\star\\star$"},{"location":"python3/0401-0500/0431-0440/#436-find-right-interval-starstar","text":"","title":"436. Find Right Interval $\\star\\star$"},{"location":"python3/0401-0500/0431-0440/#437-path-sum-iii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def pathSum ( self , root : TreeNode , sum : int ) -> int : if not root : return 0 return self . helper ( root , sum ) + \\ self . pathSum ( root . left , sum ) + \\ self . pathSum ( root . right , sum ) def helper ( self , root : TreeNode , sum : int ) -> int : if not root : return 0 return ( sum == root . val ) + \\ self . helper ( root . left , sum - root . val ) + \\ self . helper ( root . right , sum - root . val )","title":"437. Path Sum III $\\star$"},{"location":"python3/0401-0500/0431-0440/#438-find-all-anagrams-in-a-string-starstar","text":"","title":"438. Find All Anagrams in a String $\\star\\star$"},{"location":"python3/0401-0500/0431-0440/#439-ternary-expression-parser-starstar","text":"","title":"439. Ternary Expression Parser $\\star\\star$"},{"location":"python3/0401-0500/0431-0440/#440-k-th-smallest-in-lexicographical-order-starstarstar","text":"","title":"440. K-th Smallest in Lexicographical Order $\\star\\star\\star$"},{"location":"python3/0401-0500/0441-0450/","text":"441. Arranging Coins $\\star$ 442. Find All Duplicates in an Array $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution : def findDuplicates ( self , nums : List [ int ]) -> List [ int ]: ans = [] for num in nums : nums [ abs ( num ) - 1 ] *= - 1 if nums [ abs ( num ) - 1 ] > 0 : ans . append ( abs ( num )) return ans 443. String Compression $\\star$ 444. Sequence Reconstruction $\\star\\star$ 445. Add Two Numbers II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def addTwoNumbers ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : stack1 = [] stack2 = [] while l1 : stack1 . append ( l1 ) l1 = l1 . next while l2 : stack2 . append ( l2 ) l2 = l2 . next head = None carry = 0 while carry or stack1 or stack2 : carry += ( stack1 . pop () . val if stack1 else 0 ) + \\ ( stack2 . pop () . val if stack2 else 0 ) node = ListNode ( carry % 10 ) node . next = head head = node carry //= 10 return head 446. Arithmetic Slices II - Subsequence $\\star\\star\\star$ 447. Number of Boomerangs $\\star$ 448. Find All Numbers Disappeared in an Array $\\star$ 1 2 3 4 5 6 7 class Solution : def findDisappearedNumbers ( self , nums : List [ int ]) -> List [ int ]: for num in nums : index = abs ( num ) - 1 nums [ index ] = - abs ( nums [ index ]) return [ i + 1 for i , num in enumerate ( nums ) if num > 0 ] 449. Serialize and Deserialize BST $\\star\\star$ 450. Delete Node in a BST $\\star\\star$","title":"0441-0450"},{"location":"python3/0401-0500/0441-0450/#441-arranging-coins-star","text":"","title":"441. Arranging Coins $\\star$"},{"location":"python3/0401-0500/0441-0450/#442-find-all-duplicates-in-an-array-starstar","text":"1 2 3 4 5 6 7 8 9 10 class Solution : def findDuplicates ( self , nums : List [ int ]) -> List [ int ]: ans = [] for num in nums : nums [ abs ( num ) - 1 ] *= - 1 if nums [ abs ( num ) - 1 ] > 0 : ans . append ( abs ( num )) return ans","title":"442. Find All Duplicates in an Array $\\star\\star$"},{"location":"python3/0401-0500/0441-0450/#443-string-compression-star","text":"","title":"443. String Compression $\\star$"},{"location":"python3/0401-0500/0441-0450/#444-sequence-reconstruction-starstar","text":"","title":"444. Sequence Reconstruction $\\star\\star$"},{"location":"python3/0401-0500/0441-0450/#445-add-two-numbers-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Solution : def addTwoNumbers ( self , l1 : ListNode , l2 : ListNode ) -> ListNode : stack1 = [] stack2 = [] while l1 : stack1 . append ( l1 ) l1 = l1 . next while l2 : stack2 . append ( l2 ) l2 = l2 . next head = None carry = 0 while carry or stack1 or stack2 : carry += ( stack1 . pop () . val if stack1 else 0 ) + \\ ( stack2 . pop () . val if stack2 else 0 ) node = ListNode ( carry % 10 ) node . next = head head = node carry //= 10 return head","title":"445. Add Two Numbers II $\\star\\star$"},{"location":"python3/0401-0500/0441-0450/#446-arithmetic-slices-ii-subsequence-starstarstar","text":"","title":"446. Arithmetic Slices II - Subsequence $\\star\\star\\star$"},{"location":"python3/0401-0500/0441-0450/#447-number-of-boomerangs-star","text":"","title":"447. Number of Boomerangs $\\star$"},{"location":"python3/0401-0500/0441-0450/#448-find-all-numbers-disappeared-in-an-array-star","text":"1 2 3 4 5 6 7 class Solution : def findDisappearedNumbers ( self , nums : List [ int ]) -> List [ int ]: for num in nums : index = abs ( num ) - 1 nums [ index ] = - abs ( nums [ index ]) return [ i + 1 for i , num in enumerate ( nums ) if num > 0 ]","title":"448. Find All Numbers Disappeared in an Array $\\star$"},{"location":"python3/0401-0500/0441-0450/#449-serialize-and-deserialize-bst-starstar","text":"","title":"449. Serialize and Deserialize BST $\\star\\star$"},{"location":"python3/0401-0500/0441-0450/#450-delete-node-in-a-bst-starstar","text":"","title":"450. Delete Node in a BST $\\star\\star$"},{"location":"python3/0401-0500/0451-0460/","text":"451. Sort Characters By Frequency $\\star\\star$ 452. Minimum Number of Arrows to Burst Balloons $\\star\\star$ 453. Minimum Moves to Equal Array Elements $\\star$ 454. 4Sum II $\\star\\star$ 1 2 3 4 5 class Solution : def fourSumCount ( self , A : List [ int ], B : List [ int ], C : List [ int ], D : List [ int ]) -> int : dict = collections . Counter ( a + b for a in A for b in B ) return sum ( dict [ - c - d ] for c in C for d in D ) 455. Assign Cookies $\\star$ 456. 132 Pattern $\\star\\star$ 457. Circular Array Loop $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def circularArrayLoop ( self , nums : List [ int ]) -> bool : def advance ( i : int ) -> int : return ( i + nums [ i ]) % len ( nums ) if len ( nums ) < 2 : return False for i , num in enumerate ( nums ): if num == 0 : continue slow = i fast = advance ( slow ) while num * nums [ fast ] > 0 and num * nums [ advance ( fast )] > 0 : if slow == fast : if slow == advance ( slow ): break return True slow = advance ( slow ) fast = advance ( advance ( fast )) slow = i sign = num while sign * nums [ slow ] > 0 : next = advance ( slow ) nums [ slow ] = 0 slow = next return False 458. Poor Pigs $\\star\\star\\star$ 459. Repeated Substring Pattern $\\star$ 460. LFU Cache $\\star\\star\\star$","title":"0451-0460"},{"location":"python3/0401-0500/0451-0460/#451-sort-characters-by-frequency-starstar","text":"","title":"451. Sort Characters By Frequency $\\star\\star$"},{"location":"python3/0401-0500/0451-0460/#452-minimum-number-of-arrows-to-burst-balloons-starstar","text":"","title":"452. Minimum Number of Arrows to Burst Balloons $\\star\\star$"},{"location":"python3/0401-0500/0451-0460/#453-minimum-moves-to-equal-array-elements-star","text":"","title":"453. Minimum Moves to Equal Array Elements $\\star$"},{"location":"python3/0401-0500/0451-0460/#454-4sum-ii-starstar","text":"1 2 3 4 5 class Solution : def fourSumCount ( self , A : List [ int ], B : List [ int ], C : List [ int ], D : List [ int ]) -> int : dict = collections . Counter ( a + b for a in A for b in B ) return sum ( dict [ - c - d ] for c in C for d in D )","title":"454. 4Sum II $\\star\\star$"},{"location":"python3/0401-0500/0451-0460/#455-assign-cookies-star","text":"","title":"455. Assign Cookies $\\star$"},{"location":"python3/0401-0500/0451-0460/#456-132-pattern-starstar","text":"","title":"456. 132 Pattern $\\star\\star$"},{"location":"python3/0401-0500/0451-0460/#457-circular-array-loop-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def circularArrayLoop ( self , nums : List [ int ]) -> bool : def advance ( i : int ) -> int : return ( i + nums [ i ]) % len ( nums ) if len ( nums ) < 2 : return False for i , num in enumerate ( nums ): if num == 0 : continue slow = i fast = advance ( slow ) while num * nums [ fast ] > 0 and num * nums [ advance ( fast )] > 0 : if slow == fast : if slow == advance ( slow ): break return True slow = advance ( slow ) fast = advance ( advance ( fast )) slow = i sign = num while sign * nums [ slow ] > 0 : next = advance ( slow ) nums [ slow ] = 0 slow = next return False","title":"457. Circular Array Loop $\\star\\star$"},{"location":"python3/0401-0500/0451-0460/#458-poor-pigs-starstarstar","text":"","title":"458. Poor Pigs $\\star\\star\\star$"},{"location":"python3/0401-0500/0451-0460/#459-repeated-substring-pattern-star","text":"","title":"459. Repeated Substring Pattern $\\star$"},{"location":"python3/0401-0500/0451-0460/#460-lfu-cache-starstarstar","text":"","title":"460. LFU Cache $\\star\\star\\star$"},{"location":"python3/0401-0500/0461-0470/","text":"461. Hamming Distance $\\star$ 462. Minimum Moves to Equal Array Elements II $\\star\\star$ 463. Island Perimeter $\\star$ 464. Can I Win $\\star\\star$ 465. Optimal Account Balancing $\\star\\star\\star$ 466. Count The Repetitions $\\star\\star\\star$ 467. Unique Substrings in Wraparound String $\\star\\star$ 468. Validate IP Address $\\star\\star$ 469. Convex Polygon $\\star\\star$ 470. Implement Rand10() Using Rand7() $\\star\\star$","title":"0461-0470"},{"location":"python3/0401-0500/0461-0470/#461-hamming-distance-star","text":"","title":"461. Hamming Distance $\\star$"},{"location":"python3/0401-0500/0461-0470/#462-minimum-moves-to-equal-array-elements-ii-starstar","text":"","title":"462. Minimum Moves to Equal Array Elements II $\\star\\star$"},{"location":"python3/0401-0500/0461-0470/#463-island-perimeter-star","text":"","title":"463. Island Perimeter $\\star$"},{"location":"python3/0401-0500/0461-0470/#464-can-i-win-starstar","text":"","title":"464. Can I Win $\\star\\star$"},{"location":"python3/0401-0500/0461-0470/#465-optimal-account-balancing-starstarstar","text":"","title":"465. Optimal Account Balancing $\\star\\star\\star$"},{"location":"python3/0401-0500/0461-0470/#466-count-the-repetitions-starstarstar","text":"","title":"466. Count The Repetitions $\\star\\star\\star$"},{"location":"python3/0401-0500/0461-0470/#467-unique-substrings-in-wraparound-string-starstar","text":"","title":"467. Unique Substrings in Wraparound String $\\star\\star$"},{"location":"python3/0401-0500/0461-0470/#468-validate-ip-address-starstar","text":"","title":"468. Validate IP Address $\\star\\star$"},{"location":"python3/0401-0500/0461-0470/#469-convex-polygon-starstar","text":"","title":"469. Convex Polygon $\\star\\star$"},{"location":"python3/0401-0500/0461-0470/#470-implement-rand10-using-rand7-starstar","text":"","title":"470. Implement Rand10() Using Rand7() $\\star\\star$"},{"location":"python3/0401-0500/0471-0480/","text":"471. Encode String with Shortest Length $\\star\\star\\star$ 472. Concatenated Words $\\star\\star\\star$ 473. Matchsticks to Square $\\star\\star$ 474. Ones and Zeroes $\\star\\star$ 475. Heaters $\\star$ 476. Number Complement $\\star$ 477. Total Hamming Distance $\\star\\star$ 478. Generate Random Point in a Circle $\\star\\star$ 479. Largest Palindrome Product $\\star\\star\\star$ 480. Sliding Window Median $\\star\\star\\star$","title":"0471-0480"},{"location":"python3/0401-0500/0471-0480/#471-encode-string-with-shortest-length-starstarstar","text":"","title":"471. Encode String with Shortest Length $\\star\\star\\star$"},{"location":"python3/0401-0500/0471-0480/#472-concatenated-words-starstarstar","text":"","title":"472. Concatenated Words $\\star\\star\\star$"},{"location":"python3/0401-0500/0471-0480/#473-matchsticks-to-square-starstar","text":"","title":"473. Matchsticks to Square $\\star\\star$"},{"location":"python3/0401-0500/0471-0480/#474-ones-and-zeroes-starstar","text":"","title":"474. Ones and Zeroes $\\star\\star$"},{"location":"python3/0401-0500/0471-0480/#475-heaters-star","text":"","title":"475. Heaters $\\star$"},{"location":"python3/0401-0500/0471-0480/#476-number-complement-star","text":"","title":"476. Number Complement $\\star$"},{"location":"python3/0401-0500/0471-0480/#477-total-hamming-distance-starstar","text":"","title":"477. Total Hamming Distance $\\star\\star$"},{"location":"python3/0401-0500/0471-0480/#478-generate-random-point-in-a-circle-starstar","text":"","title":"478. Generate Random Point in a Circle $\\star\\star$"},{"location":"python3/0401-0500/0471-0480/#479-largest-palindrome-product-starstarstar","text":"","title":"479. Largest Palindrome Product $\\star\\star\\star$"},{"location":"python3/0401-0500/0471-0480/#480-sliding-window-median-starstarstar","text":"","title":"480. Sliding Window Median $\\star\\star\\star$"},{"location":"python3/0401-0500/0481-0490/","text":"481. Magical String $\\star\\star$ 482. License Key Formatting $\\star$ 483. Smallest Good Base $\\star\\star\\star$ 484. Find Permutation $\\star\\star$ 485. Max Consecutive Ones $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def findMaxConsecutiveOnes ( self , nums : List [ int ]) -> int : ans = 0 sum = 0 for num in nums : if num == 0 : sum = 0 else : sum += num ans = max ( ans , sum ) return ans 486. Predict the Winner $\\star\\star$ 487. Max Consecutive Ones II $\\star\\star$ 488. Zuma Game $\\star\\star\\star$ 489. Robot Room Cleaner $\\star\\star\\star$ 490. The Maze $\\star\\star$","title":"0481-0490"},{"location":"python3/0401-0500/0481-0490/#481-magical-string-starstar","text":"","title":"481. Magical String $\\star\\star$"},{"location":"python3/0401-0500/0481-0490/#482-license-key-formatting-star","text":"","title":"482. License Key Formatting $\\star$"},{"location":"python3/0401-0500/0481-0490/#483-smallest-good-base-starstarstar","text":"","title":"483. Smallest Good Base $\\star\\star\\star$"},{"location":"python3/0401-0500/0481-0490/#484-find-permutation-starstar","text":"","title":"484. Find Permutation $\\star\\star$"},{"location":"python3/0401-0500/0481-0490/#485-max-consecutive-ones-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def findMaxConsecutiveOnes ( self , nums : List [ int ]) -> int : ans = 0 sum = 0 for num in nums : if num == 0 : sum = 0 else : sum += num ans = max ( ans , sum ) return ans","title":"485. Max Consecutive Ones $\\star$"},{"location":"python3/0401-0500/0481-0490/#486-predict-the-winner-starstar","text":"","title":"486. Predict the Winner $\\star\\star$"},{"location":"python3/0401-0500/0481-0490/#487-max-consecutive-ones-ii-starstar","text":"","title":"487. Max Consecutive Ones II $\\star\\star$"},{"location":"python3/0401-0500/0481-0490/#488-zuma-game-starstarstar","text":"","title":"488. Zuma Game $\\star\\star\\star$"},{"location":"python3/0401-0500/0481-0490/#489-robot-room-cleaner-starstarstar","text":"","title":"489. Robot Room Cleaner $\\star\\star\\star$"},{"location":"python3/0401-0500/0481-0490/#490-the-maze-starstar","text":"","title":"490. The Maze $\\star\\star$"},{"location":"python3/0401-0500/0491-0500/","text":"491. Increasing Subsequences $\\star\\star$ 492. Construct the Rectangle $\\star$ 493. Reverse Pairs $\\star\\star\\star$ 494. Target Sum $\\star\\star$ 495. Teemo Attacking $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution : def findPoisonedDuration ( self , timeSeries : List [ int ], duration : int ) -> int : if timeSeries == [] or duration == 0 : return 0 ans = 0 for i in range ( 0 , len ( timeSeries ) - 1 ): ans += min ( timeSeries [ i + 1 ] - timeSeries [ i ], duration ) return ans + duration 496. Next Greater Element I $\\star$ 497. Random Point in Non-overlapping Rectangles $\\star\\star$ 498. Diagonal Traverse $\\star\\star$ 499. The Maze III $\\star\\star\\star$ 500. Keyboard Row $\\star$","title":"0491-0500"},{"location":"python3/0401-0500/0491-0500/#491-increasing-subsequences-starstar","text":"","title":"491. Increasing Subsequences $\\star\\star$"},{"location":"python3/0401-0500/0491-0500/#492-construct-the-rectangle-star","text":"","title":"492. Construct the Rectangle $\\star$"},{"location":"python3/0401-0500/0491-0500/#493-reverse-pairs-starstarstar","text":"","title":"493. Reverse Pairs $\\star\\star\\star$"},{"location":"python3/0401-0500/0491-0500/#494-target-sum-starstar","text":"","title":"494. Target Sum $\\star\\star$"},{"location":"python3/0401-0500/0491-0500/#495-teemo-attacking-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution : def findPoisonedDuration ( self , timeSeries : List [ int ], duration : int ) -> int : if timeSeries == [] or duration == 0 : return 0 ans = 0 for i in range ( 0 , len ( timeSeries ) - 1 ): ans += min ( timeSeries [ i + 1 ] - timeSeries [ i ], duration ) return ans + duration","title":"495. Teemo Attacking $\\star\\star$"},{"location":"python3/0401-0500/0491-0500/#496-next-greater-element-i-star","text":"","title":"496. Next Greater Element I $\\star$"},{"location":"python3/0401-0500/0491-0500/#497-random-point-in-non-overlapping-rectangles-starstar","text":"","title":"497. Random Point in Non-overlapping Rectangles $\\star\\star$"},{"location":"python3/0401-0500/0491-0500/#498-diagonal-traverse-starstar","text":"","title":"498. Diagonal Traverse $\\star\\star$"},{"location":"python3/0401-0500/0491-0500/#499-the-maze-iii-starstarstar","text":"","title":"499. The Maze III $\\star\\star\\star$"},{"location":"python3/0401-0500/0491-0500/#500-keyboard-row-star","text":"","title":"500. Keyboard Row $\\star$"},{"location":"python3/0501-0600/0501-0510/","text":"501. Find Mode in Binary Search Tree $\\star$ 502. IPO $\\star\\star\\star$ 503. Next Greater Element II $\\star\\star$ 504. Base 7 $\\star$ 505. The Maze II $\\star\\star$ 506. Relative Ranks $\\star$ 507. Perfect Number $\\star$ 508. Most Frequent Subtree Sum $\\star\\star$ 509. Fibonacci Number $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def fib ( self , N : int ) -> int : if N < 2 : return N dp = [ 0 , 0 , 1 ] for i in range ( 2 , N + 1 ): dp [ 0 ] = dp [ 1 ] dp [ 1 ] = dp [ 2 ] dp [ 2 ] = dp [ 0 ] + dp [ 1 ] return dp [ 2 ] 510. Inorder Successor in BST II $\\star\\star$","title":"0501-0510"},{"location":"python3/0501-0600/0501-0510/#501-find-mode-in-binary-search-tree-star","text":"","title":"501. Find Mode in Binary Search Tree $\\star$"},{"location":"python3/0501-0600/0501-0510/#502-ipo-starstarstar","text":"","title":"502. IPO $\\star\\star\\star$"},{"location":"python3/0501-0600/0501-0510/#503-next-greater-element-ii-starstar","text":"","title":"503. Next Greater Element II $\\star\\star$"},{"location":"python3/0501-0600/0501-0510/#504-base-7-star","text":"","title":"504. Base 7 $\\star$"},{"location":"python3/0501-0600/0501-0510/#505-the-maze-ii-starstar","text":"","title":"505. The Maze II $\\star\\star$"},{"location":"python3/0501-0600/0501-0510/#506-relative-ranks-star","text":"","title":"506. Relative Ranks $\\star$"},{"location":"python3/0501-0600/0501-0510/#507-perfect-number-star","text":"","title":"507. Perfect Number $\\star$"},{"location":"python3/0501-0600/0501-0510/#508-most-frequent-subtree-sum-starstar","text":"","title":"508. Most Frequent Subtree Sum $\\star\\star$"},{"location":"python3/0501-0600/0501-0510/#509-fibonacci-number-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def fib ( self , N : int ) -> int : if N < 2 : return N dp = [ 0 , 0 , 1 ] for i in range ( 2 , N + 1 ): dp [ 0 ] = dp [ 1 ] dp [ 1 ] = dp [ 2 ] dp [ 2 ] = dp [ 0 ] + dp [ 1 ] return dp [ 2 ]","title":"509. Fibonacci Number $\\star$"},{"location":"python3/0501-0600/0501-0510/#510-inorder-successor-in-bst-ii-starstar","text":"","title":"510. Inorder Successor in BST II $\\star\\star$"},{"location":"python3/0501-0600/0511-0520/","text":"511. Game Play Analysis I $\\star$ 512. Game Play Analysis II $\\star$ 513. Find Bottom Left Tree Value $\\star\\star$ 514. Freedom Trail $\\star\\star\\star$ 515. Find Largest Value in Each Tree Row $\\star\\star$ 516. Longest Palindromic Subsequence $\\star\\star$ 517. Super Washing Machines $\\star\\star\\star$ 518. Coin Change 2 $\\star\\star$ 519. Random Flip Matrix $\\star\\star$ 520. Detect Capital $\\star$","title":"0511-0520"},{"location":"python3/0501-0600/0511-0520/#511-game-play-analysis-i-star","text":"","title":"511. Game Play Analysis I $\\star$"},{"location":"python3/0501-0600/0511-0520/#512-game-play-analysis-ii-star","text":"","title":"512. Game Play Analysis II $\\star$"},{"location":"python3/0501-0600/0511-0520/#513-find-bottom-left-tree-value-starstar","text":"","title":"513. Find Bottom Left Tree Value $\\star\\star$"},{"location":"python3/0501-0600/0511-0520/#514-freedom-trail-starstarstar","text":"","title":"514. Freedom Trail $\\star\\star\\star$"},{"location":"python3/0501-0600/0511-0520/#515-find-largest-value-in-each-tree-row-starstar","text":"","title":"515. Find Largest Value in Each Tree Row $\\star\\star$"},{"location":"python3/0501-0600/0511-0520/#516-longest-palindromic-subsequence-starstar","text":"","title":"516. Longest Palindromic Subsequence $\\star\\star$"},{"location":"python3/0501-0600/0511-0520/#517-super-washing-machines-starstarstar","text":"","title":"517. Super Washing Machines $\\star\\star\\star$"},{"location":"python3/0501-0600/0511-0520/#518-coin-change-2-starstar","text":"","title":"518. Coin Change 2 $\\star\\star$"},{"location":"python3/0501-0600/0511-0520/#519-random-flip-matrix-starstar","text":"","title":"519. Random Flip Matrix $\\star\\star$"},{"location":"python3/0501-0600/0511-0520/#520-detect-capital-star","text":"","title":"520. Detect Capital $\\star$"},{"location":"python3/0501-0600/0521-0530/","text":"521. Longest Uncommon Subsequence I $\\star$ 522. Longest Uncommon Subsequence II $\\star\\star$ 523. Continuous Subarray Sum $\\star\\star$ 524. Longest Word in Dictionary through Deleting $\\star\\star$ 525. Contiguous Array $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def findMaxLength ( self , nums : List [ int ]) -> int : if not nums : return 0 ans = 0 sum = 0 dict = {} for i in range ( len ( nums )): sum += 1 if nums [ i ] else - 1 if sum == 0 : ans = i + 1 elif sum in dict : ans = max ( ans , i - dict [ sum ]) else : dict [ sum ] = i return ans 526. Beautiful Arrangement $\\star\\star$ 527. Word Abbreviation $\\star\\star\\star$ 528. Random Pick with Weight $\\star\\star$ 529. Minesweeper $\\star\\star$ 530. Minimum Absolute Difference in BST $\\star$","title":"0521-0530"},{"location":"python3/0501-0600/0521-0530/#521-longest-uncommon-subsequence-i-star","text":"","title":"521. Longest Uncommon Subsequence I  $\\star$"},{"location":"python3/0501-0600/0521-0530/#522-longest-uncommon-subsequence-ii-starstar","text":"","title":"522. Longest Uncommon Subsequence II $\\star\\star$"},{"location":"python3/0501-0600/0521-0530/#523-continuous-subarray-sum-starstar","text":"","title":"523. Continuous Subarray Sum $\\star\\star$"},{"location":"python3/0501-0600/0521-0530/#524-longest-word-in-dictionary-through-deleting-starstar","text":"","title":"524. Longest Word in Dictionary through Deleting $\\star\\star$"},{"location":"python3/0501-0600/0521-0530/#525-contiguous-array-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def findMaxLength ( self , nums : List [ int ]) -> int : if not nums : return 0 ans = 0 sum = 0 dict = {} for i in range ( len ( nums )): sum += 1 if nums [ i ] else - 1 if sum == 0 : ans = i + 1 elif sum in dict : ans = max ( ans , i - dict [ sum ]) else : dict [ sum ] = i return ans","title":"525. Contiguous Array $\\star\\star$"},{"location":"python3/0501-0600/0521-0530/#526-beautiful-arrangement-starstar","text":"","title":"526. Beautiful Arrangement $\\star\\star$"},{"location":"python3/0501-0600/0521-0530/#527-word-abbreviation-starstarstar","text":"","title":"527. Word Abbreviation $\\star\\star\\star$"},{"location":"python3/0501-0600/0521-0530/#528-random-pick-with-weight-starstar","text":"","title":"528. Random Pick with Weight $\\star\\star$"},{"location":"python3/0501-0600/0521-0530/#529-minesweeper-starstar","text":"","title":"529. Minesweeper $\\star\\star$"},{"location":"python3/0501-0600/0521-0530/#530-minimum-absolute-difference-in-bst-star","text":"","title":"530. Minimum Absolute Difference in BST $\\star$"},{"location":"python3/0501-0600/0531-0540/","text":"531. Lonely Pixel I $\\star\\star$ 532. K-diff Pairs in an Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def findPairs ( self , nums : List [ int ], k : int ) -> int : if k < 0 : return 0 ans = 0 dict = { num : i for i , num in enumerate ( nums )} for i , num in enumerate ( nums ): target = num + k if target in dict and dict [ target ] != i : ans += 1 del dict [ target ] return ans 533. Lonely Pixel II $\\star\\star$ 534. Game Play Analysis III $\\star\\star$ 535. Encode and Decode TinyURL $\\star\\star$ 536. Construct Binary Tree from String $\\star\\star$ 537. Complex Number Multiplication $\\star\\star$ 538. Convert BST to Greater Tree $\\star$ 539. Minimum Time Difference $\\star\\star$ 540. Single Element in a Sorted Array $\\star\\star$","title":"0531-0540"},{"location":"python3/0501-0600/0531-0540/#531-lonely-pixel-i-starstar","text":"","title":"531. Lonely Pixel I $\\star\\star$"},{"location":"python3/0501-0600/0531-0540/#532-k-diff-pairs-in-an-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def findPairs ( self , nums : List [ int ], k : int ) -> int : if k < 0 : return 0 ans = 0 dict = { num : i for i , num in enumerate ( nums )} for i , num in enumerate ( nums ): target = num + k if target in dict and dict [ target ] != i : ans += 1 del dict [ target ] return ans","title":"532. K-diff Pairs in an Array $\\star$"},{"location":"python3/0501-0600/0531-0540/#533-lonely-pixel-ii-starstar","text":"","title":"533. Lonely Pixel II $\\star\\star$"},{"location":"python3/0501-0600/0531-0540/#534-game-play-analysis-iii-starstar","text":"","title":"534. Game Play Analysis III $\\star\\star$"},{"location":"python3/0501-0600/0531-0540/#535-encode-and-decode-tinyurl-starstar","text":"","title":"535. Encode and Decode TinyURL $\\star\\star$"},{"location":"python3/0501-0600/0531-0540/#536-construct-binary-tree-from-string-starstar","text":"","title":"536. Construct Binary Tree from String $\\star\\star$"},{"location":"python3/0501-0600/0531-0540/#537-complex-number-multiplication-starstar","text":"","title":"537. Complex Number Multiplication $\\star\\star$"},{"location":"python3/0501-0600/0531-0540/#538-convert-bst-to-greater-tree-star","text":"","title":"538. Convert BST to Greater Tree $\\star$"},{"location":"python3/0501-0600/0531-0540/#539-minimum-time-difference-starstar","text":"","title":"539. Minimum Time Difference $\\star\\star$"},{"location":"python3/0501-0600/0531-0540/#540-single-element-in-a-sorted-array-starstar","text":"","title":"540. Single Element in a Sorted Array $\\star\\star$"},{"location":"python3/0501-0600/0541-0550/","text":"541. Reverse String II $\\star$ 542. 01 Matrix $\\star\\star$ 543. Diameter of Binary Tree $\\star$ 544. Output Contest Matches $\\star\\star$ 545. Boundary of Binary Tree $\\star\\star$ 546. Remove Boxes $\\star\\star\\star$ 547. Friend Circles $\\star\\star$ 548. Split Array with Equal Sum $\\star\\star$ 549. Binary Tree Longest Consecutive Sequence II $\\star\\star$ 550. Game Play Analysis IV $\\star\\star$","title":"0541-0550"},{"location":"python3/0501-0600/0541-0550/#541-reverse-string-ii-star","text":"","title":"541. Reverse String II $\\star$"},{"location":"python3/0501-0600/0541-0550/#542-01-matrix-starstar","text":"","title":"542. 01 Matrix $\\star\\star$"},{"location":"python3/0501-0600/0541-0550/#543-diameter-of-binary-tree-star","text":"","title":"543. Diameter of Binary Tree $\\star$"},{"location":"python3/0501-0600/0541-0550/#544-output-contest-matches-starstar","text":"","title":"544. Output Contest Matches $\\star\\star$"},{"location":"python3/0501-0600/0541-0550/#545-boundary-of-binary-tree-starstar","text":"","title":"545. Boundary of Binary Tree $\\star\\star$"},{"location":"python3/0501-0600/0541-0550/#546-remove-boxes-starstarstar","text":"","title":"546. Remove Boxes $\\star\\star\\star$"},{"location":"python3/0501-0600/0541-0550/#547-friend-circles-starstar","text":"","title":"547. Friend Circles $\\star\\star$"},{"location":"python3/0501-0600/0541-0550/#548-split-array-with-equal-sum-starstar","text":"","title":"548. Split Array with Equal Sum $\\star\\star$"},{"location":"python3/0501-0600/0541-0550/#549-binary-tree-longest-consecutive-sequence-ii-starstar","text":"","title":"549. Binary Tree Longest Consecutive Sequence II $\\star\\star$"},{"location":"python3/0501-0600/0541-0550/#550-game-play-analysis-iv-starstar","text":"","title":"550. Game Play Analysis IV $\\star\\star$"},{"location":"python3/0501-0600/0551-0560/","text":"551. Student Attendance Record I $\\star$ 552. Student Attendance Record II $\\star\\star\\star$ 553. Optimal Division $\\star\\star$ 554. Brick Wall $\\star\\star$ 555. Split Concatenated Strings $\\star\\star$ 556. Next Greater Element III $\\star\\star$ 557. Reverse Words in a String III $\\star$ 558. Quad Tree Intersection $\\star$ 559. Maximum Depth of N-ary Tree $\\star$ 560. Subarray Sum Equals K $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def subarraySum ( self , nums : List [ int ], k : int ) -> int : ans = 0 sum = 0 dict = collections . defaultdict ( lambda : 0 ) dict [ 0 ] = 1 for num in nums : sum += num ans += dict [ sum - k ] dict [ sum ] += 1 return ans","title":"0551-0560"},{"location":"python3/0501-0600/0551-0560/#551-student-attendance-record-i-star","text":"","title":"551. Student Attendance Record I $\\star$"},{"location":"python3/0501-0600/0551-0560/#552-student-attendance-record-ii-starstarstar","text":"","title":"552. Student Attendance Record II $\\star\\star\\star$"},{"location":"python3/0501-0600/0551-0560/#553-optimal-division-starstar","text":"","title":"553. Optimal Division $\\star\\star$"},{"location":"python3/0501-0600/0551-0560/#554-brick-wall-starstar","text":"","title":"554. Brick Wall $\\star\\star$"},{"location":"python3/0501-0600/0551-0560/#555-split-concatenated-strings-starstar","text":"","title":"555. Split Concatenated Strings $\\star\\star$"},{"location":"python3/0501-0600/0551-0560/#556-next-greater-element-iii-starstar","text":"","title":"556. Next Greater Element III $\\star\\star$"},{"location":"python3/0501-0600/0551-0560/#557-reverse-words-in-a-string-iii-star","text":"","title":"557. Reverse Words in a String III $\\star$"},{"location":"python3/0501-0600/0551-0560/#558-quad-tree-intersection-star","text":"","title":"558. Quad Tree Intersection $\\star$"},{"location":"python3/0501-0600/0551-0560/#559-maximum-depth-of-n-ary-tree-star","text":"","title":"559. Maximum Depth of N-ary Tree $\\star$"},{"location":"python3/0501-0600/0551-0560/#560-subarray-sum-equals-k-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def subarraySum ( self , nums : List [ int ], k : int ) -> int : ans = 0 sum = 0 dict = collections . defaultdict ( lambda : 0 ) dict [ 0 ] = 1 for num in nums : sum += num ans += dict [ sum - k ] dict [ sum ] += 1 return ans","title":"560. Subarray Sum Equals K $\\star\\star$"},{"location":"python3/0501-0600/0561-0570/","text":"561. Array Partition I $\\star$ 1 2 3 class Solution : def arrayPairSum ( self , nums : List [ int ]) -> int : return sum ( sorted ( nums )[:: 2 ]) 562. Longest Line of Consecutive One in Matrix $\\star\\star$ 563. Binary Tree Tilt $\\star$ 564. Find the Closest Palindrome $\\star\\star\\star$ 565. Array Nesting $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def arrayNesting ( self , nums : List [ int ]) -> int : ans = 0 for num in nums : if num == - 1 : continue index = num count = 0 while nums [ index ] != - 1 : temp = index index = nums [ index ] nums [ temp ] = - 1 count += 1 ans = max ( ans , count ) return ans 566. Reshape the Matrix $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def matrixReshape ( self , nums : List [ List [ int ]], r : int , c : int ) -> List [ List [ int ]]: if nums == [] or r * c != len ( nums ) * len ( nums [ 0 ]): return nums ans = [[ 0 for j in range ( c )] for i in range ( r )] k = 0 for row in nums : for num in row : ans [ k // c ][ k % c ] = num k += 1 return ans 567. Permutation in String $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def checkInclusion ( self , s1 : str , s2 : str ) -> bool : m = len ( s1 ) n = len ( s2 ) map1 = [ 0 ] * 26 map2 = [ 0 ] * 26 for c in s1 : map1 [ ord ( c ) - ord ( 'a' )] += 1 for i in range ( n ): if i >= m : map2 [ ord ( s2 [ i - m ]) - ord ( 'a' )] -= 1 map2 [ ord ( s2 [ i ]) - ord ( 'a' )] += 1 if map1 == map2 : return True return False 568. Maximum Vacation Days $\\star\\star\\star$ 569. Median Employee Salary $\\star\\star\\star$ 570. Managers with at Least 5 Direct Reports $\\star\\star$","title":"0561-0570"},{"location":"python3/0501-0600/0561-0570/#561-array-partition-i-star","text":"1 2 3 class Solution : def arrayPairSum ( self , nums : List [ int ]) -> int : return sum ( sorted ( nums )[:: 2 ])","title":"561. Array Partition I $\\star$"},{"location":"python3/0501-0600/0561-0570/#562-longest-line-of-consecutive-one-in-matrix-starstar","text":"","title":"562. Longest Line of Consecutive One in Matrix $\\star\\star$"},{"location":"python3/0501-0600/0561-0570/#563-binary-tree-tilt-star","text":"","title":"563. Binary Tree Tilt $\\star$"},{"location":"python3/0501-0600/0561-0570/#564-find-the-closest-palindrome-starstarstar","text":"","title":"564. Find the Closest Palindrome $\\star\\star\\star$"},{"location":"python3/0501-0600/0561-0570/#565-array-nesting-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def arrayNesting ( self , nums : List [ int ]) -> int : ans = 0 for num in nums : if num == - 1 : continue index = num count = 0 while nums [ index ] != - 1 : temp = index index = nums [ index ] nums [ temp ] = - 1 count += 1 ans = max ( ans , count ) return ans","title":"565. Array Nesting $\\star\\star$"},{"location":"python3/0501-0600/0561-0570/#566-reshape-the-matrix-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def matrixReshape ( self , nums : List [ List [ int ]], r : int , c : int ) -> List [ List [ int ]]: if nums == [] or r * c != len ( nums ) * len ( nums [ 0 ]): return nums ans = [[ 0 for j in range ( c )] for i in range ( r )] k = 0 for row in nums : for num in row : ans [ k // c ][ k % c ] = num k += 1 return ans","title":"566. Reshape the Matrix $\\star$"},{"location":"python3/0501-0600/0561-0570/#567-permutation-in-string-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def checkInclusion ( self , s1 : str , s2 : str ) -> bool : m = len ( s1 ) n = len ( s2 ) map1 = [ 0 ] * 26 map2 = [ 0 ] * 26 for c in s1 : map1 [ ord ( c ) - ord ( 'a' )] += 1 for i in range ( n ): if i >= m : map2 [ ord ( s2 [ i - m ]) - ord ( 'a' )] -= 1 map2 [ ord ( s2 [ i ]) - ord ( 'a' )] += 1 if map1 == map2 : return True return False","title":"567. Permutation in String $\\star\\star$"},{"location":"python3/0501-0600/0561-0570/#568-maximum-vacation-days-starstarstar","text":"","title":"568. Maximum Vacation Days $\\star\\star\\star$"},{"location":"python3/0501-0600/0561-0570/#569-median-employee-salary-starstarstar","text":"","title":"569. Median Employee Salary $\\star\\star\\star$"},{"location":"python3/0501-0600/0561-0570/#570-managers-with-at-least-5-direct-reports-starstar","text":"","title":"570. Managers with at Least 5 Direct Reports $\\star\\star$"},{"location":"python3/0501-0600/0571-0580/","text":"571. Find Median Given Frequency of Numbers $\\star\\star\\star$ 572. Subtree of Another Tree $\\star$ 573. Squirrel Simulation $\\star\\star$ 574. Winning Candidate $\\star\\star$ 575. Distribute Candies $\\star$ 576. Out of Boundary Paths $\\star\\star$ 577. Employee Bonus $\\star$ 578. Get Highest Answer Rate Question $\\star\\star$ 579. Find Cumulative Salary of an Employee $\\star\\star\\star$ 580. Count Student Number in Departments $\\star\\star$","title":"0571-0580"},{"location":"python3/0501-0600/0571-0580/#571-find-median-given-frequency-of-numbers-starstarstar","text":"","title":"571. Find Median Given Frequency of Numbers $\\star\\star\\star$"},{"location":"python3/0501-0600/0571-0580/#572-subtree-of-another-tree-star","text":"","title":"572. Subtree of Another Tree $\\star$"},{"location":"python3/0501-0600/0571-0580/#573-squirrel-simulation-starstar","text":"","title":"573. Squirrel Simulation $\\star\\star$"},{"location":"python3/0501-0600/0571-0580/#574-winning-candidate-starstar","text":"","title":"574. Winning Candidate $\\star\\star$"},{"location":"python3/0501-0600/0571-0580/#575-distribute-candies-star","text":"","title":"575. Distribute Candies $\\star$"},{"location":"python3/0501-0600/0571-0580/#576-out-of-boundary-paths-starstar","text":"","title":"576. Out of Boundary Paths $\\star\\star$"},{"location":"python3/0501-0600/0571-0580/#577-employee-bonus-star","text":"","title":"577. Employee Bonus $\\star$"},{"location":"python3/0501-0600/0571-0580/#578-get-highest-answer-rate-question-starstar","text":"","title":"578. Get Highest Answer Rate Question $\\star\\star$"},{"location":"python3/0501-0600/0571-0580/#579-find-cumulative-salary-of-an-employee-starstarstar","text":"","title":"579. Find Cumulative Salary of an Employee $\\star\\star\\star$"},{"location":"python3/0501-0600/0571-0580/#580-count-student-number-in-departments-starstar","text":"","title":"580. Count Student Number in Departments $\\star\\star$"},{"location":"python3/0501-0600/0581-0590/","text":"581. Shortest Unsorted Continuous Subarray $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution : def findUnsortedSubarray ( self , nums : List [ int ]) -> int : min_ = float ( 'inf' ) max_ = float ( '-inf' ) flag = False for i in range ( 1 , len ( nums )): if nums [ i ] < nums [ i - 1 ]: flag = True if flag : min_ = min ( min_ , nums [ i ]) flag = False for i in range ( len ( nums ) - 2 , - 1 , - 1 ): if nums [ i ] > nums [ i + 1 ]: flag = True if flag : max_ = max ( max_ , nums [ i ]) for l in range ( len ( nums )): if nums [ l ] > min_ : break for r in range ( len ( nums ) - 1 , - 1 , - 1 ): if nums [ r ] < max_ : break return 0 if l >= r else r - l + 1 582. Kill Process $\\star\\star$ 583. Delete Operation for Two Strings $\\star\\star$ 584. Find Customer Referee $\\star$ 585. Investments in 2016 $\\star\\star$ 586. Customer Placing the Largest Number of Orders $\\star$ 587. Erect the Fence $\\star\\star\\star$ 588. Design In-Memory File System $\\star\\star\\star$ 589. N-ary Tree Preorder Traversal $\\star$ 590. N-ary Tree Postorder Traversal $\\star$","title":"0581-0590"},{"location":"python3/0501-0600/0581-0590/#581-shortest-unsorted-continuous-subarray-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Solution : def findUnsortedSubarray ( self , nums : List [ int ]) -> int : min_ = float ( 'inf' ) max_ = float ( '-inf' ) flag = False for i in range ( 1 , len ( nums )): if nums [ i ] < nums [ i - 1 ]: flag = True if flag : min_ = min ( min_ , nums [ i ]) flag = False for i in range ( len ( nums ) - 2 , - 1 , - 1 ): if nums [ i ] > nums [ i + 1 ]: flag = True if flag : max_ = max ( max_ , nums [ i ]) for l in range ( len ( nums )): if nums [ l ] > min_ : break for r in range ( len ( nums ) - 1 , - 1 , - 1 ): if nums [ r ] < max_ : break return 0 if l >= r else r - l + 1","title":"581. Shortest Unsorted Continuous Subarray $\\star$"},{"location":"python3/0501-0600/0581-0590/#582-kill-process-starstar","text":"","title":"582. Kill Process $\\star\\star$"},{"location":"python3/0501-0600/0581-0590/#583-delete-operation-for-two-strings-starstar","text":"","title":"583. Delete Operation for Two Strings $\\star\\star$"},{"location":"python3/0501-0600/0581-0590/#584-find-customer-referee-star","text":"","title":"584. Find Customer Referee $\\star$"},{"location":"python3/0501-0600/0581-0590/#585-investments-in-2016-starstar","text":"","title":"585. Investments in 2016 $\\star\\star$"},{"location":"python3/0501-0600/0581-0590/#586-customer-placing-the-largest-number-of-orders-star","text":"","title":"586. Customer Placing the Largest Number of Orders $\\star$"},{"location":"python3/0501-0600/0581-0590/#587-erect-the-fence-starstarstar","text":"","title":"587. Erect the Fence $\\star\\star\\star$"},{"location":"python3/0501-0600/0581-0590/#588-design-in-memory-file-system-starstarstar","text":"","title":"588. Design In-Memory File System $\\star\\star\\star$"},{"location":"python3/0501-0600/0581-0590/#589-n-ary-tree-preorder-traversal-star","text":"","title":"589. N-ary Tree Preorder Traversal $\\star$"},{"location":"python3/0501-0600/0581-0590/#590-n-ary-tree-postorder-traversal-star","text":"","title":"590. N-ary Tree Postorder Traversal $\\star$"},{"location":"python3/0501-0600/0591-0600/","text":"591. Tag Validator $\\star\\star\\star$ 592. Fraction Addition and Subtraction $\\star\\star$ 593. Valid Square $\\star\\star$ 594. Longest Harmonious Subsequence $\\star$ 595. Big Countries $\\star$ 596. Classes More Than 5 Students $\\star$ 597. Friend Requests I: Overall Acceptance Rate $\\star$ 598. Range Addition II $\\star$ 599. Minimum Index Sum of Two Lists $\\star$ 600. Non-negative Integers without Consecutive Ones $\\star\\star\\star$","title":"0591-0600"},{"location":"python3/0501-0600/0591-0600/#591-tag-validator-starstarstar","text":"","title":"591. Tag Validator $\\star\\star\\star$"},{"location":"python3/0501-0600/0591-0600/#592-fraction-addition-and-subtraction-starstar","text":"","title":"592. Fraction Addition and Subtraction $\\star\\star$"},{"location":"python3/0501-0600/0591-0600/#593-valid-square-starstar","text":"","title":"593. Valid Square $\\star\\star$"},{"location":"python3/0501-0600/0591-0600/#594-longest-harmonious-subsequence-star","text":"","title":"594. Longest Harmonious Subsequence $\\star$"},{"location":"python3/0501-0600/0591-0600/#595-big-countries-star","text":"","title":"595. Big Countries $\\star$"},{"location":"python3/0501-0600/0591-0600/#596-classes-more-than-5-students-star","text":"","title":"596. Classes More Than 5 Students $\\star$"},{"location":"python3/0501-0600/0591-0600/#597-friend-requests-i-overall-acceptance-rate-star","text":"","title":"597. Friend Requests I: Overall Acceptance Rate $\\star$"},{"location":"python3/0501-0600/0591-0600/#598-range-addition-ii-star","text":"","title":"598. Range Addition II $\\star$"},{"location":"python3/0501-0600/0591-0600/#599-minimum-index-sum-of-two-lists-star","text":"","title":"599. Minimum Index Sum of Two Lists $\\star$"},{"location":"python3/0501-0600/0591-0600/#600-non-negative-integers-without-consecutive-ones-starstarstar","text":"","title":"600. Non-negative Integers without Consecutive Ones $\\star\\star\\star$"},{"location":"python3/0601-0700/0601-0610/","text":"601. Human Traffic of Stadium $\\star\\star\\star$ 602. Friend Requests II: Who Has the Most Friends $\\star\\star$ 603. Consecutive Available Seats $\\star$ 604. Design Compressed String Iterator $\\star$ 605. Can Place Flowers $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution : def canPlaceFlowers ( self , flowerbed : List [ int ], n : int ) -> bool : for i , flower in enumerate ( flowerbed ): if flower == 0 and ( i == 0 or flowerbed [ i - 1 ] == 0 ) and ( i == len ( flowerbed ) - 1 or flowerbed [ i + 1 ] == 0 ): flowerbed [ i ] = 1 n -= 1 if n <= 0 : return True return False 606. Construct String from Binary Tree $\\star$ 607. Sales Person $\\star$ 608. Tree Node $\\star\\star$ 609. Find Duplicate File in System $\\star\\star$ 610. Triangle Judgement $\\star$","title":"0601-0610"},{"location":"python3/0601-0700/0601-0610/#601-human-traffic-of-stadium-starstarstar","text":"","title":"601. Human Traffic of Stadium $\\star\\star\\star$"},{"location":"python3/0601-0700/0601-0610/#602-friend-requests-ii-who-has-the-most-friends-starstar","text":"","title":"602. Friend Requests II: Who Has the Most Friends $\\star\\star$"},{"location":"python3/0601-0700/0601-0610/#603-consecutive-available-seats-star","text":"","title":"603. Consecutive Available Seats $\\star$"},{"location":"python3/0601-0700/0601-0610/#604-design-compressed-string-iterator-star","text":"","title":"604. Design Compressed String Iterator $\\star$"},{"location":"python3/0601-0700/0601-0610/#605-can-place-flowers-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution : def canPlaceFlowers ( self , flowerbed : List [ int ], n : int ) -> bool : for i , flower in enumerate ( flowerbed ): if flower == 0 and ( i == 0 or flowerbed [ i - 1 ] == 0 ) and ( i == len ( flowerbed ) - 1 or flowerbed [ i + 1 ] == 0 ): flowerbed [ i ] = 1 n -= 1 if n <= 0 : return True return False","title":"605. Can Place Flowers $\\star$"},{"location":"python3/0601-0700/0601-0610/#606-construct-string-from-binary-tree-star","text":"","title":"606. Construct String from Binary Tree $\\star$"},{"location":"python3/0601-0700/0601-0610/#607-sales-person-star","text":"","title":"607. Sales Person $\\star$"},{"location":"python3/0601-0700/0601-0610/#608-tree-node-starstar","text":"","title":"608. Tree Node $\\star\\star$"},{"location":"python3/0601-0700/0601-0610/#609-find-duplicate-file-in-system-starstar","text":"","title":"609. Find Duplicate File in System $\\star\\star$"},{"location":"python3/0601-0700/0601-0610/#610-triangle-judgement-star","text":"","title":"610. Triangle Judgement $\\star$"},{"location":"python3/0601-0700/0611-0620/","text":"611. Valid Triangle Number $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def triangleNumber ( self , nums : List [ int ]) -> int : ans = 0 nums . sort () for k in range ( len ( nums ) - 1 , 1 , - 1 ): i = 0 j = k - 1 while i < j : if nums [ i ] + nums [ j ] > nums [ k ]: ans += j - i j -= 1 else : i += 1 return ans 612. Shortest Distance in a Plane $\\star\\star$ 613. Shortest Distance in a Line $\\star$ 614. Second Degree Follower $\\star\\star$ 615. Average Salary: Departments VS Company $\\star\\star\\star$ 616. Add Bold Tag in String $\\star\\star$ 617. Merge Two Binary Trees $\\star$ 618. Students Report By Geography $\\star\\star\\star$ 619. Biggest Single Number $\\star$ 620. Not Boring Movies $\\star$","title":"0611-0620"},{"location":"python3/0601-0700/0611-0620/#611-valid-triangle-number-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def triangleNumber ( self , nums : List [ int ]) -> int : ans = 0 nums . sort () for k in range ( len ( nums ) - 1 , 1 , - 1 ): i = 0 j = k - 1 while i < j : if nums [ i ] + nums [ j ] > nums [ k ]: ans += j - i j -= 1 else : i += 1 return ans","title":"611. Valid Triangle Number $\\star\\star$"},{"location":"python3/0601-0700/0611-0620/#612-shortest-distance-in-a-plane-starstar","text":"","title":"612. Shortest Distance in a Plane $\\star\\star$"},{"location":"python3/0601-0700/0611-0620/#613-shortest-distance-in-a-line-star","text":"","title":"613. Shortest Distance in a Line $\\star$"},{"location":"python3/0601-0700/0611-0620/#614-second-degree-follower-starstar","text":"","title":"614. Second Degree Follower $\\star\\star$"},{"location":"python3/0601-0700/0611-0620/#615-average-salary-departments-vs-company-starstarstar","text":"","title":"615. Average Salary: Departments VS Company $\\star\\star\\star$"},{"location":"python3/0601-0700/0611-0620/#616-add-bold-tag-in-string-starstar","text":"","title":"616. Add Bold Tag in String $\\star\\star$"},{"location":"python3/0601-0700/0611-0620/#617-merge-two-binary-trees-star","text":"","title":"617. Merge Two Binary Trees $\\star$"},{"location":"python3/0601-0700/0611-0620/#618-students-report-by-geography-starstarstar","text":"","title":"618. Students Report By Geography $\\star\\star\\star$"},{"location":"python3/0601-0700/0611-0620/#619-biggest-single-number-star","text":"","title":"619. Biggest Single Number $\\star$"},{"location":"python3/0601-0700/0611-0620/#620-not-boring-movies-star","text":"","title":"620. Not Boring Movies $\\star$"},{"location":"python3/0601-0700/0621-0630/","text":"621. Task Scheduler $\\star\\star$ 1 2 3 4 5 6 7 8 9 class Solution : def leastInterval ( self , tasks : List [ str ], n : int ) -> int : dict = collections . Counter ( tasks ) maxCount = max ( dict . values ()) ans = ( maxCount - 1 ) * ( n + 1 ) ans += sum ( map ( lambda value : value == maxCount , dict . values ())) return max ( ans , len ( tasks )) 622. Design Circular Queue $\\star\\star$ 623. Add One Row to Tree $\\star\\star$ 624. Maximum Distance in Arrays $\\star$ 625. Minimum Factorization $\\star\\star$ 626. Exchange Seats $\\star\\star$ 627. Swap Salary $\\star$ 628. Maximum Product of Three Numbers $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def maximumProduct ( self , nums : List [ int ]) -> int : min = float ( 'inf' ) secondMin = float ( 'inf' ) max_ = float ( '-inf' ) secondMax = float ( '-inf' ) thirdMax = float ( '-inf' ) for num in nums : if num <= min : secondMin = min min = num elif num <= secondMin : secondMin = num if num >= max_ : thirdMax = secondMax secondMax = max_ max_ = num elif num >= secondMax : thirdMax = secondMax secondMax = num elif num >= thirdMax : thirdMax = num return max ( min * secondMin * max_ , max_ * secondMax * thirdMax ) 629. K Inverse Pairs Array $\\star\\star\\star$ 630. Course Schedule III $\\star\\star\\star$","title":"0621-0630"},{"location":"python3/0601-0700/0621-0630/#621-task-scheduler-starstar","text":"1 2 3 4 5 6 7 8 9 class Solution : def leastInterval ( self , tasks : List [ str ], n : int ) -> int : dict = collections . Counter ( tasks ) maxCount = max ( dict . values ()) ans = ( maxCount - 1 ) * ( n + 1 ) ans += sum ( map ( lambda value : value == maxCount , dict . values ())) return max ( ans , len ( tasks ))","title":"621. Task Scheduler $\\star\\star$"},{"location":"python3/0601-0700/0621-0630/#622-design-circular-queue-starstar","text":"","title":"622. Design Circular Queue $\\star\\star$"},{"location":"python3/0601-0700/0621-0630/#623-add-one-row-to-tree-starstar","text":"","title":"623. Add One Row to Tree $\\star\\star$"},{"location":"python3/0601-0700/0621-0630/#624-maximum-distance-in-arrays-star","text":"","title":"624. Maximum Distance in Arrays $\\star$"},{"location":"python3/0601-0700/0621-0630/#625-minimum-factorization-starstar","text":"","title":"625. Minimum Factorization $\\star\\star$"},{"location":"python3/0601-0700/0621-0630/#626-exchange-seats-starstar","text":"","title":"626. Exchange Seats $\\star\\star$"},{"location":"python3/0601-0700/0621-0630/#627-swap-salary-star","text":"","title":"627. Swap Salary $\\star$"},{"location":"python3/0601-0700/0621-0630/#628-maximum-product-of-three-numbers-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def maximumProduct ( self , nums : List [ int ]) -> int : min = float ( 'inf' ) secondMin = float ( 'inf' ) max_ = float ( '-inf' ) secondMax = float ( '-inf' ) thirdMax = float ( '-inf' ) for num in nums : if num <= min : secondMin = min min = num elif num <= secondMin : secondMin = num if num >= max_ : thirdMax = secondMax secondMax = max_ max_ = num elif num >= secondMax : thirdMax = secondMax secondMax = num elif num >= thirdMax : thirdMax = num return max ( min * secondMin * max_ , max_ * secondMax * thirdMax )","title":"628. Maximum Product of Three Numbers $\\star$"},{"location":"python3/0601-0700/0621-0630/#629-k-inverse-pairs-array-starstarstar","text":"","title":"629. K Inverse Pairs Array $\\star\\star\\star$"},{"location":"python3/0601-0700/0621-0630/#630-course-schedule-iii-starstarstar","text":"","title":"630. Course Schedule III $\\star\\star\\star$"},{"location":"python3/0601-0700/0631-0640/","text":"631. Design Excel Sum Formula $\\star\\star\\star$ 632. Smallest Range Covering Elements from K Lists $\\star\\star\\star$ 633. Sum of Square Numbers $\\star$ 634. Find the Derangement of An Array $\\star\\star$ 635. Design Log Storage System $\\star\\star$ 636. Exclusive Time of Functions $\\star\\star$ 637. Average of Levels in Binary Tree $\\star$ 638. Shopping Offers $\\star\\star$ 639. Decode Ways II $\\star\\star\\star$ 640. Solve the Equation $\\star\\star$","title":"0631-0640"},{"location":"python3/0601-0700/0631-0640/#631-design-excel-sum-formula-starstarstar","text":"","title":"631. Design Excel Sum Formula $\\star\\star\\star$"},{"location":"python3/0601-0700/0631-0640/#632-smallest-range-covering-elements-from-k-lists-starstarstar","text":"","title":"632. Smallest Range Covering Elements from K Lists $\\star\\star\\star$"},{"location":"python3/0601-0700/0631-0640/#633-sum-of-square-numbers-star","text":"","title":"633. Sum of Square Numbers $\\star$"},{"location":"python3/0601-0700/0631-0640/#634-find-the-derangement-of-an-array-starstar","text":"","title":"634. Find the Derangement of An Array $\\star\\star$"},{"location":"python3/0601-0700/0631-0640/#635-design-log-storage-system-starstar","text":"","title":"635. Design Log Storage System $\\star\\star$"},{"location":"python3/0601-0700/0631-0640/#636-exclusive-time-of-functions-starstar","text":"","title":"636. Exclusive Time of Functions $\\star\\star$"},{"location":"python3/0601-0700/0631-0640/#637-average-of-levels-in-binary-tree-star","text":"","title":"637. Average of Levels in Binary Tree $\\star$"},{"location":"python3/0601-0700/0631-0640/#638-shopping-offers-starstar","text":"","title":"638. Shopping Offers $\\star\\star$"},{"location":"python3/0601-0700/0631-0640/#639-decode-ways-ii-starstarstar","text":"","title":"639. Decode Ways II $\\star\\star\\star$"},{"location":"python3/0601-0700/0631-0640/#640-solve-the-equation-starstar","text":"","title":"640. Solve the Equation $\\star\\star$"},{"location":"python3/0601-0700/0641-0650/","text":"641. Design Circular Deque $\\star\\star$ 642. Design Search Autocomplete System $\\star\\star\\star$ 643. Maximum Average Subarray I $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution : def findMaxAverage ( self , nums : List [ int ], k : int ) -> float : sum_ = sum ( nums [: k ]) ans = sum_ for i in range ( k , len ( nums )): sum_ += nums [ i ] - nums [ i - k ] ans = max ( ans , sum_ ) return ans / k 644. Maximum Average Subarray II $\\star\\star\\star$ 645. Set Mismatch $\\star$ 646. Maximum Length of Pair Chain $\\star\\star$ 647. Palindromic Substrings $\\star\\star$ 648. Replace Words $\\star\\star$ 649. Dota2 Senate $\\star\\star$ 650. 2 Keys Keyboard $\\star\\star$","title":"0641-0650"},{"location":"python3/0601-0700/0641-0650/#641-design-circular-deque-starstar","text":"","title":"641. Design Circular Deque $\\star\\star$"},{"location":"python3/0601-0700/0641-0650/#642-design-search-autocomplete-system-starstarstar","text":"","title":"642. Design Search Autocomplete System $\\star\\star\\star$"},{"location":"python3/0601-0700/0641-0650/#643-maximum-average-subarray-i-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution : def findMaxAverage ( self , nums : List [ int ], k : int ) -> float : sum_ = sum ( nums [: k ]) ans = sum_ for i in range ( k , len ( nums )): sum_ += nums [ i ] - nums [ i - k ] ans = max ( ans , sum_ ) return ans / k","title":"643. Maximum Average Subarray I $\\star$"},{"location":"python3/0601-0700/0641-0650/#644-maximum-average-subarray-ii-starstarstar","text":"","title":"644. Maximum Average Subarray II $\\star\\star\\star$"},{"location":"python3/0601-0700/0641-0650/#645-set-mismatch-star","text":"","title":"645. Set Mismatch $\\star$"},{"location":"python3/0601-0700/0641-0650/#646-maximum-length-of-pair-chain-starstar","text":"","title":"646. Maximum Length of Pair Chain $\\star\\star$"},{"location":"python3/0601-0700/0641-0650/#647-palindromic-substrings-starstar","text":"","title":"647. Palindromic Substrings $\\star\\star$"},{"location":"python3/0601-0700/0641-0650/#648-replace-words-starstar","text":"","title":"648. Replace Words $\\star\\star$"},{"location":"python3/0601-0700/0641-0650/#649-dota2-senate-starstar","text":"","title":"649. Dota2 Senate $\\star\\star$"},{"location":"python3/0601-0700/0641-0650/#650-2-keys-keyboard-starstar","text":"","title":"650. 2 Keys Keyboard $\\star\\star$"},{"location":"python3/0601-0700/0651-0660/","text":"651. 4 Keys Keyboard $\\star\\star$ 652. Find Duplicate Subtrees $\\star\\star$ 653. Two Sum IV - Input is a BST $\\star$ 654. Maximum Binary Tree $\\star\\star$ 655. Print Binary Tree $\\star\\star$ 656. Coin Path $\\star\\star\\star$ 657. Robot Return to Origin $\\star$ 658. Find K Closest Elements $\\star\\star$ 659. Split Array into Consecutive Subsequences $\\star\\star$ 660. Remove 9 $\\star\\star\\star$","title":"0651-0660"},{"location":"python3/0601-0700/0651-0660/#651-4-keys-keyboard-starstar","text":"","title":"651. 4 Keys Keyboard $\\star\\star$"},{"location":"python3/0601-0700/0651-0660/#652-find-duplicate-subtrees-starstar","text":"","title":"652. Find Duplicate Subtrees $\\star\\star$"},{"location":"python3/0601-0700/0651-0660/#653-two-sum-iv-input-is-a-bst-star","text":"","title":"653. Two Sum IV - Input is a BST $\\star$"},{"location":"python3/0601-0700/0651-0660/#654-maximum-binary-tree-starstar","text":"","title":"654. Maximum Binary Tree $\\star\\star$"},{"location":"python3/0601-0700/0651-0660/#655-print-binary-tree-starstar","text":"","title":"655. Print Binary Tree $\\star\\star$"},{"location":"python3/0601-0700/0651-0660/#656-coin-path-starstarstar","text":"","title":"656. Coin Path $\\star\\star\\star$"},{"location":"python3/0601-0700/0651-0660/#657-robot-return-to-origin-star","text":"","title":"657. Robot Return to Origin $\\star$"},{"location":"python3/0601-0700/0651-0660/#658-find-k-closest-elements-starstar","text":"","title":"658. Find K Closest Elements $\\star\\star$"},{"location":"python3/0601-0700/0651-0660/#659-split-array-into-consecutive-subsequences-starstar","text":"","title":"659. Split Array into Consecutive Subsequences $\\star\\star$"},{"location":"python3/0601-0700/0651-0660/#660-remove-9-starstarstar","text":"","title":"660. Remove 9 $\\star\\star\\star$"},{"location":"python3/0601-0700/0661-0670/","text":"661. Image Smoother $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def imageSmoother ( self , M : List [ List [ int ]]) -> List [ List [ int ]]: m = len ( M ) n = len ( M [ 0 ]) ans = [[ 0 for j in range ( n )] for i in range ( m )] for i in range ( m ): for j in range ( n ): ones = 0 count = 0 for y in range ( max ( 0 , i - 1 ), min ( m , i + 2 )): for x in range ( max ( 0 , j - 1 ), min ( n , j + 2 )): ones += M [ y ][ x ] count += 1 ans [ i ][ j ] = ones // count return ans 662. Maximum Width of Binary Tree $\\star\\star$ 663. Equal Tree Partition $\\star\\star$ 664. Strange Printer $\\star\\star\\star$ 665. Non-decreasing Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def checkPossibility ( self , nums : List [ int ]) -> bool : j = None for i in range ( len ( nums ) - 1 ): if nums [ i ] > nums [ i + 1 ]: if j is not None : return False j = i return j is None or j == 0 or j == len ( nums ) - 2 or \\ nums [ j - 1 ] <= nums [ j + 1 ] or nums [ j ] <= nums [ j + 2 ] 666. Path Sum IV $\\star\\star$ 667. Beautiful Arrangement II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution : def constructArray ( self , n : int , k : int ) -> List [ int ]: ans = list ( range ( 1 , n - k + 1 )) for i in range ( k ): if i % 2 == 0 : ans . append ( n - i // 2 ) else : ans . append ( n - k + ( i + 1 ) // 2 ) return ans 668. Kth Smallest Number in Multiplication Table $\\star\\star\\star$ 669. Trim a Binary Search Tree $\\star$ 670. Maximum Swap $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def maximumSwap ( self , num : int ) -> int : s = list ( str ( num )) dict = { c : i for i , c in enumerate ( s )} for i , c in enumerate ( s ): for digit in reversed ( string . digits ): if digit <= c : break if digit in dict and dict [ digit ] > i : s [ i ], s [ dict [ digit ]] = digit , s [ i ] return int ( '' . join ( s )) return num","title":"0661-0670"},{"location":"python3/0601-0700/0661-0670/#661-image-smoother-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def imageSmoother ( self , M : List [ List [ int ]]) -> List [ List [ int ]]: m = len ( M ) n = len ( M [ 0 ]) ans = [[ 0 for j in range ( n )] for i in range ( m )] for i in range ( m ): for j in range ( n ): ones = 0 count = 0 for y in range ( max ( 0 , i - 1 ), min ( m , i + 2 )): for x in range ( max ( 0 , j - 1 ), min ( n , j + 2 )): ones += M [ y ][ x ] count += 1 ans [ i ][ j ] = ones // count return ans","title":"661. Image Smoother $\\star$"},{"location":"python3/0601-0700/0661-0670/#662-maximum-width-of-binary-tree-starstar","text":"","title":"662. Maximum Width of Binary Tree $\\star\\star$"},{"location":"python3/0601-0700/0661-0670/#663-equal-tree-partition-starstar","text":"","title":"663. Equal Tree Partition $\\star\\star$"},{"location":"python3/0601-0700/0661-0670/#664-strange-printer-starstarstar","text":"","title":"664. Strange Printer $\\star\\star\\star$"},{"location":"python3/0601-0700/0661-0670/#665-non-decreasing-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def checkPossibility ( self , nums : List [ int ]) -> bool : j = None for i in range ( len ( nums ) - 1 ): if nums [ i ] > nums [ i + 1 ]: if j is not None : return False j = i return j is None or j == 0 or j == len ( nums ) - 2 or \\ nums [ j - 1 ] <= nums [ j + 1 ] or nums [ j ] <= nums [ j + 2 ]","title":"665. Non-decreasing Array $\\star$"},{"location":"python3/0601-0700/0661-0670/#666-path-sum-iv-starstar","text":"","title":"666. Path Sum IV $\\star\\star$"},{"location":"python3/0601-0700/0661-0670/#667-beautiful-arrangement-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution : def constructArray ( self , n : int , k : int ) -> List [ int ]: ans = list ( range ( 1 , n - k + 1 )) for i in range ( k ): if i % 2 == 0 : ans . append ( n - i // 2 ) else : ans . append ( n - k + ( i + 1 ) // 2 ) return ans","title":"667. Beautiful Arrangement II $\\star\\star$"},{"location":"python3/0601-0700/0661-0670/#668-kth-smallest-number-in-multiplication-table-starstarstar","text":"","title":"668. Kth Smallest Number in Multiplication Table $\\star\\star\\star$"},{"location":"python3/0601-0700/0661-0670/#669-trim-a-binary-search-tree-star","text":"","title":"669. Trim a Binary Search Tree $\\star$"},{"location":"python3/0601-0700/0661-0670/#670-maximum-swap-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def maximumSwap ( self , num : int ) -> int : s = list ( str ( num )) dict = { c : i for i , c in enumerate ( s )} for i , c in enumerate ( s ): for digit in reversed ( string . digits ): if digit <= c : break if digit in dict and dict [ digit ] > i : s [ i ], s [ dict [ digit ]] = digit , s [ i ] return int ( '' . join ( s )) return num","title":"670. Maximum Swap $\\star\\star$"},{"location":"python3/0601-0700/0671-0680/","text":"671. Second Minimum Node In a Binary Tree $\\star$ 672. Bulb Switcher II $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def flipLights ( self , n : int , m : int ) -> int : n = min ( n , 3 ) if m == 0 : return 1 if m == 1 : return [ 2 , 3 , 4 ][ n - 1 ] if m == 2 : return [ 2 , 4 , 7 ][ n - 1 ] return [ 2 , 4 , 8 ][ n - 1 ] 673. Number of Longest Increasing Subsequence $\\star\\star$ 674. Longest Continuous Increasing Subsequence $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution : def findLengthOfLCIS ( self , nums : List [ int ]) -> int : ans = 0 j = 0 for i in range ( len ( nums )): if i > 0 and nums [ i ] <= nums [ i - 1 ]: j = i ans = max ( ans , i - j + 1 ) return ans 675. Cut Off Trees for Golf Event $\\star\\star\\star$ 676. Implement Magic Dictionary $\\star\\star$ 677. Map Sum Pairs $\\star\\star$ 678. Valid Parenthesis String $\\star\\star$ 679. 24 Game $\\star\\star\\star$ 680. Valid Palindrome II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def validPalindrome ( self , s : str ) -> bool : def validPalindrome ( l : int , r : int ) -> bool : return all ( s [ i ] == s [ r - i + l ] for i in range ( l , l + ( r - l ) // 2 + 1 )) n = len ( s ) for i in range ( n // 2 ): if s [ i ] != s [ ~ i ]: return validPalindrome ( i + 1 , n - 1 - i ) or validPalindrome ( i , n - 2 - i ) return True","title":"0671-0680"},{"location":"python3/0601-0700/0671-0680/#671-second-minimum-node-in-a-binary-tree-star","text":"","title":"671. Second Minimum Node In a Binary Tree $\\star$"},{"location":"python3/0601-0700/0671-0680/#672-bulb-switcher-ii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def flipLights ( self , n : int , m : int ) -> int : n = min ( n , 3 ) if m == 0 : return 1 if m == 1 : return [ 2 , 3 , 4 ][ n - 1 ] if m == 2 : return [ 2 , 4 , 7 ][ n - 1 ] return [ 2 , 4 , 8 ][ n - 1 ]","title":"672. Bulb Switcher II $\\star\\star$"},{"location":"python3/0601-0700/0671-0680/#673-number-of-longest-increasing-subsequence-starstar","text":"","title":"673. Number of Longest Increasing Subsequence $\\star\\star$"},{"location":"python3/0601-0700/0671-0680/#674-longest-continuous-increasing-subsequence-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution : def findLengthOfLCIS ( self , nums : List [ int ]) -> int : ans = 0 j = 0 for i in range ( len ( nums )): if i > 0 and nums [ i ] <= nums [ i - 1 ]: j = i ans = max ( ans , i - j + 1 ) return ans","title":"674. Longest Continuous Increasing Subsequence $\\star$"},{"location":"python3/0601-0700/0671-0680/#675-cut-off-trees-for-golf-event-starstarstar","text":"","title":"675. Cut Off Trees for Golf Event $\\star\\star\\star$"},{"location":"python3/0601-0700/0671-0680/#676-implement-magic-dictionary-starstar","text":"","title":"676. Implement Magic Dictionary $\\star\\star$"},{"location":"python3/0601-0700/0671-0680/#677-map-sum-pairs-starstar","text":"","title":"677. Map Sum Pairs $\\star\\star$"},{"location":"python3/0601-0700/0671-0680/#678-valid-parenthesis-string-starstar","text":"","title":"678. Valid Parenthesis String $\\star\\star$"},{"location":"python3/0601-0700/0671-0680/#679-24-game-starstarstar","text":"","title":"679. 24 Game $\\star\\star\\star$"},{"location":"python3/0601-0700/0671-0680/#680-valid-palindrome-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def validPalindrome ( self , s : str ) -> bool : def validPalindrome ( l : int , r : int ) -> bool : return all ( s [ i ] == s [ r - i + l ] for i in range ( l , l + ( r - l ) // 2 + 1 )) n = len ( s ) for i in range ( n // 2 ): if s [ i ] != s [ ~ i ]: return validPalindrome ( i + 1 , n - 1 - i ) or validPalindrome ( i , n - 2 - i ) return True","title":"680. Valid Palindrome II $\\star$"},{"location":"python3/0601-0700/0681-0690/","text":"681. Next Closest Time $\\star\\star$ 682. Baseball Game $\\star$ 683. K Empty Slots $\\star\\star\\star$ 684. Redundant Connection $\\star\\star$ 685. Redundant Connection II $\\star\\star\\star$ 686. Repeated String Match $\\star$ 687. Longest Univalue Path $\\star$ 688. Knight Probability in Chessboard $\\star\\star$ 689. Maximum Sum of 3 Non-Overlapping Subarrays $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution : def maxSumOfThreeSubarrays ( self , nums , k ): ans = [ - 1 ] * 3 subarrayCount = len ( nums ) - k + 1 dp = [ 0 ] * subarrayCount sum = 0 for i , num in enumerate ( nums ): sum += num if i >= k : sum -= nums [ i - k ] if i >= k - 1 : dp [ i - k + 1 ] = sum left = [ 0 ] * subarrayCount maxIndex = 0 for i in range ( subarrayCount ): if dp [ i ] > dp [ maxIndex ]: maxIndex = i left [ i ] = maxIndex right = [ 0 ] * subarrayCount maxIndex = subarrayCount - 1 for i in range ( subarrayCount - 1 , - 1 , - 1 ): if dp [ i ] >= dp [ maxIndex ]: maxIndex = i right [ i ] = maxIndex for i in range ( k , subarrayCount - k ): if ans [ 0 ] == - 1 or dp [ left [ i - k ]] + dp [ i ] + dp [ right [ i + k ]] > dp [ ans [ 0 ]] + dp [ ans [ 1 ]] + dp [ ans [ 2 ]]: ans = [ left [ i - k ], i , right [ i + k ]] return ans 690. Employee Importance $\\star$","title":"0681-0690"},{"location":"python3/0601-0700/0681-0690/#681-next-closest-time-starstar","text":"","title":"681. Next Closest Time $\\star\\star$"},{"location":"python3/0601-0700/0681-0690/#682-baseball-game-star","text":"","title":"682. Baseball Game $\\star$"},{"location":"python3/0601-0700/0681-0690/#683-k-empty-slots-starstarstar","text":"","title":"683. K Empty Slots $\\star\\star\\star$"},{"location":"python3/0601-0700/0681-0690/#684-redundant-connection-starstar","text":"","title":"684. Redundant Connection $\\star\\star$"},{"location":"python3/0601-0700/0681-0690/#685-redundant-connection-ii-starstarstar","text":"","title":"685. Redundant Connection II $\\star\\star\\star$"},{"location":"python3/0601-0700/0681-0690/#686-repeated-string-match-star","text":"","title":"686. Repeated String Match $\\star$"},{"location":"python3/0601-0700/0681-0690/#687-longest-univalue-path-star","text":"","title":"687. Longest Univalue Path $\\star$"},{"location":"python3/0601-0700/0681-0690/#688-knight-probability-in-chessboard-starstar","text":"","title":"688. Knight Probability in Chessboard $\\star\\star$"},{"location":"python3/0601-0700/0681-0690/#689-maximum-sum-of-3-non-overlapping-subarrays-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution : def maxSumOfThreeSubarrays ( self , nums , k ): ans = [ - 1 ] * 3 subarrayCount = len ( nums ) - k + 1 dp = [ 0 ] * subarrayCount sum = 0 for i , num in enumerate ( nums ): sum += num if i >= k : sum -= nums [ i - k ] if i >= k - 1 : dp [ i - k + 1 ] = sum left = [ 0 ] * subarrayCount maxIndex = 0 for i in range ( subarrayCount ): if dp [ i ] > dp [ maxIndex ]: maxIndex = i left [ i ] = maxIndex right = [ 0 ] * subarrayCount maxIndex = subarrayCount - 1 for i in range ( subarrayCount - 1 , - 1 , - 1 ): if dp [ i ] >= dp [ maxIndex ]: maxIndex = i right [ i ] = maxIndex for i in range ( k , subarrayCount - k ): if ans [ 0 ] == - 1 or dp [ left [ i - k ]] + dp [ i ] + dp [ right [ i + k ]] > dp [ ans [ 0 ]] + dp [ ans [ 1 ]] + dp [ ans [ 2 ]]: ans = [ left [ i - k ], i , right [ i + k ]] return ans","title":"689. Maximum Sum of 3 Non-Overlapping Subarrays $\\star\\star\\star$"},{"location":"python3/0601-0700/0681-0690/#690-employee-importance-star","text":"","title":"690. Employee Importance $\\star$"},{"location":"python3/0601-0700/0691-0700/","text":"691. Stickers to Spell Word $\\star\\star\\star$ 692. Top K Frequent Words $\\star\\star$ 693. Binary Number with Alternating Bits $\\star$ 694. Number of Distinct Islands $\\star\\star$ 695. Max Area of Island $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def maxAreaOfIsland ( self , grid : List [ List [ int ]]) -> int : def dfs ( i : int , j : int ) -> int : if not 0 <= i < len ( grid ) or not 0 <= j < len ( grid [ 0 ]) or visited [ i ][ j ] or grid [ i ][ j ] == 0 : return 0 visited [ i ][ j ] = True return 1 + dfs ( i + 1 , j ) + dfs ( i - 1 , j ) + dfs ( i , j + 1 ) + dfs ( i , j - 1 ) m = len ( grid ) n = len ( grid [ 0 ]) ans = 0 visited = [[ False ] * n for _ in range ( m )] for i in range ( m ): for j in range ( n ): if not visited [ i ][ j ]: ans = max ( ans , dfs ( i , j )) return ans 696. Count Binary Substrings $\\star$ 697. Degree of an Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def findShortestSubArray ( self , nums : List [ int ]) -> int : ans = 0 degree = 0 firstSeen = {} numCounts = collections . defaultdict ( int ) for i , num in enumerate ( nums ): if num not in firstSeen : firstSeen [ num ] = i numCounts [ num ] += 1 if numCounts [ num ] > degree : degree = numCounts [ num ] ans = i - firstSeen [ num ] + 1 elif numCounts [ num ] == degree : ans = min ( ans , i - firstSeen [ num ] + 1 ) return ans 698. Partition to K Equal Sum Subsets $\\star\\star$ 699. Falling Squares $\\star\\star\\star$ 700. Search in a Binary Search Tree $\\star$","title":"0691-0700"},{"location":"python3/0601-0700/0691-0700/#691-stickers-to-spell-word-starstarstar","text":"","title":"691. Stickers to Spell Word $\\star\\star\\star$"},{"location":"python3/0601-0700/0691-0700/#692-top-k-frequent-words-starstar","text":"","title":"692. Top K Frequent Words $\\star\\star$"},{"location":"python3/0601-0700/0691-0700/#693-binary-number-with-alternating-bits-star","text":"","title":"693. Binary Number with Alternating Bits $\\star$"},{"location":"python3/0601-0700/0691-0700/#694-number-of-distinct-islands-starstar","text":"","title":"694. Number of Distinct Islands $\\star\\star$"},{"location":"python3/0601-0700/0691-0700/#695-max-area-of-island-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def maxAreaOfIsland ( self , grid : List [ List [ int ]]) -> int : def dfs ( i : int , j : int ) -> int : if not 0 <= i < len ( grid ) or not 0 <= j < len ( grid [ 0 ]) or visited [ i ][ j ] or grid [ i ][ j ] == 0 : return 0 visited [ i ][ j ] = True return 1 + dfs ( i + 1 , j ) + dfs ( i - 1 , j ) + dfs ( i , j + 1 ) + dfs ( i , j - 1 ) m = len ( grid ) n = len ( grid [ 0 ]) ans = 0 visited = [[ False ] * n for _ in range ( m )] for i in range ( m ): for j in range ( n ): if not visited [ i ][ j ]: ans = max ( ans , dfs ( i , j )) return ans","title":"695. Max Area of Island $\\star\\star$"},{"location":"python3/0601-0700/0691-0700/#696-count-binary-substrings-star","text":"","title":"696. Count Binary Substrings $\\star$"},{"location":"python3/0601-0700/0691-0700/#697-degree-of-an-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def findShortestSubArray ( self , nums : List [ int ]) -> int : ans = 0 degree = 0 firstSeen = {} numCounts = collections . defaultdict ( int ) for i , num in enumerate ( nums ): if num not in firstSeen : firstSeen [ num ] = i numCounts [ num ] += 1 if numCounts [ num ] > degree : degree = numCounts [ num ] ans = i - firstSeen [ num ] + 1 elif numCounts [ num ] == degree : ans = min ( ans , i - firstSeen [ num ] + 1 ) return ans","title":"697. Degree of an Array $\\star$"},{"location":"python3/0601-0700/0691-0700/#698-partition-to-k-equal-sum-subsets-starstar","text":"","title":"698. Partition to K Equal Sum Subsets $\\star\\star$"},{"location":"python3/0601-0700/0691-0700/#699-falling-squares-starstarstar","text":"","title":"699. Falling Squares $\\star\\star\\star$"},{"location":"python3/0601-0700/0691-0700/#700-search-in-a-binary-search-tree-star","text":"","title":"700. Search in a Binary Search Tree $\\star$"},{"location":"python3/0701-0800/0701-0710/","text":"701. Insert into a Binary Search Tree $\\star\\star$ 702. Search in a Sorted Array of Unknown Size $\\star\\star$ 703. Kth Largest Element in a Stream $\\star$ 704. Binary Search $\\star$ 705. Design HashSet $\\star$ 706. Design HashMap $\\star$ 707. Design Linked List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class ListNode : def __init__ ( self , x ): self . val = x self . next = None class MyLinkedList : def __init__ ( self ): self . len = 0 self . head = ListNode ( 0 ) def get ( self , index : int ) -> int : if index < 0 or index >= self . len : return - 1 curr = self . head . next for i in range ( index ): curr = curr . next return curr . val def addAtHead ( self , val : int ) -> None : curr = self . head . next self . head . next = ListNode ( val ) self . head . next . next = curr self . len += 1 def addAtTail ( self , val : int ) -> None : curr = self . head while curr . next : curr = curr . next curr . next = ListNode ( val ) self . len += 1 def addAtIndex ( self , index : int , val : int ) -> None : if index > self . len : return curr = self . head for i in range ( index ): curr = curr . next temp = curr . next curr . next = ListNode ( val ) curr . next . next = temp self . len += 1 def deleteAtIndex ( self , index : int ) -> None : if index < 0 or index >= self . len : return curr = self . head for i in range ( index ): curr = curr . next temp = curr . next curr . next = temp . next self . len -= 1 708. Insert into a Sorted Circular Linked List $\\star\\star$ 709. To Lower Case $\\star$ 710. Random Pick with Blacklist $\\star\\star\\star$","title":"0701-0710"},{"location":"python3/0701-0800/0701-0710/#701-insert-into-a-binary-search-tree-starstar","text":"","title":"701. Insert into a Binary Search Tree $\\star\\star$"},{"location":"python3/0701-0800/0701-0710/#702-search-in-a-sorted-array-of-unknown-size-starstar","text":"","title":"702. Search in a Sorted Array of Unknown Size $\\star\\star$"},{"location":"python3/0701-0800/0701-0710/#703-kth-largest-element-in-a-stream-star","text":"","title":"703. Kth Largest Element in a Stream $\\star$"},{"location":"python3/0701-0800/0701-0710/#704-binary-search-star","text":"","title":"704. Binary Search $\\star$"},{"location":"python3/0701-0800/0701-0710/#705-design-hashset-star","text":"","title":"705. Design HashSet $\\star$"},{"location":"python3/0701-0800/0701-0710/#706-design-hashmap-star","text":"","title":"706. Design HashMap $\\star$"},{"location":"python3/0701-0800/0701-0710/#707-design-linked-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 class ListNode : def __init__ ( self , x ): self . val = x self . next = None class MyLinkedList : def __init__ ( self ): self . len = 0 self . head = ListNode ( 0 ) def get ( self , index : int ) -> int : if index < 0 or index >= self . len : return - 1 curr = self . head . next for i in range ( index ): curr = curr . next return curr . val def addAtHead ( self , val : int ) -> None : curr = self . head . next self . head . next = ListNode ( val ) self . head . next . next = curr self . len += 1 def addAtTail ( self , val : int ) -> None : curr = self . head while curr . next : curr = curr . next curr . next = ListNode ( val ) self . len += 1 def addAtIndex ( self , index : int , val : int ) -> None : if index > self . len : return curr = self . head for i in range ( index ): curr = curr . next temp = curr . next curr . next = ListNode ( val ) curr . next . next = temp self . len += 1 def deleteAtIndex ( self , index : int ) -> None : if index < 0 or index >= self . len : return curr = self . head for i in range ( index ): curr = curr . next temp = curr . next curr . next = temp . next self . len -= 1","title":"707. Design Linked List $\\star\\star$"},{"location":"python3/0701-0800/0701-0710/#708-insert-into-a-sorted-circular-linked-list-starstar","text":"","title":"708. Insert into a Sorted Circular Linked List $\\star\\star$"},{"location":"python3/0701-0800/0701-0710/#709-to-lower-case-star","text":"","title":"709. To Lower Case $\\star$"},{"location":"python3/0701-0800/0701-0710/#710-random-pick-with-blacklist-starstarstar","text":"","title":"710. Random Pick with Blacklist $\\star\\star\\star$"},{"location":"python3/0701-0800/0711-0720/","text":"711. Number of Distinct Islands II $\\star\\star\\star$ 712. Minimum ASCII Delete Sum for Two Strings $\\star\\star$ 713. Subarray Product Less Than K $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def numSubarrayProductLessThanK ( self , nums : List [ int ], k : int ) -> int : if k <= 1 : return 0 ans = 0 prod = 1 j = 0 for i , num in enumerate ( nums ): prod *= num while prod >= k : prod /= nums [ j ] j += 1 ans += i - j + 1 return ans 714. Best Time to Buy and Sell Stock with Transaction Fee $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution : def maxProfit ( self , prices : List [ int ], fee : int ) -> int : sell = 0 hold = float ( '-inf' ) for price in prices : sell = max ( sell , hold + price ) hold = max ( hold , sell - price - fee ) return sell 715. Range Module $\\star\\star\\star$ 716. Max Stack $\\star$ 717. 1-bit and 2-bit Characters $\\star$ 1 2 3 4 5 6 7 class Solution : def isOneBitCharacter ( self , bits : List [ int ]) -> bool : i = 0 while i < len ( bits ) - 1 : i += bits [ i ] + 1 return i == len ( bits ) - 1 718. Maximum Length of Repeated Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def findLength ( self , A : List [ int ], B : List [ int ]) -> int : m = len ( A ) n = len ( B ) dp = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( m - 1 , - 1 , - 1 ): for j in range ( n - 1 , - 1 , - 1 ): if A [ i ] == B [ j ]: dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 return max ( max ( row ) for row in dp ) 719. Find K-th Smallest Pair Distance $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def smallestDistancePair ( self , nums : List [ int ], k : int ) -> int : nums . sort () l = 0 r = nums [ - 1 ] - nums [ 0 ] while l < r : m = ( l + r ) // 2 count = 0 j = 0 for i in range ( len ( nums )): while j < len ( nums ) and nums [ j ] <= nums [ i ] + m : j += 1 count += j - i - 1 if count < k : l = m + 1 else : r = m return l 720. Longest Word in Dictionary $\\star$","title":"0711-0720"},{"location":"python3/0701-0800/0711-0720/#711-number-of-distinct-islands-ii-starstarstar","text":"","title":"711. Number of Distinct Islands II $\\star\\star\\star$"},{"location":"python3/0701-0800/0711-0720/#712-minimum-ascii-delete-sum-for-two-strings-starstar","text":"","title":"712. Minimum ASCII Delete Sum for Two Strings $\\star\\star$"},{"location":"python3/0701-0800/0711-0720/#713-subarray-product-less-than-k-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def numSubarrayProductLessThanK ( self , nums : List [ int ], k : int ) -> int : if k <= 1 : return 0 ans = 0 prod = 1 j = 0 for i , num in enumerate ( nums ): prod *= num while prod >= k : prod /= nums [ j ] j += 1 ans += i - j + 1 return ans","title":"713. Subarray Product Less Than K $\\star\\star$"},{"location":"python3/0701-0800/0711-0720/#714-best-time-to-buy-and-sell-stock-with-transaction-fee-starstar","text":"1 2 3 4 5 6 7 8 9 10 class Solution : def maxProfit ( self , prices : List [ int ], fee : int ) -> int : sell = 0 hold = float ( '-inf' ) for price in prices : sell = max ( sell , hold + price ) hold = max ( hold , sell - price - fee ) return sell","title":"714. Best Time to Buy and Sell Stock with Transaction Fee $\\star\\star$"},{"location":"python3/0701-0800/0711-0720/#715-range-module-starstarstar","text":"","title":"715. Range Module $\\star\\star\\star$"},{"location":"python3/0701-0800/0711-0720/#716-max-stack-star","text":"","title":"716. Max Stack $\\star$"},{"location":"python3/0701-0800/0711-0720/#717-1-bit-and-2-bit-characters-star","text":"1 2 3 4 5 6 7 class Solution : def isOneBitCharacter ( self , bits : List [ int ]) -> bool : i = 0 while i < len ( bits ) - 1 : i += bits [ i ] + 1 return i == len ( bits ) - 1","title":"717. 1-bit and 2-bit Characters $\\star$"},{"location":"python3/0701-0800/0711-0720/#718-maximum-length-of-repeated-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def findLength ( self , A : List [ int ], B : List [ int ]) -> int : m = len ( A ) n = len ( B ) dp = [[ 0 ] * ( n + 1 ) for _ in range ( m + 1 )] for i in range ( m - 1 , - 1 , - 1 ): for j in range ( n - 1 , - 1 , - 1 ): if A [ i ] == B [ j ]: dp [ i ][ j ] = dp [ i + 1 ][ j + 1 ] + 1 return max ( max ( row ) for row in dp )","title":"718. Maximum Length of Repeated Subarray $\\star\\star$"},{"location":"python3/0701-0800/0711-0720/#719-find-k-th-smallest-pair-distance-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 class Solution : def smallestDistancePair ( self , nums : List [ int ], k : int ) -> int : nums . sort () l = 0 r = nums [ - 1 ] - nums [ 0 ] while l < r : m = ( l + r ) // 2 count = 0 j = 0 for i in range ( len ( nums )): while j < len ( nums ) and nums [ j ] <= nums [ i ] + m : j += 1 count += j - i - 1 if count < k : l = m + 1 else : r = m return l","title":"719. Find K-th Smallest Pair Distance $\\star\\star\\star$"},{"location":"python3/0701-0800/0711-0720/#720-longest-word-in-dictionary-star","text":"","title":"720. Longest Word in Dictionary $\\star$"},{"location":"python3/0701-0800/0721-0730/","text":"721. Accounts Merge $\\star\\star$ 722. Remove Comments $\\star\\star$ 723. Candy Crush $\\star\\star$ 724. Find Pivot Index $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution : def pivotIndex ( self , nums : List [ int ]) -> int : sum_ = sum ( nums ) presum = 0 for i , num in enumerate ( nums ): if presum == sum_ - presum - num : return i presum += num return - 1 725. Split Linked List in Parts $\\star\\star$ 726. Number of Atoms $\\star\\star\\star$ 727. Minimum Window Subsequence $\\star\\star\\star$ 728. Self Dividing Numbers $\\star$ 729. My Calendar I $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class MyCalendar : def __init__ ( self ): self . tree = self . Tree () def book ( self , start : int , end : int ) -> bool : return self . tree . insert ( self . Node ( start , end )) class Node : def __init__ ( self , start : int , end : int ): self . start = start self . end = end self . left = None self . right = None class Tree : def __init__ ( self ): self . root = None def insert ( self , node , root = None ): if not root : if not self . root : self . root = node return True else : root = self . root if node . start >= root . end : if not root . right : root . right = node return True return self . insert ( node , root . right ) elif node . end <= root . start : if not root . left : root . left = node return True return self . insert ( node , root . left ) else : return False 730. Count Different Palindromic Subsequences $\\star\\star\\star$","title":"0721-0730"},{"location":"python3/0701-0800/0721-0730/#721-accounts-merge-starstar","text":"","title":"721. Accounts Merge $\\star\\star$"},{"location":"python3/0701-0800/0721-0730/#722-remove-comments-starstar","text":"","title":"722. Remove Comments $\\star\\star$"},{"location":"python3/0701-0800/0721-0730/#723-candy-crush-starstar","text":"","title":"723. Candy Crush $\\star\\star$"},{"location":"python3/0701-0800/0721-0730/#724-find-pivot-index-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution : def pivotIndex ( self , nums : List [ int ]) -> int : sum_ = sum ( nums ) presum = 0 for i , num in enumerate ( nums ): if presum == sum_ - presum - num : return i presum += num return - 1","title":"724. Find Pivot Index $\\star$"},{"location":"python3/0701-0800/0721-0730/#725-split-linked-list-in-parts-starstar","text":"","title":"725. Split Linked List in Parts $\\star\\star$"},{"location":"python3/0701-0800/0721-0730/#726-number-of-atoms-starstarstar","text":"","title":"726. Number of Atoms $\\star\\star\\star$"},{"location":"python3/0701-0800/0721-0730/#727-minimum-window-subsequence-starstarstar","text":"","title":"727. Minimum Window Subsequence $\\star\\star\\star$"},{"location":"python3/0701-0800/0721-0730/#728-self-dividing-numbers-star","text":"","title":"728. Self Dividing Numbers $\\star$"},{"location":"python3/0701-0800/0721-0730/#729-my-calendar-i-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class MyCalendar : def __init__ ( self ): self . tree = self . Tree () def book ( self , start : int , end : int ) -> bool : return self . tree . insert ( self . Node ( start , end )) class Node : def __init__ ( self , start : int , end : int ): self . start = start self . end = end self . left = None self . right = None class Tree : def __init__ ( self ): self . root = None def insert ( self , node , root = None ): if not root : if not self . root : self . root = node return True else : root = self . root if node . start >= root . end : if not root . right : root . right = node return True return self . insert ( node , root . right ) elif node . end <= root . start : if not root . left : root . left = node return True return self . insert ( node , root . left ) else : return False","title":"729. My Calendar I $\\star\\star$"},{"location":"python3/0701-0800/0721-0730/#730-count-different-palindromic-subsequences-starstarstar","text":"","title":"730. Count Different Palindromic Subsequences $\\star\\star\\star$"},{"location":"python3/0701-0800/0731-0740/","text":"731. My Calendar II $\\star\\star$ 732. My Calendar III $\\star\\star\\star$ 733. Flood Fill $\\star$ 734. Sentence Similarity $\\star$ 735. Asteroid Collision $\\star\\star$ 736. Parse Lisp Expression $\\star\\star\\star$ 737. Sentence Similarity II $\\star\\star$ 738. Monotone Increasing Digits $\\star\\star$ 739. Daily Temperatures $\\star\\star$ 740. Delete and Earn $\\star\\star$","title":"0731-0740"},{"location":"python3/0701-0800/0731-0740/#731-my-calendar-ii-starstar","text":"","title":"731. My Calendar II $\\star\\star$"},{"location":"python3/0701-0800/0731-0740/#732-my-calendar-iii-starstarstar","text":"","title":"732. My Calendar III $\\star\\star\\star$"},{"location":"python3/0701-0800/0731-0740/#733-flood-fill-star","text":"","title":"733. Flood Fill $\\star$"},{"location":"python3/0701-0800/0731-0740/#734-sentence-similarity-star","text":"","title":"734. Sentence Similarity $\\star$"},{"location":"python3/0701-0800/0731-0740/#735-asteroid-collision-starstar","text":"","title":"735. Asteroid Collision $\\star\\star$"},{"location":"python3/0701-0800/0731-0740/#736-parse-lisp-expression-starstarstar","text":"","title":"736. Parse Lisp Expression $\\star\\star\\star$"},{"location":"python3/0701-0800/0731-0740/#737-sentence-similarity-ii-starstar","text":"","title":"737. Sentence Similarity II $\\star\\star$"},{"location":"python3/0701-0800/0731-0740/#738-monotone-increasing-digits-starstar","text":"","title":"738. Monotone Increasing Digits $\\star\\star$"},{"location":"python3/0701-0800/0731-0740/#739-daily-temperatures-starstar","text":"","title":"739. Daily Temperatures $\\star\\star$"},{"location":"python3/0701-0800/0731-0740/#740-delete-and-earn-starstar","text":"","title":"740. Delete and Earn $\\star\\star$"},{"location":"python3/0701-0800/0741-0750/","text":"741. Cherry Pickup $\\star\\star\\star$ 742. Closest Leaf in a Binary Tree $\\star\\star$ 743. Network Delay Time $\\star\\star$ 744. Find Smallest Letter Greater Than Target $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def nextGreatestLetter ( self , letters : List [ str ], target : str ) -> str : l = 0 r = len ( letters ) while l < r : m = ( l + r ) >> 1 if letters [ m ] <= target : l = m + 1 else : r = m return letters [ l % len ( letters )] 745. Prefix and Suffix Search $\\star\\star\\star$ 746. Min Cost Climbing Stairs $\\star$ 1 2 3 4 5 6 7 8 class Solution : def minCostClimbingStairs ( self , cost : List [ int ]) -> int : n = len ( cost ) for i in range ( 2 , n ): cost [ i ] += min ( cost [ i - 1 ], cost [ i - 2 ]) return min ( cost [ n - 1 ], cost [ n - 2 ]) 747. Largest Number At Least Twice of Others $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def dominantIndex ( self , nums : List [ int ]) -> int : max = 0 secondMax = 0 for i , num in enumerate ( nums ): if num > max : secondMax = max max = num ans = i elif num > secondMax : secondMax = num return ans if max >= 2 * secondMax else - 1 748. Shortest Completing Word $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def shortestCompletingWord ( self , licensePlate : str , words : List [ str ]) -> str : def isMatch ( word : str ) -> bool : wordDict = collections . Counter ( word ) for i in string . ascii_lowercase : if wordDict [ i ] < dict [ i ]: return False return True dict = { chr ( i + ord ( 'a' )): 0 for i in range ( 26 )} for c in licensePlate : if c . isalpha (): dict [ c . lower ()] += 1 min = float ( 'inf' ) for word in words : if len ( word ) >= min : continue if not isMatch ( word ): continue min = len ( word ) ans = word return ans 749. Contain Virus $\\star\\star\\star$ 750. Number Of Corner Rectangles $\\star\\star$","title":"0741-0750"},{"location":"python3/0701-0800/0741-0750/#741-cherry-pickup-starstarstar","text":"","title":"741. Cherry Pickup $\\star\\star\\star$"},{"location":"python3/0701-0800/0741-0750/#742-closest-leaf-in-a-binary-tree-starstar","text":"","title":"742. Closest Leaf in a Binary Tree $\\star\\star$"},{"location":"python3/0701-0800/0741-0750/#743-network-delay-time-starstar","text":"","title":"743. Network Delay Time $\\star\\star$"},{"location":"python3/0701-0800/0741-0750/#744-find-smallest-letter-greater-than-target-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def nextGreatestLetter ( self , letters : List [ str ], target : str ) -> str : l = 0 r = len ( letters ) while l < r : m = ( l + r ) >> 1 if letters [ m ] <= target : l = m + 1 else : r = m return letters [ l % len ( letters )]","title":"744. Find Smallest Letter Greater Than Target $\\star$"},{"location":"python3/0701-0800/0741-0750/#745-prefix-and-suffix-search-starstarstar","text":"","title":"745. Prefix and Suffix Search $\\star\\star\\star$"},{"location":"python3/0701-0800/0741-0750/#746-min-cost-climbing-stairs-star","text":"1 2 3 4 5 6 7 8 class Solution : def minCostClimbingStairs ( self , cost : List [ int ]) -> int : n = len ( cost ) for i in range ( 2 , n ): cost [ i ] += min ( cost [ i - 1 ], cost [ i - 2 ]) return min ( cost [ n - 1 ], cost [ n - 2 ])","title":"746. Min Cost Climbing Stairs $\\star$"},{"location":"python3/0701-0800/0741-0750/#747-largest-number-at-least-twice-of-others-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def dominantIndex ( self , nums : List [ int ]) -> int : max = 0 secondMax = 0 for i , num in enumerate ( nums ): if num > max : secondMax = max max = num ans = i elif num > secondMax : secondMax = num return ans if max >= 2 * secondMax else - 1","title":"747. Largest Number At Least Twice of Others $\\star$"},{"location":"python3/0701-0800/0741-0750/#748-shortest-completing-word-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class Solution : def shortestCompletingWord ( self , licensePlate : str , words : List [ str ]) -> str : def isMatch ( word : str ) -> bool : wordDict = collections . Counter ( word ) for i in string . ascii_lowercase : if wordDict [ i ] < dict [ i ]: return False return True dict = { chr ( i + ord ( 'a' )): 0 for i in range ( 26 )} for c in licensePlate : if c . isalpha (): dict [ c . lower ()] += 1 min = float ( 'inf' ) for word in words : if len ( word ) >= min : continue if not isMatch ( word ): continue min = len ( word ) ans = word return ans","title":"748. Shortest Completing Word $\\star$"},{"location":"python3/0701-0800/0741-0750/#749-contain-virus-starstarstar","text":"","title":"749. Contain Virus $\\star\\star\\star$"},{"location":"python3/0701-0800/0741-0750/#750-number-of-corner-rectangles-starstar","text":"","title":"750. Number Of Corner Rectangles $\\star\\star$"},{"location":"python3/0701-0800/0751-0760/","text":"751. IP to CIDR $\\star$ 752. Open the Lock $\\star\\star$ 753. Cracking the Safe $\\star\\star\\star$ 754. Reach a Number $\\star\\star$ 755. Pour Water $\\star\\star$ 756. Pyramid Transition Matrix $\\star\\star$ 757. Set Intersection Size At Least Two $\\star\\star\\star$ 758. Bold Words in String $\\star$ 759. Employee Free Time $\\star\\star\\star$ 760. Find Anagram Mappings $\\star$","title":"0751-0760"},{"location":"python3/0701-0800/0751-0760/#751-ip-to-cidr-star","text":"","title":"751. IP to CIDR $\\star$"},{"location":"python3/0701-0800/0751-0760/#752-open-the-lock-starstar","text":"","title":"752. Open the Lock $\\star\\star$"},{"location":"python3/0701-0800/0751-0760/#753-cracking-the-safe-starstarstar","text":"","title":"753. Cracking the Safe $\\star\\star\\star$"},{"location":"python3/0701-0800/0751-0760/#754-reach-a-number-starstar","text":"","title":"754. Reach a Number $\\star\\star$"},{"location":"python3/0701-0800/0751-0760/#755-pour-water-starstar","text":"","title":"755. Pour Water $\\star\\star$"},{"location":"python3/0701-0800/0751-0760/#756-pyramid-transition-matrix-starstar","text":"","title":"756. Pyramid Transition Matrix $\\star\\star$"},{"location":"python3/0701-0800/0751-0760/#757-set-intersection-size-at-least-two-starstarstar","text":"","title":"757. Set Intersection Size At Least Two $\\star\\star\\star$"},{"location":"python3/0701-0800/0751-0760/#758-bold-words-in-string-star","text":"","title":"758. Bold Words in String $\\star$"},{"location":"python3/0701-0800/0751-0760/#759-employee-free-time-starstarstar","text":"","title":"759. Employee Free Time $\\star\\star\\star$"},{"location":"python3/0701-0800/0751-0760/#760-find-anagram-mappings-star","text":"","title":"760. Find Anagram Mappings $\\star$"},{"location":"python3/0701-0800/0761-0770/","text":"761. Special Binary String $\\star\\star\\star$ 762. Prime Number of Set Bits in Binary Representation $\\star$ 763. Partition Labels $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def partitionLabels ( self , S : str ) -> List [ int ]: ans = [] dict = { c : i for i , c in enumerate ( S )} start = 0 end = 0 for i , c in enumerate ( S ): end = max ( end , dict [ c ]) if i == end : ans . append ( end - start + 1 ) start = end + 1 return ans 764. Largest Plus Sign $\\star\\star$ 765. Couples Holding Hands $\\star\\star\\star$ 766. Toeplitz Matrix $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Error `` ` ## 767. Reorganize String [$\\star\\star$](https://leetcode.com/problems/reorganize-string) ## 768. Max Chunks To Make Sorted II [$\\star\\star\\star$](https://leetcode.com/problems/max-chunks-to-make-sorted-ii) `` ` python class Solution : def maxChunksToSorted ( self , arr : List [ int ]) -> int : n = len ( arr ) ans = 0 max_ = float ( '-inf' ) min_ = [ arr [ - 1 ]] * n for i in range ( n - 2 , - 1 , - 1 ): min_ [ i ] = min ( min_ [ i + 1 ], arr [ i ]) for i in range ( n - 1 ): max_ = max ( max_ , arr [ i ]) if max_ <= min_ [ i + 1 ]: ans += 1 return ans + 1 769. Max Chunks To Make Sorted $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution : def maxChunksToSorted ( self , arr : List [ int ]) -> int : ans = 0 max_ = float ( '-inf' ) for i , a in enumerate ( arr ): max_ = max ( max_ , a ) if max_ == i : ans += 1 return ans 770. Basic Calculator IV $\\star\\star\\star$","title":"0761-0770"},{"location":"python3/0701-0800/0761-0770/#761-special-binary-string-starstarstar","text":"","title":"761. Special Binary String $\\star\\star\\star$"},{"location":"python3/0701-0800/0761-0770/#762-prime-number-of-set-bits-in-binary-representation-star","text":"","title":"762. Prime Number of Set Bits in Binary Representation $\\star$"},{"location":"python3/0701-0800/0761-0770/#763-partition-labels-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def partitionLabels ( self , S : str ) -> List [ int ]: ans = [] dict = { c : i for i , c in enumerate ( S )} start = 0 end = 0 for i , c in enumerate ( S ): end = max ( end , dict [ c ]) if i == end : ans . append ( end - start + 1 ) start = end + 1 return ans","title":"763. Partition Labels $\\star\\star$"},{"location":"python3/0701-0800/0761-0770/#764-largest-plus-sign-starstar","text":"","title":"764. Largest Plus Sign $\\star\\star$"},{"location":"python3/0701-0800/0761-0770/#765-couples-holding-hands-starstarstar","text":"","title":"765. Couples Holding Hands $\\star\\star\\star$"},{"location":"python3/0701-0800/0761-0770/#766-toeplitz-matrix-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Error `` ` ## 767. Reorganize String [$\\star\\star$](https://leetcode.com/problems/reorganize-string) ## 768. Max Chunks To Make Sorted II [$\\star\\star\\star$](https://leetcode.com/problems/max-chunks-to-make-sorted-ii) `` ` python class Solution : def maxChunksToSorted ( self , arr : List [ int ]) -> int : n = len ( arr ) ans = 0 max_ = float ( '-inf' ) min_ = [ arr [ - 1 ]] * n for i in range ( n - 2 , - 1 , - 1 ): min_ [ i ] = min ( min_ [ i + 1 ], arr [ i ]) for i in range ( n - 1 ): max_ = max ( max_ , arr [ i ]) if max_ <= min_ [ i + 1 ]: ans += 1 return ans + 1","title":"766. Toeplitz Matrix $\\star$"},{"location":"python3/0701-0800/0761-0770/#769-max-chunks-to-make-sorted-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution : def maxChunksToSorted ( self , arr : List [ int ]) -> int : ans = 0 max_ = float ( '-inf' ) for i , a in enumerate ( arr ): max_ = max ( max_ , a ) if max_ == i : ans += 1 return ans","title":"769. Max Chunks To Make Sorted $\\star\\star$"},{"location":"python3/0701-0800/0761-0770/#770-basic-calculator-iv-starstarstar","text":"","title":"770. Basic Calculator IV $\\star\\star\\star$"},{"location":"python3/0701-0800/0771-0780/","text":"771. Jewels and Stones $\\star$ 772. Basic Calculator III $\\star\\star\\star$ 773. Sliding Puzzle $\\star\\star\\star$ 774. Minimize Max Distance to Gas Station $\\star\\star\\star$ 775. Global and Local Inversions $\\star\\star$ 1 2 3 4 5 6 7 class Solution : def isIdealPermutation ( self , A : List [ int ]) -> bool : for i , a in enumerate ( A ): if abs ( a - i ) > 1 : return False return True 776. Split BST $\\star\\star$ 777. Swap Adjacent in LR String $\\star\\star$ 778. Swim in Rising Water $\\star\\star\\star$ 779. K-th Symbol in Grammar $\\star\\star$ 780. Reaching Points $\\star\\star\\star$","title":"0771-0780"},{"location":"python3/0701-0800/0771-0780/#771-jewels-and-stones-star","text":"","title":"771. Jewels and Stones $\\star$"},{"location":"python3/0701-0800/0771-0780/#772-basic-calculator-iii-starstarstar","text":"","title":"772. Basic Calculator III $\\star\\star\\star$"},{"location":"python3/0701-0800/0771-0780/#773-sliding-puzzle-starstarstar","text":"","title":"773. Sliding Puzzle $\\star\\star\\star$"},{"location":"python3/0701-0800/0771-0780/#774-minimize-max-distance-to-gas-station-starstarstar","text":"","title":"774. Minimize Max Distance to Gas Station $\\star\\star\\star$"},{"location":"python3/0701-0800/0771-0780/#775-global-and-local-inversions-starstar","text":"1 2 3 4 5 6 7 class Solution : def isIdealPermutation ( self , A : List [ int ]) -> bool : for i , a in enumerate ( A ): if abs ( a - i ) > 1 : return False return True","title":"775. Global and Local Inversions $\\star\\star$"},{"location":"python3/0701-0800/0771-0780/#776-split-bst-starstar","text":"","title":"776. Split BST $\\star\\star$"},{"location":"python3/0701-0800/0771-0780/#777-swap-adjacent-in-lr-string-starstar","text":"","title":"777. Swap Adjacent in LR String $\\star\\star$"},{"location":"python3/0701-0800/0771-0780/#778-swim-in-rising-water-starstarstar","text":"","title":"778. Swim in Rising Water $\\star\\star\\star$"},{"location":"python3/0701-0800/0771-0780/#779-k-th-symbol-in-grammar-starstar","text":"","title":"779. K-th Symbol in Grammar $\\star\\star$"},{"location":"python3/0701-0800/0771-0780/#780-reaching-points-starstarstar","text":"","title":"780. Reaching Points $\\star\\star\\star$"},{"location":"python3/0701-0800/0781-0790/","text":"781. Rabbits in Forest $\\star\\star$ 782. Transform to Chessboard $\\star\\star\\star$ 783. Minimum Distance Between BST Nodes $\\star$ 784. Letter Case Permutation $\\star$ 785. Is Graph Bipartite? $\\star\\star$ 786. K-th Smallest Prime Fraction $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def kthSmallestPrimeFraction ( self , A : List [ int ], K : int ) -> List [ int ]: n = len ( A ) ans = [ 0 , 1 ] l = 0 r = 1 while True : m = ( l + r ) / 2 ans [ 0 ] = 0 count = 0 j = 1 for i in range ( n ): while j < n and A [ i ] > m * A [ j ]: j += 1 count += n - j if j == n : break if ans [ 0 ] * A [ j ] < ans [ 1 ] * A [ i ]: ans [ 0 ] = A [ i ] ans [ 1 ] = A [ j ] if count < K : l = m elif count > K : r = m else : return ans 787. Cheapest Flights Within K Stops $\\star\\star$ 788. Rotated Digits $\\star$ 789. Escape The Ghosts $\\star\\star$ 790. Domino and Tromino Tiling $\\star\\star$","title":"0781-0790"},{"location":"python3/0701-0800/0781-0790/#781-rabbits-in-forest-starstar","text":"","title":"781. Rabbits in Forest $\\star\\star$"},{"location":"python3/0701-0800/0781-0790/#782-transform-to-chessboard-starstarstar","text":"","title":"782. Transform to Chessboard $\\star\\star\\star$"},{"location":"python3/0701-0800/0781-0790/#783-minimum-distance-between-bst-nodes-star","text":"","title":"783. Minimum Distance Between BST Nodes $\\star$"},{"location":"python3/0701-0800/0781-0790/#784-letter-case-permutation-star","text":"","title":"784. Letter Case Permutation $\\star$"},{"location":"python3/0701-0800/0781-0790/#785-is-graph-bipartite-starstar","text":"","title":"785. Is Graph Bipartite? $\\star\\star$"},{"location":"python3/0701-0800/0781-0790/#786-k-th-smallest-prime-fraction-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 class Solution : def kthSmallestPrimeFraction ( self , A : List [ int ], K : int ) -> List [ int ]: n = len ( A ) ans = [ 0 , 1 ] l = 0 r = 1 while True : m = ( l + r ) / 2 ans [ 0 ] = 0 count = 0 j = 1 for i in range ( n ): while j < n and A [ i ] > m * A [ j ]: j += 1 count += n - j if j == n : break if ans [ 0 ] * A [ j ] < ans [ 1 ] * A [ i ]: ans [ 0 ] = A [ i ] ans [ 1 ] = A [ j ] if count < K : l = m elif count > K : r = m else : return ans","title":"786. K-th Smallest Prime Fraction $\\star\\star\\star$"},{"location":"python3/0701-0800/0781-0790/#787-cheapest-flights-within-k-stops-starstar","text":"","title":"787. Cheapest Flights Within K Stops $\\star\\star$"},{"location":"python3/0701-0800/0781-0790/#788-rotated-digits-star","text":"","title":"788. Rotated Digits $\\star$"},{"location":"python3/0701-0800/0781-0790/#789-escape-the-ghosts-starstar","text":"","title":"789. Escape The Ghosts $\\star\\star$"},{"location":"python3/0701-0800/0781-0790/#790-domino-and-tromino-tiling-starstar","text":"","title":"790. Domino and Tromino Tiling $\\star\\star$"},{"location":"python3/0701-0800/0791-0800/","text":"791. Custom Sort String $\\star\\star$ 792. Number of Matching Subsequences $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution : def numMatchingSubseq ( self , S : str , words : List [ str ]) -> int : def insert ( word : str ) -> None : node = self . root for c in word : if c not in node : node [ c ] = { 'count' : 0 } node = node [ c ] node [ 'count' ] += 1 def dfs ( S : str , s : int , node : dict ) -> int : ans = node [ 'count' ] if 'count' in node else 0 if s >= len ( S ): return ans for c in string . ascii_lowercase : if c in node : try : index = S . index ( c , s ) ans += dfs ( S , index + 1 , node [ c ]) except ValueError : continue return ans self . root = {} for word in words : insert ( word ) return dfs ( S , 0 , self . root ) 793. Preimage Size of Factorial Zeroes Function $\\star\\star\\star$ 794. Valid Tic-Tac-Toe State $\\star\\star$ 795. Number of Subarrays with Bounded Maximum $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def numSubarrayBoundedMax ( self , A : List [ int ], L : int , R : int ) -> int : ans = 0 l = - 1 r = - 1 for i , a in enumerate ( A ): if a > R : l = i if a >= L : r = i ans += r - l return ans 796. Rotate String $\\star$ 797. All Paths From Source to Target $\\star\\star$ 798. Smallest Rotation with Highest Score $\\star\\star\\star$ 799. Champagne Tower $\\star\\star$ 800. Similar RGB Color $\\star$","title":"0791-0800"},{"location":"python3/0701-0800/0791-0800/#791-custom-sort-string-starstar","text":"","title":"791. Custom Sort String $\\star\\star$"},{"location":"python3/0701-0800/0791-0800/#792-number-of-matching-subsequences-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 class Solution : def numMatchingSubseq ( self , S : str , words : List [ str ]) -> int : def insert ( word : str ) -> None : node = self . root for c in word : if c not in node : node [ c ] = { 'count' : 0 } node = node [ c ] node [ 'count' ] += 1 def dfs ( S : str , s : int , node : dict ) -> int : ans = node [ 'count' ] if 'count' in node else 0 if s >= len ( S ): return ans for c in string . ascii_lowercase : if c in node : try : index = S . index ( c , s ) ans += dfs ( S , index + 1 , node [ c ]) except ValueError : continue return ans self . root = {} for word in words : insert ( word ) return dfs ( S , 0 , self . root )","title":"792. Number of Matching Subsequences $\\star\\star$"},{"location":"python3/0701-0800/0791-0800/#793-preimage-size-of-factorial-zeroes-function-starstarstar","text":"","title":"793. Preimage Size of Factorial Zeroes Function $\\star\\star\\star$"},{"location":"python3/0701-0800/0791-0800/#794-valid-tic-tac-toe-state-starstar","text":"","title":"794. Valid Tic-Tac-Toe State $\\star\\star$"},{"location":"python3/0701-0800/0791-0800/#795-number-of-subarrays-with-bounded-maximum-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def numSubarrayBoundedMax ( self , A : List [ int ], L : int , R : int ) -> int : ans = 0 l = - 1 r = - 1 for i , a in enumerate ( A ): if a > R : l = i if a >= L : r = i ans += r - l return ans","title":"795. Number of Subarrays with Bounded Maximum $\\star\\star$"},{"location":"python3/0701-0800/0791-0800/#796-rotate-string-star","text":"","title":"796. Rotate String $\\star$"},{"location":"python3/0701-0800/0791-0800/#797-all-paths-from-source-to-target-starstar","text":"","title":"797. All Paths From Source to Target $\\star\\star$"},{"location":"python3/0701-0800/0791-0800/#798-smallest-rotation-with-highest-score-starstarstar","text":"","title":"798. Smallest Rotation with Highest Score $\\star\\star\\star$"},{"location":"python3/0701-0800/0791-0800/#799-champagne-tower-starstar","text":"","title":"799. Champagne Tower $\\star\\star$"},{"location":"python3/0701-0800/0791-0800/#800-similar-rgb-color-star","text":"","title":"800. Similar RGB Color $\\star$"},{"location":"python3/0801-0900/0801-0810/","text":"801. Minimum Swaps To Make Sequences Increasing $\\star\\star$ 802. Find Eventual Safe States $\\star\\star$ 803. Bricks Falling When Hit $\\star\\star\\star$ 804. Unique Morse Code Words $\\star$ 805. Split Array With Same Average $\\star\\star\\star$ 806. Number of Lines To Write String $\\star$ 807. Max Increase to Keep City Skyline $\\star\\star$ 808. Soup Servings $\\star\\star$ 809. Expressive Words $\\star\\star$ 810. Chalkboard XOR Game $\\star\\star\\star$","title":"0801-0810"},{"location":"python3/0801-0900/0801-0810/#801-minimum-swaps-to-make-sequences-increasing-starstar","text":"","title":"801. Minimum Swaps To Make Sequences Increasing $\\star\\star$"},{"location":"python3/0801-0900/0801-0810/#802-find-eventual-safe-states-starstar","text":"","title":"802. Find Eventual Safe States $\\star\\star$"},{"location":"python3/0801-0900/0801-0810/#803-bricks-falling-when-hit-starstarstar","text":"","title":"803. Bricks Falling When Hit $\\star\\star\\star$"},{"location":"python3/0801-0900/0801-0810/#804-unique-morse-code-words-star","text":"","title":"804. Unique Morse Code Words $\\star$"},{"location":"python3/0801-0900/0801-0810/#805-split-array-with-same-average-starstarstar","text":"","title":"805. Split Array With Same Average $\\star\\star\\star$"},{"location":"python3/0801-0900/0801-0810/#806-number-of-lines-to-write-string-star","text":"","title":"806. Number of Lines To Write String $\\star$"},{"location":"python3/0801-0900/0801-0810/#807-max-increase-to-keep-city-skyline-starstar","text":"","title":"807. Max Increase to Keep City Skyline $\\star\\star$"},{"location":"python3/0801-0900/0801-0810/#808-soup-servings-starstar","text":"","title":"808. Soup Servings $\\star\\star$"},{"location":"python3/0801-0900/0801-0810/#809-expressive-words-starstar","text":"","title":"809. Expressive Words $\\star\\star$"},{"location":"python3/0801-0900/0801-0810/#810-chalkboard-xor-game-starstarstar","text":"","title":"810. Chalkboard XOR Game $\\star\\star\\star$"},{"location":"python3/0801-0900/0811-0820/","text":"811. Subdomain Visit Count $\\star$ 812. Largest Triangle Area $\\star$ 813. Largest Sum of Averages $\\star\\star$ 814. Binary Tree Pruning $\\star\\star$ 815. Bus Routes $\\star\\star\\star$ 816. Ambiguous Coordinates $\\star\\star$ 817. Linked List Components $\\star\\star$ 818. Race Car $\\star\\star\\star$ 819. Most Common Word $\\star$ 820. Short Encoding of Words $\\star\\star$","title":"0811-0820"},{"location":"python3/0801-0900/0811-0820/#811-subdomain-visit-count-star","text":"","title":"811. Subdomain Visit Count $\\star$"},{"location":"python3/0801-0900/0811-0820/#812-largest-triangle-area-star","text":"","title":"812. Largest Triangle Area $\\star$"},{"location":"python3/0801-0900/0811-0820/#813-largest-sum-of-averages-starstar","text":"","title":"813. Largest Sum of Averages $\\star\\star$"},{"location":"python3/0801-0900/0811-0820/#814-binary-tree-pruning-starstar","text":"","title":"814. Binary Tree Pruning $\\star\\star$"},{"location":"python3/0801-0900/0811-0820/#815-bus-routes-starstarstar","text":"","title":"815. Bus Routes $\\star\\star\\star$"},{"location":"python3/0801-0900/0811-0820/#816-ambiguous-coordinates-starstar","text":"","title":"816. Ambiguous Coordinates $\\star\\star$"},{"location":"python3/0801-0900/0811-0820/#817-linked-list-components-starstar","text":"","title":"817. Linked List Components $\\star\\star$"},{"location":"python3/0801-0900/0811-0820/#818-race-car-starstarstar","text":"","title":"818. Race Car $\\star\\star\\star$"},{"location":"python3/0801-0900/0811-0820/#819-most-common-word-star","text":"","title":"819. Most Common Word $\\star$"},{"location":"python3/0801-0900/0811-0820/#820-short-encoding-of-words-starstar","text":"","title":"820. Short Encoding of Words $\\star\\star$"},{"location":"python3/0801-0900/0821-0830/","text":"821. Shortest Distance to a Character $\\star$ 822. Card Flipping Game $\\star\\star$ 823. Binary Trees With Factors $\\star\\star$ 824. Goat Latin $\\star$ 825. Friends Of Appropriate Ages $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def numFriendRequests ( self , ages : List [ int ]) -> int : ans = 0 count = [ 0 ] * 121 for age in ages : count [ age ] += 1 for i in range ( 15 , 121 ): ans += count [ i ] * ( count [ i ] - 1 ) for i in range ( 15 , 121 ): for j in range ( i // 2 + 8 , i ): ans += count [ i ] * count [ j ] return ans 826. Most Profit Assigning Work $\\star\\star$ 827. Making A Large Island $\\star\\star\\star$ 828. Unique Letter String $\\star\\star\\star$ 829. Consecutive Numbers Sum $\\star\\star\\star$ 830. Positions of Large Groups $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def largeGroupPositions ( self , S : str ) -> List [ List [ int ]]: n = len ( S ) ans = [] i = 0 j = 0 while i < n : while j < n and S [ j ] == S [ i ]: j += 1 if j - i >= 3 : ans . append ([ i , j - 1 ]) i = j return ans","title":"0821-0830"},{"location":"python3/0801-0900/0821-0830/#821-shortest-distance-to-a-character-star","text":"","title":"821. Shortest Distance to a Character $\\star$"},{"location":"python3/0801-0900/0821-0830/#822-card-flipping-game-starstar","text":"","title":"822. Card Flipping Game $\\star\\star$"},{"location":"python3/0801-0900/0821-0830/#823-binary-trees-with-factors-starstar","text":"","title":"823. Binary Trees With Factors $\\star\\star$"},{"location":"python3/0801-0900/0821-0830/#824-goat-latin-star","text":"","title":"824. Goat Latin $\\star$"},{"location":"python3/0801-0900/0821-0830/#825-friends-of-appropriate-ages-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def numFriendRequests ( self , ages : List [ int ]) -> int : ans = 0 count = [ 0 ] * 121 for age in ages : count [ age ] += 1 for i in range ( 15 , 121 ): ans += count [ i ] * ( count [ i ] - 1 ) for i in range ( 15 , 121 ): for j in range ( i // 2 + 8 , i ): ans += count [ i ] * count [ j ] return ans","title":"825. Friends Of Appropriate Ages $\\star\\star$"},{"location":"python3/0801-0900/0821-0830/#826-most-profit-assigning-work-starstar","text":"","title":"826. Most Profit Assigning Work $\\star\\star$"},{"location":"python3/0801-0900/0821-0830/#827-making-a-large-island-starstarstar","text":"","title":"827. Making A Large Island $\\star\\star\\star$"},{"location":"python3/0801-0900/0821-0830/#828-unique-letter-string-starstarstar","text":"","title":"828. Unique Letter String $\\star\\star\\star$"},{"location":"python3/0801-0900/0821-0830/#829-consecutive-numbers-sum-starstarstar","text":"","title":"829. Consecutive Numbers Sum $\\star\\star\\star$"},{"location":"python3/0801-0900/0821-0830/#830-positions-of-large-groups-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def largeGroupPositions ( self , S : str ) -> List [ List [ int ]]: n = len ( S ) ans = [] i = 0 j = 0 while i < n : while j < n and S [ j ] == S [ i ]: j += 1 if j - i >= 3 : ans . append ([ i , j - 1 ]) i = j return ans","title":"830. Positions of Large Groups $\\star$"},{"location":"python3/0801-0900/0831-0840/","text":"831. Masking Personal Information $\\star\\star$ 832. Flipping an Image $\\star$ 1 2 3 4 5 6 7 class Solution : def flipAndInvertImage ( self , A : List [ List [ int ]]) -> List [ List [ int ]]: for row in A : for i in range (( len ( row ) + 1 ) // 2 ): row [ i ], row [ ~ i ] = row [ ~ i ] ^ 1 , row [ i ] ^ 1 return A 833. Find And Replace in String $\\star\\star$ 834. Sum of Distances in Tree $\\star\\star\\star$ 835. Image Overlap $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def largestOverlap ( self , A : List [ List [ int ]], B : List [ List [ int ]]) -> int : n = len ( A ) magic = 100 onesA = [] onesB = [] dict = collections . defaultdict ( int ) for i in range ( n ): for j in range ( n ): if A [ i ][ j ] == 1 : onesA . append ([ i , j ]) if B [ i ][ j ] == 1 : onesB . append ([ i , j ]) for a in onesA : for b in onesB : dict [( a [ 0 ] - b [ 0 ]) * magic + ( a [ 1 ] - b [ 1 ])] += 1 return max ( dict . values ()) if dict else 0 836. Rectangle Overlap $\\star$ 837. New 21 Game $\\star\\star$ 838. Push Dominoes $\\star\\star$ 839. Similar String Groups $\\star\\star\\star$ 840. Magic Squares In Grid $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def numMagicSquaresInside ( self , grid : List [ List [ int ]]) -> int : def isMagic ( i : int , j : int ) -> int : s = \"\" . join ( str ( grid [ i + num // 3 ][ j + num % 3 ]) for num in [ 0 , 1 , 2 , 5 , 8 , 7 , 6 , 3 ]) return s in \"43816729\" * 2 or s in \"43816729\" [:: - 1 ] * 2 ans = 0 for i in range ( len ( grid ) - 2 ): for j in range ( len ( grid [ 0 ]) - 2 ): if grid [ i ][ j ] % 2 == 0 and grid [ i + 1 ][ j + 1 ] == 5 : ans += isMagic ( i , j ) return ans","title":"0831-0840"},{"location":"python3/0801-0900/0831-0840/#831-masking-personal-information-starstar","text":"","title":"831. Masking Personal Information $\\star\\star$"},{"location":"python3/0801-0900/0831-0840/#832-flipping-an-image-star","text":"1 2 3 4 5 6 7 class Solution : def flipAndInvertImage ( self , A : List [ List [ int ]]) -> List [ List [ int ]]: for row in A : for i in range (( len ( row ) + 1 ) // 2 ): row [ i ], row [ ~ i ] = row [ ~ i ] ^ 1 , row [ i ] ^ 1 return A","title":"832. Flipping an Image $\\star$"},{"location":"python3/0801-0900/0831-0840/#833-find-and-replace-in-string-starstar","text":"","title":"833. Find And Replace in String $\\star\\star$"},{"location":"python3/0801-0900/0831-0840/#834-sum-of-distances-in-tree-starstarstar","text":"","title":"834. Sum of Distances in Tree $\\star\\star\\star$"},{"location":"python3/0801-0900/0831-0840/#835-image-overlap-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def largestOverlap ( self , A : List [ List [ int ]], B : List [ List [ int ]]) -> int : n = len ( A ) magic = 100 onesA = [] onesB = [] dict = collections . defaultdict ( int ) for i in range ( n ): for j in range ( n ): if A [ i ][ j ] == 1 : onesA . append ([ i , j ]) if B [ i ][ j ] == 1 : onesB . append ([ i , j ]) for a in onesA : for b in onesB : dict [( a [ 0 ] - b [ 0 ]) * magic + ( a [ 1 ] - b [ 1 ])] += 1 return max ( dict . values ()) if dict else 0","title":"835. Image Overlap $\\star\\star$"},{"location":"python3/0801-0900/0831-0840/#836-rectangle-overlap-star","text":"","title":"836. Rectangle Overlap $\\star$"},{"location":"python3/0801-0900/0831-0840/#837-new-21-game-starstar","text":"","title":"837. New 21 Game $\\star\\star$"},{"location":"python3/0801-0900/0831-0840/#838-push-dominoes-starstar","text":"","title":"838. Push Dominoes $\\star\\star$"},{"location":"python3/0801-0900/0831-0840/#839-similar-string-groups-starstarstar","text":"","title":"839. Similar String Groups $\\star\\star\\star$"},{"location":"python3/0801-0900/0831-0840/#840-magic-squares-in-grid-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def numMagicSquaresInside ( self , grid : List [ List [ int ]]) -> int : def isMagic ( i : int , j : int ) -> int : s = \"\" . join ( str ( grid [ i + num // 3 ][ j + num % 3 ]) for num in [ 0 , 1 , 2 , 5 , 8 , 7 , 6 , 3 ]) return s in \"43816729\" * 2 or s in \"43816729\" [:: - 1 ] * 2 ans = 0 for i in range ( len ( grid ) - 2 ): for j in range ( len ( grid [ 0 ]) - 2 ): if grid [ i ][ j ] % 2 == 0 and grid [ i + 1 ][ j + 1 ] == 5 : ans += isMagic ( i , j ) return ans","title":"840. Magic Squares In Grid $\\star$"},{"location":"python3/0801-0900/0841-0850/","text":"841. Keys and Rooms $\\star\\star$ 842. Split Array into Fibonacci Sequence $\\star\\star$ 843. Guess the Word $\\star\\star\\star$ 844. Backspace String Compare $\\star$ 845. Longest Mountain in Array $\\star\\star$ 846. Hand of Straights $\\star\\star$ 847. Shortest Path Visiting All Nodes $\\star\\star\\star$ 848. Shifting Letters $\\star\\star$ 849. Maximize Distance to Closest Person $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def maxDistToClosest ( self , seats : List [ int ]) -> int : n = len ( seats ) ans = 0 j = - 1 for i in range ( n ): if seats [ i ] == 1 : ans = i if j == - 1 else max ( ans , ( i - j ) // 2 ) j = i return max ( ans , n - j - 1 ) 850. Rectangle Area II $\\star\\star\\star$","title":"0841-0850"},{"location":"python3/0801-0900/0841-0850/#841-keys-and-rooms-starstar","text":"","title":"841. Keys and Rooms $\\star\\star$"},{"location":"python3/0801-0900/0841-0850/#842-split-array-into-fibonacci-sequence-starstar","text":"","title":"842. Split Array into Fibonacci Sequence $\\star\\star$"},{"location":"python3/0801-0900/0841-0850/#843-guess-the-word-starstarstar","text":"","title":"843. Guess the Word $\\star\\star\\star$"},{"location":"python3/0801-0900/0841-0850/#844-backspace-string-compare-star","text":"","title":"844. Backspace String Compare $\\star$"},{"location":"python3/0801-0900/0841-0850/#845-longest-mountain-in-array-starstar","text":"","title":"845. Longest Mountain in Array $\\star\\star$"},{"location":"python3/0801-0900/0841-0850/#846-hand-of-straights-starstar","text":"","title":"846. Hand of Straights $\\star\\star$"},{"location":"python3/0801-0900/0841-0850/#847-shortest-path-visiting-all-nodes-starstarstar","text":"","title":"847. Shortest Path Visiting All Nodes $\\star\\star\\star$"},{"location":"python3/0801-0900/0841-0850/#848-shifting-letters-starstar","text":"","title":"848. Shifting Letters $\\star\\star$"},{"location":"python3/0801-0900/0841-0850/#849-maximize-distance-to-closest-person-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def maxDistToClosest ( self , seats : List [ int ]) -> int : n = len ( seats ) ans = 0 j = - 1 for i in range ( n ): if seats [ i ] == 1 : ans = i if j == - 1 else max ( ans , ( i - j ) // 2 ) j = i return max ( ans , n - j - 1 )","title":"849. Maximize Distance to Closest Person $\\star$"},{"location":"python3/0801-0900/0841-0850/#850-rectangle-area-ii-starstarstar","text":"","title":"850. Rectangle Area II $\\star\\star\\star$"},{"location":"python3/0801-0900/0851-0860/","text":"851. Loud and Rich $\\star\\star$ 852. Peak Index in a Mountain Array $\\star$ 853. Car Fleet $\\star\\star$ 854. K-Similar Strings $\\star\\star\\star$ 855. Exam Room $\\star\\star$ 856. Score of Parentheses $\\star\\star$ 857. Minimum Cost to Hire K Workers $\\star\\star\\star$ 858. Mirror Reflection $\\star\\star$ 859. Buddy Strings $\\star$ 860. Lemonade Change $\\star$","title":"0851-0860"},{"location":"python3/0801-0900/0851-0860/#851-loud-and-rich-starstar","text":"","title":"851. Loud and Rich $\\star\\star$"},{"location":"python3/0801-0900/0851-0860/#852-peak-index-in-a-mountain-array-star","text":"","title":"852. Peak Index in a Mountain Array $\\star$"},{"location":"python3/0801-0900/0851-0860/#853-car-fleet-starstar","text":"","title":"853. Car Fleet $\\star\\star$"},{"location":"python3/0801-0900/0851-0860/#854-k-similar-strings-starstarstar","text":"","title":"854. K-Similar Strings $\\star\\star\\star$"},{"location":"python3/0801-0900/0851-0860/#855-exam-room-starstar","text":"","title":"855. Exam Room $\\star\\star$"},{"location":"python3/0801-0900/0851-0860/#856-score-of-parentheses-starstar","text":"","title":"856. Score of Parentheses $\\star\\star$"},{"location":"python3/0801-0900/0851-0860/#857-minimum-cost-to-hire-k-workers-starstarstar","text":"","title":"857. Minimum Cost to Hire K Workers $\\star\\star\\star$"},{"location":"python3/0801-0900/0851-0860/#858-mirror-reflection-starstar","text":"","title":"858. Mirror Reflection $\\star\\star$"},{"location":"python3/0801-0900/0851-0860/#859-buddy-strings-star","text":"","title":"859. Buddy Strings $\\star$"},{"location":"python3/0801-0900/0851-0860/#860-lemonade-change-star","text":"","title":"860. Lemonade Change $\\star$"},{"location":"python3/0801-0900/0861-0870/","text":"861. Score After Flipping Matrix $\\star\\star$ 862. Shortest Subarray with Sum at Least K $\\star\\star\\star$ 863. All Nodes Distance K in Binary Tree $\\star\\star$ 864. Shortest Path to Get All Keys $\\star\\star\\star$ 865. Smallest Subtree with all the Deepest Nodes $\\star\\star$ 866. Prime Palindrome $\\star\\star$ 867. Transpose Matrix $\\star$ 1 2 3 4 5 6 7 8 9 class Solution : def transpose ( self , A : List [ List [ int ]]) -> List [ List [ int ]]: ans = [[ 0 ] * len ( A ) for _ in range ( len ( A [ 0 ]))] for i in range ( len ( A )): for j in range ( len ( A [ 0 ])): ans [ j ][ i ] = A [ i ][ j ] return ans 868. Binary Gap $\\star$ 869. Reordered Power of 2 $\\star\\star$ 870. Advantage Shuffle $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution : def advantageCount ( self , A : List [ int ], B : List [ int ]) -> List [ int ]: A . sort () dict = collections . defaultdict ( list ) for b in sorted ( B )[:: - 1 ]: if b < A [ - 1 ]: dict [ b ] . append ( A . pop ()) return [( dict [ b ] or A ) . pop () for b in B ]","title":"0861-0870"},{"location":"python3/0801-0900/0861-0870/#861-score-after-flipping-matrix-starstar","text":"","title":"861. Score After Flipping Matrix $\\star\\star$"},{"location":"python3/0801-0900/0861-0870/#862-shortest-subarray-with-sum-at-least-k-starstarstar","text":"","title":"862. Shortest Subarray with Sum at Least K $\\star\\star\\star$"},{"location":"python3/0801-0900/0861-0870/#863-all-nodes-distance-k-in-binary-tree-starstar","text":"","title":"863. All Nodes Distance K in Binary Tree $\\star\\star$"},{"location":"python3/0801-0900/0861-0870/#864-shortest-path-to-get-all-keys-starstarstar","text":"","title":"864. Shortest Path to Get All Keys $\\star\\star\\star$"},{"location":"python3/0801-0900/0861-0870/#865-smallest-subtree-with-all-the-deepest-nodes-starstar","text":"","title":"865. Smallest Subtree with all the Deepest Nodes $\\star\\star$"},{"location":"python3/0801-0900/0861-0870/#866-prime-palindrome-starstar","text":"","title":"866. Prime Palindrome $\\star\\star$"},{"location":"python3/0801-0900/0861-0870/#867-transpose-matrix-star","text":"1 2 3 4 5 6 7 8 9 class Solution : def transpose ( self , A : List [ List [ int ]]) -> List [ List [ int ]]: ans = [[ 0 ] * len ( A ) for _ in range ( len ( A [ 0 ]))] for i in range ( len ( A )): for j in range ( len ( A [ 0 ])): ans [ j ][ i ] = A [ i ][ j ] return ans","title":"867. Transpose Matrix $\\star$"},{"location":"python3/0801-0900/0861-0870/#868-binary-gap-star","text":"","title":"868. Binary Gap $\\star$"},{"location":"python3/0801-0900/0861-0870/#869-reordered-power-of-2-starstar","text":"","title":"869. Reordered Power of 2 $\\star\\star$"},{"location":"python3/0801-0900/0861-0870/#870-advantage-shuffle-starstar","text":"1 2 3 4 5 6 7 8 9 10 class Solution : def advantageCount ( self , A : List [ int ], B : List [ int ]) -> List [ int ]: A . sort () dict = collections . defaultdict ( list ) for b in sorted ( B )[:: - 1 ]: if b < A [ - 1 ]: dict [ b ] . append ( A . pop ()) return [( dict [ b ] or A ) . pop () for b in B ]","title":"870. Advantage Shuffle $\\star\\star$"},{"location":"python3/0801-0900/0871-0880/","text":"871. Minimum Number of Refueling Stops $\\star\\star\\star$ 872. Leaf-Similar Trees $\\star$ 873. Length of Longest Fibonacci Subsequence $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def lenLongestFibSubseq ( self , A : List [ int ]) -> int : n = len ( A ) ans = 0 dict = { a : i for i , a in enumerate ( A )} dp = [[ 2 ] * n for _ in range ( n )] for j in range ( n ): for k in range ( j + 1 , n ): ai = A [ k ] - A [ j ] if ai < A [ j ] and ai in dict : i = dict [ ai ] dp [ j ][ k ] = dp [ i ][ j ] + 1 ans = max ( ans , dp [ j ][ k ]) return ans 874. Walking Robot Simulation $\\star$ 875. Koko Eating Bananas $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def minEatingSpeed ( self , piles : List [ int ], H : int ) -> int : l = 1 r = max ( piles ) + 1 while l < r : m = ( l + r ) >> 1 hour = 0 for pile in piles : hour += ( pile - 1 ) // m + 1 if hour <= H : r = m else : l = m + 1 return l 876. Middle of the Linked List $\\star$ 877. Stone Game $\\star\\star$ 878. Nth Magical Number $\\star\\star\\star$ 879. Profitable Schemes $\\star\\star\\star$ 880. Decoded String at Index $\\star\\star$","title":"0871-0880"},{"location":"python3/0801-0900/0871-0880/#871-minimum-number-of-refueling-stops-starstarstar","text":"","title":"871. Minimum Number of Refueling Stops $\\star\\star\\star$"},{"location":"python3/0801-0900/0871-0880/#872-leaf-similar-trees-star","text":"","title":"872. Leaf-Similar Trees $\\star$"},{"location":"python3/0801-0900/0871-0880/#873-length-of-longest-fibonacci-subsequence-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def lenLongestFibSubseq ( self , A : List [ int ]) -> int : n = len ( A ) ans = 0 dict = { a : i for i , a in enumerate ( A )} dp = [[ 2 ] * n for _ in range ( n )] for j in range ( n ): for k in range ( j + 1 , n ): ai = A [ k ] - A [ j ] if ai < A [ j ] and ai in dict : i = dict [ ai ] dp [ j ][ k ] = dp [ i ][ j ] + 1 ans = max ( ans , dp [ j ][ k ]) return ans","title":"873. Length of Longest Fibonacci Subsequence $\\star\\star$"},{"location":"python3/0801-0900/0871-0880/#874-walking-robot-simulation-star","text":"","title":"874. Walking Robot Simulation $\\star$"},{"location":"python3/0801-0900/0871-0880/#875-koko-eating-bananas-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def minEatingSpeed ( self , piles : List [ int ], H : int ) -> int : l = 1 r = max ( piles ) + 1 while l < r : m = ( l + r ) >> 1 hour = 0 for pile in piles : hour += ( pile - 1 ) // m + 1 if hour <= H : r = m else : l = m + 1 return l","title":"875. Koko Eating Bananas $\\star\\star$"},{"location":"python3/0801-0900/0871-0880/#876-middle-of-the-linked-list-star","text":"","title":"876. Middle of the Linked List $\\star$"},{"location":"python3/0801-0900/0871-0880/#877-stone-game-starstar","text":"","title":"877. Stone Game $\\star\\star$"},{"location":"python3/0801-0900/0871-0880/#878-nth-magical-number-starstarstar","text":"","title":"878. Nth Magical Number $\\star\\star\\star$"},{"location":"python3/0801-0900/0871-0880/#879-profitable-schemes-starstarstar","text":"","title":"879. Profitable Schemes $\\star\\star\\star$"},{"location":"python3/0801-0900/0871-0880/#880-decoded-string-at-index-starstar","text":"","title":"880. Decoded String at Index $\\star\\star$"},{"location":"python3/0801-0900/0881-0890/","text":"881. Boats to Save People $\\star\\star$ 882. Reachable Nodes In Subdivided Graph $\\star\\star\\star$ 883. Projection Area of 3D Shapes $\\star$ 884. Uncommon Words from Two Sentences $\\star$ 885. Spiral Matrix III $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def spiralMatrixIII ( self , R : int , C : int , r0 : int , c0 : int ) -> List [ List [ int ]]: ans = [[ r0 , c0 ]] x = 0 y = 1 i = 0 while len ( ans ) < R * C : for j in range ( i // 2 + 1 ): r0 += x c0 += y if 0 <= r0 < R and 0 <= c0 < C : ans . append ([ r0 , c0 ]) x , y = y , - x i += 1 return ans 886. Possible Bipartition $\\star\\star$ 887. Super Egg Drop $\\star\\star\\star$ 888. Fair Candy Swap $\\star$ 1 2 3 4 5 6 7 8 class Solution : def fairCandySwap ( self , A : List [ int ], B : List [ int ]) -> List [ int ]: diff = ( sum ( A ) - sum ( B )) // 2 B = set ( B ) for a in A : if a - diff in B : return [ a , a - diff ] 889. Construct Binary Tree from Preorder and Postorder Traversal $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def constructFromPrePost ( self , pre : List [ int ], post : List [ int ]) -> TreeNode : return self . helper ( 0 , 0 , len ( pre ), pre , post ) def helper ( self , i : int , j : int , n : int , pre : List [ int ], post : List [ int ]) -> TreeNode : if n == 0 : return None root = TreeNode ( pre [ i ]) if n == 1 : return root k = j while post [ k ] != pre [ i + 1 ]: k += 1 l = k - j + 1 root . left = self . helper ( i + 1 , j , l , pre , post ) root . right = self . helper ( i + l + 1 , j + l , n - l - 1 , pre , post ) return root 890. Find and Replace Pattern $\\star\\star$","title":"0881-0890"},{"location":"python3/0801-0900/0881-0890/#881-boats-to-save-people-starstar","text":"","title":"881. Boats to Save People $\\star\\star$"},{"location":"python3/0801-0900/0881-0890/#882-reachable-nodes-in-subdivided-graph-starstarstar","text":"","title":"882. Reachable Nodes In Subdivided Graph $\\star\\star\\star$"},{"location":"python3/0801-0900/0881-0890/#883-projection-area-of-3d-shapes-star","text":"","title":"883. Projection Area of 3D Shapes $\\star$"},{"location":"python3/0801-0900/0881-0890/#884-uncommon-words-from-two-sentences-star","text":"","title":"884. Uncommon Words from Two Sentences $\\star$"},{"location":"python3/0801-0900/0881-0890/#885-spiral-matrix-iii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def spiralMatrixIII ( self , R : int , C : int , r0 : int , c0 : int ) -> List [ List [ int ]]: ans = [[ r0 , c0 ]] x = 0 y = 1 i = 0 while len ( ans ) < R * C : for j in range ( i // 2 + 1 ): r0 += x c0 += y if 0 <= r0 < R and 0 <= c0 < C : ans . append ([ r0 , c0 ]) x , y = y , - x i += 1 return ans","title":"885. Spiral Matrix III $\\star\\star$"},{"location":"python3/0801-0900/0881-0890/#886-possible-bipartition-starstar","text":"","title":"886. Possible Bipartition $\\star\\star$"},{"location":"python3/0801-0900/0881-0890/#887-super-egg-drop-starstarstar","text":"","title":"887. Super Egg Drop $\\star\\star\\star$"},{"location":"python3/0801-0900/0881-0890/#888-fair-candy-swap-star","text":"1 2 3 4 5 6 7 8 class Solution : def fairCandySwap ( self , A : List [ int ], B : List [ int ]) -> List [ int ]: diff = ( sum ( A ) - sum ( B )) // 2 B = set ( B ) for a in A : if a - diff in B : return [ a , a - diff ]","title":"888. Fair Candy Swap $\\star$"},{"location":"python3/0801-0900/0881-0890/#889-construct-binary-tree-from-preorder-and-postorder-traversal-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def constructFromPrePost ( self , pre : List [ int ], post : List [ int ]) -> TreeNode : return self . helper ( 0 , 0 , len ( pre ), pre , post ) def helper ( self , i : int , j : int , n : int , pre : List [ int ], post : List [ int ]) -> TreeNode : if n == 0 : return None root = TreeNode ( pre [ i ]) if n == 1 : return root k = j while post [ k ] != pre [ i + 1 ]: k += 1 l = k - j + 1 root . left = self . helper ( i + 1 , j , l , pre , post ) root . right = self . helper ( i + l + 1 , j + l , n - l - 1 , pre , post ) return root","title":"889. Construct Binary Tree from Preorder and Postorder Traversal $\\star\\star$"},{"location":"python3/0801-0900/0881-0890/#890-find-and-replace-pattern-starstar","text":"","title":"890. Find and Replace Pattern $\\star\\star$"},{"location":"python3/0801-0900/0891-0900/","text":"891. Sum of Subsequence Widths $\\star\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def sumSubseqWidths ( self , A : List [ int ]) -> int : n = len ( A ) kMod = 10 ** 9 + 7 ans = 0 exp = 1 A . sort () for i in range ( n ): ans = ( ans + A [ i ] * exp - A [ n - i - 1 ] * exp ) % kMod exp = exp * 2 % kMod return ans 892. Surface Area of 3D Shapes $\\star$ 893. Groups of Special-Equivalent Strings $\\star$ 894. All Possible Full Binary Trees $\\star\\star$ 895. Maximum Frequency Stack $\\star\\star\\star$ 896. Monotonic Array $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution : def isMonotonic ( self , A : List [ int ]) -> bool : increasing = True decreasing = True for i in range ( 1 , len ( A )): increasing &= A [ i - 1 ] <= A [ i ] decreasing &= A [ i - 1 ] >= A [ i ] return increasing or decreasing 897. Increasing Order Search Tree $\\star$ 898. Bitwise ORs of Subarrays $\\star\\star$ 899. Orderly Queue $\\star\\star\\star$ 900. RLE Iterator $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class RLEIterator : def __init__ ( self , A : List [ int ]): self . A = A self . index = 0 def next ( self , n : int ) -> int : while self . index < len ( self . A ) and self . A [ self . index ] < n : n -= self . A [ self . index ] self . index += 2 if self . index == len ( self . A ): return - 1 self . A [ self . index ] -= n return self . A [ self . index + 1 ]","title":"0891-0900"},{"location":"python3/0801-0900/0891-0900/#891-sum-of-subsequence-widths-starstarstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def sumSubseqWidths ( self , A : List [ int ]) -> int : n = len ( A ) kMod = 10 ** 9 + 7 ans = 0 exp = 1 A . sort () for i in range ( n ): ans = ( ans + A [ i ] * exp - A [ n - i - 1 ] * exp ) % kMod exp = exp * 2 % kMod return ans","title":"891. Sum of Subsequence Widths $\\star\\star\\star$"},{"location":"python3/0801-0900/0891-0900/#892-surface-area-of-3d-shapes-star","text":"","title":"892. Surface Area of 3D Shapes $\\star$"},{"location":"python3/0801-0900/0891-0900/#893-groups-of-special-equivalent-strings-star","text":"","title":"893. Groups of Special-Equivalent Strings $\\star$"},{"location":"python3/0801-0900/0891-0900/#894-all-possible-full-binary-trees-starstar","text":"","title":"894. All Possible Full Binary Trees $\\star\\star$"},{"location":"python3/0801-0900/0891-0900/#895-maximum-frequency-stack-starstarstar","text":"","title":"895. Maximum Frequency Stack $\\star\\star\\star$"},{"location":"python3/0801-0900/0891-0900/#896-monotonic-array-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution : def isMonotonic ( self , A : List [ int ]) -> bool : increasing = True decreasing = True for i in range ( 1 , len ( A )): increasing &= A [ i - 1 ] <= A [ i ] decreasing &= A [ i - 1 ] >= A [ i ] return increasing or decreasing","title":"896. Monotonic Array $\\star$"},{"location":"python3/0801-0900/0891-0900/#897-increasing-order-search-tree-star","text":"","title":"897. Increasing Order Search Tree $\\star$"},{"location":"python3/0801-0900/0891-0900/#898-bitwise-ors-of-subarrays-starstar","text":"","title":"898. Bitwise ORs of Subarrays $\\star\\star$"},{"location":"python3/0801-0900/0891-0900/#899-orderly-queue-starstarstar","text":"","title":"899. Orderly Queue $\\star\\star\\star$"},{"location":"python3/0801-0900/0891-0900/#900-rle-iterator-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class RLEIterator : def __init__ ( self , A : List [ int ]): self . A = A self . index = 0 def next ( self , n : int ) -> int : while self . index < len ( self . A ) and self . A [ self . index ] < n : n -= self . A [ self . index ] self . index += 2 if self . index == len ( self . A ): return - 1 self . A [ self . index ] -= n return self . A [ self . index + 1 ]","title":"900. RLE Iterator $\\star\\star$"},{"location":"python3/0901-1000/0901-0910/","text":"901. Online Stock Span $\\star\\star$ 902. Numbers At Most N Given Digit Set $\\star\\star\\star$ 903. Valid Permutations for DI Sequence $\\star\\star\\star$ 904. Fruit Into Baskets $\\star\\star$ 905. Sort Array By Parity $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def sortArrayByParity ( self , A : List [ int ]) -> List [ int ]: l = 0 r = len ( A ) - 1 while l < r : if A [ l ] % 2 == 1 and A [ r ] % 2 == 0 : A [ l ], A [ r ] = A [ r ], A [ l ] if A [ l ] % 2 == 0 : l += 1 if A [ r ] % 2 == 1 : r -= 1 return A 906. Super Palindromes $\\star\\star\\star$ 907. Sum of Subarray Minimums $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def sumSubarrayMins ( self , A : List [ int ]) -> int : n = len ( A ) kMod = int ( 1e9 + 7 ) ans = 0 prev = [ - 1 ] * n next = [ n ] * n stack1 = [] stack2 = [] for i , a in enumerate ( A ): while stack1 and A [ stack1 [ - 1 ]] > a : stack1 . pop () prev [ i ] = stack1 [ - 1 ] if stack1 else - 1 stack1 . append ( i ) while stack2 and A [ stack2 [ - 1 ]] > a : index = stack2 . pop () next [ index ] = i stack2 . append ( i ) for i , a in enumerate ( A ): ans = ( ans + a * ( i - prev [ i ]) * ( next [ i ] - i )) % kMod return ans 908. Smallest Range I $\\star$ 909. Snakes and Ladders $\\star\\star$ 910. Smallest Range II $\\star\\star$","title":"0901-0910"},{"location":"python3/0901-1000/0901-0910/#901-online-stock-span-starstar","text":"","title":"901. Online Stock Span $\\star\\star$"},{"location":"python3/0901-1000/0901-0910/#902-numbers-at-most-n-given-digit-set-starstarstar","text":"","title":"902. Numbers At Most N Given Digit Set $\\star\\star\\star$"},{"location":"python3/0901-1000/0901-0910/#903-valid-permutations-for-di-sequence-starstarstar","text":"","title":"903. Valid Permutations for DI Sequence $\\star\\star\\star$"},{"location":"python3/0901-1000/0901-0910/#904-fruit-into-baskets-starstar","text":"","title":"904. Fruit Into Baskets $\\star\\star$"},{"location":"python3/0901-1000/0901-0910/#905-sort-array-by-parity-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def sortArrayByParity ( self , A : List [ int ]) -> List [ int ]: l = 0 r = len ( A ) - 1 while l < r : if A [ l ] % 2 == 1 and A [ r ] % 2 == 0 : A [ l ], A [ r ] = A [ r ], A [ l ] if A [ l ] % 2 == 0 : l += 1 if A [ r ] % 2 == 1 : r -= 1 return A","title":"905. Sort Array By Parity $\\star$"},{"location":"python3/0901-1000/0901-0910/#906-super-palindromes-starstarstar","text":"","title":"906. Super Palindromes $\\star\\star\\star$"},{"location":"python3/0901-1000/0901-0910/#907-sum-of-subarray-minimums-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Solution : def sumSubarrayMins ( self , A : List [ int ]) -> int : n = len ( A ) kMod = int ( 1e9 + 7 ) ans = 0 prev = [ - 1 ] * n next = [ n ] * n stack1 = [] stack2 = [] for i , a in enumerate ( A ): while stack1 and A [ stack1 [ - 1 ]] > a : stack1 . pop () prev [ i ] = stack1 [ - 1 ] if stack1 else - 1 stack1 . append ( i ) while stack2 and A [ stack2 [ - 1 ]] > a : index = stack2 . pop () next [ index ] = i stack2 . append ( i ) for i , a in enumerate ( A ): ans = ( ans + a * ( i - prev [ i ]) * ( next [ i ] - i )) % kMod return ans","title":"907. Sum of Subarray Minimums $\\star\\star$"},{"location":"python3/0901-1000/0901-0910/#908-smallest-range-i-star","text":"","title":"908. Smallest Range I $\\star$"},{"location":"python3/0901-1000/0901-0910/#909-snakes-and-ladders-starstar","text":"","title":"909. Snakes and Ladders $\\star\\star$"},{"location":"python3/0901-1000/0901-0910/#910-smallest-range-ii-starstar","text":"","title":"910. Smallest Range II $\\star\\star$"},{"location":"python3/0901-1000/0911-0920/","text":"911. Online Election $\\star\\star$ 912. Sort an Array $\\star\\star$ 913. Cat and Mouse $\\star\\star\\star$ 914. X of a Kind in a Deck of Cards $\\star$ 1 2 3 4 5 6 7 8 9 10 11 from functools import reduce class Solution : def hasGroupsSizeX ( self , deck : List [ int ]) -> bool : def gcd ( a , b ): return gcd ( b , a % b ) if b > 0 else a numCounts = collections . Counter ( deck ) return reduce ( gcd , numCounts . values ()) >= 2 915. Partition Array into Disjoint Intervals $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def partitionDisjoint ( self , A : List [ int ]) -> int : n = len ( A ) min_ = [ 0 ] * ( n - 1 ) + [ A [ - 1 ]] max_ = float ( '-inf' ) for i in range ( n - 2 , - 1 , - 1 ): min_ [ i ] = min ( min_ [ i + 1 ], A [ i ]) for i , a in enumerate ( A ): max_ = max ( max_ , a ) if max_ <= min_ [ i + 1 ]: return i + 1 916. Word Subsets $\\star\\star$ 917. Reverse Only Letters $\\star$ 918. Maximum Sum Circular Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def maxSubarraySumCircular ( self , A : List [ int ]) -> int : totalSum = 0 currMaxSum = 0 currMinSum = 0 maxSum = float ( '-inf' ) minSum = float ( 'inf' ) for a in A : totalSum += a currMaxSum = max ( currMaxSum + a , a ) currMinSum = min ( currMinSum + a , a ) maxSum = max ( maxSum , currMaxSum ) minSum = min ( minSum , currMinSum ) return maxSum if maxSum < 0 else max ( maxSum , totalSum - minSum ) 919. Complete Binary Tree Inserter $\\star\\star$ 920. Number of Music Playlists $\\star\\star\\star$","title":"0911-0920"},{"location":"python3/0901-1000/0911-0920/#911-online-election-starstar","text":"","title":"911. Online Election $\\star\\star$"},{"location":"python3/0901-1000/0911-0920/#912-sort-an-array-starstar","text":"","title":"912. Sort an Array $\\star\\star$"},{"location":"python3/0901-1000/0911-0920/#913-cat-and-mouse-starstarstar","text":"","title":"913. Cat and Mouse $\\star\\star\\star$"},{"location":"python3/0901-1000/0911-0920/#914-x-of-a-kind-in-a-deck-of-cards-star","text":"1 2 3 4 5 6 7 8 9 10 11 from functools import reduce class Solution : def hasGroupsSizeX ( self , deck : List [ int ]) -> bool : def gcd ( a , b ): return gcd ( b , a % b ) if b > 0 else a numCounts = collections . Counter ( deck ) return reduce ( gcd , numCounts . values ()) >= 2","title":"914. X of a Kind in a Deck of Cards $\\star$"},{"location":"python3/0901-1000/0911-0920/#915-partition-array-into-disjoint-intervals-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def partitionDisjoint ( self , A : List [ int ]) -> int : n = len ( A ) min_ = [ 0 ] * ( n - 1 ) + [ A [ - 1 ]] max_ = float ( '-inf' ) for i in range ( n - 2 , - 1 , - 1 ): min_ [ i ] = min ( min_ [ i + 1 ], A [ i ]) for i , a in enumerate ( A ): max_ = max ( max_ , a ) if max_ <= min_ [ i + 1 ]: return i + 1","title":"915. Partition Array into Disjoint Intervals $\\star\\star$"},{"location":"python3/0901-1000/0911-0920/#916-word-subsets-starstar","text":"","title":"916. Word Subsets $\\star\\star$"},{"location":"python3/0901-1000/0911-0920/#917-reverse-only-letters-star","text":"","title":"917. Reverse Only Letters $\\star$"},{"location":"python3/0901-1000/0911-0920/#918-maximum-sum-circular-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Solution : def maxSubarraySumCircular ( self , A : List [ int ]) -> int : totalSum = 0 currMaxSum = 0 currMinSum = 0 maxSum = float ( '-inf' ) minSum = float ( 'inf' ) for a in A : totalSum += a currMaxSum = max ( currMaxSum + a , a ) currMinSum = min ( currMinSum + a , a ) maxSum = max ( maxSum , currMaxSum ) minSum = min ( minSum , currMinSum ) return maxSum if maxSum < 0 else max ( maxSum , totalSum - minSum )","title":"918. Maximum Sum Circular Subarray $\\star\\star$"},{"location":"python3/0901-1000/0911-0920/#919-complete-binary-tree-inserter-starstar","text":"","title":"919. Complete Binary Tree Inserter $\\star\\star$"},{"location":"python3/0901-1000/0911-0920/#920-number-of-music-playlists-starstarstar","text":"","title":"920. Number of Music Playlists $\\star\\star\\star$"},{"location":"python3/0901-1000/0921-0930/","text":"921. Minimum Add to Make Parentheses Valid $\\star\\star$ 922. Sort Array By Parity II $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def sortArrayByParityII ( self , A : List [ int ]) -> List [ int ]: n = len ( A ) i = 0 j = 1 while i < n : while i < n and A [ i ] % 2 == 0 : i += 2 while j < n and A [ j ] % 2 == 1 : j += 2 if i < n : A [ i ], A [ j ] = A [ j ], A [ i ] i += 2 j += 2 return A 923. 3Sum With Multiplicity $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def threeSumMulti ( self , A : List [ int ], target : int ) -> int : ans = 0 dict = collections . Counter ( A ) for i , x in dict . items (): for j , y in dict . items (): k = target - i - j if k not in dict : continue if i == j and j == k : ans += x * ( x - 1 ) * ( x - 2 ) // 6 elif i == j and j != k : ans += x * ( x - 1 ) // 2 * dict [ k ] elif i < j and j < k : ans += x * y * dict [ k ] return ans % int ( 1e9 + 7 ) 924. Minimize Malware Spread $\\star\\star\\star$ 925. Long Pressed Name $\\star$ 926. Flip String to Monotone Increasing $\\star\\star$ 1 2 3 4 5 6 7 8 class Solution : def minFlipsMonoIncr ( self , S : str ) -> int : dp = [ 0 ] * 2 for i , c in enumerate ( S ): dp [ 0 ], dp [ 1 ] = dp [ 0 ] + ( c == '1' ), min ( dp [ 0 ], dp [ 1 ]) + ( c == '0' ) return min ( dp [ 0 ], dp [ 1 ]) 927. Three Equal Parts $\\star\\star\\star$ 928. Minimize Malware Spread II $\\star\\star\\star$ 929. Unique Email Addresses $\\star$ 930. Binary Subarrays With Sum $\\star\\star$","title":"0921-0930"},{"location":"python3/0901-1000/0921-0930/#921-minimum-add-to-make-parentheses-valid-starstar","text":"","title":"921. Minimum Add to Make Parentheses Valid $\\star\\star$"},{"location":"python3/0901-1000/0921-0930/#922-sort-array-by-parity-ii-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def sortArrayByParityII ( self , A : List [ int ]) -> List [ int ]: n = len ( A ) i = 0 j = 1 while i < n : while i < n and A [ i ] % 2 == 0 : i += 2 while j < n and A [ j ] % 2 == 1 : j += 2 if i < n : A [ i ], A [ j ] = A [ j ], A [ i ] i += 2 j += 2 return A","title":"922. Sort Array By Parity II $\\star$"},{"location":"python3/0901-1000/0921-0930/#923-3sum-with-multiplicity-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def threeSumMulti ( self , A : List [ int ], target : int ) -> int : ans = 0 dict = collections . Counter ( A ) for i , x in dict . items (): for j , y in dict . items (): k = target - i - j if k not in dict : continue if i == j and j == k : ans += x * ( x - 1 ) * ( x - 2 ) // 6 elif i == j and j != k : ans += x * ( x - 1 ) // 2 * dict [ k ] elif i < j and j < k : ans += x * y * dict [ k ] return ans % int ( 1e9 + 7 )","title":"923. 3Sum With Multiplicity $\\star\\star$"},{"location":"python3/0901-1000/0921-0930/#924-minimize-malware-spread-starstarstar","text":"","title":"924. Minimize Malware Spread $\\star\\star\\star$"},{"location":"python3/0901-1000/0921-0930/#925-long-pressed-name-star","text":"","title":"925. Long Pressed Name $\\star$"},{"location":"python3/0901-1000/0921-0930/#926-flip-string-to-monotone-increasing-starstar","text":"1 2 3 4 5 6 7 8 class Solution : def minFlipsMonoIncr ( self , S : str ) -> int : dp = [ 0 ] * 2 for i , c in enumerate ( S ): dp [ 0 ], dp [ 1 ] = dp [ 0 ] + ( c == '1' ), min ( dp [ 0 ], dp [ 1 ]) + ( c == '0' ) return min ( dp [ 0 ], dp [ 1 ])","title":"926. Flip String to Monotone Increasing $\\star\\star$"},{"location":"python3/0901-1000/0921-0930/#927-three-equal-parts-starstarstar","text":"","title":"927. Three Equal Parts $\\star\\star\\star$"},{"location":"python3/0901-1000/0921-0930/#928-minimize-malware-spread-ii-starstarstar","text":"","title":"928. Minimize Malware Spread II $\\star\\star\\star$"},{"location":"python3/0901-1000/0921-0930/#929-unique-email-addresses-star","text":"","title":"929. Unique Email Addresses $\\star$"},{"location":"python3/0901-1000/0921-0930/#930-binary-subarrays-with-sum-starstar","text":"","title":"930. Binary Subarrays With Sum $\\star\\star$"},{"location":"python3/0901-1000/0931-0940/","text":"931. Minimum Falling Path Sum $\\star\\star$ 932. Beautiful Array $\\star\\star$ 933. Number of Recent Calls $\\star$ 934. Shortest Bridge $\\star\\star$ 935. Knight Dialer $\\star\\star$ 936. Stamping The Sequence $\\star\\star\\star$ 937. Reorder Data in Log Files $\\star$ 938. Range Sum of BST $\\star$ 939. Minimum Area Rectangle $\\star\\star$ 940. Distinct Subsequences II $\\star\\star\\star$ 1 2 3 4 5 6 7 8 class Solution : def distinctSubseqII ( self , S : str ) -> int : dict = [ 0 ] * 26 for c in S : dict [ ord ( c ) - ord ( 'a' )] = ( sum ( dict ) + 1 ) % int ( 1e9 + 7 ) return sum ( dict ) % int ( 1e9 + 7 )","title":"0931-0940"},{"location":"python3/0901-1000/0931-0940/#931-minimum-falling-path-sum-starstar","text":"","title":"931. Minimum Falling Path Sum $\\star\\star$"},{"location":"python3/0901-1000/0931-0940/#932-beautiful-array-starstar","text":"","title":"932. Beautiful Array $\\star\\star$"},{"location":"python3/0901-1000/0931-0940/#933-number-of-recent-calls-star","text":"","title":"933. Number of Recent Calls $\\star$"},{"location":"python3/0901-1000/0931-0940/#934-shortest-bridge-starstar","text":"","title":"934. Shortest Bridge $\\star\\star$"},{"location":"python3/0901-1000/0931-0940/#935-knight-dialer-starstar","text":"","title":"935. Knight Dialer $\\star\\star$"},{"location":"python3/0901-1000/0931-0940/#936-stamping-the-sequence-starstarstar","text":"","title":"936. Stamping The Sequence $\\star\\star\\star$"},{"location":"python3/0901-1000/0931-0940/#937-reorder-data-in-log-files-star","text":"","title":"937. Reorder Data in Log Files $\\star$"},{"location":"python3/0901-1000/0931-0940/#938-range-sum-of-bst-star","text":"","title":"938. Range Sum of BST $\\star$"},{"location":"python3/0901-1000/0931-0940/#939-minimum-area-rectangle-starstar","text":"","title":"939. Minimum Area Rectangle $\\star\\star$"},{"location":"python3/0901-1000/0931-0940/#940-distinct-subsequences-ii-starstarstar","text":"1 2 3 4 5 6 7 8 class Solution : def distinctSubseqII ( self , S : str ) -> int : dict = [ 0 ] * 26 for c in S : dict [ ord ( c ) - ord ( 'a' )] = ( sum ( dict ) + 1 ) % int ( 1e9 + 7 ) return sum ( dict ) % int ( 1e9 + 7 )","title":"940. Distinct Subsequences II $\\star\\star\\star$"},{"location":"python3/0901-1000/0941-0950/","text":"941. Valid Mountain Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def validMountainArray ( self , A : List [ int ]) -> bool : if len ( A ) < 3 : return False l = 0 r = len ( A ) - 1 while l + 1 < len ( A ) and A [ l ] < A [ l + 1 ]: l += 1 while r > 0 and A [ r ] < A [ r - 1 ]: r -= 1 return l > 0 and r < len ( A ) - 1 and l == r 942. DI String Match $\\star$ 943. Find the Shortest Superstring $\\star\\star\\star$ 944. Delete Columns to Make Sorted $\\star$ 945. Minimum Increment to Make Array Unique $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def minIncrementForUnique ( self , A : List [ int ]) -> int : ans = 0 minAvailable = 0 A . sort () for a in A : ans += max ( minAvailable - a , 0 ) minAvailable = max ( minAvailable , a ) + 1 return ans 946. Validate Stack Sequences $\\star\\star$ 947. Most Stones Removed with Same Row or Column $\\star\\star$ 948. Bag of Tokens $\\star\\star$ 949. Largest Time for Given Digits $\\star$ 950. Reveal Cards In Increasing Order $\\star\\star$ 1 2 3 4 5 6 7 8 9 class Solution : def deckRevealedIncreasing ( self , deck : List [ int ]) -> List [ int ]: deque = collections . deque () for card in sorted ( deck )[:: - 1 ]: deque . rotate () deque . appendleft ( card ) return list ( deque )","title":"0941-0950"},{"location":"python3/0901-1000/0941-0950/#941-valid-mountain-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def validMountainArray ( self , A : List [ int ]) -> bool : if len ( A ) < 3 : return False l = 0 r = len ( A ) - 1 while l + 1 < len ( A ) and A [ l ] < A [ l + 1 ]: l += 1 while r > 0 and A [ r ] < A [ r - 1 ]: r -= 1 return l > 0 and r < len ( A ) - 1 and l == r","title":"941. Valid Mountain Array $\\star$"},{"location":"python3/0901-1000/0941-0950/#942-di-string-match-star","text":"","title":"942. DI String Match $\\star$"},{"location":"python3/0901-1000/0941-0950/#943-find-the-shortest-superstring-starstarstar","text":"","title":"943. Find the Shortest Superstring $\\star\\star\\star$"},{"location":"python3/0901-1000/0941-0950/#944-delete-columns-to-make-sorted-star","text":"","title":"944. Delete Columns to Make Sorted $\\star$"},{"location":"python3/0901-1000/0941-0950/#945-minimum-increment-to-make-array-unique-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def minIncrementForUnique ( self , A : List [ int ]) -> int : ans = 0 minAvailable = 0 A . sort () for a in A : ans += max ( minAvailable - a , 0 ) minAvailable = max ( minAvailable , a ) + 1 return ans","title":"945. Minimum Increment to Make Array Unique $\\star\\star$"},{"location":"python3/0901-1000/0941-0950/#946-validate-stack-sequences-starstar","text":"","title":"946. Validate Stack Sequences $\\star\\star$"},{"location":"python3/0901-1000/0941-0950/#947-most-stones-removed-with-same-row-or-column-starstar","text":"","title":"947. Most Stones Removed with Same Row or Column $\\star\\star$"},{"location":"python3/0901-1000/0941-0950/#948-bag-of-tokens-starstar","text":"","title":"948. Bag of Tokens $\\star\\star$"},{"location":"python3/0901-1000/0941-0950/#949-largest-time-for-given-digits-star","text":"","title":"949. Largest Time for Given Digits $\\star$"},{"location":"python3/0901-1000/0941-0950/#950-reveal-cards-in-increasing-order-starstar","text":"1 2 3 4 5 6 7 8 9 class Solution : def deckRevealedIncreasing ( self , deck : List [ int ]) -> List [ int ]: deque = collections . deque () for card in sorted ( deck )[:: - 1 ]: deque . rotate () deque . appendleft ( card ) return list ( deque )","title":"950. Reveal Cards In Increasing Order $\\star\\star$"},{"location":"python3/0901-1000/0951-0960/","text":"951. Flip Equivalent Binary Trees $\\star\\star$ 952. Largest Component Size by Common Factor $\\star\\star\\star$ 953. Verifying an Alien Dictionary $\\star$ 954. Array of Doubled Pairs $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution : def canReorderDoubled ( self , A : List [ int ]) -> bool : dict = collections . Counter ( A ) for key in sorted ( dict , key = abs ): if dict [ key ] > dict [ 2 * key ]: return False dict [ 2 * key ] -= dict [ key ] return True 955. Delete Columns to Make Sorted II $\\star\\star$ 956. Tallest Billboard $\\star\\star\\star$ 957. Prison Cells After N Days $\\star\\star$ 958. Check Completeness of a Binary Tree $\\star\\star$ 959. Regions Cut By Slashes $\\star\\star$ 960. Delete Columns to Make Sorted III $\\star\\star\\star$","title":"0951-0960"},{"location":"python3/0901-1000/0951-0960/#951-flip-equivalent-binary-trees-starstar","text":"","title":"951. Flip Equivalent Binary Trees $\\star\\star$"},{"location":"python3/0901-1000/0951-0960/#952-largest-component-size-by-common-factor-starstarstar","text":"","title":"952. Largest Component Size by Common Factor $\\star\\star\\star$"},{"location":"python3/0901-1000/0951-0960/#953-verifying-an-alien-dictionary-star","text":"","title":"953. Verifying an Alien Dictionary $\\star$"},{"location":"python3/0901-1000/0951-0960/#954-array-of-doubled-pairs-starstar","text":"1 2 3 4 5 6 7 8 9 10 class Solution : def canReorderDoubled ( self , A : List [ int ]) -> bool : dict = collections . Counter ( A ) for key in sorted ( dict , key = abs ): if dict [ key ] > dict [ 2 * key ]: return False dict [ 2 * key ] -= dict [ key ] return True","title":"954. Array of Doubled Pairs $\\star\\star$"},{"location":"python3/0901-1000/0951-0960/#955-delete-columns-to-make-sorted-ii-starstar","text":"","title":"955. Delete Columns to Make Sorted II $\\star\\star$"},{"location":"python3/0901-1000/0951-0960/#956-tallest-billboard-starstarstar","text":"","title":"956. Tallest Billboard $\\star\\star\\star$"},{"location":"python3/0901-1000/0951-0960/#957-prison-cells-after-n-days-starstar","text":"","title":"957. Prison Cells After N Days $\\star\\star$"},{"location":"python3/0901-1000/0951-0960/#958-check-completeness-of-a-binary-tree-starstar","text":"","title":"958. Check Completeness of a Binary Tree $\\star\\star$"},{"location":"python3/0901-1000/0951-0960/#959-regions-cut-by-slashes-starstar","text":"","title":"959. Regions Cut By Slashes $\\star\\star$"},{"location":"python3/0901-1000/0951-0960/#960-delete-columns-to-make-sorted-iii-starstarstar","text":"","title":"960. Delete Columns to Make Sorted III $\\star\\star\\star$"},{"location":"python3/0901-1000/0961-0970/","text":"961. N-Repeated Element in Size 2N Array $\\star$ 962. Maximum Width Ramp $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def maxWidthRamp ( self , A : List [ int ]) -> int : ans = 0 stack = [] for i , a in enumerate ( A ): if stack == [] or a <= A [ stack [ - 1 ]]: stack . append ( i ) for i in range ( len ( A ))[:: - 1 ]: while stack and A [ i ] >= A [ stack [ - 1 ]]: ans = max ( ans , i - stack . pop ()) return ans 963. Minimum Area Rectangle II $\\star\\star$ 964. Least Operators to Express Number $\\star\\star\\star$ 965. Univalued Binary Tree $\\star$ 966. Vowel Spellchecker $\\star\\star$ 967. Numbers With Same Consecutive Differences $\\star\\star$ 968. Binary Tree Cameras $\\star\\star\\star$ 969. Pancake Sorting $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def pancakeSort ( self , A : List [ int ]) -> List [ int ]: ans = [] for target in range ( len ( A ), 0 , - 1 ): index = A . index ( target ) A [: index + 1 ] = A [: index + 1 ][:: - 1 ] A [: target ] = A [: target ][:: - 1 ] ans . append ( index + 1 ) ans . append ( target ) return ans 970. Powerful Integers $\\star$","title":"0961-0970"},{"location":"python3/0901-1000/0961-0970/#961-n-repeated-element-in-size-2n-array-star","text":"","title":"961. N-Repeated Element in Size 2N Array $\\star$"},{"location":"python3/0901-1000/0961-0970/#962-maximum-width-ramp-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def maxWidthRamp ( self , A : List [ int ]) -> int : ans = 0 stack = [] for i , a in enumerate ( A ): if stack == [] or a <= A [ stack [ - 1 ]]: stack . append ( i ) for i in range ( len ( A ))[:: - 1 ]: while stack and A [ i ] >= A [ stack [ - 1 ]]: ans = max ( ans , i - stack . pop ()) return ans","title":"962. Maximum Width Ramp $\\star\\star$"},{"location":"python3/0901-1000/0961-0970/#963-minimum-area-rectangle-ii-starstar","text":"","title":"963. Minimum Area Rectangle II $\\star\\star$"},{"location":"python3/0901-1000/0961-0970/#964-least-operators-to-express-number-starstarstar","text":"","title":"964. Least Operators to Express Number $\\star\\star\\star$"},{"location":"python3/0901-1000/0961-0970/#965-univalued-binary-tree-star","text":"","title":"965. Univalued Binary Tree $\\star$"},{"location":"python3/0901-1000/0961-0970/#966-vowel-spellchecker-starstar","text":"","title":"966. Vowel Spellchecker $\\star\\star$"},{"location":"python3/0901-1000/0961-0970/#967-numbers-with-same-consecutive-differences-starstar","text":"","title":"967. Numbers With Same Consecutive Differences $\\star\\star$"},{"location":"python3/0901-1000/0961-0970/#968-binary-tree-cameras-starstarstar","text":"","title":"968. Binary Tree Cameras $\\star\\star\\star$"},{"location":"python3/0901-1000/0961-0970/#969-pancake-sorting-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def pancakeSort ( self , A : List [ int ]) -> List [ int ]: ans = [] for target in range ( len ( A ), 0 , - 1 ): index = A . index ( target ) A [: index + 1 ] = A [: index + 1 ][:: - 1 ] A [: target ] = A [: target ][:: - 1 ] ans . append ( index + 1 ) ans . append ( target ) return ans","title":"969. Pancake Sorting $\\star\\star$"},{"location":"python3/0901-1000/0961-0970/#970-powerful-integers-star","text":"","title":"970. Powerful Integers $\\star$"},{"location":"python3/0901-1000/0971-0980/","text":"971. Flip Binary Tree To Match Preorder Traversal $\\star\\star$ 972. Equal Rational Numbers $\\star\\star\\star$ 973. K Closest Points to Origin $\\star\\star$ 974. Subarray Sums Divisible by K $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def subarraysDivByK ( self , A : List [ int ], K : int ) -> int : ans = 0 presum = 0 count = [ 1 ] + [ 0 ] * ( K - 1 ) for a in A : presum = ( presum + a ) % K ans += count [ presum ] count [ presum ] += 1 return ans 975. Odd Even Jump $\\star\\star\\star$ 976. Largest Perimeter Triangle $\\star$ 977. Squares of a Sorted Array $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def sortedSquares ( self , A : List [ int ]) -> List [ int ]: n = len ( A ) l = 0 r = n - 1 ans = [ 0 ] * n while n : n -= 1 if abs ( A [ l ]) > abs ( A [ r ]): ans [ n ] = A [ l ] * A [ l ] l += 1 else : ans [ n ] = A [ r ] * A [ r ] r -= 1 return ans 978. Longest Turbulent Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def maxTurbulenceSize ( self , A : List [ int ]) -> int : ans = 1 increasing = 1 decreasing = 1 for i in range ( 1 , len ( A )): if A [ i ] > A [ i - 1 ]: increasing = decreasing + 1 decreasing = 1 elif A [ i ] < A [ i - 1 ]: decreasing = increasing + 1 increasing = 1 else : increasing = 1 decreasing = 1 ans = max ( ans , max ( increasing , decreasing )) return ans 979. Distribute Coins in Binary Tree $\\star\\star$ 980. Unique Paths III $\\star\\star\\star$","title":"0971-0980"},{"location":"python3/0901-1000/0971-0980/#971-flip-binary-tree-to-match-preorder-traversal-starstar","text":"","title":"971. Flip Binary Tree To Match Preorder Traversal $\\star\\star$"},{"location":"python3/0901-1000/0971-0980/#972-equal-rational-numbers-starstarstar","text":"","title":"972. Equal Rational Numbers $\\star\\star\\star$"},{"location":"python3/0901-1000/0971-0980/#973-k-closest-points-to-origin-starstar","text":"","title":"973. K Closest Points to Origin $\\star\\star$"},{"location":"python3/0901-1000/0971-0980/#974-subarray-sums-divisible-by-k-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def subarraysDivByK ( self , A : List [ int ], K : int ) -> int : ans = 0 presum = 0 count = [ 1 ] + [ 0 ] * ( K - 1 ) for a in A : presum = ( presum + a ) % K ans += count [ presum ] count [ presum ] += 1 return ans","title":"974. Subarray Sums Divisible by K $\\star\\star$"},{"location":"python3/0901-1000/0971-0980/#975-odd-even-jump-starstarstar","text":"","title":"975. Odd Even Jump $\\star\\star\\star$"},{"location":"python3/0901-1000/0971-0980/#976-largest-perimeter-triangle-star","text":"","title":"976. Largest Perimeter Triangle $\\star$"},{"location":"python3/0901-1000/0971-0980/#977-squares-of-a-sorted-array-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def sortedSquares ( self , A : List [ int ]) -> List [ int ]: n = len ( A ) l = 0 r = n - 1 ans = [ 0 ] * n while n : n -= 1 if abs ( A [ l ]) > abs ( A [ r ]): ans [ n ] = A [ l ] * A [ l ] l += 1 else : ans [ n ] = A [ r ] * A [ r ] r -= 1 return ans","title":"977. Squares of a Sorted Array $\\star$"},{"location":"python3/0901-1000/0971-0980/#978-longest-turbulent-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Solution : def maxTurbulenceSize ( self , A : List [ int ]) -> int : ans = 1 increasing = 1 decreasing = 1 for i in range ( 1 , len ( A )): if A [ i ] > A [ i - 1 ]: increasing = decreasing + 1 decreasing = 1 elif A [ i ] < A [ i - 1 ]: decreasing = increasing + 1 increasing = 1 else : increasing = 1 decreasing = 1 ans = max ( ans , max ( increasing , decreasing )) return ans","title":"978. Longest Turbulent Subarray $\\star\\star$"},{"location":"python3/0901-1000/0971-0980/#979-distribute-coins-in-binary-tree-starstar","text":"","title":"979. Distribute Coins in Binary Tree $\\star\\star$"},{"location":"python3/0901-1000/0971-0980/#980-unique-paths-iii-starstarstar","text":"","title":"980. Unique Paths III $\\star\\star\\star$"},{"location":"python3/0901-1000/0981-0990/","text":"981. Time Based Key-Value Store $\\star\\star$ 982. Triples with Bitwise AND Equal To Zero $\\star\\star\\star$ 983. Minimum Cost For Tickets $\\star\\star$ 984. String Without AAA or BBB $\\star\\star$ 985. Sum of Even Numbers After Queries $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def sumEvenAfterQueries ( self , A : List [ int ], queries : List [ List [ int ]]) -> List [ int ]: ans = [] sum_ = sum ( a for a in A if a % 2 == 0 ) for query in queries : if A [ query [ 1 ]] % 2 == 0 : sum_ -= A [ query [ 1 ]] A [ query [ 1 ]] += query [ 0 ] if A [ query [ 1 ]] % 2 == 0 : sum_ += A [ query [ 1 ]] ans . append ( sum_ ) return ans 986. Interval List Intersections $\\star\\star$ 987. Vertical Order Traversal of a Binary Tree $\\star\\star$ 988. Smallest String Starting From Leaf $\\star\\star$ 989. Add to Array-Form of Integer $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution : def addToArrayForm ( self , A : List [ int ], K : int ) -> List [ int ]: for i in range ( len ( A ))[:: - 1 ]: K , A [ i ] = divmod ( A [ i ] + K , 10 ) while K > 0 : A = [ K % 10 ] + A K //= 10 return A 990. Satisfiability of Equality Equations $\\star\\star$","title":"0981-0990"},{"location":"python3/0901-1000/0981-0990/#981-time-based-key-value-store-starstar","text":"","title":"981. Time Based Key-Value Store $\\star\\star$"},{"location":"python3/0901-1000/0981-0990/#982-triples-with-bitwise-and-equal-to-zero-starstarstar","text":"","title":"982. Triples with Bitwise AND Equal To Zero $\\star\\star\\star$"},{"location":"python3/0901-1000/0981-0990/#983-minimum-cost-for-tickets-starstar","text":"","title":"983. Minimum Cost For Tickets $\\star\\star$"},{"location":"python3/0901-1000/0981-0990/#984-string-without-aaa-or-bbb-starstar","text":"","title":"984. String Without AAA or BBB $\\star\\star$"},{"location":"python3/0901-1000/0981-0990/#985-sum-of-even-numbers-after-queries-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Solution : def sumEvenAfterQueries ( self , A : List [ int ], queries : List [ List [ int ]]) -> List [ int ]: ans = [] sum_ = sum ( a for a in A if a % 2 == 0 ) for query in queries : if A [ query [ 1 ]] % 2 == 0 : sum_ -= A [ query [ 1 ]] A [ query [ 1 ]] += query [ 0 ] if A [ query [ 1 ]] % 2 == 0 : sum_ += A [ query [ 1 ]] ans . append ( sum_ ) return ans","title":"985. Sum of Even Numbers After Queries $\\star$"},{"location":"python3/0901-1000/0981-0990/#986-interval-list-intersections-starstar","text":"","title":"986. Interval List Intersections $\\star\\star$"},{"location":"python3/0901-1000/0981-0990/#987-vertical-order-traversal-of-a-binary-tree-starstar","text":"","title":"987. Vertical Order Traversal of a Binary Tree $\\star\\star$"},{"location":"python3/0901-1000/0981-0990/#988-smallest-string-starting-from-leaf-starstar","text":"","title":"988. Smallest String Starting From Leaf $\\star\\star$"},{"location":"python3/0901-1000/0981-0990/#989-add-to-array-form-of-integer-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution : def addToArrayForm ( self , A : List [ int ], K : int ) -> List [ int ]: for i in range ( len ( A ))[:: - 1 ]: K , A [ i ] = divmod ( A [ i ] + K , 10 ) while K > 0 : A = [ K % 10 ] + A K //= 10 return A","title":"989. Add to Array-Form of Integer $\\star$"},{"location":"python3/0901-1000/0981-0990/#990-satisfiability-of-equality-equations-starstar","text":"","title":"990. Satisfiability of Equality Equations $\\star\\star$"},{"location":"python3/0901-1000/0991-1000/","text":"991. Broken Calculator $\\star\\star$ 992. Subarrays with K Different Integers $\\star\\star\\star$ 993. Cousins in Binary Tree $\\star$ 994. Rotting Oranges $\\star$ 995. Minimum Number of K Consecutive Bit Flips $\\star\\star\\star$ 996. Number of Squareful Arrays $\\star\\star\\star$ 997. Find the Town Judge $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def findJudge ( self , N : int , trust : List [ List [ int ]]) -> int : count = [ 0 ] * N for t in trust : count [ t [ 0 ] - 1 ] -= 1 count [ t [ 1 ] - 1 ] += 1 for i in range ( len ( count )): if count [ i ] == N - 1 : return i + 1 return - 1 998. Maximum Binary Tree II $\\star\\star$ 999. Available Captures for Rook $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def numRookCaptures ( self , board : List [ List [ str ]]) -> int : ans = 0 for i in range ( 8 ): for j in range ( 8 ): if board [ i ][ j ] == 'R' : i0 = i j0 = j for d in [[ 1 , 0 ], [ 0 , 1 ], [ - 1 , 0 ], [ 0 , - 1 ]]: i = i0 + d [ 0 ] j = j0 + d [ 1 ] while 0 <= i < 8 and 0 <= j < 8 : if board [ i ][ j ] == 'p' : ans += 1 if board [ i ][ j ] != '.' : break i += d [ 0 ] j += d [ 1 ] return ans 1000. Minimum Cost to Merge Stones $\\star\\star\\star$","title":"0991-1000"},{"location":"python3/0901-1000/0991-1000/#991-broken-calculator-starstar","text":"","title":"991. Broken Calculator $\\star\\star$"},{"location":"python3/0901-1000/0991-1000/#992-subarrays-with-k-different-integers-starstarstar","text":"","title":"992. Subarrays with K Different Integers $\\star\\star\\star$"},{"location":"python3/0901-1000/0991-1000/#993-cousins-in-binary-tree-star","text":"","title":"993. Cousins in Binary Tree $\\star$"},{"location":"python3/0901-1000/0991-1000/#994-rotting-oranges-star","text":"","title":"994. Rotting Oranges $\\star$"},{"location":"python3/0901-1000/0991-1000/#995-minimum-number-of-k-consecutive-bit-flips-starstarstar","text":"","title":"995. Minimum Number of K Consecutive Bit Flips $\\star\\star\\star$"},{"location":"python3/0901-1000/0991-1000/#996-number-of-squareful-arrays-starstarstar","text":"","title":"996. Number of Squareful Arrays $\\star\\star\\star$"},{"location":"python3/0901-1000/0991-1000/#997-find-the-town-judge-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def findJudge ( self , N : int , trust : List [ List [ int ]]) -> int : count = [ 0 ] * N for t in trust : count [ t [ 0 ] - 1 ] -= 1 count [ t [ 1 ] - 1 ] += 1 for i in range ( len ( count )): if count [ i ] == N - 1 : return i + 1 return - 1","title":"997. Find the Town Judge $\\star$"},{"location":"python3/0901-1000/0991-1000/#998-maximum-binary-tree-ii-starstar","text":"","title":"998. Maximum Binary Tree II $\\star\\star$"},{"location":"python3/0901-1000/0991-1000/#999-available-captures-for-rook-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Solution : def numRookCaptures ( self , board : List [ List [ str ]]) -> int : ans = 0 for i in range ( 8 ): for j in range ( 8 ): if board [ i ][ j ] == 'R' : i0 = i j0 = j for d in [[ 1 , 0 ], [ 0 , 1 ], [ - 1 , 0 ], [ 0 , - 1 ]]: i = i0 + d [ 0 ] j = j0 + d [ 1 ] while 0 <= i < 8 and 0 <= j < 8 : if board [ i ][ j ] == 'p' : ans += 1 if board [ i ][ j ] != '.' : break i += d [ 0 ] j += d [ 1 ] return ans","title":"999. Available Captures for Rook $\\star$"},{"location":"python3/0901-1000/0991-1000/#1000-minimum-cost-to-merge-stones-starstarstar","text":"","title":"1000. Minimum Cost to Merge Stones $\\star\\star\\star$"},{"location":"python3/1001-1100/1001-1010/","text":"1001. Grid Illumination $\\star\\star\\star$ 1002. Find Common Characters $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def commonChars ( self , A : List [ str ]) -> List [ str ]: ans = [] commonCount = [ float ( 'inf' )] * 26 for a in A : count = [ 0 ] * 26 for c in a : count [ ord ( c ) - ord ( 'a' )] += 1 for i in range ( 26 ): commonCount [ i ] = min ( commonCount [ i ], count [ i ]) for c in string . ascii_lowercase : for j in range ( commonCount [ ord ( c ) - ord ( 'a' )]): ans . append ( c ) return ans 1003. Check If Word Is Valid After Substitutions $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def isValid ( self , S : str ) -> bool : stack = [] for c in S : if c == 'c' : n = len ( stack ) if n < 2 or stack [ n - 2 ] != 'a' or stack [ n - 1 ] != 'b' : return False stack . pop () stack . pop () else : stack . append ( c ) return len ( stack ) == 0 1004. Max Consecutive Ones III $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution : def longestOnes ( self , A : List [ int ], K : int ) -> int : i = 0 for a in A : K -= 1 - a if K < 0 : K += 1 - A [ i ] i += 1 return len ( A ) - i 1005. Maximize Sum Of Array After K Negations $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution : def largestSumAfterKNegations ( self , A : List [ int ], K : int ) -> int : A . sort () for i in range ( len ( A )): if A [ i ] > 0 or K == 0 : break A [ i ] = - A [ i ] K -= 1 return sum ( A ) - ( K % 2 ) * min ( A ) * 2 1006. Clumsy Factorial $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution : def clumsy ( self , N : int ) -> int : if N <= 2 : return N if N <= 4 : return N + 3 if ( N - 4 ) % 4 == 0 : return N + 1 if ( N - 4 ) % 4 <= 2 : return N + 2 return N - 1 1007. Minimum Domino Rotations For Equal Row $\\star\\star$ 1 2 3 4 5 6 7 class Solution : def minDominoRotations ( self , A : List [ int ], B : List [ int ]) -> int : for num in range ( 1 , 7 ): if all ( num in pair for pair in zip ( A , B )): return len ( A ) - max ( A . count ( num ), B . count ( num )) return - 1 1008. Construct Binary Search Tree from Preorder Traversal $\\star\\star$ 1009. Complement of Base 10 Integer $\\star$ 1010. Pairs of Songs With Total Durations Divisible by 60 $\\star$ 1 2 3 4 5 6 7 8 9 10 11 class Solution : def numPairsDivisibleBy60 ( self , time : List [ int ]) -> int : ans = 0 count = [ 0 ] * 60 for t in time : t %= 60 ans += count [ 0 ] if t == 0 else count [ 60 - t ] count [ t ] += 1 return ans","title":"1001-1010"},{"location":"python3/1001-1100/1001-1010/#1001-grid-illumination-starstarstar","text":"","title":"1001. Grid Illumination $\\star\\star\\star$"},{"location":"python3/1001-1100/1001-1010/#1002-find-common-characters-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def commonChars ( self , A : List [ str ]) -> List [ str ]: ans = [] commonCount = [ float ( 'inf' )] * 26 for a in A : count = [ 0 ] * 26 for c in a : count [ ord ( c ) - ord ( 'a' )] += 1 for i in range ( 26 ): commonCount [ i ] = min ( commonCount [ i ], count [ i ]) for c in string . ascii_lowercase : for j in range ( commonCount [ ord ( c ) - ord ( 'a' )]): ans . append ( c ) return ans","title":"1002. Find Common Characters $\\star$"},{"location":"python3/1001-1100/1001-1010/#1003-check-if-word-is-valid-after-substitutions-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def isValid ( self , S : str ) -> bool : stack = [] for c in S : if c == 'c' : n = len ( stack ) if n < 2 or stack [ n - 2 ] != 'a' or stack [ n - 1 ] != 'b' : return False stack . pop () stack . pop () else : stack . append ( c ) return len ( stack ) == 0","title":"1003. Check If Word Is Valid After Substitutions $\\star\\star$"},{"location":"python3/1001-1100/1001-1010/#1004-max-consecutive-ones-iii-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution : def longestOnes ( self , A : List [ int ], K : int ) -> int : i = 0 for a in A : K -= 1 - a if K < 0 : K += 1 - A [ i ] i += 1 return len ( A ) - i","title":"1004. Max Consecutive Ones III $\\star\\star$"},{"location":"python3/1001-1100/1001-1010/#1005-maximize-sum-of-array-after-k-negations-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution : def largestSumAfterKNegations ( self , A : List [ int ], K : int ) -> int : A . sort () for i in range ( len ( A )): if A [ i ] > 0 or K == 0 : break A [ i ] = - A [ i ] K -= 1 return sum ( A ) - ( K % 2 ) * min ( A ) * 2","title":"1005. Maximize Sum Of Array After K Negations $\\star$"},{"location":"python3/1001-1100/1001-1010/#1006-clumsy-factorial-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution : def clumsy ( self , N : int ) -> int : if N <= 2 : return N if N <= 4 : return N + 3 if ( N - 4 ) % 4 == 0 : return N + 1 if ( N - 4 ) % 4 <= 2 : return N + 2 return N - 1","title":"1006. Clumsy Factorial $\\star\\star$"},{"location":"python3/1001-1100/1001-1010/#1007-minimum-domino-rotations-for-equal-row-starstar","text":"1 2 3 4 5 6 7 class Solution : def minDominoRotations ( self , A : List [ int ], B : List [ int ]) -> int : for num in range ( 1 , 7 ): if all ( num in pair for pair in zip ( A , B )): return len ( A ) - max ( A . count ( num ), B . count ( num )) return - 1","title":"1007. Minimum Domino Rotations For Equal Row $\\star\\star$"},{"location":"python3/1001-1100/1001-1010/#1008-construct-binary-search-tree-from-preorder-traversal-starstar","text":"","title":"1008. Construct Binary Search Tree from Preorder Traversal $\\star\\star$"},{"location":"python3/1001-1100/1001-1010/#1009-complement-of-base-10-integer-star","text":"","title":"1009. Complement of Base 10 Integer $\\star$"},{"location":"python3/1001-1100/1001-1010/#1010-pairs-of-songs-with-total-durations-divisible-by-60-star","text":"1 2 3 4 5 6 7 8 9 10 11 class Solution : def numPairsDivisibleBy60 ( self , time : List [ int ]) -> int : ans = 0 count = [ 0 ] * 60 for t in time : t %= 60 ans += count [ 0 ] if t == 0 else count [ 60 - t ] count [ t ] += 1 return ans","title":"1010. Pairs of Songs With Total Durations Divisible by 60 $\\star$"},{"location":"python3/1001-1100/1011-1020/","text":"1011. Capacity To Ship Packages Within D Days $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def shipWithinDays ( self , weights : List [ int ], D : int ) -> int : l = max ( weights ) r = sum ( weights ) while l < r : m = ( l + r ) // 2 day = 1 capacity = 0 for weight in weights : if capacity + weight > m : day += 1 capacity = weight else : capacity += weight if day <= D : r = m else : l = m + 1 return l 1012. Numbers With Repeated Digits $\\star\\star\\star$ 1013. Partition Array Into Three Parts With Equal Sum $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def canThreePartsEqualSum ( self , A : List [ int ]) -> bool : sum_ = sum ( A ) presum = 0 parts = 1 for a in A : presum += a if presum == sum_ * parts // 3 : parts += 1 return sum_ % 3 == 0 and parts >= 3 1014. Best Sightseeing Pair $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution : def maxScoreSightseeingPair ( self , A : List [ int ]) -> int : ans = 0 bestPrev = 0 for a in A : ans = max ( ans , a + bestPrev ) bestPrev = max ( bestPrev , a ) - 1 return ans 1015. Smallest Integer Divisible by K $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def smallestRepunitDivByK ( self , K : int ) -> int : if K % 10 not in { 1 , 3 , 7 , 9 }: return - 1 set_ = set () mod = 0 for N in range ( 1 , K + 1 ): mod = ( mod * 10 + 1 ) % K if mod == 0 : return N if mod in set_ : return - 1 set_ . add ( mod ) return - 1 1016. Binary String With Substrings Representing 1 To N $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution : def queryString ( self , S : str , N : int ) -> bool : if N > 1511 : return False for i in range ( N , N // 2 , - 1 ): if format ( i , \"b\" ) not in S : return False return True 1017. Convert to Base -2 $\\star\\star$ 1018. Binary Prefix Divisible By 5 $\\star$ 1 2 3 4 5 6 7 8 9 10 class Solution : def prefixesDivBy5 ( self , A : List [ int ]) -> List [ bool ]: ans = [] num = 0 for a in A : num = ( num * 2 + a ) % 5 ans . append ( num % 5 == 0 ) return ans 1019. Next Greater Node In Linked List $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def nextLargerNodes ( self , head : ListNode ) -> List [ int ]: ans = [] stack = [] curr = head while curr : while stack and ans [ stack [ - 1 ]] < curr . val : ans [ stack [ - 1 ]] = curr . val stack . pop () stack . append ( len ( ans )) ans . append ( curr . val ) curr = curr . next for i in stack : ans [ i ] = 0 return ans 1020. Number of Enclaves $\\star\\star$","title":"1011-1020"},{"location":"python3/1001-1100/1011-1020/#1011-capacity-to-ship-packages-within-d-days-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Solution : def shipWithinDays ( self , weights : List [ int ], D : int ) -> int : l = max ( weights ) r = sum ( weights ) while l < r : m = ( l + r ) // 2 day = 1 capacity = 0 for weight in weights : if capacity + weight > m : day += 1 capacity = weight else : capacity += weight if day <= D : r = m else : l = m + 1 return l","title":"1011. Capacity To Ship Packages Within D Days $\\star\\star$"},{"location":"python3/1001-1100/1011-1020/#1012-numbers-with-repeated-digits-starstarstar","text":"","title":"1012. Numbers With Repeated Digits $\\star\\star\\star$"},{"location":"python3/1001-1100/1011-1020/#1013-partition-array-into-three-parts-with-equal-sum-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def canThreePartsEqualSum ( self , A : List [ int ]) -> bool : sum_ = sum ( A ) presum = 0 parts = 1 for a in A : presum += a if presum == sum_ * parts // 3 : parts += 1 return sum_ % 3 == 0 and parts >= 3","title":"1013. Partition Array Into Three Parts With Equal Sum $\\star$"},{"location":"python3/1001-1100/1011-1020/#1014-best-sightseeing-pair-starstar","text":"1 2 3 4 5 6 7 8 9 10 class Solution : def maxScoreSightseeingPair ( self , A : List [ int ]) -> int : ans = 0 bestPrev = 0 for a in A : ans = max ( ans , a + bestPrev ) bestPrev = max ( bestPrev , a ) - 1 return ans","title":"1014. Best Sightseeing Pair $\\star\\star$"},{"location":"python3/1001-1100/1011-1020/#1015-smallest-integer-divisible-by-k-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def smallestRepunitDivByK ( self , K : int ) -> int : if K % 10 not in { 1 , 3 , 7 , 9 }: return - 1 set_ = set () mod = 0 for N in range ( 1 , K + 1 ): mod = ( mod * 10 + 1 ) % K if mod == 0 : return N if mod in set_ : return - 1 set_ . add ( mod ) return - 1","title":"1015. Smallest Integer Divisible by K $\\star\\star$"},{"location":"python3/1001-1100/1011-1020/#1016-binary-string-with-substrings-representing-1-to-n-starstar","text":"1 2 3 4 5 6 7 8 9 10 class Solution : def queryString ( self , S : str , N : int ) -> bool : if N > 1511 : return False for i in range ( N , N // 2 , - 1 ): if format ( i , \"b\" ) not in S : return False return True","title":"1016. Binary String With Substrings Representing 1 To N $\\star\\star$"},{"location":"python3/1001-1100/1011-1020/#1017-convert-to-base-2-starstar","text":"","title":"1017. Convert to Base -2 $\\star\\star$"},{"location":"python3/1001-1100/1011-1020/#1018-binary-prefix-divisible-by-5-star","text":"1 2 3 4 5 6 7 8 9 10 class Solution : def prefixesDivBy5 ( self , A : List [ int ]) -> List [ bool ]: ans = [] num = 0 for a in A : num = ( num * 2 + a ) % 5 ans . append ( num % 5 == 0 ) return ans","title":"1018. Binary Prefix Divisible By 5 $\\star$"},{"location":"python3/1001-1100/1011-1020/#1019-next-greater-node-in-linked-list-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class Solution : def nextLargerNodes ( self , head : ListNode ) -> List [ int ]: ans = [] stack = [] curr = head while curr : while stack and ans [ stack [ - 1 ]] < curr . val : ans [ stack [ - 1 ]] = curr . val stack . pop () stack . append ( len ( ans )) ans . append ( curr . val ) curr = curr . next for i in stack : ans [ i ] = 0 return ans","title":"1019. Next Greater Node In Linked List $\\star\\star$"},{"location":"python3/1001-1100/1011-1020/#1020-number-of-enclaves-starstar","text":"","title":"1020. Number of Enclaves $\\star\\star$"},{"location":"python3/1001-1100/1021-1030/","text":"1021. Remove Outermost Parentheses $\\star$ 1022. Sum of Root To Leaf Binary Numbers $\\star$ 1023. Camelcase Matching $\\star\\star$ 1024. Video Stitching $\\star\\star$ 1025. Divisor Game $\\star$ 1026. Maximum Difference Between Node and Ancestor $\\star\\star$ 1027. Longest Arithmetic Sequence $\\star\\star$ 1028. Recover a Tree From Preorder Traversal $\\star\\star\\star$ 1029. Two City Scheduling $\\star$ 1030. Matrix Cells in Distance Order $\\star$","title":"1021-1030"},{"location":"python3/1001-1100/1021-1030/#1021-remove-outermost-parentheses-star","text":"","title":"1021. Remove Outermost Parentheses $\\star$"},{"location":"python3/1001-1100/1021-1030/#1022-sum-of-root-to-leaf-binary-numbers-star","text":"","title":"1022. Sum of Root To Leaf Binary Numbers $\\star$"},{"location":"python3/1001-1100/1021-1030/#1023-camelcase-matching-starstar","text":"","title":"1023. Camelcase Matching $\\star\\star$"},{"location":"python3/1001-1100/1021-1030/#1024-video-stitching-starstar","text":"","title":"1024. Video Stitching $\\star\\star$"},{"location":"python3/1001-1100/1021-1030/#1025-divisor-game-star","text":"","title":"1025. Divisor Game $\\star$"},{"location":"python3/1001-1100/1021-1030/#1026-maximum-difference-between-node-and-ancestor-starstar","text":"","title":"1026. Maximum Difference Between Node and Ancestor $\\star\\star$"},{"location":"python3/1001-1100/1021-1030/#1027-longest-arithmetic-sequence-starstar","text":"","title":"1027. Longest Arithmetic Sequence $\\star\\star$"},{"location":"python3/1001-1100/1021-1030/#1028-recover-a-tree-from-preorder-traversal-starstarstar","text":"","title":"1028. Recover a Tree From Preorder Traversal $\\star\\star\\star$"},{"location":"python3/1001-1100/1021-1030/#1029-two-city-scheduling-star","text":"","title":"1029. Two City Scheduling $\\star$"},{"location":"python3/1001-1100/1021-1030/#1030-matrix-cells-in-distance-order-star","text":"","title":"1030. Matrix Cells in Distance Order $\\star$"},{"location":"python3/1001-1100/1031-1040/","text":"1031. Maximum Sum of Two Non-Overlapping Subarrays $\\star\\star$ 1032. Stream of Characters $\\star\\star\\star$ 1033. Moving Stones Until Consecutive $\\star$ 1034. Coloring A Border $\\star\\star$ 1035. Uncrossed Lines $\\star\\star$ 1036. Escape a Large Maze $\\star\\star\\star$ 1037. Valid Boomerang $\\star$ 1038. Binary Search Tree to Greater Sum Tree $\\star\\star$ 1039. Minimum Score Triangulation of Polygon $\\star\\star$ 1040. Moving Stones Until Consecutive II $\\star\\star$","title":"1031-1040"},{"location":"python3/1001-1100/1031-1040/#1031-maximum-sum-of-two-non-overlapping-subarrays-starstar","text":"","title":"1031. Maximum Sum of Two Non-Overlapping Subarrays $\\star\\star$"},{"location":"python3/1001-1100/1031-1040/#1032-stream-of-characters-starstarstar","text":"","title":"1032. Stream of Characters $\\star\\star\\star$"},{"location":"python3/1001-1100/1031-1040/#1033-moving-stones-until-consecutive-star","text":"","title":"1033. Moving Stones Until Consecutive $\\star$"},{"location":"python3/1001-1100/1031-1040/#1034-coloring-a-border-starstar","text":"","title":"1034. Coloring A Border $\\star\\star$"},{"location":"python3/1001-1100/1031-1040/#1035-uncrossed-lines-starstar","text":"","title":"1035. Uncrossed Lines $\\star\\star$"},{"location":"python3/1001-1100/1031-1040/#1036-escape-a-large-maze-starstarstar","text":"","title":"1036. Escape a Large Maze $\\star\\star\\star$"},{"location":"python3/1001-1100/1031-1040/#1037-valid-boomerang-star","text":"","title":"1037. Valid Boomerang $\\star$"},{"location":"python3/1001-1100/1031-1040/#1038-binary-search-tree-to-greater-sum-tree-starstar","text":"","title":"1038. Binary Search Tree to Greater Sum Tree $\\star\\star$"},{"location":"python3/1001-1100/1031-1040/#1039-minimum-score-triangulation-of-polygon-starstar","text":"","title":"1039. Minimum Score Triangulation of Polygon $\\star\\star$"},{"location":"python3/1001-1100/1031-1040/#1040-moving-stones-until-consecutive-ii-starstar","text":"","title":"1040. Moving Stones Until Consecutive II $\\star\\star$"},{"location":"python3/1001-1100/1041-1050/","text":"1041. Robot Bounded In Circle $\\star\\star$ 1042. Flower Planting With No Adjacent $\\star$ 1043. Partition Array for Maximum Sum $\\star\\star$ 1044. Longest Duplicate Substring $\\star\\star\\star$ 1045. Customers Who Bought All Products $\\star\\star$ 1046. Last Stone Weight $\\star$ 1047. Remove All Adjacent Duplicates In String $\\star$ 1048. Longest String Chain $\\star\\star$ 1049. Last Stone Weight II $\\star\\star$ 1050. Actors and Directors Who Cooperated At Least Three Times $\\star$","title":"1041-1050"},{"location":"python3/1001-1100/1041-1050/#1041-robot-bounded-in-circle-starstar","text":"","title":"1041. Robot Bounded In Circle $\\star\\star$"},{"location":"python3/1001-1100/1041-1050/#1042-flower-planting-with-no-adjacent-star","text":"","title":"1042. Flower Planting With No Adjacent $\\star$"},{"location":"python3/1001-1100/1041-1050/#1043-partition-array-for-maximum-sum-starstar","text":"","title":"1043. Partition Array for Maximum Sum $\\star\\star$"},{"location":"python3/1001-1100/1041-1050/#1044-longest-duplicate-substring-starstarstar","text":"","title":"1044. Longest Duplicate Substring $\\star\\star\\star$"},{"location":"python3/1001-1100/1041-1050/#1045-customers-who-bought-all-products-starstar","text":"","title":"1045. Customers Who Bought All Products $\\star\\star$"},{"location":"python3/1001-1100/1041-1050/#1046-last-stone-weight-star","text":"","title":"1046. Last Stone Weight $\\star$"},{"location":"python3/1001-1100/1041-1050/#1047-remove-all-adjacent-duplicates-in-string-star","text":"","title":"1047. Remove All Adjacent Duplicates In String $\\star$"},{"location":"python3/1001-1100/1041-1050/#1048-longest-string-chain-starstar","text":"","title":"1048. Longest String Chain $\\star\\star$"},{"location":"python3/1001-1100/1041-1050/#1049-last-stone-weight-ii-starstar","text":"","title":"1049. Last Stone Weight II $\\star\\star$"},{"location":"python3/1001-1100/1041-1050/#1050-actors-and-directors-who-cooperated-at-least-three-times-star","text":"","title":"1050. Actors and Directors Who Cooperated At Least Three Times $\\star$"},{"location":"python3/1001-1100/1051-1060/","text":"1051. Height Checker $\\star$ 1052. Grumpy Bookstore Owner $\\star\\star$ 1053. Previous Permutation With One Swap $\\star\\star$ 1054. Distant Barcodes $\\star\\star$ 1055. Shortest Way to Form String $\\star\\star$ 1056. Confusing Number $\\star$ 1057. Campus Bikes $\\star\\star$ 1058. Minimize Rounding Error to Meet Target $\\star\\star$ 1059. All Paths from Source Lead to Destination $\\star\\star$ 1060. Missing Element in Sorted Array $\\star\\star$","title":"1051-1060"},{"location":"python3/1001-1100/1051-1060/#1051-height-checker-star","text":"","title":"1051. Height Checker $\\star$"},{"location":"python3/1001-1100/1051-1060/#1052-grumpy-bookstore-owner-starstar","text":"","title":"1052. Grumpy Bookstore Owner $\\star\\star$"},{"location":"python3/1001-1100/1051-1060/#1053-previous-permutation-with-one-swap-starstar","text":"","title":"1053. Previous Permutation With One Swap $\\star\\star$"},{"location":"python3/1001-1100/1051-1060/#1054-distant-barcodes-starstar","text":"","title":"1054. Distant Barcodes $\\star\\star$"},{"location":"python3/1001-1100/1051-1060/#1055-shortest-way-to-form-string-starstar","text":"","title":"1055. Shortest Way to Form String $\\star\\star$"},{"location":"python3/1001-1100/1051-1060/#1056-confusing-number-star","text":"","title":"1056. Confusing Number $\\star$"},{"location":"python3/1001-1100/1051-1060/#1057-campus-bikes-starstar","text":"","title":"1057. Campus Bikes $\\star\\star$"},{"location":"python3/1001-1100/1051-1060/#1058-minimize-rounding-error-to-meet-target-starstar","text":"","title":"1058. Minimize Rounding Error to Meet Target $\\star\\star$"},{"location":"python3/1001-1100/1051-1060/#1059-all-paths-from-source-lead-to-destination-starstar","text":"","title":"1059. All Paths from Source Lead to Destination $\\star\\star$"},{"location":"python3/1001-1100/1051-1060/#1060-missing-element-in-sorted-array-starstar","text":"","title":"1060. Missing Element in Sorted Array $\\star\\star$"},{"location":"python3/1001-1100/1061-1070/","text":"1061. Lexicographically Smallest Equivalent String $\\star\\star$ 1062. Longest Repeating Substring $\\star\\star$ 1063. Number of Valid Subarrays $\\star\\star\\star$ 1064. Fixed Point $\\star$ 1065. Index Pairs of a String $\\star$ 1066. Campus Bikes II $\\star\\star$ 1067. Digit Count in Range $\\star\\star\\star$ 1068. Product Sales Analysis I $\\star$ 1069. Product Sales Analysis II $\\star$ 1070. Product Sales Analysis III $\\star\\star$","title":"1061-1070"},{"location":"python3/1001-1100/1061-1070/#1061-lexicographically-smallest-equivalent-string-starstar","text":"","title":"1061. Lexicographically Smallest Equivalent String $\\star\\star$"},{"location":"python3/1001-1100/1061-1070/#1062-longest-repeating-substring-starstar","text":"","title":"1062. Longest Repeating Substring $\\star\\star$"},{"location":"python3/1001-1100/1061-1070/#1063-number-of-valid-subarrays-starstarstar","text":"","title":"1063. Number of Valid Subarrays $\\star\\star\\star$"},{"location":"python3/1001-1100/1061-1070/#1064-fixed-point-star","text":"","title":"1064. Fixed Point $\\star$"},{"location":"python3/1001-1100/1061-1070/#1065-index-pairs-of-a-string-star","text":"","title":"1065. Index Pairs of a String $\\star$"},{"location":"python3/1001-1100/1061-1070/#1066-campus-bikes-ii-starstar","text":"","title":"1066. Campus Bikes II $\\star\\star$"},{"location":"python3/1001-1100/1061-1070/#1067-digit-count-in-range-starstarstar","text":"","title":"1067. Digit Count in Range $\\star\\star\\star$"},{"location":"python3/1001-1100/1061-1070/#1068-product-sales-analysis-i-star","text":"","title":"1068. Product Sales Analysis I $\\star$"},{"location":"python3/1001-1100/1061-1070/#1069-product-sales-analysis-ii-star","text":"","title":"1069. Product Sales Analysis II $\\star$"},{"location":"python3/1001-1100/1061-1070/#1070-product-sales-analysis-iii-starstar","text":"","title":"1070. Product Sales Analysis III $\\star\\star$"},{"location":"python3/1001-1100/1071-1080/","text":"1071. Greatest Common Divisor of Strings $\\star$ 1072. Flip Columns For Maximum Number of Equal Rows $\\star\\star$ 1073. Adding Two Negabinary Numbers $\\star\\star$ 1074. Number of Submatrices That Sum to Target $\\star\\star\\star$ 1075. Project Employees I $\\star$ 1076. Project Employees II $\\star$ 1077. Project Employees III $\\star\\star$ 1078. Occurrences After Bigram $\\star$ 1079. Letter Tile Possibilities $\\star\\star$ 1080. Insufficient Nodes in Root to Leaf Paths $\\star\\star$","title":"1071-1080"},{"location":"python3/1001-1100/1071-1080/#1071-greatest-common-divisor-of-strings-star","text":"","title":"1071. Greatest Common Divisor of Strings $\\star$"},{"location":"python3/1001-1100/1071-1080/#1072-flip-columns-for-maximum-number-of-equal-rows-starstar","text":"","title":"1072. Flip Columns For Maximum Number of Equal Rows $\\star\\star$"},{"location":"python3/1001-1100/1071-1080/#1073-adding-two-negabinary-numbers-starstar","text":"","title":"1073. Adding Two Negabinary Numbers $\\star\\star$"},{"location":"python3/1001-1100/1071-1080/#1074-number-of-submatrices-that-sum-to-target-starstarstar","text":"","title":"1074. Number of Submatrices That Sum to Target $\\star\\star\\star$"},{"location":"python3/1001-1100/1071-1080/#1075-project-employees-i-star","text":"","title":"1075. Project Employees I $\\star$"},{"location":"python3/1001-1100/1071-1080/#1076-project-employees-ii-star","text":"","title":"1076. Project Employees II $\\star$"},{"location":"python3/1001-1100/1071-1080/#1077-project-employees-iii-starstar","text":"","title":"1077. Project Employees III $\\star\\star$"},{"location":"python3/1001-1100/1071-1080/#1078-occurrences-after-bigram-star","text":"","title":"1078. Occurrences After Bigram $\\star$"},{"location":"python3/1001-1100/1071-1080/#1079-letter-tile-possibilities-starstar","text":"","title":"1079. Letter Tile Possibilities $\\star\\star$"},{"location":"python3/1001-1100/1071-1080/#1080-insufficient-nodes-in-root-to-leaf-paths-starstar","text":"","title":"1080. Insufficient Nodes in Root to Leaf Paths $\\star\\star$"},{"location":"python3/1001-1100/1081-1090/","text":"1081. Smallest Subsequence of Distinct Characters $\\star\\star$ 1082. Sales Analysis I $\\star$ 1083. Sales Analysis II $\\star$ 1084. Sales Analysis III $\\star$ 1085. Sum of Digits in the Minimum Number $\\star$ 1086. High Five $\\star$ 1087. Brace Expansion $\\star\\star$ 1088. Confusing Number II $\\star\\star\\star$ 1089. Duplicate Zeros $\\star$ 1090. Largest Values From Labels $\\star\\star$","title":"1081-1090"},{"location":"python3/1001-1100/1081-1090/#1081-smallest-subsequence-of-distinct-characters-starstar","text":"","title":"1081. Smallest Subsequence of Distinct Characters $\\star\\star$"},{"location":"python3/1001-1100/1081-1090/#1082-sales-analysis-i-star","text":"","title":"1082. Sales Analysis I $\\star$"},{"location":"python3/1001-1100/1081-1090/#1083-sales-analysis-ii-star","text":"","title":"1083. Sales Analysis II $\\star$"},{"location":"python3/1001-1100/1081-1090/#1084-sales-analysis-iii-star","text":"","title":"1084. Sales Analysis III $\\star$"},{"location":"python3/1001-1100/1081-1090/#1085-sum-of-digits-in-the-minimum-number-star","text":"","title":"1085. Sum of Digits in the Minimum Number $\\star$"},{"location":"python3/1001-1100/1081-1090/#1086-high-five-star","text":"","title":"1086. High Five $\\star$"},{"location":"python3/1001-1100/1081-1090/#1087-brace-expansion-starstar","text":"","title":"1087. Brace Expansion $\\star\\star$"},{"location":"python3/1001-1100/1081-1090/#1088-confusing-number-ii-starstarstar","text":"","title":"1088. Confusing Number II $\\star\\star\\star$"},{"location":"python3/1001-1100/1081-1090/#1089-duplicate-zeros-star","text":"","title":"1089. Duplicate Zeros $\\star$"},{"location":"python3/1001-1100/1081-1090/#1090-largest-values-from-labels-starstar","text":"","title":"1090. Largest Values From Labels $\\star\\star$"},{"location":"python3/1001-1100/1091-1100/","text":"1091. Shortest Path in Binary Matrix $\\star\\star$ 1092. Shortest Common Supersequence $\\star\\star\\star$ 1093. Statistics from a Large Sample $\\star\\star$ 1094. Car Pooling $\\star\\star$ 1095. Find in Mountain Array $\\star\\star\\star$ 1096. Brace Expansion II $\\star\\star\\star$ 1097. Game Play Analysis V $\\star\\star\\star$ 1098. Unpopular Books $\\star\\star$ 1099. Two Sum Less Than K $\\star$ 1100. Find K-Length Substrings With No Repeated Characters $\\star\\star$","title":"1091-1100"},{"location":"python3/1001-1100/1091-1100/#1091-shortest-path-in-binary-matrix-starstar","text":"","title":"1091. Shortest Path in Binary Matrix $\\star\\star$"},{"location":"python3/1001-1100/1091-1100/#1092-shortest-common-supersequence-starstarstar","text":"","title":"1092. Shortest Common Supersequence  $\\star\\star\\star$"},{"location":"python3/1001-1100/1091-1100/#1093-statistics-from-a-large-sample-starstar","text":"","title":"1093. Statistics from a Large Sample $\\star\\star$"},{"location":"python3/1001-1100/1091-1100/#1094-car-pooling-starstar","text":"","title":"1094. Car Pooling $\\star\\star$"},{"location":"python3/1001-1100/1091-1100/#1095-find-in-mountain-array-starstarstar","text":"","title":"1095. Find in Mountain Array $\\star\\star\\star$"},{"location":"python3/1001-1100/1091-1100/#1096-brace-expansion-ii-starstarstar","text":"","title":"1096. Brace Expansion II $\\star\\star\\star$"},{"location":"python3/1001-1100/1091-1100/#1097-game-play-analysis-v-starstarstar","text":"","title":"1097. Game Play Analysis V $\\star\\star\\star$"},{"location":"python3/1001-1100/1091-1100/#1098-unpopular-books-starstar","text":"","title":"1098. Unpopular Books $\\star\\star$"},{"location":"python3/1001-1100/1091-1100/#1099-two-sum-less-than-k-star","text":"","title":"1099. Two Sum Less Than K $\\star$"},{"location":"python3/1001-1100/1091-1100/#1100-find-k-length-substrings-with-no-repeated-characters-starstar","text":"","title":"1100. Find K-Length Substrings With No Repeated Characters $\\star\\star$"},{"location":"python3/1101-1200/1101-1110/","text":"1101. The Earliest Moment When Everyone Become Friends $\\star\\star$ 1102. Path With Maximum Minimum Value $\\star\\star$ 1103. Distribute Candies to People $\\star$ 1104. Path In Zigzag Labelled Binary Tree $\\star\\star$ 1105. Filling Bookcase Shelves $\\star\\star$ 1106. Parsing A Boolean Expression $\\star\\star\\star$ 1107. New Users Daily Count $\\star\\star$ 1108. Defanging an IP Address $\\star$ 1109. Corporate Flight Bookings $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def corpFlightBookings ( self , bookings : List [ List [ int ]], n : int ) -> List [ int ]: ans = [ 0 ] * n for booking in bookings : ans [ booking [ 0 ] - 1 ] += booking [ 2 ] if booking [ 1 ] < n : ans [ booking [ 1 ]] -= booking [ 2 ] for i in range ( 1 , n ): ans [ i ] += ans [ i - 1 ] return ans 1110. Delete Nodes And Return Forest $\\star\\star$","title":"1101-1110"},{"location":"python3/1101-1200/1101-1110/#1101-the-earliest-moment-when-everyone-become-friends-starstar","text":"","title":"1101. The Earliest Moment When Everyone Become Friends $\\star\\star$"},{"location":"python3/1101-1200/1101-1110/#1102-path-with-maximum-minimum-value-starstar","text":"","title":"1102. Path With Maximum Minimum Value $\\star\\star$"},{"location":"python3/1101-1200/1101-1110/#1103-distribute-candies-to-people-star","text":"","title":"1103. Distribute Candies to People $\\star$"},{"location":"python3/1101-1200/1101-1110/#1104-path-in-zigzag-labelled-binary-tree-starstar","text":"","title":"1104. Path In Zigzag Labelled Binary Tree $\\star\\star$"},{"location":"python3/1101-1200/1101-1110/#1105-filling-bookcase-shelves-starstar","text":"","title":"1105. Filling Bookcase Shelves $\\star\\star$"},{"location":"python3/1101-1200/1101-1110/#1106-parsing-a-boolean-expression-starstarstar","text":"","title":"1106. Parsing A Boolean Expression $\\star\\star\\star$"},{"location":"python3/1101-1200/1101-1110/#1107-new-users-daily-count-starstar","text":"","title":"1107. New Users Daily Count $\\star\\star$"},{"location":"python3/1101-1200/1101-1110/#1108-defanging-an-ip-address-star","text":"","title":"1108. Defanging an IP Address $\\star$"},{"location":"python3/1101-1200/1101-1110/#1109-corporate-flight-bookings-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 class Solution : def corpFlightBookings ( self , bookings : List [ List [ int ]], n : int ) -> List [ int ]: ans = [ 0 ] * n for booking in bookings : ans [ booking [ 0 ] - 1 ] += booking [ 2 ] if booking [ 1 ] < n : ans [ booking [ 1 ]] -= booking [ 2 ] for i in range ( 1 , n ): ans [ i ] += ans [ i - 1 ] return ans","title":"1109. Corporate Flight Bookings $\\star\\star$"},{"location":"python3/1101-1200/1101-1110/#1110-delete-nodes-and-return-forest-starstar","text":"","title":"1110. Delete Nodes And Return Forest $\\star\\star$"},{"location":"python3/1101-1200/1111-1120/","text":"1111. Maximum Nesting Depth of Two Valid Parentheses Strings $\\star\\star$ 1112. Highest Grade For Each Student $\\star\\star$ 1113. Reported Posts $\\star$ 1114. Print in Order $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from threading import Lock class Foo : def __init__ ( self ): self . mutex2 = Lock () self . mutex3 = Lock () self . mutex2 . acquire () self . mutex3 . acquire () def first ( self , printFirst : 'Callable[[], None]' ) -> None : printFirst () self . mutex2 . release () def second ( self , printSecond : 'Callable[[], None]' ) -> None : self . mutex2 . acquire () printSecond () self . mutex3 . release () def third ( self , printThird : 'Callable[[], None]' ) -> None : self . mutex3 . acquire () printThird () 1115. Print FooBar Alternately $\\star\\star$ 1116. Print Zero Even Odd $\\star\\star$ 1117. Building H2O $\\star\\star$ 1118. Number of Days in a Month $\\star$ 1119. Remove Vowels from a String $\\star$ 1120. Maximum Average Subtree $\\star\\star$","title":"1111-1120"},{"location":"python3/1101-1200/1111-1120/#1111-maximum-nesting-depth-of-two-valid-parentheses-strings-starstar","text":"","title":"1111. Maximum Nesting Depth of Two Valid Parentheses Strings $\\star\\star$"},{"location":"python3/1101-1200/1111-1120/#1112-highest-grade-for-each-student-starstar","text":"","title":"1112. Highest Grade For Each Student $\\star\\star$"},{"location":"python3/1101-1200/1111-1120/#1113-reported-posts-star","text":"","title":"1113. Reported Posts $\\star$"},{"location":"python3/1101-1200/1111-1120/#1114-print-in-order-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from threading import Lock class Foo : def __init__ ( self ): self . mutex2 = Lock () self . mutex3 = Lock () self . mutex2 . acquire () self . mutex3 . acquire () def first ( self , printFirst : 'Callable[[], None]' ) -> None : printFirst () self . mutex2 . release () def second ( self , printSecond : 'Callable[[], None]' ) -> None : self . mutex2 . acquire () printSecond () self . mutex3 . release () def third ( self , printThird : 'Callable[[], None]' ) -> None : self . mutex3 . acquire () printThird ()","title":"1114. Print in Order $\\star$"},{"location":"python3/1101-1200/1111-1120/#1115-print-foobar-alternately-starstar","text":"","title":"1115. Print FooBar Alternately $\\star\\star$"},{"location":"python3/1101-1200/1111-1120/#1116-print-zero-even-odd-starstar","text":"","title":"1116. Print Zero Even Odd $\\star\\star$"},{"location":"python3/1101-1200/1111-1120/#1117-building-h2o-starstar","text":"","title":"1117. Building H2O $\\star\\star$"},{"location":"python3/1101-1200/1111-1120/#1118-number-of-days-in-a-month-star","text":"","title":"1118. Number of Days in a Month $\\star$"},{"location":"python3/1101-1200/1111-1120/#1119-remove-vowels-from-a-string-star","text":"","title":"1119. Remove Vowels from a String $\\star$"},{"location":"python3/1101-1200/1111-1120/#1120-maximum-average-subtree-starstar","text":"","title":"1120. Maximum Average Subtree $\\star\\star$"},{"location":"python3/1101-1200/1121-1130/","text":"1121. Divide Array Into Increasing Sequences $\\star\\star\\star$ 1122. Relative Sort Array $\\star$ 1123. Lowest Common Ancestor of Deepest Leaves $\\star\\star$ 1124. Longest Well-Performing Interval $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def longestWPI ( self , hours : List [ int ]) -> int : ans = 0 presum = 0 dict = {} for i in range ( len ( hours )): presum += 1 if hours [ i ] > 8 else - 1 if presum > 0 : ans = i + 1 else : if presum not in dict : dict [ presum ] = i if presum - 1 in dict : ans = max ( ans , i - dict [ presum - 1 ]) return ans 1125. Smallest Sufficient Team $\\star\\star\\star$ 1126. Active Businesses $\\star\\star$ 1127. User Purchase Platform $\\star\\star\\star$ 1128. Number of Equivalent Domino Pairs $\\star$ 1129. Shortest Path with Alternating Colors $\\star\\star$ 1130. Minimum Cost Tree From Leaf Values $\\star\\star$","title":"1121-1130"},{"location":"python3/1101-1200/1121-1130/#1121-divide-array-into-increasing-sequences-starstarstar","text":"","title":"1121. Divide Array Into Increasing Sequences $\\star\\star\\star$"},{"location":"python3/1101-1200/1121-1130/#1122-relative-sort-array-star","text":"","title":"1122. Relative Sort Array $\\star$"},{"location":"python3/1101-1200/1121-1130/#1123-lowest-common-ancestor-of-deepest-leaves-starstar","text":"","title":"1123. Lowest Common Ancestor of Deepest Leaves $\\star\\star$"},{"location":"python3/1101-1200/1121-1130/#1124-longest-well-performing-interval-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 class Solution : def longestWPI ( self , hours : List [ int ]) -> int : ans = 0 presum = 0 dict = {} for i in range ( len ( hours )): presum += 1 if hours [ i ] > 8 else - 1 if presum > 0 : ans = i + 1 else : if presum not in dict : dict [ presum ] = i if presum - 1 in dict : ans = max ( ans , i - dict [ presum - 1 ]) return ans","title":"1124. Longest Well-Performing Interval $\\star\\star$"},{"location":"python3/1101-1200/1121-1130/#1125-smallest-sufficient-team-starstarstar","text":"","title":"1125. Smallest Sufficient Team $\\star\\star\\star$"},{"location":"python3/1101-1200/1121-1130/#1126-active-businesses-starstar","text":"","title":"1126. Active Businesses $\\star\\star$"},{"location":"python3/1101-1200/1121-1130/#1127-user-purchase-platform-starstarstar","text":"","title":"1127. User Purchase Platform $\\star\\star\\star$"},{"location":"python3/1101-1200/1121-1130/#1128-number-of-equivalent-domino-pairs-star","text":"","title":"1128. Number of Equivalent Domino Pairs $\\star$"},{"location":"python3/1101-1200/1121-1130/#1129-shortest-path-with-alternating-colors-starstar","text":"","title":"1129. Shortest Path with Alternating Colors $\\star\\star$"},{"location":"python3/1101-1200/1121-1130/#1130-minimum-cost-tree-from-leaf-values-starstar","text":"","title":"1130. Minimum Cost Tree From Leaf Values $\\star\\star$"},{"location":"python3/1101-1200/1131-1140/","text":"1131. Maximum of Absolute Value Expression $\\star\\star$ 1132. Reported Posts II $\\star\\star$ 1133. Largest Unique Number $\\star$ 1134. Armstrong Number $\\star$ 1135. Connecting Cities With Minimum Cost $\\star\\star$ 1136. Parallel Courses $\\star\\star\\star$ 1137. N-th Tribonacci Number $\\star$ 1138. Alphabet Board Path $\\star\\star$ 1139. Largest 1-Bordered Square $\\star\\star$ 1140. Stone Game II $\\star\\star$","title":"1131-1140"},{"location":"python3/1101-1200/1131-1140/#1131-maximum-of-absolute-value-expression-starstar","text":"","title":"1131. Maximum of Absolute Value Expression $\\star\\star$"},{"location":"python3/1101-1200/1131-1140/#1132-reported-posts-ii-starstar","text":"","title":"1132. Reported Posts II $\\star\\star$"},{"location":"python3/1101-1200/1131-1140/#1133-largest-unique-number-star","text":"","title":"1133. Largest Unique Number $\\star$"},{"location":"python3/1101-1200/1131-1140/#1134-armstrong-number-star","text":"","title":"1134. Armstrong Number $\\star$"},{"location":"python3/1101-1200/1131-1140/#1135-connecting-cities-with-minimum-cost-starstar","text":"","title":"1135. Connecting Cities With Minimum Cost $\\star\\star$"},{"location":"python3/1101-1200/1131-1140/#1136-parallel-courses-starstarstar","text":"","title":"1136. Parallel Courses $\\star\\star\\star$"},{"location":"python3/1101-1200/1131-1140/#1137-n-th-tribonacci-number-star","text":"","title":"1137. N-th Tribonacci Number $\\star$"},{"location":"python3/1101-1200/1131-1140/#1138-alphabet-board-path-starstar","text":"","title":"1138. Alphabet Board Path $\\star\\star$"},{"location":"python3/1101-1200/1131-1140/#1139-largest-1-bordered-square-starstar","text":"","title":"1139. Largest 1-Bordered Square $\\star\\star$"},{"location":"python3/1101-1200/1131-1140/#1140-stone-game-ii-starstar","text":"","title":"1140. Stone Game II $\\star\\star$"},{"location":"python3/1101-1200/1141-1150/","text":"1141. User Activity for the Past 30 Days I $\\star$ 1142. User Activity for the Past 30 Days II $\\star$ 1143. Longest Common Subsequence $\\star\\star$ 1144. Decrease Elements To Make Array Zigzag $\\star\\star$ 1145. Binary Tree Coloring Game $\\star\\star$ 1146. Snapshot Array $\\star\\star$ 1147. Longest Chunked Palindrome Decomposition $\\star\\star\\star$ 1148. Article Views I $\\star$ 1149. Article Views II $\\star\\star$ 1150. Check If a Number Is Majority Element in a Sorted Array $\\star$","title":"1141-1150"},{"location":"python3/1101-1200/1141-1150/#1141-user-activity-for-the-past-30-days-i-star","text":"","title":"1141. User Activity for the Past 30 Days I $\\star$"},{"location":"python3/1101-1200/1141-1150/#1142-user-activity-for-the-past-30-days-ii-star","text":"","title":"1142. User Activity for the Past 30 Days II $\\star$"},{"location":"python3/1101-1200/1141-1150/#1143-longest-common-subsequence-starstar","text":"","title":"1143. Longest Common Subsequence $\\star\\star$"},{"location":"python3/1101-1200/1141-1150/#1144-decrease-elements-to-make-array-zigzag-starstar","text":"","title":"1144. Decrease Elements To Make Array Zigzag $\\star\\star$"},{"location":"python3/1101-1200/1141-1150/#1145-binary-tree-coloring-game-starstar","text":"","title":"1145. Binary Tree Coloring Game $\\star\\star$"},{"location":"python3/1101-1200/1141-1150/#1146-snapshot-array-starstar","text":"","title":"1146. Snapshot Array $\\star\\star$"},{"location":"python3/1101-1200/1141-1150/#1147-longest-chunked-palindrome-decomposition-starstarstar","text":"","title":"1147. Longest Chunked Palindrome Decomposition $\\star\\star\\star$"},{"location":"python3/1101-1200/1141-1150/#1148-article-views-i-star","text":"","title":"1148. Article Views I $\\star$"},{"location":"python3/1101-1200/1141-1150/#1149-article-views-ii-starstar","text":"","title":"1149. Article Views II $\\star\\star$"},{"location":"python3/1101-1200/1141-1150/#1150-check-if-a-number-is-majority-element-in-a-sorted-array-star","text":"","title":"1150. Check If a Number Is Majority Element in a Sorted Array $\\star$"},{"location":"python3/1101-1200/1151-1160/","text":"1151. Minimum Swaps to Group All 1's Together $\\star\\star$ 1152. Analyze User Website Visit Pattern $\\star\\star$ 1153. String Transforms Into Another String $\\star\\star\\star$ 1154. Day of the Year $\\star$ 1155. Number of Dice Rolls With Target Sum $\\star\\star$ 1156. Swap For Longest Repeated Character Substring $\\star\\star$ 1157. Online Majority Element In Subarray $\\star\\star\\star$ 1158. Market Analysis I $\\star\\star$ 1159. Market Analysis II $\\star\\star\\star$ 1160. Find Words That Can Be Formed by Characters $\\star$","title":"1151-1160"},{"location":"python3/1101-1200/1151-1160/#1151-minimum-swaps-to-group-all-1s-together-starstar","text":"","title":"1151. Minimum Swaps to Group All 1's Together $\\star\\star$"},{"location":"python3/1101-1200/1151-1160/#1152-analyze-user-website-visit-pattern-starstar","text":"","title":"1152. Analyze User Website Visit Pattern $\\star\\star$"},{"location":"python3/1101-1200/1151-1160/#1153-string-transforms-into-another-string-starstarstar","text":"","title":"1153. String Transforms Into Another String $\\star\\star\\star$"},{"location":"python3/1101-1200/1151-1160/#1154-day-of-the-year-star","text":"","title":"1154. Day of the Year $\\star$"},{"location":"python3/1101-1200/1151-1160/#1155-number-of-dice-rolls-with-target-sum-starstar","text":"","title":"1155. Number of Dice Rolls With Target Sum $\\star\\star$"},{"location":"python3/1101-1200/1151-1160/#1156-swap-for-longest-repeated-character-substring-starstar","text":"","title":"1156. Swap For Longest Repeated Character Substring $\\star\\star$"},{"location":"python3/1101-1200/1151-1160/#1157-online-majority-element-in-subarray-starstarstar","text":"","title":"1157. Online Majority Element In Subarray $\\star\\star\\star$"},{"location":"python3/1101-1200/1151-1160/#1158-market-analysis-i-starstar","text":"","title":"1158. Market Analysis I $\\star\\star$"},{"location":"python3/1101-1200/1151-1160/#1159-market-analysis-ii-starstarstar","text":"","title":"1159. Market Analysis II $\\star\\star\\star$"},{"location":"python3/1101-1200/1151-1160/#1160-find-words-that-can-be-formed-by-characters-star","text":"","title":"1160. Find Words That Can Be Formed by Characters $\\star$"},{"location":"python3/1101-1200/1161-1170/","text":"1161. Maximum Level Sum of a Binary Tree $\\star\\star$ 1162. As Far from Land as Possible $\\star\\star$ 1163. Last Substring in Lexicographical Order $\\star\\star\\star$ 1164. Product Price at a Given Date $\\star\\star$ 1165. Single-Row Keyboard $\\star$ 1166. Design File System $\\star\\star$ 1167. Minimum Cost to Connect Sticks $\\star\\star$ 1168. Optimize Water Distribution in a Village $\\star\\star\\star$ 1169. Invalid Transactions $\\star\\star$ 1170. Compare Strings by Frequency of the Smallest Character $\\star$","title":"1161-1170"},{"location":"python3/1101-1200/1161-1170/#1161-maximum-level-sum-of-a-binary-tree-starstar","text":"","title":"1161. Maximum Level Sum of a Binary Tree $\\star\\star$"},{"location":"python3/1101-1200/1161-1170/#1162-as-far-from-land-as-possible-starstar","text":"","title":"1162. As Far from Land as Possible $\\star\\star$"},{"location":"python3/1101-1200/1161-1170/#1163-last-substring-in-lexicographical-order-starstarstar","text":"","title":"1163. Last Substring in Lexicographical Order $\\star\\star\\star$"},{"location":"python3/1101-1200/1161-1170/#1164-product-price-at-a-given-date-starstar","text":"","title":"1164. Product Price at a Given Date $\\star\\star$"},{"location":"python3/1101-1200/1161-1170/#1165-single-row-keyboard-star","text":"","title":"1165. Single-Row Keyboard $\\star$"},{"location":"python3/1101-1200/1161-1170/#1166-design-file-system-starstar","text":"","title":"1166. Design File System $\\star\\star$"},{"location":"python3/1101-1200/1161-1170/#1167-minimum-cost-to-connect-sticks-starstar","text":"","title":"1167. Minimum Cost to Connect Sticks $\\star\\star$"},{"location":"python3/1101-1200/1161-1170/#1168-optimize-water-distribution-in-a-village-starstarstar","text":"","title":"1168. Optimize Water Distribution in a Village $\\star\\star\\star$"},{"location":"python3/1101-1200/1161-1170/#1169-invalid-transactions-starstar","text":"","title":"1169. Invalid Transactions $\\star\\star$"},{"location":"python3/1101-1200/1161-1170/#1170-compare-strings-by-frequency-of-the-smallest-character-star","text":"","title":"1170. Compare Strings by Frequency of the Smallest Character $\\star$"},{"location":"python3/1101-1200/1171-1180/","text":"1171. Remove Zero Sum Consecutive Nodes from Linked List $\\star\\star$ 1172. Dinner Plate Stacks $\\star\\star\\star$ 1173. Immediate Food Delivery I $\\star$ 1174. Immediate Food Delivery II $\\star\\star$ 1175. Prime Arrangements $\\star$ 1176. Diet Plan Performance $\\star$ 1177. Can Make Palindrome from Substring $\\star\\star$ 1178. Number of Valid Words for Each Puzzle $\\star\\star\\star$ 1179. Reformat Department Table $\\star$ 1180. Count Substrings with Only One Distinct Letter $\\star$","title":"1171-1180"},{"location":"python3/1101-1200/1171-1180/#1171-remove-zero-sum-consecutive-nodes-from-linked-list-starstar","text":"","title":"1171. Remove Zero Sum Consecutive Nodes from Linked List $\\star\\star$"},{"location":"python3/1101-1200/1171-1180/#1172-dinner-plate-stacks-starstarstar","text":"","title":"1172. Dinner Plate Stacks $\\star\\star\\star$"},{"location":"python3/1101-1200/1171-1180/#1173-immediate-food-delivery-i-star","text":"","title":"1173. Immediate Food Delivery I $\\star$"},{"location":"python3/1101-1200/1171-1180/#1174-immediate-food-delivery-ii-starstar","text":"","title":"1174. Immediate Food Delivery II $\\star\\star$"},{"location":"python3/1101-1200/1171-1180/#1175-prime-arrangements-star","text":"","title":"1175. Prime Arrangements $\\star$"},{"location":"python3/1101-1200/1171-1180/#1176-diet-plan-performance-star","text":"","title":"1176. Diet Plan Performance $\\star$"},{"location":"python3/1101-1200/1171-1180/#1177-can-make-palindrome-from-substring-starstar","text":"","title":"1177. Can Make Palindrome from Substring $\\star\\star$"},{"location":"python3/1101-1200/1171-1180/#1178-number-of-valid-words-for-each-puzzle-starstarstar","text":"","title":"1178. Number of Valid Words for Each Puzzle $\\star\\star\\star$"},{"location":"python3/1101-1200/1171-1180/#1179-reformat-department-table-star","text":"","title":"1179. Reformat Department Table $\\star$"},{"location":"python3/1101-1200/1171-1180/#1180-count-substrings-with-only-one-distinct-letter-star","text":"","title":"1180. Count Substrings with Only One Distinct Letter $\\star$"},{"location":"python3/1101-1200/1181-1190/","text":"1181. Before and After Puzzle $\\star\\star$ 1182. Shortest Distance to Target Color $\\star\\star$ 1183. Maximum Number of Ones $\\star\\star\\star$ 1184. Distance Between Bus Stops $\\star$ 1185. Day of the Week $\\star$ 1186. Maximum Subarray Sum with One Deletion $\\star\\star$ 1187. Make Array Strictly Increasing $\\star\\star\\star$ 1188. Design Bounded Blocking Queue $\\star\\star$ 1189. Maximum Number of Balloons $\\star$ 1190. Reverse Substrings Between Each Pair of Parentheses $\\star\\star$","title":"1181-1190"},{"location":"python3/1101-1200/1181-1190/#1181-before-and-after-puzzle-starstar","text":"","title":"1181. Before and After Puzzle $\\star\\star$"},{"location":"python3/1101-1200/1181-1190/#1182-shortest-distance-to-target-color-starstar","text":"","title":"1182. Shortest Distance to Target Color $\\star\\star$"},{"location":"python3/1101-1200/1181-1190/#1183-maximum-number-of-ones-starstarstar","text":"","title":"1183. Maximum Number of Ones $\\star\\star\\star$"},{"location":"python3/1101-1200/1181-1190/#1184-distance-between-bus-stops-star","text":"","title":"1184. Distance Between Bus Stops $\\star$"},{"location":"python3/1101-1200/1181-1190/#1185-day-of-the-week-star","text":"","title":"1185. Day of the Week $\\star$"},{"location":"python3/1101-1200/1181-1190/#1186-maximum-subarray-sum-with-one-deletion-starstar","text":"","title":"1186. Maximum Subarray Sum with One Deletion $\\star\\star$"},{"location":"python3/1101-1200/1181-1190/#1187-make-array-strictly-increasing-starstarstar","text":"","title":"1187. Make Array Strictly Increasing $\\star\\star\\star$"},{"location":"python3/1101-1200/1181-1190/#1188-design-bounded-blocking-queue-starstar","text":"","title":"1188. Design Bounded Blocking Queue $\\star\\star$"},{"location":"python3/1101-1200/1181-1190/#1189-maximum-number-of-balloons-star","text":"","title":"1189. Maximum Number of Balloons $\\star$"},{"location":"python3/1101-1200/1181-1190/#1190-reverse-substrings-between-each-pair-of-parentheses-starstar","text":"","title":"1190. Reverse Substrings Between Each Pair of Parentheses $\\star\\star$"},{"location":"python3/1101-1200/1191-1200/","text":"1191. K-Concatenation Maximum Sum $\\star\\star$ 1192. Critical Connections in a Network $\\star\\star\\star$ 1193. Monthly Transactions I $\\star\\star$ 1194. Tournament Winners $\\star\\star\\star$ 1195. Fizz Buzz Multithreaded $\\star\\star$ 1196. How Many Apples Can You Put into the Basket $\\star$ 1197. Minimum Knight Moves $\\star\\star$ 1198. Find Smallest Common Element in All Rows $\\star\\star$ 1199. Minimum Time to Build Blocks $\\star\\star\\star$ 1200. Minimum Absolute Difference $\\star$","title":"1191-1200"},{"location":"python3/1101-1200/1191-1200/#1191-k-concatenation-maximum-sum-starstar","text":"","title":"1191. K-Concatenation Maximum Sum $\\star\\star$"},{"location":"python3/1101-1200/1191-1200/#1192-critical-connections-in-a-network-starstarstar","text":"","title":"1192. Critical Connections in a Network $\\star\\star\\star$"},{"location":"python3/1101-1200/1191-1200/#1193-monthly-transactions-i-starstar","text":"","title":"1193. Monthly Transactions I $\\star\\star$"},{"location":"python3/1101-1200/1191-1200/#1194-tournament-winners-starstarstar","text":"","title":"1194. Tournament Winners $\\star\\star\\star$"},{"location":"python3/1101-1200/1191-1200/#1195-fizz-buzz-multithreaded-starstar","text":"","title":"1195. Fizz Buzz Multithreaded $\\star\\star$"},{"location":"python3/1101-1200/1191-1200/#1196-how-many-apples-can-you-put-into-the-basket-star","text":"","title":"1196. How Many Apples Can You Put into the Basket $\\star$"},{"location":"python3/1101-1200/1191-1200/#1197-minimum-knight-moves-starstar","text":"","title":"1197. Minimum Knight Moves $\\star\\star$"},{"location":"python3/1101-1200/1191-1200/#1198-find-smallest-common-element-in-all-rows-starstar","text":"","title":"1198. Find Smallest Common Element in All Rows $\\star\\star$"},{"location":"python3/1101-1200/1191-1200/#1199-minimum-time-to-build-blocks-starstarstar","text":"","title":"1199. Minimum Time to Build Blocks $\\star\\star\\star$"},{"location":"python3/1101-1200/1191-1200/#1200-minimum-absolute-difference-star","text":"","title":"1200. Minimum Absolute Difference $\\star$"},{"location":"python3/1201-1300/1201-1210/","text":"1201. Ugly Number III $\\star\\star$ 1202. Smallest String With Swaps $\\star\\star$ 1203. Sort Items by Groups Respecting Dependencies $\\star\\star\\star$ 1204. Last Person to Fit in the Elevator $\\star\\star$ 1205. Monthly Transactions II $\\star\\star$ 1206. Design Skiplist $\\star\\star\\star$ 1207. Unique Number of Occurrences $\\star$ 1208. Get Equal Substrings Within Budget $\\star\\star$ 1209. Remove All Adjacent Duplicates in String II $\\star\\star$ 1210. Minimum Moves to Reach Target with Rotations $\\star\\star\\star$","title":"1201-1210"},{"location":"python3/1201-1300/1201-1210/#1201-ugly-number-iii-starstar","text":"","title":"1201. Ugly Number III $\\star\\star$"},{"location":"python3/1201-1300/1201-1210/#1202-smallest-string-with-swaps-starstar","text":"","title":"1202. Smallest String With Swaps $\\star\\star$"},{"location":"python3/1201-1300/1201-1210/#1203-sort-items-by-groups-respecting-dependencies-starstarstar","text":"","title":"1203. Sort Items by Groups Respecting Dependencies $\\star\\star\\star$"},{"location":"python3/1201-1300/1201-1210/#1204-last-person-to-fit-in-the-elevator-starstar","text":"","title":"1204. Last Person to Fit in the Elevator $\\star\\star$"},{"location":"python3/1201-1300/1201-1210/#1205-monthly-transactions-ii-starstar","text":"","title":"1205. Monthly Transactions II $\\star\\star$"},{"location":"python3/1201-1300/1201-1210/#1206-design-skiplist-starstarstar","text":"","title":"1206. Design Skiplist $\\star\\star\\star$"},{"location":"python3/1201-1300/1201-1210/#1207-unique-number-of-occurrences-star","text":"","title":"1207. Unique Number of Occurrences $\\star$"},{"location":"python3/1201-1300/1201-1210/#1208-get-equal-substrings-within-budget-starstar","text":"","title":"1208. Get Equal Substrings Within Budget $\\star\\star$"},{"location":"python3/1201-1300/1201-1210/#1209-remove-all-adjacent-duplicates-in-string-ii-starstar","text":"","title":"1209. Remove All Adjacent Duplicates in String II $\\star\\star$"},{"location":"python3/1201-1300/1201-1210/#1210-minimum-moves-to-reach-target-with-rotations-starstarstar","text":"","title":"1210. Minimum Moves to Reach Target with Rotations $\\star\\star\\star$"},{"location":"python3/1201-1300/1211-1220/","text":"1211. Queries Quality and Percentage $\\star$ 1212. Team Scores in Football Tournament $\\star\\star$ 1213. Intersection of Three Sorted Arrays $\\star$ 1214. Two Sum BSTs $\\star\\star$ 1215. Stepping Numbers $\\star\\star$ 1216. Valid Palindrome III $\\star\\star\\star$ 1217. Play with Chips $\\star$ 1218. Longest Arithmetic Subsequence of Given Difference $\\star\\star$ 1219. Path with Maximum Gold $\\star\\star$ 1220. Count Vowels Permutation $\\star\\star\\star$","title":"1211-1220"},{"location":"python3/1201-1300/1211-1220/#1211-queries-quality-and-percentage-star","text":"","title":"1211. Queries Quality and Percentage $\\star$"},{"location":"python3/1201-1300/1211-1220/#1212-team-scores-in-football-tournament-starstar","text":"","title":"1212. Team Scores in Football Tournament $\\star\\star$"},{"location":"python3/1201-1300/1211-1220/#1213-intersection-of-three-sorted-arrays-star","text":"","title":"1213. Intersection of Three Sorted Arrays $\\star$"},{"location":"python3/1201-1300/1211-1220/#1214-two-sum-bsts-starstar","text":"","title":"1214. Two Sum BSTs $\\star\\star$"},{"location":"python3/1201-1300/1211-1220/#1215-stepping-numbers-starstar","text":"","title":"1215. Stepping Numbers $\\star\\star$"},{"location":"python3/1201-1300/1211-1220/#1216-valid-palindrome-iii-starstarstar","text":"","title":"1216. Valid Palindrome III $\\star\\star\\star$"},{"location":"python3/1201-1300/1211-1220/#1217-play-with-chips-star","text":"","title":"1217. Play with Chips $\\star$"},{"location":"python3/1201-1300/1211-1220/#1218-longest-arithmetic-subsequence-of-given-difference-starstar","text":"","title":"1218. Longest Arithmetic Subsequence of Given Difference $\\star\\star$"},{"location":"python3/1201-1300/1211-1220/#1219-path-with-maximum-gold-starstar","text":"","title":"1219. Path with Maximum Gold $\\star\\star$"},{"location":"python3/1201-1300/1211-1220/#1220-count-vowels-permutation-starstarstar","text":"","title":"1220. Count Vowels Permutation $\\star\\star\\star$"},{"location":"python3/1201-1300/1221-1230/","text":"1221. Split a String in Balanced Strings $\\star$ 1222. Queens That Can Attack the King $\\star\\star$ 1223. Dice Roll Simulation $\\star\\star$ 1224. Maximum Equal Frequency $\\star\\star\\star$ 1225. Report Contiguous Dates $\\star\\star\\star$ 1226. The Dining Philosophers $\\star\\star$ 1227. Airplane Seat Assignment Probability $\\star\\star$ 1228. Missing Number In Arithmetic Progression $\\star$ 1229. Meeting Scheduler $\\star\\star$ 1230. Toss Strange Coins $\\star\\star$","title":"1221-1230"},{"location":"python3/1201-1300/1221-1230/#1221-split-a-string-in-balanced-strings-star","text":"","title":"1221. Split a String in Balanced Strings $\\star$"},{"location":"python3/1201-1300/1221-1230/#1222-queens-that-can-attack-the-king-starstar","text":"","title":"1222. Queens That Can Attack the King $\\star\\star$"},{"location":"python3/1201-1300/1221-1230/#1223-dice-roll-simulation-starstar","text":"","title":"1223. Dice Roll Simulation $\\star\\star$"},{"location":"python3/1201-1300/1221-1230/#1224-maximum-equal-frequency-starstarstar","text":"","title":"1224. Maximum Equal Frequency $\\star\\star\\star$"},{"location":"python3/1201-1300/1221-1230/#1225-report-contiguous-dates-starstarstar","text":"","title":"1225. Report Contiguous Dates $\\star\\star\\star$"},{"location":"python3/1201-1300/1221-1230/#1226-the-dining-philosophers-starstar","text":"","title":"1226. The Dining Philosophers $\\star\\star$"},{"location":"python3/1201-1300/1221-1230/#1227-airplane-seat-assignment-probability-starstar","text":"","title":"1227. Airplane Seat Assignment Probability $\\star\\star$"},{"location":"python3/1201-1300/1221-1230/#1228-missing-number-in-arithmetic-progression-star","text":"","title":"1228. Missing Number In Arithmetic Progression $\\star$"},{"location":"python3/1201-1300/1221-1230/#1229-meeting-scheduler-starstar","text":"","title":"1229. Meeting Scheduler $\\star\\star$"},{"location":"python3/1201-1300/1221-1230/#1230-toss-strange-coins-starstar","text":"","title":"1230. Toss Strange Coins $\\star\\star$"},{"location":"python3/1201-1300/1231-1240/","text":"1231. Divide Chocolate $\\star\\star\\star$ 1232. Check If It Is a Straight Line $\\star$ 1233. Remove Sub-Folders from the Filesystem $\\star\\star$ 1234. Replace the Substring for Balanced String $\\star\\star$ 1235. Maximum Profit in Job Scheduling $\\star\\star\\star$ 1236. Web Crawler $\\star\\star$ 1237. Find Positive Integer Solution for a Given Equation $\\star$ 1238. Circular Permutation in Binary Representation $\\star\\star$ 1239. Maximum Length of a Concatenated String with Unique Characters $\\star\\star$ 1240. Tiling a Rectangle with the Fewest Squares $\\star\\star\\star$","title":"1231-1240"},{"location":"python3/1201-1300/1231-1240/#1231-divide-chocolate-starstarstar","text":"","title":"1231. Divide Chocolate $\\star\\star\\star$"},{"location":"python3/1201-1300/1231-1240/#1232-check-if-it-is-a-straight-line-star","text":"","title":"1232. Check If It Is a Straight Line $\\star$"},{"location":"python3/1201-1300/1231-1240/#1233-remove-sub-folders-from-the-filesystem-starstar","text":"","title":"1233. Remove Sub-Folders from the Filesystem $\\star\\star$"},{"location":"python3/1201-1300/1231-1240/#1234-replace-the-substring-for-balanced-string-starstar","text":"","title":"1234. Replace the Substring for Balanced String $\\star\\star$"},{"location":"python3/1201-1300/1231-1240/#1235-maximum-profit-in-job-scheduling-starstarstar","text":"","title":"1235. Maximum Profit in Job Scheduling $\\star\\star\\star$"},{"location":"python3/1201-1300/1231-1240/#1236-web-crawler-starstar","text":"","title":"1236. Web Crawler $\\star\\star$"},{"location":"python3/1201-1300/1231-1240/#1237-find-positive-integer-solution-for-a-given-equation-star","text":"","title":"1237. Find Positive Integer Solution for a Given Equation $\\star$"},{"location":"python3/1201-1300/1231-1240/#1238-circular-permutation-in-binary-representation-starstar","text":"","title":"1238. Circular Permutation in Binary Representation $\\star\\star$"},{"location":"python3/1201-1300/1231-1240/#1239-maximum-length-of-a-concatenated-string-with-unique-characters-starstar","text":"","title":"1239. Maximum Length of a Concatenated String with Unique Characters $\\star\\star$"},{"location":"python3/1201-1300/1231-1240/#1240-tiling-a-rectangle-with-the-fewest-squares-starstarstar","text":"","title":"1240. Tiling a Rectangle with the Fewest Squares $\\star\\star\\star$"},{"location":"python3/1201-1300/1241-1250/","text":"1241. Number of Comments per Post $\\star$ 1242. Web Crawler Multithreaded $\\star\\star$ 1243. Array Transformation $\\star$ 1244. Design A Leaderboard $\\star\\star$ 1245. Tree Diameter $\\star\\star$ 1246. Palindrome Removal $\\star\\star\\star$ 1247. Minimum Swaps to Make Strings Equal $\\star\\star$ 1248. Count Number of Nice Subarrays $\\star\\star$ 1249. Minimum Remove to Make Valid Parentheses $\\star\\star$ 1250. Check If It Is a Good Array $\\star\\star\\star$","title":"1241-1250"},{"location":"python3/1201-1300/1241-1250/#1241-number-of-comments-per-post-star","text":"","title":"1241. Number of Comments per Post $\\star$"},{"location":"python3/1201-1300/1241-1250/#1242-web-crawler-multithreaded-starstar","text":"","title":"1242. Web Crawler Multithreaded $\\star\\star$"},{"location":"python3/1201-1300/1241-1250/#1243-array-transformation-star","text":"","title":"1243. Array Transformation $\\star$"},{"location":"python3/1201-1300/1241-1250/#1244-design-a-leaderboard-starstar","text":"","title":"1244. Design A Leaderboard $\\star\\star$"},{"location":"python3/1201-1300/1241-1250/#1245-tree-diameter-starstar","text":"","title":"1245. Tree Diameter $\\star\\star$"},{"location":"python3/1201-1300/1241-1250/#1246-palindrome-removal-starstarstar","text":"","title":"1246. Palindrome Removal $\\star\\star\\star$"},{"location":"python3/1201-1300/1241-1250/#1247-minimum-swaps-to-make-strings-equal-starstar","text":"","title":"1247. Minimum Swaps to Make Strings Equal $\\star\\star$"},{"location":"python3/1201-1300/1241-1250/#1248-count-number-of-nice-subarrays-starstar","text":"","title":"1248. Count Number of Nice Subarrays $\\star\\star$"},{"location":"python3/1201-1300/1241-1250/#1249-minimum-remove-to-make-valid-parentheses-starstar","text":"","title":"1249. Minimum Remove to Make Valid Parentheses $\\star\\star$"},{"location":"python3/1201-1300/1241-1250/#1250-check-if-it-is-a-good-array-starstarstar","text":"","title":"1250. Check If It Is a Good Array $\\star\\star\\star$"},{"location":"python3/1201-1300/1251-1260/","text":"1251. Average Selling Price $\\star$ 1252. Cells with Odd Values in a Matrix $\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def oddCells ( self , n : int , m : int , indices : List [ List [ int ]]) -> int : ans = 0 rows = [ 0 ] * n cols = [ 0 ] * m for indice in indices : rows [ indice [ 0 ]] ^= 1 cols [ indice [ 1 ]] ^= 1 for i in range ( n ): for j in range ( m ): ans += rows [ i ] ^ cols [ j ] return ans 1253. Reconstruct a 2-Row Binary Matrix $\\star\\star$ 1254. Number of Closed Islands $\\star\\star$ 1255. Maximum Score Words Formed by Letters $\\star\\star\\star$ 1256. Encode Number $\\star\\star$ 1257. Smallest Common Region $\\star\\star$ 1258. Synonymous Sentences $\\star\\star$ 1259. Handshakes That Don't Cross $\\star\\star\\star$ 1260. Shift 2D Grid $\\star$","title":"1251-1260"},{"location":"python3/1201-1300/1251-1260/#1251-average-selling-price-star","text":"","title":"1251. Average Selling Price $\\star$"},{"location":"python3/1201-1300/1251-1260/#1252-cells-with-odd-values-in-a-matrix-star","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Solution : def oddCells ( self , n : int , m : int , indices : List [ List [ int ]]) -> int : ans = 0 rows = [ 0 ] * n cols = [ 0 ] * m for indice in indices : rows [ indice [ 0 ]] ^= 1 cols [ indice [ 1 ]] ^= 1 for i in range ( n ): for j in range ( m ): ans += rows [ i ] ^ cols [ j ] return ans","title":"1252. Cells with Odd Values in a Matrix $\\star$"},{"location":"python3/1201-1300/1251-1260/#1253-reconstruct-a-2-row-binary-matrix-starstar","text":"","title":"1253. Reconstruct a 2-Row Binary Matrix $\\star\\star$"},{"location":"python3/1201-1300/1251-1260/#1254-number-of-closed-islands-starstar","text":"","title":"1254. Number of Closed Islands $\\star\\star$"},{"location":"python3/1201-1300/1251-1260/#1255-maximum-score-words-formed-by-letters-starstarstar","text":"","title":"1255. Maximum Score Words Formed by Letters $\\star\\star\\star$"},{"location":"python3/1201-1300/1251-1260/#1256-encode-number-starstar","text":"","title":"1256. Encode Number $\\star\\star$"},{"location":"python3/1201-1300/1251-1260/#1257-smallest-common-region-starstar","text":"","title":"1257. Smallest Common Region $\\star\\star$"},{"location":"python3/1201-1300/1251-1260/#1258-synonymous-sentences-starstar","text":"","title":"1258. Synonymous Sentences $\\star\\star$"},{"location":"python3/1201-1300/1251-1260/#1259-handshakes-that-dont-cross-starstarstar","text":"","title":"1259. Handshakes That Don't Cross $\\star\\star\\star$"},{"location":"python3/1201-1300/1251-1260/#1260-shift-2d-grid-star","text":"","title":"1260. Shift 2D Grid $\\star$"},{"location":"python3/1201-1300/1261-1270/","text":"1261. Find Elements in a Contaminated Binary Tree $\\star\\star$ 1262. Greatest Sum Divisible by Three $\\star\\star$ 1263. Minimum Moves to Move a Box to Their Target Location $\\star\\star\\star$ 1264. Page Recommendations $\\star\\star$ 1265. Print Immutable Linked List in Reverse $\\star\\star$ 1266. Minimum Time Visiting All Points $\\star$ 1267. Count Servers that Communicate $\\star\\star$ 1268. Search Suggestions System $\\star\\star$ 1269. Number of Ways to Stay in the Same Place After Some Steps $\\star\\star\\star$ 1270. All People Report to the Given Manager $\\star\\star$","title":"1261-1270"},{"location":"python3/1201-1300/1261-1270/#1261-find-elements-in-a-contaminated-binary-tree-starstar","text":"","title":"1261. Find Elements in a Contaminated Binary Tree $\\star\\star$"},{"location":"python3/1201-1300/1261-1270/#1262-greatest-sum-divisible-by-three-starstar","text":"","title":"1262. Greatest Sum Divisible by Three $\\star\\star$"},{"location":"python3/1201-1300/1261-1270/#1263-minimum-moves-to-move-a-box-to-their-target-location-starstarstar","text":"","title":"1263. Minimum Moves to Move a Box to Their Target Location $\\star\\star\\star$"},{"location":"python3/1201-1300/1261-1270/#1264-page-recommendations-starstar","text":"","title":"1264. Page Recommendations $\\star\\star$"},{"location":"python3/1201-1300/1261-1270/#1265-print-immutable-linked-list-in-reverse-starstar","text":"","title":"1265. Print Immutable Linked List in Reverse $\\star\\star$"},{"location":"python3/1201-1300/1261-1270/#1266-minimum-time-visiting-all-points-star","text":"","title":"1266. Minimum Time Visiting All Points $\\star$"},{"location":"python3/1201-1300/1261-1270/#1267-count-servers-that-communicate-starstar","text":"","title":"1267. Count Servers that Communicate $\\star\\star$"},{"location":"python3/1201-1300/1261-1270/#1268-search-suggestions-system-starstar","text":"","title":"1268. Search Suggestions System $\\star\\star$"},{"location":"python3/1201-1300/1261-1270/#1269-number-of-ways-to-stay-in-the-same-place-after-some-steps-starstarstar","text":"","title":"1269. Number of Ways to Stay in the Same Place After Some Steps $\\star\\star\\star$"},{"location":"python3/1201-1300/1261-1270/#1270-all-people-report-to-the-given-manager-starstar","text":"","title":"1270. All People Report to the Given Manager $\\star\\star$"},{"location":"python3/1201-1300/1271-1280/","text":"1271. Hexspeak $\\star$ 1272. Remove Interval $\\star\\star$ 1273. Delete Tree Nodes $\\star\\star$ 1274. Number of Ships in a Rectangle $\\star\\star\\star$ 1275. Find Winner on a Tic Tac Toe Game $\\star$ 1276. Number of Burgers with No Waste of Ingredients $\\star\\star$ 1277. Count Square Submatrices with All Ones $\\star\\star$ 1278. Palindrome Partitioning III $\\star\\star\\star$ 1279. Traffic Light Controlled Intersection $\\star$ 1280. Students and Examinations $\\star$","title":"1271-1280"},{"location":"python3/1201-1300/1271-1280/#1271-hexspeak-star","text":"","title":"1271. Hexspeak $\\star$"},{"location":"python3/1201-1300/1271-1280/#1272-remove-interval-starstar","text":"","title":"1272. Remove Interval $\\star\\star$"},{"location":"python3/1201-1300/1271-1280/#1273-delete-tree-nodes-starstar","text":"","title":"1273. Delete Tree Nodes $\\star\\star$"},{"location":"python3/1201-1300/1271-1280/#1274-number-of-ships-in-a-rectangle-starstarstar","text":"","title":"1274. Number of Ships in a Rectangle $\\star\\star\\star$"},{"location":"python3/1201-1300/1271-1280/#1275-find-winner-on-a-tic-tac-toe-game-star","text":"","title":"1275. Find Winner on a Tic Tac Toe Game $\\star$"},{"location":"python3/1201-1300/1271-1280/#1276-number-of-burgers-with-no-waste-of-ingredients-starstar","text":"","title":"1276. Number of Burgers with No Waste of Ingredients $\\star\\star$"},{"location":"python3/1201-1300/1271-1280/#1277-count-square-submatrices-with-all-ones-starstar","text":"","title":"1277. Count Square Submatrices with All Ones $\\star\\star$"},{"location":"python3/1201-1300/1271-1280/#1278-palindrome-partitioning-iii-starstarstar","text":"","title":"1278. Palindrome Partitioning III $\\star\\star\\star$"},{"location":"python3/1201-1300/1271-1280/#1279-traffic-light-controlled-intersection-star","text":"","title":"1279. Traffic Light Controlled Intersection $\\star$"},{"location":"python3/1201-1300/1271-1280/#1280-students-and-examinations-star","text":"","title":"1280. Students and Examinations $\\star$"},{"location":"python3/1201-1300/1281-1290/","text":"1281. Subtract the Product and Sum of Digits of an Integer $\\star$ 1282. Group the People Given the Group Size They Belong To $\\star\\star$ 1283. Find the Smallest Divisor Given a Threshold $\\star\\star$ 1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix $\\star\\star\\star$ 1285. Find the Start and End Number of Continuous Ranges $\\star\\star$ 1286. Iterator for Combination $\\star\\star$ 1287. Element Appearing More Than 25% In Sorted Array $\\star$ 1288. Remove Covered Intervals $\\star\\star$ 1289. Minimum Falling Path Sum II $\\star\\star\\star$ 1290. Convert Binary Number in a Linked List to Integer $\\star$","title":"1281-1290"},{"location":"python3/1201-1300/1281-1290/#1281-subtract-the-product-and-sum-of-digits-of-an-integer-star","text":"","title":"1281. Subtract the Product and Sum of Digits of an Integer $\\star$"},{"location":"python3/1201-1300/1281-1290/#1282-group-the-people-given-the-group-size-they-belong-to-starstar","text":"","title":"1282. Group the People Given the Group Size They Belong To $\\star\\star$"},{"location":"python3/1201-1300/1281-1290/#1283-find-the-smallest-divisor-given-a-threshold-starstar","text":"","title":"1283. Find the Smallest Divisor Given a Threshold $\\star\\star$"},{"location":"python3/1201-1300/1281-1290/#1284-minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix-starstarstar","text":"","title":"1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix $\\star\\star\\star$"},{"location":"python3/1201-1300/1281-1290/#1285-find-the-start-and-end-number-of-continuous-ranges-starstar","text":"","title":"1285. Find the Start and End Number of Continuous Ranges $\\star\\star$"},{"location":"python3/1201-1300/1281-1290/#1286-iterator-for-combination-starstar","text":"","title":"1286. Iterator for Combination $\\star\\star$"},{"location":"python3/1201-1300/1281-1290/#1287-element-appearing-more-than-25-in-sorted-array-star","text":"","title":"1287. Element Appearing More Than 25% In Sorted Array $\\star$"},{"location":"python3/1201-1300/1281-1290/#1288-remove-covered-intervals-starstar","text":"","title":"1288. Remove Covered Intervals $\\star\\star$"},{"location":"python3/1201-1300/1281-1290/#1289-minimum-falling-path-sum-ii-starstarstar","text":"","title":"1289. Minimum Falling Path Sum II $\\star\\star\\star$"},{"location":"python3/1201-1300/1281-1290/#1290-convert-binary-number-in-a-linked-list-to-integer-star","text":"","title":"1290. Convert Binary Number in a Linked List to Integer $\\star$"},{"location":"python3/1201-1300/1291-1300/","text":"1291. Sequential Digits $\\star\\star$ 1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold $\\star\\star$ 1293. Shortest Path in a Grid with Obstacles Elimination $\\star\\star\\star$ 1294. Weather Type in Each Country $\\star$ 1295. Find Numbers with Even Number of Digits $\\star$ 1296. Divide Array in Sets of K Consecutive Numbers $\\star\\star$ 1297. Maximum Number of Occurrences of a Substring $\\star\\star$ 1298. Maximum Candies You Can Get from Boxes $\\star\\star\\star$ 1299. Replace Elements with Greatest Element on Right Side $\\star$ 1300. Sum of Mutated Array Closest to Target $\\star\\star$","title":"1291-1300"},{"location":"python3/1201-1300/1291-1300/#1291-sequential-digits-starstar","text":"","title":"1291. Sequential Digits $\\star\\star$"},{"location":"python3/1201-1300/1291-1300/#1292-maximum-side-length-of-a-square-with-sum-less-than-or-equal-to-threshold-starstar","text":"","title":"1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold $\\star\\star$"},{"location":"python3/1201-1300/1291-1300/#1293-shortest-path-in-a-grid-with-obstacles-elimination-starstarstar","text":"","title":"1293. Shortest Path in a Grid with Obstacles Elimination $\\star\\star\\star$"},{"location":"python3/1201-1300/1291-1300/#1294-weather-type-in-each-country-star","text":"","title":"1294. Weather Type in Each Country $\\star$"},{"location":"python3/1201-1300/1291-1300/#1295-find-numbers-with-even-number-of-digits-star","text":"","title":"1295. Find Numbers with Even Number of Digits $\\star$"},{"location":"python3/1201-1300/1291-1300/#1296-divide-array-in-sets-of-k-consecutive-numbers-starstar","text":"","title":"1296. Divide Array in Sets of K Consecutive Numbers $\\star\\star$"},{"location":"python3/1201-1300/1291-1300/#1297-maximum-number-of-occurrences-of-a-substring-starstar","text":"","title":"1297. Maximum Number of Occurrences of a Substring $\\star\\star$"},{"location":"python3/1201-1300/1291-1300/#1298-maximum-candies-you-can-get-from-boxes-starstarstar","text":"","title":"1298. Maximum Candies You Can Get from Boxes $\\star\\star\\star$"},{"location":"python3/1201-1300/1291-1300/#1299-replace-elements-with-greatest-element-on-right-side-star","text":"","title":"1299. Replace Elements with Greatest Element on Right Side $\\star$"},{"location":"python3/1201-1300/1291-1300/#1300-sum-of-mutated-array-closest-to-target-starstar","text":"","title":"1300. Sum of Mutated Array Closest to Target $\\star\\star$"},{"location":"python3/1301-1400/1301-1310/","text":"1301. Number of Paths with Max Score $\\star\\star\\star$ 1302. Deepest Leaves Sum $\\star\\star$ 1303. Find the Team Size $\\star$ 1304. Find N Unique Integers Sum up to Zero $\\star$ 1305. All Elements in Two Binary Search Trees $\\star\\star$ 1306. Jump Game III $\\star\\star$ 1307. Verbal Arithmetic Puzzle $\\star\\star\\star$ 1308. Running Total for Different Genders $\\star\\star$ 1309. Decrypt String from Alphabet to Integer Mapping $\\star$ 1310. XOR Queries of a Subarray $\\star\\star$ 1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def xorQueries ( self , arr : List [ int ], queries : List [ List [ int ]]) -> List [ int ]: ans = [] xors = [ 0 ] * ( len ( arr ) + 1 ) for i , a in enumerate ( arr ): xors [ i + 1 ] ^= xors [ i ] ^ a for l , r in queries : ans . append ( xors [ l ] ^ xors [ r + 1 ]) return ans","title":"1301-1310"},{"location":"python3/1301-1400/1301-1310/#1301-number-of-paths-with-max-score-starstarstar","text":"","title":"1301. Number of Paths with Max Score $\\star\\star\\star$"},{"location":"python3/1301-1400/1301-1310/#1302-deepest-leaves-sum-starstar","text":"","title":"1302. Deepest Leaves Sum $\\star\\star$"},{"location":"python3/1301-1400/1301-1310/#1303-find-the-team-size-star","text":"","title":"1303. Find the Team Size $\\star$"},{"location":"python3/1301-1400/1301-1310/#1304-find-n-unique-integers-sum-up-to-zero-star","text":"","title":"1304. Find N Unique Integers Sum up to Zero $\\star$"},{"location":"python3/1301-1400/1301-1310/#1305-all-elements-in-two-binary-search-trees-starstar","text":"","title":"1305. All Elements in Two Binary Search Trees $\\star\\star$"},{"location":"python3/1301-1400/1301-1310/#1306-jump-game-iii-starstar","text":"","title":"1306. Jump Game III $\\star\\star$"},{"location":"python3/1301-1400/1301-1310/#1307-verbal-arithmetic-puzzle-starstarstar","text":"","title":"1307. Verbal Arithmetic Puzzle $\\star\\star\\star$"},{"location":"python3/1301-1400/1301-1310/#1308-running-total-for-different-genders-starstar","text":"","title":"1308. Running Total for Different Genders $\\star\\star$"},{"location":"python3/1301-1400/1301-1310/#1309-decrypt-string-from-alphabet-to-integer-mapping-star","text":"","title":"1309. Decrypt String from Alphabet to Integer Mapping $\\star$"},{"location":"python3/1301-1400/1301-1310/#1310-xor-queries-of-a-subarray-starstar","text":"1 2 3 4 5 6 7 8 9 10 11 12 class Solution : def xorQueries ( self , arr : List [ int ], queries : List [ List [ int ]]) -> List [ int ]: ans = [] xors = [ 0 ] * ( len ( arr ) + 1 ) for i , a in enumerate ( arr ): xors [ i + 1 ] ^= xors [ i ] ^ a for l , r in queries : ans . append ( xors [ l ] ^ xors [ r + 1 ]) return ans","title":"1310. XOR Queries of a Subarray $\\star\\star$"},{"location":"python3/1301-1400/1311-1320/","text":"1311. Get Watched Videos by Your Friends $\\star\\star$ 1312. Minimum Insertion Steps to Make a String Palindrome $\\star\\star\\star$ 1313. Decompress Run-Length Encoded List $\\star$ 1314. Matrix Block Sum $\\star\\star$ 1315. Sum of Nodes with Even-Valued Grandparent $\\star\\star$ 1316. Distinct Echo Substrings $\\star\\star\\star$ 1317. Convert Integer to the Sum of Two No-Zero Integers $\\star$ 1318. Minimum Flips to Make a OR b Equal to c $\\star\\star$ 1319. Number of Operations to Make Network Connected $\\star\\star$ 1320. Minimum Distance to Type a Word Using Two Fingers $\\star\\star\\star$","title":"1311-1320"},{"location":"python3/1301-1400/1311-1320/#1311-get-watched-videos-by-your-friends-starstar","text":"","title":"1311. Get Watched Videos by Your Friends $\\star\\star$"},{"location":"python3/1301-1400/1311-1320/#1312-minimum-insertion-steps-to-make-a-string-palindrome-starstarstar","text":"","title":"1312. Minimum Insertion Steps to Make a String Palindrome $\\star\\star\\star$"},{"location":"python3/1301-1400/1311-1320/#1313-decompress-run-length-encoded-list-star","text":"","title":"1313. Decompress Run-Length Encoded List $\\star$"},{"location":"python3/1301-1400/1311-1320/#1314-matrix-block-sum-starstar","text":"","title":"1314. Matrix Block Sum $\\star\\star$"},{"location":"python3/1301-1400/1311-1320/#1315-sum-of-nodes-with-even-valued-grandparent-starstar","text":"","title":"1315. Sum of Nodes with Even-Valued Grandparent $\\star\\star$"},{"location":"python3/1301-1400/1311-1320/#1316-distinct-echo-substrings-starstarstar","text":"","title":"1316. Distinct Echo Substrings $\\star\\star\\star$"},{"location":"python3/1301-1400/1311-1320/#1317-convert-integer-to-the-sum-of-two-no-zero-integers-star","text":"","title":"1317. Convert Integer to the Sum of Two No-Zero Integers $\\star$"},{"location":"python3/1301-1400/1311-1320/#1318-minimum-flips-to-make-a-or-b-equal-to-c-starstar","text":"","title":"1318. Minimum Flips to Make a OR b Equal to c $\\star\\star$"},{"location":"python3/1301-1400/1311-1320/#1319-number-of-operations-to-make-network-connected-starstar","text":"","title":"1319. Number of Operations to Make Network Connected $\\star\\star$"},{"location":"python3/1301-1400/1311-1320/#1320-minimum-distance-to-type-a-word-using-two-fingers-starstarstar","text":"","title":"1320. Minimum Distance to Type a Word Using Two Fingers $\\star\\star\\star$"},{"location":"python3/1301-1400/1321-1330/","text":"1321. Restaurant Growth $\\star\\star$ 1322. Ads Performance $\\star$","title":"1321-1321"},{"location":"python3/1301-1400/1321-1330/#1321-restaurant-growth-starstar","text":"","title":"1321. Restaurant Growth $\\star\\star$"},{"location":"python3/1301-1400/1321-1330/#1322-ads-performance-star","text":"","title":"1322. Ads Performance $\\star$"}]}